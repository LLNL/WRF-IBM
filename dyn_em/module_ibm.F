MODULE module_ibm

!NOTICE
!This work was produced at the Lawrence Livermore National Laboratory (LLNL) and University of California, Berkeley, under contract no. DE-AC52-07NA27344 (Contract 44) between the U.S. Department of Energy (DOE) and Lawrence Livermore National Security, LLC (LLNS) for the operation of LLNL.  Copyright is reserved to Lawrence Livermore National Security, LLC for purposes of controlled dissemination, commercialization through formal licensing, or other disposition under terms of Contract 44; DOE policies, regulations and orders; and U.S. statutes. The rights of the Federal Government are reserved under Contract 44. 
!
!DISCLAIMER 
!This work was prepared as an account of work sponsored by an agency of the United States Government. NEITHER THE UNITED STATES GOVERNMENT NOR LAWRENCE LIVERMORE NATIONAL SECURITY, LLC, NOR REGENTS OF UNIVERSITY OF CALIFORNIA, NOR ANY OF THEIR EMPLOYEES, MAKES ANY WARRANTY, EXPRESS OR IMPLIED, OR ASSUMES ANY LIABILITY OR RESPONSIBILITY FOR THE ACCURACY, COMPLETENESS, OR USEFULNESS OF ANY INFORMATION, APPARATUS, PRODUCT, OR PROCESS DISCLOSED, OR REPRESENTS THAT ITS USE WOULD NOT INFRINGE PRIVATELY-OWNED RIGHTS.  THIS SOFTWARE IS PROVIDED BY LAWRENCE LIVERMORE NATIONAL SECURITY, LLC "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
!
!Reference herein to any specific commercial products, process, or service by trade name, trademark, manufacturer or otherwise does not necessarily constitute or imply its endorsement, recommendation, or favoring by the United States Government or Lawrence Livermore National Security, LLC or Regents of the University of California. The views and opinions of authors expressed herein do not necessarily state or reflect those of the United States Government or Lawrence Livermore National Security, LLC, and shall not be used for advertising or product endorsement purposes.
!
!NOTIFICATION OF COMMERCIAL USE
!Commercialization of this product is prohibited without notifying the Department of Energy (DOE) or Lawrence Livermore National Security or the Regents of the University of California.


USE module_configure
USE module_model_constants
USE module_wrf_error
!KAL need this even for serial runs so that files 
!KAL can be named with proc number, even if it is just zero
!!!#ifdef DM_PARALLEL
USE module_dm
!!!#endif
!KAL use ranking routine for inverse distance weighting
! moved this subroutine to the end of module_ibm.F
! it was in the module m_rnkpar.F, however, I was getting an error
! when trying to compile in double precision
! Ambiguous interfaces for generic procedure rnkpar
! the -DPROMOTE_FLOAT flag did not fix this
!!!USE m_rnkpar		
USE module_diffusion_em !KAL this is for the shear_stress_ibm routine only, which needs to calculate tau		      

CONTAINS
!-------------------------------------------------------------------------------
 SUBROUTINE start_ibm_init ( config_flags,                           &
                             ibm_ht_u, ibm_ht_v,                     &
                             ibm_ht_w, ibm_ht_c,                     &
                             ibm_z0,                                 &
                             phb, ph,                                &
                             ht_s, ht_u, ht_v, ht_w,                 &
                             top_s, top_u, top_v, top_w,             &
                             prox_s, prox_u, prox_v, prox_w,         &
                             inside_s, inside_u, inside_v, inside_w, &
                             inside_all_s,                           &
                             inside_all_u,                           &
                             inside_all_v,                           &
                             inside_all_w,                           &
                             ids, ide, jds, jde, kds, kde,           &
                             ims, ime, jms, jme, kms, kme,           &
                             its, ite, jts, jte, kts, kte )
 IMPLICIT NONE
 !input data
 TYPE(grid_config_rec_type), INTENT(IN   )               :: config_flags
 REAL, DIMENSION(ims:ime,jms:jme), INTENT(  OUT)         :: ibm_ht_u,       & !ibm terrain height at velocity points
                                                            ibm_ht_v,       & !terrain height has twice the resolution of
                                                            ibm_ht_w,       & !the computational grid							    
                                                            ibm_ht_c,       & !ibm terrain height at corners
                                                            ibm_z0            !ibm z0 at cell center
 REAL, DIMENSION(ims:ime,kms:kme,jms:jme), INTENT(IN   ) :: phb, ph
 REAL, DIMENSION(ims:ime,kms:kme,jms:jme), INTENT(  OUT) :: ht_s,           & !this is the total geopotential
                                                            ht_u,           & !at center, u, v, and w points
                                                            ht_v,           & 
                                                            ht_w
 INTEGER, DIMENSION(ims:ime,jms:jme), INTENT(  OUT)      :: top_s,          & !'top boundary' ghost points
                                                            top_u,          &  
                                                            top_v,          & 
                                                            top_w,          &
                                                            prox_s,         & !one if the pt is outside of the terrain
                                                            prox_u,         & !meaning that the location has been changed due to proximity
                                                            prox_v,         &
                                                            prox_w
 INTEGER, DIMENSION(ims:ime,kms:kme,jms:jme), INTENT(OUT):: inside_s,       & !one if the pt is inside boundary, zero if it is outside
                                                            inside_u,       &
                                                            inside_v,       &
                                                            inside_w
 INTEGER, DIMENSION(ims:ime,kms:kme,jms:jme), INTENT(OUT):: inside_all_s,   & !RSA inside includes recon pts, inside_all does not
                                                            inside_all_u,   &
                                                            inside_all_v,   &
                                                            inside_all_w
 INTEGER, INTENT(IN   )                                  :: ids, ide, jds, jde, kds, kde, & !d: domain 
                                                            ims, ime, jms, jme, kms, kme, & !m: memory
                                                            its, ite, jts, jte, kts, kte    !p: patch t: tile
 !local data
 INTEGER                                                 :: i, j, k
 CHARACTER(LEN=256)                                      :: wrf_msg
 !DJW added the declarations below for ideal_terrain=115
 REAL :: bldx, bldy, bldz, gapx, gapy, theta, xoff, yoff, bx, by, xmid, ymid
 LOGICAL :: keepgoing

!---------------------------------------------------------------------------------
! this subroutine is called from start_em.F.  
! the executable begins here
 CALL wrf_debug(100,'dyn_em/module_ibm.F/subroutine start_ibm_init')
!--------------------------------------------------------------------------------- 

 write(wrf_msg,'(A,I3,A,I1)') "setting ideal_terrain-",config_flags%ideal_terrain," for grid-",config_flags%grid_id
 CALL wrf_message(TRIM(wrf_msg))

 CALL ibm_terrain ( config_flags,                 &
                    ibm_ht_u, ibm_ht_v,           &
                    ibm_ht_w, ibm_ht_c,           &
                    ibm_z0,                       &
                    ids, ide, jds, jde, kds, kde, &
                    ims, ime, jms, jme, kms, kme, &
                    its, ite, jts, jte, kts, kte ) 

 IF (config_flags%ibm_opt .EQ. 3) THEN
     IF (config_flags%ideal_terrain .EQ. 0) THEN
         write(*,'(A,I1)') "DJW[module_ibm/start_ibm_init]: setting ibm_ht_* based on geopotential for grid%id=",config_flags%grid_id
         DO i=its,ite
             DO j=jts,jte
                 ibm_ht_w(i,j) =  phb(i,   1, j  ) / 9.81
                 ibm_ht_u(i,j) = (phb(i-1, 1, j  ) + phb(i,   1, j  )) / (2.0*9.81)
                 ibm_ht_v(i,j) = (phb(i,   1, j-1) + phb(i,   1, j  )) / (2.0*9.81)
                 ibm_ht_c(i,j) = (phb(i-1, 1, j-1) + phb(i-1, 1, j  ) + &
                                  phb(i,   1, j-1) + phb(i,   1, j  )) / (4.0*9.81)
             ENDDO
         ENDDO
         write(*,'(4(A,I3),A,I1)') "DJW[module_ibm/start_ibm_init]: ibm_ht_w(",its,":",ite,", ",jts,":",jte,") for grid%id=",config_flags%grid_id
         write(*,'(A)',ADVANCE='NO') "    "
         DO i=its,ite-1
             write(*,'(I5,A)',ADVANCE='NO') i," "
         ENDDO
         write(*,'(I5)') ite
         DO j=jts,jte
             write(*,'(I3,A)',ADVANCE='NO') j," "
             DO i=its,ite-1
                 write(*,'(F5.1,A)',ADVANCE='NO') ibm_ht_w(i,j)," "
             ENDDO
             write(*,'(F5.1)') ibm_ht_w(ite,j)
         ENDDO
     ELSEIF (config_flags%ideal_terrain .EQ. 114) THEN
         DO i=its,ite
             DO j=jts,jte
                 ibm_ht_w(i,j) =  phb(i,   1, j  ) / 9.81
                 ibm_ht_u(i,j) = (phb(i-1, 1, j  ) + phb(i,   1, j  )) / (2.0*9.81)
                 ibm_ht_v(i,j) = (phb(i,   1, j-1) + phb(i,   1, j  )) / (2.0*9.81)
                 ibm_ht_c(i,j) = (phb(i-1, 1, j-1) + phb(i-1, 1, j  ) + &
                                  phb(i,   1, j-1) + phb(i,   1, j  )) / (4.0*9.81)
             ENDDO
         ENDDO
         IF (((its .GE. (ide-ids)/2+ids-5) .OR. (ite .LE. (ide-ids)/2+ids+5)) .AND. &
             ((jts .GE. (jde-jds)/2+jds-5) .OR. (jte .LE. (jde-jds)/2+jds+5))) THEN
             DO i=MAX(its,(ide-ids)/2+ids-5),MIN(ite,(ide-ids)/2+ids+5)
                 DO j=MAX(jts,(jde-jds)/2+jds-5),MIN(jte,(jde-jds)/2+jds+5)
                     ibm_ht_w(i,j) = 400.0
                     ibm_ht_u(i,j) = 400.0
                     ibm_ht_v(i,j) = 400.0
                     ibm_ht_c(i,j) = 400.0
                 ENDDO
             ENDDO
         ENDIF
     ELSEIF (config_flags%ideal_terrain .EQ. 115) THEN
         !This will add an angled set of buildings to the existing IBM height
         DO i=its,ite
             DO j=jts,jte
                 ibm_ht_w(i,j) =  phb(i,   1, j  ) / 9.81
                 ibm_ht_u(i,j) = (phb(i-1, 1, j  ) + phb(i,   1, j  )) / (2.0*9.81)
                 ibm_ht_v(i,j) = (phb(i,   1, j-1) + phb(i,   1, j  )) / (2.0*9.81)
                 ibm_ht_c(i,j) = (phb(i-1, 1, j-1) + phb(i-1, 1, j  ) + &
                                  phb(i,   1, j-1) + phb(i,   1, j  )) / (4.0*9.81)
             ENDDO
         ENDDO
         bldx = 75.0 !east-west width of building
         bldy = 75.0 !north-south width of building
         bldz = 10.0 !height of building
         gapx = 150.0 !east-west gap between buildings
         gapy = 150.0 !north-south gap between buildings
         theta = 10.0*2.0*4.0*ATAN(1.0_8)/360.0 !angle of buildings (deviation clockwise from north)
         DO i=(its-1)*2,(ite-1)*2
             DO j=(jts-1)*2,(jte-1)*2
                 xoff = j*config_flags%dy/2.0*TAN(theta)
                 bx = MOD(i*config_flags%dx/2.0+xoff, gapx+bldx)
                 IF ((bx .GE. (gapx+bldx)/2.0-bldx/2.0) .AND. (bx .LE. (gapx+bldx)/2.0+bldx/2.0)) THEN
                     yoff = i*config_flags%dx/2.0*TAN(-theta)
                     by = MOD(j*config_flags%dy/2.0+yoff, gapy+bldy)
                     IF ((by .GE. (gapy+bldy)/2.0-bldy/2.0) .AND. (by .LE. (gapy+bldy)/2.0+bldy/2.0)) THEN
                         IF ((FLOOR(i/2.0) .EQ. i/2.0) .AND. (FLOOR(j/2.0) .EQ. j/2.0)) THEN
                             ibm_ht_c(FLOOR(i/2.0)+1,FLOOR(j/2.0)+1) = ibm_ht_c(FLOOR(i/2.0)+1,FLOOR(j/2.0)+1)+bldz
                         ELSEIF (FLOOR(i/2.0) .EQ. i/2.0) THEN
                             ibm_ht_u(FLOOR(i/2.0)+1,FLOOR(j/2.0)+1) = ibm_ht_u(FLOOR(i/2.0)+1,FLOOR(j/2.0)+1)+bldz
                         ELSEIF (FLOOR(j/2.0) .EQ. j/2.0) THEN
                             ibm_ht_v(FLOOR(i/2.0)+1,FLOOR(j/2.0)+1) = ibm_ht_v(FLOOR(i/2.0)+1,FLOOR(j/2.0)+1)+bldz
                         ELSE
                             ibm_ht_w(FLOOR(i/2.0)+1,FLOOR(j/2.0)+1) = ibm_ht_w(FLOOR(i/2.0)+1,FLOOR(j/2.0)+1)+bldz
                         ENDIF
                     ENDIF
                 ENDIF
             ENDDO !j-loop
         ENDDO !i-loop
     ELSEIF (config_flags%ideal_terrain .EQ. 116) THEN
         !This will add a set of buildings offset at an angle to the existing IBM height
         !The result is different than 115 since the buildings in 116 are still
         !oriented north-south instead of rotating to match the offset angle.
         DO i=its,ite
             DO j=jts,jte
                 ibm_ht_w(i,j) =  phb(i,   1, j  ) / 9.81
                 ibm_ht_u(i,j) = (phb(i-1, 1, j  ) + phb(i,   1, j  )) / (2.0*9.81)
                 ibm_ht_v(i,j) = (phb(i,   1, j-1) + phb(i,   1, j  )) / (2.0*9.81)
                 ibm_ht_c(i,j) = (phb(i-1, 1, j-1) + phb(i-1, 1, j  ) + &
                                  phb(i,   1, j-1) + phb(i,   1, j  )) / (4.0*9.81)
             ENDDO
         ENDDO
         bldx = 80.0 !east-west width of buildings
         bldy = 80.0 !north-south width of buildings
         bldz = 10.0 !height AGL of buildings
         gapx = 240.0 !east-west gap between buildings
         gapy = 240.0 !north-south gap between buildings
         theta = 30.0 !angle (degrees) of buildings (clockwise from north)
         DO j=(jts-1)*2,(jte-1)*2+1
             by = j*config_flags%dy/2.0-(FLOOR(j*config_flags%dy/2.0/(gapy+bldy))+0.5)*(gapy+bldy)
             keepgoing = .TRUE.
             ymid = (FLOOR(j*config_flags%dy/2.0/(gapy+bldy))+0.5)*(gapy+bldy)
             IF ((ymid-bldy/2.0 .LE. (config_flags%spec_bdy_width-0.5)*config_flags%dy) .OR. &
                 (ymid+bldy/2.0 .GE. (jde-config_flags%spec_bdy_width-0.5)*config_flags%dy)) THEN
                 keepgoing = .FALSE.
             ENDIF
             IF ((by .GE. -bldy/2.0) .AND. (by .LE. bldy/2.0) .AND. keepgoing) THEN
                 yoff = FLOOR(j*config_flags%dy/2.0/(gapy+bldy))*(gapy+bldy)
                 xoff = yoff*TAN(-theta*2.0*4.0*ATAN(1.0_8)/360.0)
                 DO i=(its-1)*2,(ite-1)*2+1
                     bx = (i*config_flags%dx/2.0+xoff)-(FLOOR((i*config_flags%dx/2.0+xoff)/(gapx+bldx))+0.5)*(gapx+bldx)
                     keepgoing = .TRUE.
                     xmid = i*config_flags%dx/2.0-bx
                     IF ((xmid-bldx/2.0 .LE. (config_flags%spec_bdy_width-0.5)*config_flags%dx) .OR. &
                         (xmid+bldx/2.0 .GE. (ide-config_flags%spec_bdy_width-0.5)*config_flags%dx)) THEN
                         keepgoing = .FALSE.
                     ENDIF
                     IF ((bx .GE. -bldx/2.0) .AND. (bx .LE. bldx/2.0) .AND. keepgoing) THEN
                         IF ((FLOOR(i/2.0) .EQ. i/2.0) .AND. (FLOOR(j/2.0) .EQ. j/2.0)) THEN
                             ibm_ht_c(FLOOR(i/2.0)+1,FLOOR(j/2.0)+1) = ibm_ht_c(FLOOR(i/2.0)+1,FLOOR(j/2.0)+1)+bldz
                         ELSEIF (FLOOR(i/2.0) .EQ. i/2.0) THEN
                             ibm_ht_u(FLOOR(i/2.0)+1,FLOOR(j/2.0)+1) = ibm_ht_u(FLOOR(i/2.0)+1,FLOOR(j/2.0)+1)+bldz
                         ELSEIF (FLOOR(j/2.0) .EQ. j/2.0) THEN
                             ibm_ht_v(FLOOR(i/2.0)+1,FLOOR(j/2.0)+1) = ibm_ht_v(FLOOR(i/2.0)+1,FLOOR(j/2.0)+1)+bldz
                         ELSE
                             ibm_ht_w(FLOOR(i/2.0)+1,FLOOR(j/2.0)+1) = ibm_ht_w(FLOOR(i/2.0)+1,FLOOR(j/2.0)+1)+bldz
                         ENDIF
                     ENDIF !within x-extents of building
                 ENDDO !x-loop
             ENDIF !within y-extents of building
         ENDDO !y-loop
     ENDIF !ideal_terrain
 ENDIF !ibm_opt=3

 CALL calc_ht_all_init ( phb, ph,                      &
                         ht_s, ht_u, ht_v, ht_w,       &
                         ids, ide, jds, jde, kds, kde, &
                         ims, ime, jms, jme, kms, kme, &
                         its, ite, jts, jte, kts, kte )

 IF ( (config_flags%ibm_temp .EQ. 1) .OR. &
      (config_flags%ibm_scalar .EQ. 1) ) THEN
    CALL ghost_pts_top ( 't', ht_s, ibm_ht_w,          &
                         top_s, prox_s, inside_s,      &
                         ids, ide, jds, jde, kds, kde, &
                         ims, ime, jms, jme, kms, kme, &
                         its, ite, jts, jte, kts, kte )
 ELSEIF ( (config_flags%ibm_temp .EQ. 2) .OR. &
          (config_flags%ibm_temp .EQ. 3) .OR. &
          (config_flags%ibm_scalar .EQ. 2) ) THEN
    CALL reconstruct_pts_top ( 't', ht_s, ibm_ht_w,          &
                               top_s, inside_s,              &
                               inside_all_s,                 & !RSA for using recon pts as neighbors
                               config_flags%z_rough,         &
                               .true.,                       & !zero_within_z_rough
                               config_flags%recon_pt_bump_tol,           & !RSA
                               config_flags%bump_up_recon_pt_within_tol, & !RSA
                               ids, ide, jds, jde, kds, kde, &
                               ims, ime, jms, jme, kms, kme, &
                               its, ite, jts, jte, kts, kte )
 ENDIF

 IF ( (config_flags%ibm_opt .EQ. 1) .OR. &
      (config_flags%ibm_opt .EQ. 2) .OR. &
      (config_flags%ibm_opt .EQ. 4) .OR. &
      (config_flags%ibm_opt .EQ. 6) ) THEN
    CALL ghost_pts_top ( 'u', ht_u, ibm_ht_u,          &
                         top_u, prox_u, inside_u,      &
                         ids, ide, jds, jde, kds, kde, &
                         ims, ime, jms, jme, kms, kme, &
                         its, ite, jts, jte, kts, kte )
    CALL ghost_pts_top ( 'v', ht_v, ibm_ht_v,          &
                         top_v, prox_v, inside_v,      &
                         ids, ide, jds, jde, kds, kde, &
                         ims, ime, jms, jme, kms, kme, &
                         its, ite, jts, jte, kts, kte )
    CALL ghost_pts_top ( 'w', ht_w, ibm_ht_w,          &
                         top_w, prox_w, inside_w,      &
                         ids, ide, jds, jde, kds, kde, &
                         ims, ime, jms, jme, kms, kme, &
                         its, ite, jts, jte, kts, kte )  
 ELSEIF (config_flags%ibm_opt .EQ. 3) THEN
    CALL reconstruct_pts_top ( 'u', ht_u, ibm_ht_u,              &
                               top_u, inside_u,                  &
                               inside_all_u,                     & !RSA for using recon pts as neighbors
                               config_flags%z_rough,             &
                               config_flags%zero_within_z_rough, &
                               config_flags%recon_pt_bump_tol,           & !RSA
                               config_flags%bump_up_recon_pt_within_tol, & !RSA
                               ids, ide, jds, jde, kds, kde,     &
                               ims, ime, jms, jme, kms, kme,     &
                               its, ite, jts, jte, kts, kte )
    CALL reconstruct_pts_top ( 'v', ht_v, ibm_ht_v,              &
                               top_v, inside_v,                  &
                               inside_all_v,                     & !RSA for using recon pts as neighbors
                               config_flags%z_rough,             &
                               config_flags%zero_within_z_rough, &
                               config_flags%recon_pt_bump_tol,           & !RSA
                               config_flags%bump_up_recon_pt_within_tol, & !RSA
                               ids, ide, jds, jde, kds, kde,     &
                               ims, ime, jms, jme, kms, kme,     &
                               its, ite, jts, jte, kts, kte )
    CALL reconstruct_pts_top ( 'w', ht_w, ibm_ht_w,              &
                               top_w, inside_w,                  &
                               inside_all_w,                     & !RSA for using recon pts as neighbors
                               config_flags%z_rough,             &
                               config_flags%zero_within_z_rough, &
                               config_flags%recon_pt_bump_tol,           & !RSA
                               config_flags%bump_up_recon_pt_within_tol, & !RSA
                               ids, ide, jds, jde, kds, kde,     &
                               ims, ime, jms, jme, kms, kme,     &
                               its, ite, jts, jte, kts, kte )
 ELSEIF (config_flags%ibm_opt .EQ. 5) THEN
    CALL ghost_pts_top_ss ( 'u', ht_u, ibm_ht_u,          &
                            top_u, inside_u,              &
                            ids, ide, jds, jde, kds, kde, &
                            ims, ime, jms, jme, kms, kme, &
                            its, ite, jts, jte, kts, kte )
    CALL ghost_pts_top_ss ( 'v', ht_v, ibm_ht_v,          &
                            top_v, inside_v,              &
                            ids, ide, jds, jde, kds, kde, &
                            ims, ime, jms, jme, kms, kme, &
                            its, ite, jts, jte, kts, kte )
    CALL ghost_pts_top_ss ( 'w', ht_w, ibm_ht_w,          &
                            top_w, inside_w,              &
                            ids, ide, jds, jde, kds, kde, &
                            ims, ime, jms, jme, kms, kme, &
                            its, ite, jts, jte, kts, kte )
 ENDIF !ibm_opt

 END SUBROUTINE start_ibm_init

!--------------------------------------------------------------------------------------------------------

 SUBROUTINE start_scalar_ibm( config_flags, stag, bc_type,  &
                              var,                          &
                              num_moist, moist,             &
                              num_scalar, scalar,           &
                              ibm_ht_u, ibm_ht_v,           &
                              ibm_ht_w, ibm_ht_c,           &
                              ht_s, top_s,                  &
                              prox_s, inside_s,             &
                              inside_all_s,                 &
                              n,                            &
                              ids, ide, jds, jde, kds, kde, &
                              ims, ime, jms, jme, kms, kme, &
                              its, ite, jts, jte, kts, kte )
 IMPLICIT NONE
 !input data
 TYPE(grid_config_rec_type),                 INTENT(IN   ) :: config_flags
 INTEGER,                                    INTENT(IN   ) :: bc_type,     &  !1 = dirchlet, 2 = neumann
                                                              num_moist,   &
                                                              num_scalar 
 CHARACTER,                                  INTENT(IN   ) :: stag
 REAL, DIMENSION(ims:ime,kms:kme,jms:jme),   INTENT(INOUT) :: var             !pot temp
 REAL, DIMENSION(ims:ime,kms:kme,jms:jme,num_moist) ,                      &
                                             INTENT(INOUT) :: moist
 REAL, DIMENSION(ims:ime,kms:kme,jms:jme,num_scalar),                      &
                                             INTENT(INOUT) :: scalar
 REAL, DIMENSION(ims:ime,jms:jme),           INTENT(IN   ) :: ibm_ht_u,    &
                                                              ibm_ht_v,    &
                                                              ibm_ht_w,    &
                                                              ibm_ht_c
 INTEGER, DIMENSION(ims:ime,jms:jme),        INTENT(IN   ) :: top_s           !'top boundary' ghost points
 REAL, DIMENSION(ims:ime,kms:kme,jms:jme),   INTENT(IN   ) :: ht_s            !this is the total height of the cell center
 INTEGER, DIMENSION(ims:ime,jms:jme),        INTENT(IN   ) :: prox_s
 INTEGER, DIMENSION(ims:ime,kms:kme,jms:jme),INTENT(IN   ) :: inside_s        !one if the pt is inside boundary, zero if it is outside
 INTEGER, DIMENSION(ims:ime,kms:kme,jms:jme),INTENT(IN   ) :: inside_all_s    !RSA inside includes recon pts, inside_all does not
 INTEGER,                                    INTENT(IN   ) :: n               !desired number of nearest neighbors							    
 INTEGER, INTENT(IN   )                                    :: ids, ide, jds, jde, kds, kde, & !d: domain 
                                                              ims, ime, jms, jme, kms, kme, & !m: memory
                                                              its, ite, jts, jte, kts, kte    !p: patch, t: tile
   
 !local data
 INTEGER                                                   :: ns,          &  !number of 'side boundary' ghost points
                                                              is,          &  !counter for scalar loops
                                                              i, j, k
 INTEGER, DIMENSION(ims:ime,jms:jme)                       :: ants            !actual number of nearest neighbors for top points
 REAL, DIMENSION(ims:ime,jms:jme)                          :: grad,        &  !gradient at boundary
                                                              top_dist        !1/2 of the distance from the ghost point to the image/interpolation pt
                                                                              !    the distance from the surface to the image/interpolation pt (used for
                                                                              !    neumann boundary condition with ibm interp method 2) 
 REAL, DIMENSION(ims:ime,jms:jme,6)                        :: top_s_img       !(x,y,z) location of ghost point and image point of the 'top boundary' ghost points
 REAL, DIMENSION(ims:ime,jms:jme,3)                        :: top_s_bound, &  !keep the (x,y,z) location of the boundary points for the no-slip bc
                                                              top_norm
 REAL, DIMENSION(ims:ime,jms:jme,0:3*n-1)                  :: top_s_neigh     !(x,y,z) location of top neighbors
 INTEGER, DIMENSION(ims:ime,jms:jme,0:3*n-1)               :: top_s_neigh_i   !(i,j,k) index of top neighbors							    
 INTEGER, DIMENSION(:), ALLOCATABLE                        :: anss            !actual number of nearest neighbors for side points  
 INTEGER, DIMENSION(:,:), ALLOCATABLE                      :: side_s          !'side boundary' ghost points
 REAL, DIMENSION(:,:), ALLOCATABLE                         :: side_s_img,   & !(x,y,z) location of ghost point
                                                              side_s_bound, & !(x,y,z) location of the boundary for side points
                                                              side_s_neigh, & !(x,y,z) location of side neighbors
                                                              side_norm
 REAL, DIMENSION(:), ALLOCATABLE                           :: side_dist
 INTEGER, DIMENSION(:,:), ALLOCATABLE                      :: side_s_neigh_i  !(i,j,k) index of side neighbors							    
 LOGICAL                                                   :: in_scalar !RSA flag for neighbors_ns (true for temp or scalar, false for velocity)
 LOGICAL                                                   :: in_vel_recon !RSA for now, only use recon pts as nearest neighbors from vel_recon routines
!---------------------------------------------------------------------------------
! the executable begins here
 CALL wrf_debug ( 100 , 'dyn_em/module_ibm.F/subroutine start_scalar_ibm' )
!---------------------------------------------------------------------------------
 !initialize scalar fluxes
 grad = 0.0

 CALL count_side_pts( stag, top_s, ns,              &
                      ids, ide, jds, jde, kds, kde, &
                      ims, ime, jms, jme, kms, kme, &
                      its, ite, jts, jte, kts, kte )

 !allocate and store side ghost points
 ALLOCATE (side_s(3,ns))
 ALLOCATE (side_s_img(6,ns))
 ALLOCATE (side_s_bound(3,ns))
 ALLOCATE (side_s_neigh(0:3*n-1,ns))
 ALLOCATE (side_s_neigh_i(0:3*n-1,ns))
 ALLOCATE (side_norm(3,ns))
 ALLOCATE (side_dist(ns))
 ALLOCATE (anss(ns))

 IF (ns .GT. 0) THEN
    CALL ghost_pts_side( stag, top_s, side_s, ns,      &
                         ids, ide, jds, jde, kds, kde, &
                         ims, ime, jms, jme, kms, kme, &
                         its, ite, jts, jte, kts, kte )
 ENDIF !end of get side points

 CALL image_pts ( stag,config_flags%interp_opt, bc_type, &
                  config_flags%dx, config_flags%dy,      &
                  ht_s,                                  &
                  ibm_ht_u, ibm_ht_v,                    &
                  ibm_ht_w, ibm_ht_c,                    &
                  top_s, side_s,                         &
                  top_s_img, top_s_bound,                &
                  side_s_img, side_s_bound,              &
                  prox_s, ns, top_norm, side_norm,       &
                  top_dist,                              &
                  side_dist,                             &
                  ids, ide, jds, jde, kds, kde,          &
                  ims, ime, jms, jme, kms, kme,          &
                  its, ite, jts, jte, kts, kte )

 in_scalar = .true. !RSA flag for neighbors_ns (true for temp or scalar, false for velocity)
 in_vel_recon = .false. !RSA for now, only use recon pts as nearest neighbors from vel_recon routines
 CALL neighbors_ns( config_flags%ibm_opt,                    &
                    config_flags%ibm_scalar,                 & !RSA for using VRM with ghost pt scalar BC
                    in_scalar,                               & !RSA for using VRM with ghost pt scalar BC
                    config_flags%interp_opt,                 &
                    config_flags%dim_terrain, stag, bc_type, &
                    config_flags%ibm_nn_horz,                &
                    config_flags%ibm_nn_vert,                &
                    config_flags%dx, config_flags%dy,        &
                    prox_s,                                  &
                    ibm_ht_u, ibm_ht_v,                      &
                    ibm_ht_w, ibm_ht_c,                      &
                    ht_s, inside_s,                          &
                    inside_all_s,                            & !RSA for using recon pts as neighbors
                    config_flags%recon_pts_as_neigh,         & !RSA for using recon pts as neighbors
                    in_vel_recon,                            & !RSA for using recon pts as neighbors
                    top_s, side_s, top_s_img, side_s_img,    &
                    top_s_bound, side_s_bound,               &
                    top_s_neigh, top_s_neigh_i,              &
                    side_s_neigh, side_s_neigh_i,            &
                    n, ns, ants, anss,                       &
                    ids, ide, jds, jde, kds, kde,            &
                    ims, ime, jms, jme, kms, kme,            &
                    its, ite, jts, jte, kts, kte )

 IF (config_flags%write_ibm_data) THEN
    write(*,'(A,A)') "DJW[module_ibm/start_scalar_ibm]: calling write_ibm_data for stag=",stag
    CALL write_ibm_data( stag, side_s,                 &
                         top_s_img, side_s_img,        &
                         top_s_bound, side_s_bound,    &
                         top_s_neigh, side_s_neigh,    &
                         n, ns,                        &
                         ids, ide, jds, jde, kds, kde, &
                         ims, ime, jms, jme, kms, kme, &
                         its, ite, jts, jte, kts, kte )
 ENDIF

 IF (bc_type .EQ. 1) THEN
    write(0,*) 'Dirchlet Boundary Condition not set for Temp, Moist, or Scalar'
 ELSEIF (bc_type .EQ. 2) THEN
    IF (config_flags%interp_opt .EQ. 1) THEN
       CALL neumann_lin( var, prox_s, config_flags%dim_terrain, & 
                         grad,                                  &
                         top_norm, side_norm,                   &
                         top_dist, side_dist,                   &
                         top_s, top_s_img,                      &
                         side_s, side_s_img,                    &
                         top_s_neigh, side_s_neigh,             &
                         top_s_neigh_i, side_s_neigh_i,         &
                         n, ns,                                 &
                         ids, ide, jds, jde, kds, kde,          &
                         ims, ime, jms, jme, kms, kme,          &
                         its, ite, jts, jte, kts, kte )
    ELSEIF ((config_flags%interp_opt .EQ. 2) .OR. (config_flags%interp_opt .EQ. 3)) THEN
       CALL neumann_inverse_dist( var, prox_s, config_flags%dim_terrain, & 
                                  grad,                                  &
                                  top_norm, side_norm,                   &
                                  top_dist, side_dist,                   &
                                  top_s, top_s_img,                      &
                                  side_s, side_s_img,                    &
                                  top_s_neigh, side_s_neigh,             &
                                  top_s_neigh_i, side_s_neigh_i,         &
                                  n, ns, ants, anss,                     &
                                  ids, ide, jds, jde, kds, kde,          &
                                  ims, ime, jms, jme, kms, kme,          &
                                  its, ite, jts, jte, kts, kte )
    ENDIF
    
    IF (num_moist .GE. PARAM_FIRST_SCALAR) THEN 
       DO is=PARAM_FIRST_SCALAR, num_moist
          IF (config_flags%interp_opt .EQ. 1) THEN
             CALL neumann_lin( moist(ims:ime,kms:kme,jms:jme,is), &
                               prox_s, config_flags%dim_terrain,  &
                               grad,                              &
                               top_norm, side_norm,               &
                               top_dist, side_dist,               &
                               top_s, top_s_img,                  &
                               side_s, side_s_img,                &
                               top_s_neigh, side_s_neigh,         &
                               top_s_neigh_i, side_s_neigh_i,     &
                               n, ns,                             &
                               ids, ide, jds, jde, kds, kde,      &
                               ims, ime, jms, jme, kms, kme,      &
                               its, ite, jts, jte, kts, kte )
          ELSEIF ((config_flags%interp_opt .EQ. 2) .OR. (config_flags%interp_opt .EQ. 3)) THEN
             CALL neumann_inverse_dist( moist(ims:ime,kms:kme,jms:jme,is), &
                                        prox_s, config_flags%dim_terrain,  &
                                        grad,                              &
                                        top_norm, side_norm,               &
                                        top_dist, side_dist,               &
                                        top_s, top_s_img,                  &
                                        side_s, side_s_img,                &
                                        top_s_neigh, side_s_neigh,         &
                                        top_s_neigh_i, side_s_neigh_i,     &
                                        n, ns, ants, anss,                 &
                                        ids, ide, jds, jde, kds, kde,      &
                                        ims, ime, jms, jme, kms, kme,      &
                                        its, ite, jts, jte, kts, kte )
          ENDIF
       ENDDO 
    ENDIF

    IF (num_scalar .GE. PARAM_FIRST_SCALAR) THEN
       DO is=PARAM_FIRST_SCALAR, num_scalar
          IF (config_flags%interp_opt .EQ. 1) THEN
             CALL neumann_lin( scalar(ims:ime,kms:kme,jms:jme,is), &
                               prox_s, config_flags%dim_terrain,   &
                               grad,                               &
                               top_norm, side_norm,                &
                               top_dist, side_dist,                &
                               top_s, top_s_img,                   &
                               side_s, side_s_img,                 &
                               top_s_neigh, side_s_neigh,          &
                               top_s_neigh_i, side_s_neigh_i,      &
                               n, ns,                              &
                               ids, ide, jds, jde, kds, kde,       &
                               ims, ime, jms, jme, kms, kme,       &
                               its, ite, jts, jte, kts, kte )
          ELSEIF ((config_flags%interp_opt .EQ. 2) .OR. (config_flags%interp_opt .EQ. 3)) THEN
             CALL neumann_inverse_dist( scalar(ims:ime,kms:kme,jms:jme,is), &
                                        prox_s, config_flags%dim_terrain,   &
                                        grad,                               &
                                        top_norm, side_norm,                &
                                        top_dist, side_dist,                &
                                        top_s, top_s_img,                   &
                                        side_s, side_s_img,                 &
                                        top_s_neigh, side_s_neigh,          &
                                        top_s_neigh_i, side_s_neigh_i,      &
                                        n, ns, ants, anss,                  &
                                        ids, ide, jds, jde, kds, kde,       &
                                        ims, ime, jms, jme, kms, kme,       &
                                        its, ite, jts, jte, kts, kte )
          ENDIF
       ENDDO
    ENDIF
 ENDIF !end of bc_type 1 or 2

 !deallocate side ghost points
 CALL wrf_debug(100, 'deallocate dyn_em/module_ibm.F/subroutine start_scalar_ibm')
 DEALLOCATE (side_s)
 DEALLOCATE (side_s_img)
 DEALLOCATE (side_s_bound)
 DEALLOCATE (side_s_neigh)
 DEALLOCATE (side_s_neigh_i)
 DEALLOCATE (side_norm)
 DEALLOCATE (side_dist)
 DEALLOCATE (anss)

 END SUBROUTINE start_scalar_ibm

!-------------------------------------------------------------------------------

 SUBROUTINE start_vel_ns_ibm ( config_flags,                              &
                               u_1, v_1, w_1,                             &
                               u_2, v_2, w_2,                             &
                               ibm_ht_u, ibm_ht_v,                        &
                               ibm_ht_w, ibm_ht_c,                        &
                               ht_u, ht_v, ht_w,                          &
                               top_u, top_v, top_w,                       &
                               prox_u, prox_v,prox_w,                     &
                               inside_u, inside_v, inside_w,              & 
                               inside_all_u, inside_all_v, inside_all_w,  & !RSA
                               n,                                         &
                               ids, ide, jds, jde, kds, kde,              &
                               ims, ime, jms, jme, kms, kme,              &
                               its, ite, jts, jte, kts, kte )
 IMPLICIT NONE
 !input data
 TYPE(grid_config_rec_type), INTENT(IN   )               :: config_flags
 REAL, DIMENSION(ims:ime,kms:kme,jms:jme), INTENT(INOUT) :: u_1, v_1, w_1,  &  
                                                            u_2, v_2, w_2
 REAL, DIMENSION(ims:ime,jms:jme), INTENT(IN   )         :: ibm_ht_u,       & ! ibm terrain height at velocity points
                                                            ibm_ht_v,       & ! terrain height has twice the resolution of
                                                            ibm_ht_w,       & ! the computational grid							    
                                                            ibm_ht_c          ! ibm terrain height at corners
 REAL, DIMENSION(ims:ime,kms:kme,jms:jme), INTENT(IN   ) :: ht_u,           & ! this is the total height
                                                            ht_v,           & ! at u, v, and w points
                                                            ht_w
 INTEGER, DIMENSION(ims:ime,jms:jme), INTENT(IN   )      :: top_u,     &     !'top boundary' ghost points
                                                            top_v,     &
                                                            top_w,     &
                                                            prox_u,    &
                                                            prox_v,    &
                                                            prox_w
 INTEGER, DIMENSION(ims:ime,kms:kme,jms:jme), INTENT(IN) :: inside_u,  &     ! one if the pt is inside boundary, zero if it is outside
                                                            inside_v,  &
                                                            inside_w
 INTEGER, DIMENSION(ims:ime,kms:kme,jms:jme), INTENT(IN) :: inside_all_u,  & ! RSA inside includes recon pts, inside_all does not
                                                            inside_all_v,  &
                                                            inside_all_w
 INTEGER, INTENT(IN   )                                  :: n               ! desired number of nearest neighbors  							    		
 INTEGER, INTENT(IN   )                                  :: ids, ide, jds, jde, kds, kde, &  ! d: domain m:memory p:patch t:tile 
                                                            ims, ime, jms, jme, kms, kme, &
                                                            its, ite, jts, jte, kts, kte   

 !local data
 INTEGER                                                 :: nu,nv,nw        ! number of 'side boundary' ghost point
 INTEGER, DIMENSION(ims:ime,jms:jme)                     :: antu,antv,antw  ! actual number of nearest neighbors for top points
 REAL, DIMENSION(ims:ime,jms:jme)                        :: top_dist        ! these variables are used for neumann bc (not here)
 REAL, DIMENSION(ims:ime,jms:jme,6)                      :: utop_img,    &  ! (x,y,z) location of ghost point
                                                            vtop_img,    &  ! and image point of the 'top boundary' ghost points
                                                            wtop_img
 REAL, DIMENSION(ims:ime,jms:jme,3)                      :: top_norm,    &  ! for neumann
                                                            utop_bound,  &  ! keep the (x,y,z) location of the
                                                            vtop_bound,  &  ! boundary points for the no-slip bc
                                                            wtop_bound
 REAL, DIMENSION(ims:ime,jms:jme,0:3*n-1)                :: utop_neigh,  &  ! (x,y,z) location of top neighbors
                                                            vtop_neigh,  &
                                                            wtop_neigh 
 INTEGER, DIMENSION(ims:ime,jms:jme,0:3*n-1)             :: utop_neigh_i,&  ! (i,j,k) index of top neighbors
                                                            vtop_neigh_i,&
                                                            wtop_neigh_i
 INTEGER, DIMENSION(:), ALLOCATABLE                      :: ansu,ansv,answ  ! actual number of nearest neighbors for side points
 REAL, DIMENSION(:), ALLOCATABLE                         :: uside_dist,  &  ! this variable is used for neumann bc
                                                            vside_dist,  &  ! but not used here
                                                            wside_dist 
 INTEGER, DIMENSION(:,:), ALLOCATABLE                    :: uside,       &  !'side boundary' ghost points
                                                            vside,       &
                                                            wside
 REAL, DIMENSION(:,:), ALLOCATABLE                       :: uside_img,   &  ! (x,y,z) location of ghost point
                                                            vside_img,   &  ! and image point of the 'side boundary' ghost points
                                                            wside_img,   &
                                                            uside_bound, &  ! (x,y,z) location of the boundary for side points
                                                            vside_bound, &
                                                            wside_bound, &  
                                                            uside_neigh, &  ! (x,y,z) location of side neighbors
                                                            vside_neigh, &
                                                            uside_norm,  &  ! not in use (for neumann)
                                                            vside_norm,  &
                                                            wside_norm,  &
                                                            wside_neigh
 INTEGER, DIMENSION(:,:), ALLOCATABLE                    :: uside_neigh_i,& ! (i,j,k) index of side neighbors
                                                            vside_neigh_i,&
                                                            wside_neigh_i
 LOGICAL                                                 :: in_scalar !RSA flag for neighbors_ns (true for temp or scalar, false for velocity)
 LOGICAL                                                 :: in_vel_recon !RSA for now, only use recon pts as nearest neighbors from vel_recon routines
!---------------------------------------------------------------------------------
! this subroutine is called from start_em.F.  
! the executable begins here
 CALL wrf_debug(100,'dyn_em/module_ibm.F/subroutine start_vel_ns_ibm')
!---------------------------------------------------------------------------------  

 CALL count_side_pts ( 'u', top_u, nu,                          &
                       ids, ide, jds, jde, kds, kde,            &
                       ims, ime, jms, jme, kms, kme,            &
                       its, ite, jts, jte, kts, kte )      
 CALL count_side_pts ( 'v', top_v, nv,                          &
                       ids, ide, jds, jde, kds, kde,            &
                       ims, ime, jms, jme, kms, kme,            &
                       its, ite, jts, jte, kts, kte )
 CALL count_side_pts ( 'w', top_w, nw,                          &
                       ids, ide, jds, jde, kds, kde,            &
                       ims, ime, jms, jme, kms, kme,            &
                       its, ite, jts, jte, kts, kte )
 
 ! allocate and store side ghost points
 ALLOCATE (uside(3,nu))
 ALLOCATE (uside_img(6,nu))
 ALLOCATE (uside_bound(3,nu))
 ALLOCATE (uside_neigh(0:3*n-1,nu))
 ALLOCATE (uside_neigh_i(0:3*n-1,nu))
 ALLOCATE (uside_norm(3,nu))
 ALLOCATE (uside_dist(nu))
 ALLOCATE (ansu(nu))
 ALLOCATE (vside(3,nv))
 ALLOCATE (vside_img(6,nv))
 ALLOCATE (vside_bound(3,nv))
 ALLOCATE (vside_neigh(0:3*n-1,nv))
 ALLOCATE (vside_neigh_i(0:3*n-1,nv))
 ALLOCATE (vside_norm(3,nv))
 ALLOCATE (vside_dist(nv))
 ALLOCATE (ansv(nv))
 ALLOCATE (wside(3,nw))
 ALLOCATE (wside_img(6,nw))
 ALLOCATE (wside_bound(3,nw))
 ALLOCATE (wside_neigh(0:3*n-1,nw))
 ALLOCATE (wside_neigh_i(0:3*n-1,nw))
 ALLOCATE (wside_norm(3,nw))
 ALLOCATE (wside_dist(nw))
 ALLOCATE (answ(nw))

 if (nu > 0) then
    CALL ghost_pts_side ( 'u', top_u, uside, nu,        &
                          ids, ide, jds, jde, kds, kde, &
                          ims, ime, jms, jme, kms, kme, &
                          its, ite, jts, jte, kts, kte )
 endif ! end of side ghost points
 if (nv > 0) then
    CALL ghost_pts_side ( 'v', top_v, vside, nv,        &
                          ids, ide, jds, jde, kds, kde, &
                          ims, ime, jms, jme, kms, kme, &
                          its, ite, jts, jte, kts, kte )
 endif ! end of side ghost points
 if (nw > 0) then
    CALL ghost_pts_side ( 'w', top_w, wside, nw,        &
                          ids, ide, jds, jde, kds, kde, &
                          ims, ime, jms, jme, kms, kme, &
                          its, ite, jts, jte, kts, kte )
 endif ! end of side ghost points

 ! only zero if this is the first run (not a restart)
 ! and if it is the no slip boundary condition
 !if ((.NOT. config_flags%restart).AND.(config_flags%ibm_opt == 2)) then
 IF ((.NOT. config_flags%restart) .AND. (config_flags%zero_interior)) THEN
      CALL zero_interior ( config_flags%ibm_opt,         &
                           u_1, v_1, w_1,                &
                           top_u, top_v, top_w,          &
                           ids, ide, jds, jde, kds, kde, &
                           ims, ime, jms, jme, kms, kme, &
                           its, ite, jts, jte, kts, kte)

      CALL zero_interior ( config_flags%ibm_opt,         &
                           u_2, v_2, w_2,                &
                           top_u, top_v, top_w,          &
                           ids, ide, jds, jde, kds, kde, &
                           ims, ime, jms, jme, kms, kme, &
                           its, ite, jts, jte, kts, kte)
 ENDIF

 CALL image_pts ( 'u', config_flags%interp_opt, 1,       &
                  config_flags%dx, config_flags%dy,      &  !The variable top_slope can be calculated in this
                  ht_u,                                  &  !subroutine. It is used for the free slip
                  ibm_ht_u, ibm_ht_v,                    &  !boundary condition (right now just 2d terrain)
                  ibm_ht_w, ibm_ht_c,                    &
                  top_u, uside,                          &
                  utop_img, utop_bound,                  &
                  uside_img, uside_bound,                &
                  prox_u, nu, top_norm, uside_norm,      & !top_norm and side_norm are only used for the neumann bd
                  top_dist, uside_dist,                  & !top_dist and side_dist are only used for the neumann bc
                  ids, ide, jds, jde, kds, kde,          &
                  ims, ime, jms, jme, kms, kme,          &
                  its, ite, jts, jte, kts, kte )
 CALL image_pts ( 'v', config_flags%interp_opt, 1,       &
                  config_flags%dx, config_flags%dy,      &  
                  ht_v,                                  &  
                  ibm_ht_u, ibm_ht_v,                    &  
                  ibm_ht_w, ibm_ht_c,                    &
                  top_v, vside,                          &
                  vtop_img, vtop_bound,                  &
                  vside_img, vside_bound,                &
                  prox_v, nv, top_norm, vside_norm,      & !top_norm and side_norm are only used for the neumann bd
                  top_dist, vside_dist,                  & !top_dist and side_dist are only used for the neumann bc
                  ids, ide, jds, jde, kds, kde,          &
                  ims, ime, jms, jme, kms, kme,          &
                  its, ite, jts, jte, kts, kte )
 CALL image_pts ( 'w', config_flags%interp_opt, 1,       &
                  config_flags%dx, config_flags%dy,      &  
                  ht_w,                                  &  
                  ibm_ht_u, ibm_ht_v,                    &  
                  ibm_ht_w, ibm_ht_c,                    &
                  top_w, wside,                          &
                  wtop_img, wtop_bound,                  &
                  wside_img, wside_bound,                &
                  prox_w, nw, top_norm, wside_norm,      & !top_norm and side_norm are only used for the neumann bd
                  top_dist, wside_dist,                  & !top_dist and side_dist are only used for the neumann bc
                  ids, ide, jds, jde, kds, kde,          &
                  ims, ime, jms, jme, kms, kme,          &
                  its, ite, jts, jte, kts, kte )

 if (config_flags%ibm_opt == 1) then
      write(0,*) 'Free Slip Boundary Condition is not implemented'
      !CALL neighbors_fs( config_flags%dx, config_flags%dy,           &
      !          	 ibm_ht_u, ibm_ht_v,                          &
      !			 ibm_ht_w, ibm_ht_c,                          &
      !          	 ht_u, ht_v, ht_w,                            &
      !			 uinside, vinside, winside,                   &
      !	        	 utop, vtop, wtop,                            &
      !			 uside, vside, wside,                         &
      !			 utop_img, vtop_img, wtop_img,                &
      !			 uside_img, vside_img, wside_img,             &
      !		         utop_bound, vtop_bound, wtop_bound,          &
      !			 uside_bound, vside_bound, wside_bound,       &
      !			 utop_neigh, vtop_neigh, wtop_neigh,          &
      !			 utop_neigh_i, vtop_neigh_i, wtop_neigh_i,    &
      !			 uside_neigh, vside_neigh, wside_neigh,       &
      !			 uside_neigh_i, vside_neigh_i, wside_neigh_i, & 
      !			 n, nu, nv, nw,                               &
      !               	 ids, ide, jds, jde, kds, kde,                &
      !               	 ims, ime, jms, jme, kms, kme,                &
      !			 its, ite, jts, jte, kts, kte)
 elseif (config_flags%ibm_opt == 2) then
      in_scalar = .false. !RSA flag for neighbors_ns (true for temp or scalar, false for velocity)
      in_vel_recon = .false. !RSA for now, only use recon pts as nearest neighbors from vel_recon routines
      CALL neighbors_ns( config_flags%ibm_opt,             &
                         config_flags%ibm_scalar,          & !RSA for using VRM with ghost pt scalar BC
                         in_scalar,                        & !RSA for using VRM with ghost pt scalar BC
                         config_flags%interp_opt,          &
                         config_flags%dim_terrain, 'u', 1, &
                         config_flags%ibm_nn_horz,         &
                         config_flags%ibm_nn_vert,         &
                         config_flags%dx, config_flags%dy, &
                         prox_u,                           &
                         ibm_ht_u, ibm_ht_v,               &
                         ibm_ht_w, ibm_ht_c,               &
                         ht_u, inside_u,                   &
                         inside_u,                         & !RSA for using recon pts as neighbors
                         config_flags%recon_pts_as_neigh,  & !RSA for using recon pts as neighbors
                         in_vel_recon,                     & !RSA for using recon pts as neighbors
                         top_u,uside, utop_img, uside_img, &
                         utop_bound, uside_bound,          &
                         utop_neigh, utop_neigh_i,         &
                         uside_neigh, uside_neigh_i,       &
                         n, nu, antu, ansu,                &
                         ids, ide, jds, jde, kds, kde,     &
                         ims, ime, jms, jme, kms, kme,     &
                         its, ite, jts, jte, kts, kte )
      CALL neighbors_ns( config_flags%ibm_opt,             &
                         config_flags%ibm_scalar,          & !RSA for using VRM with ghost pt scalar BC
                         in_scalar,                        & !RSA for using VRM with ghost pt scalar BC
                         config_flags%interp_opt,          &
                         config_flags%dim_terrain, 'v', 1, &
                         config_flags%ibm_nn_horz,         &
                         config_flags%ibm_nn_vert,         &
                         config_flags%dx, config_flags%dy, &
                         prox_v,                           &
                         ibm_ht_u, ibm_ht_v,               &
                         ibm_ht_w, ibm_ht_c,               &
                         ht_v, inside_v,                   &
                         inside_v,                         & !RSA for using recon pts as neighbors
                         config_flags%recon_pts_as_neigh,  & !RSA for using recon pts as neighbors
                         in_vel_recon,                     & !RSA for using recon pts as neighbors
                         top_v,vside, vtop_img, vside_img, &
                         vtop_bound, vside_bound,          &
                         vtop_neigh, vtop_neigh_i,         &
                         vside_neigh, vside_neigh_i,       &
                         n, nv,antv, ansv,                 &
                         ids, ide, jds, jde, kds, kde,     &
                         ims, ime, jms, jme, kms, kme,     &
                         its, ite, jts, jte, kts, kte )
      CALL neighbors_ns( config_flags%ibm_opt,             &
                         config_flags%ibm_scalar,          & !RSA for using VRM with ghost pt scalar BC
                         in_scalar,                        & !RSA for using VRM with ghost pt scalar BC
                         config_flags%interp_opt,          &
                         config_flags%dim_terrain, 'w', 1, &
                         config_flags%ibm_nn_horz,         &
                         config_flags%ibm_nn_vert,         &
                         config_flags%dx, config_flags%dy, &
                         prox_w,                           &
                         ibm_ht_u, ibm_ht_v,               &
                         ibm_ht_w, ibm_ht_c,               &
                         ht_w, inside_w,                   &
                         inside_w,                         & !RSA for using recon pts as neighbors
                         config_flags%recon_pts_as_neigh,  & !RSA for using recon pts as neighbors
                         in_vel_recon,                     & !RSA for using recon pts as neighbors
                         top_w,wside, wtop_img, wside_img, &
                         wtop_bound, wside_bound,          &
                         wtop_neigh, wtop_neigh_i,         &
                         wside_neigh, wside_neigh_i,       &
                         n, nw, antw, answ,                &
                         ids, ide, jds, jde, kds, kde,     &
                         ims, ime, jms, jme, kms, kme,     &
                         its, ite, jts, jte, kts, kte )
 endif

!#ifdef DM_PARALLEL
! ! figure out how to gather this
!#else
 IF (config_flags%write_ibm_data) THEN
    write(*,'(A)') "DJW[module_ibm/start_vel_ns_ibm]: calling write_ibm_data for stag=u"
    CALL write_ibm_data ( 'u', uside,                   &
                          utop_img, uside_img,          &
                          utop_bound, uside_bound,      &
                          utop_neigh, uside_neigh,      &
                          n, nu,                        &
                          ids, ide, jds, jde, kds, kde, &
                          ims, ime, jms, jme, kms, kme, &
                          its, ite, jts, jte, kts, kte )
    write(*,'(A)') "DJW[module_ibm/start_vel_ns_ibm]: calling write_ibm_data for stag=v"
    CALL write_ibm_data ( 'v', vside,                   &
                          vtop_img, vside_img,          &
                          vtop_bound, vside_bound,      &
                          vtop_neigh, vside_neigh,      &
                          n, nv,                        &
                          ids, ide, jds, jde, kds, kde, &
                          ims, ime, jms, jme, kms, kme, &
                          its, ite, jts, jte, kts, kte )
    write(*,'(A)') "DJW[module_ibm/start_vel_ns_ibm]: calling write_ibm_data for stag=w"
    CALL write_ibm_data ( 'w', wside,                   &
                          wtop_img, wside_img,          &
                          wtop_bound, wside_bound,      &
                          wtop_neigh, wside_neigh,      &
                          n, nw,                        &
                          ids, ide, jds, jde, kds, kde, &
                          ims, ime, jms, jme, kms, kme, &
                          its, ite, jts, jte, kts, kte )
!#endif
 ENDIF

 CALL terrain_check( top_u, top_v, top_w,          &
                     ids, ide, jds, jde, kds, kde, &
                     ims, ime, jms, jme, kms, kme, &
                     its, ite, jts, jte, kts, kte )

 if (config_flags%ibm_opt == 1) then
    !CALL free_slip_bilin ( top_slope, 				 &
    !  		     u_1, v_1, w_1,				 &
    !  		     ht_u, ht_v, ht_w,  			 &
    !  		     utop, vtop, wtop,  			 &
    !  		     uprox, vprox, wprox,			 &
    !  		     utop_img, vtop_img, wtop_img,		 &
    !  		     uside, vside, wside,			 &
    !  		     uside_img, vside_img, wside_img,		 &
    !  		     utop_neigh, vtop_neigh, wtop_neigh,	 &
    !  		     uside_neigh, vside_neigh, wside_neigh,	 &
    !  		     utop_neigh_i, vtop_neigh_i, wtop_neigh_i,   &
    !  		     uside_neigh_i, vside_neigh_i, wside_neigh_i,&
    !  		     n, nu, nv, nw,				 &
    !  		     ids, ide, jds, jde, kds, kde,		 &
    !  		     ims, ime, jms, jme, kms, kme,		 &
    !  		     its, ite, jts, jte, kts, kte)
    !CALL free_slip_bilin ( top_slope, 				 &
    !  		     u_2, v_2, w_2,				 &
    !
    !  		     ht_u, ht_v, ht_w,  			 &
    !  		     utop, vtop, wtop,  			 &
    !  		     uprox, vprox, wprox,			 &
    !  		     utop_img, vtop_img, wtop_img,		 &
    !  		     uside, vside, wside,			 &
    !  		     uside_img, vside_img, wside_img,		 &
    !  		     utop_neigh, vtop_neigh, wtop_neigh,	 &
    !  		     uside_neigh, vside_neigh, wside_neigh,	 &
    !  		     utop_neigh_i, vtop_neigh_i, wtop_neigh_i,   &
    !  		     uside_neigh_i, vside_neigh_i, wside_neigh_i,&
    !  		     n, nu, nv, nw,				 &
    !  		     ids, ide, jds, jde, kds, kde,		 &
    !  		     ims, ime, jms, jme, kms, kme,		 &
    !  		     its, ite, jts, jte, kts, kte)     
 elseif (config_flags%ibm_opt == 2) then
      if (config_flags%interp_opt == 1) then
         CALL no_slip_lin ( 'u', prox_u, config_flags%dim_terrain, &
                             u_1,                                  &
                             top_u, utop_img,                      &
                             uside, uside_img,                     &
                             utop_neigh, uside_neigh,              &
                             utop_neigh_i, uside_neigh_i,          &
                             n, nu,                                &
                             ids, ide, jds, jde, kds, kde,         &
                             ims, ime, jms, jme, kms, kme,         &
                             its, ite, jts, jte, kts, kte )
         CALL no_slip_lin ( 'u', prox_u, config_flags%dim_terrain, &
                             u_2,                                  &
                             top_u, utop_img,                      &
                             uside, uside_img,                     &
                             utop_neigh, uside_neigh,              &
                             utop_neigh_i, uside_neigh_i,          &
                             n, nu,                                &
                             ids, ide, jds, jde, kds, kde,         &
                             ims, ime, jms, jme, kms, kme,         &
                             its, ite, jts, jte, kts, kte )
         CALL no_slip_lin ( 'v', prox_v, config_flags%dim_terrain, &
                             v_1,                                  &
                             top_v, vtop_img,                      &
                             vside, vside_img,                     &
                             vtop_neigh, vside_neigh,              &
                             vtop_neigh_i, vside_neigh_i,          &
                             n, nv,                                &
                             ids, ide, jds, jde, kds, kde,         &
                             ims, ime, jms, jme, kms, kme,         &
                             its, ite, jts, jte, kts, kte )
         CALL no_slip_lin ( 'v', prox_v, config_flags%dim_terrain, &
                             v_2,                                  &
                             top_v, vtop_img,                      &
                             vside, vside_img,                     &
                             vtop_neigh, vside_neigh,              &
                             vtop_neigh_i, vside_neigh_i,          &
                             n, nv,                                &
                             ids, ide, jds, jde, kds, kde,         &
                             ims, ime, jms, jme, kms, kme,         &
                             its, ite, jts, jte, kts, kte )
         CALL no_slip_lin ( 'w', prox_w, config_flags%dim_terrain, &
                             w_1,                                  &
                             top_w, wtop_img,                      &
                             wside, wside_img,                     &
                             wtop_neigh, wside_neigh,              &
                             wtop_neigh_i, wside_neigh_i,          &
                             n, nw,                                &
                             ids, ide, jds, jde, kds, kde,         &
                             ims, ime, jms, jme, kms, kme,         &
                             its, ite, jts, jte, kts, kte )
         CALL no_slip_lin ( 'w', prox_w, config_flags%dim_terrain, &
                             w_2,                                  &
                             top_w, wtop_img,                      &
                             wside, wside_img,                     &
                             wtop_neigh, wside_neigh,              &
                             wtop_neigh_i, wside_neigh_i,          &
                             n, nw,                                &
                             ids, ide, jds, jde, kds, kde,         &
                             ims, ime, jms, jme, kms, kme,         &
                             its, ite, jts, jte, kts, kte )
      elseif ((config_flags%interp_opt == 2).OR.(config_flags%interp_opt == 3)) then
         CALL no_slip_inverse_dist ( 'u', prox_u,                  &
                             u_1,                                  &
                             top_u,                                &
                             uside,                                &
                             utop_neigh, uside_neigh,              &
                             utop_neigh_i, uside_neigh_i,          &
                             n, nu, antu, ansu,                    &
                             ids, ide, jds, jde, kds, kde,         &
                             ims, ime, jms, jme, kms, kme,         &
                             its, ite, jts, jte, kts, kte )
         CALL no_slip_inverse_dist ( 'u', prox_u,                  &
                             u_2,                                  &
                             top_u,                                &
                             uside,                                &
                             utop_neigh, uside_neigh,              &
                             utop_neigh_i, uside_neigh_i,          &
                             n, nu, antu, ansu,                    &
                             ids, ide, jds, jde, kds, kde,         &
                             ims, ime, jms, jme, kms, kme,         &
                             its, ite, jts, jte, kts, kte )
         CALL no_slip_inverse_dist ( 'v', prox_v,                  &
                             v_1,                                  &
                             top_v,                                &
                             vside,                                &
                             vtop_neigh, vside_neigh,              &
                             vtop_neigh_i, vside_neigh_i,          &
                             n, nv, antv, ansv,                    &
                             ids, ide, jds, jde, kds, kde,         &
                             ims, ime, jms, jme, kms, kme,         &
                             its, ite, jts, jte, kts, kte )
         CALL no_slip_inverse_dist ( 'v', prox_v,                  &
                             v_2,                                  &
                             top_v,                                &
                             vside,                                &
                             vtop_neigh, vside_neigh,              &
                             vtop_neigh_i, vside_neigh_i,          &
                             n, nv, antv, ansv,                    &
                             ids, ide, jds, jde, kds, kde,         &
                             ims, ime, jms, jme, kms, kme,         &
                             its, ite, jts, jte, kts, kte )
         CALL no_slip_inverse_dist ( 'w', prox_w,                  &
                             w_1,                                  &
                             top_w,                                &
                             wside,                                &
                             wtop_neigh, wside_neigh,              &
                             wtop_neigh_i, wside_neigh_i,          &
                             n, nw, antw, answ,                    &
                             ids, ide, jds, jde, kds, kde,         &
                             ims, ime, jms, jme, kms, kme,         &
                             its, ite, jts, jte, kts, kte )
         CALL no_slip_inverse_dist ( 'w', prox_w,                  &
                             w_2,                                  &
                             top_w,                                &
                             wside,                                &
                             wtop_neigh, wside_neigh,              &
                             wtop_neigh_i, wside_neigh_i,          &
                             n, nw, antw, answ,                    &
                             ids, ide, jds, jde, kds, kde,         &
                             ims, ime, jms, jme, kms, kme,         &
                             its, ite, jts, jte, kts, kte )
    endif
 endif

 ! deallocate 
 CALL wrf_debug(100,'deallocate dyn_em/module_ibm.F/subroutine start_vel_ns_ibm')
 DEALLOCATE (uside)
 DEALLOCATE (uside_img)
 DEALLOCATE (uside_bound)
 DEALLOCATE (uside_neigh)
 DEALLOCATE (uside_neigh_i)
 DEALLOCATE (uside_norm)
 DEALLOCATE (uside_dist)
 DEALLOCATE (ansu)
 DEALLOCATE (vside)
 DEALLOCATE (vside_img)
 DEALLOCATE (vside_bound)
 DEALLOCATE (vside_neigh)
 DEALLOCATE (vside_neigh_i)
 DEALLOCATE (vside_norm)
 DEALLOCATE (vside_dist)
 DEALLOCATE (ansv)
 DEALLOCATE (wside)
 DEALLOCATE (wside_img)
 DEALLOCATE (wside_bound)
 DEALLOCATE (wside_neigh)
 DEALLOCATE (wside_neigh_i)
 DEALLOCATE (wside_norm)
 DEALLOCATE (wside_dist)
 DEALLOCATE (answ)

 END SUBROUTINE start_vel_ns_ibm

!-------------------------------------------------------------------------------

 SUBROUTINE vel_recon_ibm_part1 ( config_flags,                 &
                                  top_s, top_u,                 &
                                  top_v, top_w,                 &
                                  inside_s, inside_u,           &
                                  inside_v, inside_w,           &
                                  ids, ide, jds, jde, kds, kde, &
                                  ims, ime, jms, jme, kms, kme, &
                                  its, ite, jts, jte, kts, kte )
 IMPLICIT NONE
 !input data
 TYPE(grid_config_rec_type), INTENT(IN   )                  :: config_flags
 INTEGER, DIMENSION(ims:ime,jms:jme), INTENT(IN   )         :: top_s,    & !'top boundary' ghost points
                                                               top_u,    &
                                                               top_v,    &
                                                               top_w
 INTEGER, DIMENSION(ims:ime,kms:kme,jms:jme), INTENT(INOUT) :: inside_s, & !one if the pt is inside boundary, zero if it is outside
                                                               inside_u, &
                                                               inside_v, &
                                                               inside_w
 INTEGER, INTENT(IN   )                                      :: ids, ide, jds, jde, kds, kde, & !d: domain 
                                                                ims, ime, jms, jme, kms, kme, & !m: memory
                                                                its, ite, jts, jte, kts, kte    !p: patch, t: tile
 !local data

!---------------------------------------------------------------------------------
 !this subroutine is called from start_em.F.  
 !the executable begins here
 CALL wrf_debug(100,'dyn_em/module_ibm.F/subroutine vel_recon_ibm_part1')
!---------------------------------------------------------------------------------  

 CALL label_side_pts_inside ( 'u', inside_u, top_u,         &
                              ids, ide, jds, jde, kds, kde, &
                              ims, ime, jms, jme, kms, kme, &
                              its, ite, jts, jte, kts, kte )
 CALL label_side_pts_inside ( 'v', inside_v, top_v,         &
                              ids, ide, jds, jde, kds, kde, &
                              ims, ime, jms, jme, kms, kme, &
                              its, ite, jts, jte, kts, kte )
 CALL label_side_pts_inside ( 'w', inside_w, top_w,         &
                              ids, ide, jds, jde, kds, kde, &
                              ims, ime, jms, jme, kms, kme, &
                              its, ite, jts, jte, kts, kte )
 IF ( (config_flags%ibm_temp .EQ. 2) .OR. &
      (config_flags%ibm_temp .EQ. 3) .OR. &
      (config_flags%ibm_scalar .EQ. 2) ) THEN
    !DJW we only need to worry about this if a BC needs to be set on moisture,
    !temperature, a tracer, or other scalar variables.
    CALL label_side_pts_inside ( 't', inside_s, top_s,         &
                                 ids, ide, jds, jde, kds, kde, &
                                 ims, ime, jms, jme, kms, kme, &
                                 its, ite, jts, jte, kts, kte )
 ENDIF

 END SUBROUTINE vel_recon_ibm_part1 
 
!---------------------------------------------------------------------------------  

 SUBROUTINE start_vel_recon_ibm_part2 ( config_flags,                 &
                                        u_1, v_1, w_1,                &
                                        u_2, v_2, w_2,                &
                                        ibm_ht_u, ibm_ht_v,           &
                                        ibm_ht_w, ibm_ht_c,           &
                                        ht_u, ht_v, ht_w,             &
                                        top_u, top_v, top_w,          &
                                        inside_u, inside_v, inside_w, &
                                        inside_all_u, inside_all_v, inside_all_w, & !RSA
                                        n,                            &
                                        ids, ide, jds, jde, kds, kde, &
                                        ims, ime, jms, jme, kms, kme, &
                                        its, ite, jts, jte, kts, kte )
 IMPLICIT NONE
 !input data
 TYPE(grid_config_rec_type), INTENT(IN   )               :: config_flags
 REAL, DIMENSION(ims:ime,kms:kme,jms:jme), INTENT(INOUT) :: u_1, v_1, w_1, &  
                                                            u_2, v_2, w_2
 REAL, DIMENSION(ims:ime,jms:jme), INTENT(IN   )         :: ibm_ht_u,      & !ibm terrain height at velocity points
                                                            ibm_ht_v,      & !terrain height has twice the resolution of
                                                            ibm_ht_w,      & !the computational grid							    
                                                            ibm_ht_c         !ibm terrain height at corners
 REAL, DIMENSION(ims:ime,kms:kme,jms:jme), INTENT(IN   ) :: ht_u,          & !this is the total height
                                                            ht_v,          & !at u, v, and w points
                                                            ht_w
 INTEGER, DIMENSION(ims:ime,jms:jme), INTENT(IN   )      :: top_u,         & !'top boundary' ghost points
                                                            top_v,         &
                                                            top_w
 INTEGER, DIMENSION(ims:ime,kms:kme,jms:jme), INTENT(IN) :: inside_u,      & !one if the pt is inside boundary, zero if it is outside
                                                            inside_v,      &
                                                            inside_w
 INTEGER, DIMENSION(ims:ime,kms:kme,jms:jme), INTENT(IN) :: inside_all_u,  & !RSA inside includes recon pts, inside_all does not
                                                            inside_all_v,  &
                                                            inside_all_w
 INTEGER, INTENT(IN   )                                  :: n                !desired number of nearest neighbors  							    		
 INTEGER, INTENT(IN   )                                  :: ids, ide, jds, jde, kds, kde, & !d: domain
                                                            ims, ime, jms, jme, kms, kme, & !m: memory
                                                            its, ite, jts, jte, kts, kte    !p: patch, t: tile

 !local data
 INTEGER                                                 :: nu,nv,nw         !number of 'side boundary' ghost point
 INTEGER, DIMENSION(ims:ime,jms:jme)                     :: antu_at_u,     & !actual number of nearest neighbors for top points
                                                            antv_at_u,     &
                                                            antw_at_u,     &
                                                            antu_at_v,     &
                                                            antv_at_v,     &
                                                            antw_at_v,     &
                                                            antu_at_w,     &
                                                            antv_at_w,     &
                                                            antw_at_w 
 REAL, DIMENSION(ims:ime,jms:jme,2)                      :: utop_dist,     & !distance of reconstruction and interpolation pt from boundary 
                                                            vtop_dist,     &
                                                            wtop_dist
 REAL, DIMENSION(ims:ime,jms:jme,6)                      :: utop_img,      & !(x,y,z) location of ghost point
                                                            vtop_img,      & !and image point of the 'top boundary' ghost points
                                                            wtop_img
 REAL, DIMENSION(ims:ime,jms:jme,3)                      :: utop_norm,     & !normal vector to the terrain surface
                                                            vtop_norm,     &
                                                            wtop_norm,     &
                                                            utop_bound,    & !keep the (x,y,z) location of the
                                                            vtop_bound,    & !boundary points for the no-slip bc
                                                            wtop_bound
 REAL, DIMENSION(ims:ime,jms:jme,0:9*n-1)                :: utop_neigh,    & !(x,y,z) location of top neighbors
                                                            vtop_neigh,    &
                                                            wtop_neigh 
 INTEGER, DIMENSION(ims:ime,jms:jme,0:9*n-1)             :: utop_neigh_i,  & !(i,j,k) index of top neighbors
                                                            vtop_neigh_i,  &
                                                            wtop_neigh_i
 INTEGER, DIMENSION(:), ALLOCATABLE                      :: ansu_at_u,     & !actual number of nearest neighbors for side points
                                                            ansv_at_u,     &
                                                            answ_at_u,     &
                                                            ansu_at_v,     &
                                                            ansv_at_v,     &
                                                            answ_at_v,     &
                                                            ansu_at_w,     &
                                                            ansv_at_w,     &
                                                            answ_at_w 
 INTEGER, DIMENSION(:,:), ALLOCATABLE                    :: uside,         & !'side boundary' ghost points
                                                            vside,         &
                                                            wside
 REAL, DIMENSION(:,:), ALLOCATABLE                       :: uside_img,     & !(x,y,z) location of ghost point
                                                            vside_img,     & !and image point of the 'side boundary' ghost points
                                                            wside_img,     &
                                                            uside_bound,   & !(x,y,z) location of the boundary for side points
                                                            vside_bound,   &
                                                            wside_bound,   &  
                                                            uside_neigh,   & !(x,y,z) location of side neighbors
                                                            vside_neigh,   &
                                                            wside_neigh,   &
                                                            uside_norm,    & 
                                                            vside_norm,    &
                                                            wside_norm,    &
                                                            uside_dist,    &  
                                                            vside_dist,    &
                                                            wside_dist 
 INTEGER, DIMENSION(:,:), ALLOCATABLE                    :: uside_neigh_i, & !(i,j,k) index of side neighbors
                                                            vside_neigh_i, &
                                                            wside_neigh_i
 LOGICAL                                                 :: allgood !used for checking for ill-conditioned points
 !RSA *_in are copies of * before any updates are made at the immersed boundary.
 !this allows reconstruction pts to be used as nearest neighbors without being
 !continuously updated during the loop.
 REAL, DIMENSION(ims:ime,kms:kme,jms:jme)                :: u_1_in, v_1_in, w_1_in, &
                                                            u_2_in, v_2_in, w_2_in
 LOGICAL                                                 :: in_vel_recon !for now, only use recon pts as nearest neighbors from vel_recon routines

!---------------------------------------------------------------------------------
 !this subroutine is called from start_em.F.  
 !the executable begins here
 CALL wrf_debug(100,'dyn_em/module_ibm.F/subroutine start_vel_recon_ibm_part2')
!---------------------------------------------------------------------------------  

 CALL count_side_pts ( 'u', top_u, nu,               &
                       ids, ide, jds, jde, kds, kde, &
                       ims, ime, jms, jme, kms, kme, &
                       its, ite, jts, jte, kts, kte )
 CALL count_side_pts ( 'v', top_v, nv,               &
                       ids, ide, jds, jde, kds, kde, &
                       ims, ime, jms, jme, kms, kme, &
                       its, ite, jts, jte, kts, kte )
 CALL count_side_pts ( 'w', top_w, nw,               &
                       ids, ide, jds, jde, kds, kde, &
                       ims, ime, jms, jme, kms, kme, &
                       its, ite, jts, jte, kts, kte )

 !allocate and store side ghost points
 ALLOCATE (uside(3,nu))
 ALLOCATE (uside_img(6,nu))
 ALLOCATE (uside_bound(3,nu))
 ALLOCATE (uside_neigh(0:9*n-1,nu))
 ALLOCATE (uside_neigh_i(0:9*n-1,nu))
 ALLOCATE (uside_norm(3,nu))
 ALLOCATE (uside_dist(2,nu))
 ALLOCATE (ansu_at_u(nu))
 ALLOCATE (ansv_at_u(nu))
 ALLOCATE (answ_at_u(nu))
 ALLOCATE (vside(3,nv))
 ALLOCATE (vside_img(6,nv))
 ALLOCATE (vside_bound(3,nv))
 ALLOCATE (vside_neigh(0:9*n-1,nv))
 ALLOCATE (vside_neigh_i(0:9*n-1,nv))
 ALLOCATE (vside_norm(3,nv))
 ALLOCATE (vside_dist(2,nv))
 ALLOCATE (ansu_at_v(nv))
 ALLOCATE (ansv_at_v(nv))
 ALLOCATE (answ_at_v(nv))
 ALLOCATE (wside(3,nw))
 ALLOCATE (wside_img(6,nw))
 ALLOCATE (wside_bound(3,nw))
 ALLOCATE (wside_neigh(0:9*n-1,nw))
 ALLOCATE (wside_neigh_i(0:9*n-1,nw))
 ALLOCATE (wside_norm(3,nw))
 ALLOCATE (wside_dist(2,nw))
 ALLOCATE (ansu_at_w(nw))
 ALLOCATE (ansv_at_w(nw))
 ALLOCATE (answ_at_w(nw))

 IF (nu .GT. 0) THEN
    CALL reconstruct_pts_side ( 'u', top_u, uside, nu,           &
                                ids, ide, jds, jde, kds, kde,    &
                                ims, ime, jms, jme, kms, kme,    &
                                its, ite, jts, jte, kts, kte )
 ENDIF !end of side ghost points
 IF (nv .GT. 0) THEN
    CALL reconstruct_pts_side ( 'v', top_v, vside, nv,           &
                                ids, ide, jds, jde, kds, kde,    &
                                ims, ime, jms, jme, kms, kme,    &
                                its, ite, jts, jte, kts, kte )
 ENDIF !end of side ghost points
 IF (nw .GT. 0) THEN
    CALL reconstruct_pts_side ( 'w', top_w, wside, nw,           &
                                ids, ide, jds, jde, kds, kde,    &
                                ims, ime, jms, jme, kms, kme,    &
                                its, ite, jts, jte, kts, kte )
 ENDIF !end of side ghost points

 !only zero if this is the first run (not a restart)
 IF ((.NOT. config_flags%restart) .AND. &
     ((config_flags%zero_interior) .OR. (config_flags%zero_interior_init_only))) THEN
    CALL zero_interior( config_flags%ibm_opt,         &
                        u_1, v_1, w_1,                &
                        top_u, top_v, top_w,          &
                        ids, ide, jds, jde, kds, kde, &
                        ims, ime, jms, jme, kms, kme, &
                        its, ite, jts, jte, kts, kte )
    CALL zero_interior( config_flags%ibm_opt,         &
                        u_2, v_2, w_2,                &
                        top_u, top_v, top_w,          &
                        ids, ide, jds, jde, kds, kde, &
                        ims, ime, jms, jme, kms, kme, &
                        its, ite, jts, jte, kts, kte )
!    CALL zero_interior_t( t_2, top_s,                   &
!                          ids, ide, jds, jde, kds, kde, &
!                          ims, ime, jms, jme, kms, kme, &
!                          its, ite, jts, jte, kts, kte )
 ENDIF

 CALL interpolation_pts ( 'u',                              &
                          config_flags%dx, config_flags%dy, &  !The variable top_slope can be calculated in this
                          ht_u,                             &  !subroutine. It is used for the free slip
                          ibm_ht_u, ibm_ht_v,               &  !boundary condition (right now just 2d terrain)
                          ibm_ht_w, ibm_ht_c,               &
                          inside_u, top_u, uside,           &
                          utop_img, utop_bound,             &
                          uside_img, uside_bound,           &
                          nu, utop_norm, uside_norm,        &
                          utop_dist, uside_dist,            &
                          config_flags%ibm_nn_horz,         &
                          config_flags%ibm_nn_vert,         &
                          ids, ide, jds, jde, kds, kde,     &
                          ims, ime, jms, jme, kms, kme,     &
                          its, ite, jts, jte, kts, kte )

 CALL interpolation_pts ( 'v',                              &
                          config_flags%dx, config_flags%dy, &
                          ht_v,                             &
                          ibm_ht_u, ibm_ht_v,               &
                          ibm_ht_w, ibm_ht_c,               &
                          inside_v, top_v, vside,           &
                          vtop_img, vtop_bound,             &
                          vside_img, vside_bound,           &
                          nv, vtop_norm, vside_norm,        &
                          vtop_dist, vside_dist,            &
                          config_flags%ibm_nn_horz,         &
                          config_flags%ibm_nn_vert,         &
                          ids, ide, jds, jde, kds, kde,     &
                          ims, ime, jms, jme, kms, kme,     &
                          its, ite, jts, jte, kts, kte )

 CALL interpolation_pts ( 'w',                              &
                          config_flags%dx, config_flags%dy, &
                          ht_w,                             &
                          ibm_ht_u, ibm_ht_v,               &
                          ibm_ht_w, ibm_ht_c,               &
                          inside_w, top_w, wside,           &
                          wtop_img, wtop_bound,             &
                          wside_img, wside_bound,           &
                          nw, wtop_norm, wside_norm,        &
                          wtop_dist, wside_dist,            &
                          config_flags%ibm_nn_horz,         &
                          config_flags%ibm_nn_vert,         &
                          ids, ide, jds, jde, kds, kde,     &
                          ims, ime, jms, jme, kms, kme,     &
                          its, ite, jts, jte, kts, kte ) 

 in_vel_recon = .true. !RSA for now, only use recon pts as nearest neighbors from vel_recon routines
 CALL neighbors_fs( config_flags%ibm_opt,                         &
                    config_flags%interp_opt,                      &
                    config_flags%dim_terrain, 'u', 1,             &
                    config_flags%ibm_nn_horz,                     &
                    config_flags%ibm_nn_vert,                     &
                    config_flags%dx, config_flags%dy,             &
                    ibm_ht_u, ibm_ht_v,                           &
                    ibm_ht_w, ibm_ht_c,                           &
                    ht_u, ht_v, ht_w,                             &
                    inside_u, inside_v, inside_w,                 &
                    inside_all_u, inside_all_v, inside_all_w,     & !RSA for using reconstruction pts as nearest neighbors
                    config_flags%recon_pts_as_neigh,              & !RSA for using reconstruction pts as nearest neighbors
                    in_vel_recon,                                 & !RSA for using reconstruction pts as nearest neighbors
                    uside,                                        &
                    utop_img, uside_img,                          &
                    utop_bound, uside_bound,                      &
                    utop_neigh, utop_neigh_i,                     &
                    uside_neigh, uside_neigh_i,                   &
                    n, nu,                                        &
                    antu_at_u, antv_at_u, antw_at_u,              &
                    ansu_at_u, ansv_at_u, answ_at_u,              &
                    ids, ide, jds, jde, kds, kde,                 &
                    ims, ime, jms, jme, kms, kme,                 &
                    its, ite, jts, jte, kts, kte )

 CALL neighbors_fs( config_flags%ibm_opt,                         &
                    config_flags%interp_opt,                      &
                    config_flags%dim_terrain, 'v', 1,             &
                    config_flags%ibm_nn_horz,                     &
                    config_flags%ibm_nn_vert,                     &
                    config_flags%dx, config_flags%dy,             &
                    ibm_ht_u, ibm_ht_v,                           &
                    ibm_ht_w, ibm_ht_c,                           &
                    ht_u, ht_v, ht_w,                             &
                    inside_u, inside_v, inside_w,                 &
                    inside_all_u, inside_all_v, inside_all_w,     & !RSA for using reconstruction pts as nearest neighbors
                    config_flags%recon_pts_as_neigh,              & !RSA for using reconstruction pts as nearest neighbors
                    in_vel_recon,                                 & !RSA for using reconstruction pts as nearest neighbors
                    vside,                                        &
                    vtop_img, vside_img,                          &
                    vtop_bound, vside_bound,                      &
                    vtop_neigh, vtop_neigh_i,                     &
                    vside_neigh, vside_neigh_i,                   &
                    n, nv,                                        &
                    antu_at_v, antv_at_v, antw_at_v,              &
                    ansu_at_v, ansv_at_v, answ_at_v,              &
                    ids, ide, jds, jde, kds, kde,                 &
                    ims, ime, jms, jme, kms, kme,                 &
                    its, ite, jts, jte, kts, kte )

 CALL neighbors_fs( config_flags%ibm_opt,                         &
                    config_flags%interp_opt,                      &
                    config_flags%dim_terrain, 'w', 1,             &
                    config_flags%ibm_nn_horz,                     &
                    config_flags%ibm_nn_vert,                     &
                    config_flags%dx, config_flags%dy,             &
                    ibm_ht_u, ibm_ht_v,                           &
                    ibm_ht_w, ibm_ht_c,                           &
                    ht_u, ht_v, ht_w,                             &
                    inside_u, inside_v, inside_w,                 &
                    inside_all_u, inside_all_v, inside_all_w,     & !RSA for using reconstruction pts as nearest neighbors
                    config_flags%recon_pts_as_neigh,              & !RSA for using reconstruction pts as nearest neighbors
                    in_vel_recon,                                 & !RSA for using reconstruction pts as nearest neighbors
                    wside,                                        &
                    wtop_img, wside_img,                          &
                    wtop_bound, wside_bound,                      &
                    wtop_neigh, wtop_neigh_i,                     &
                    wside_neigh, wside_neigh_i,                   &
                    n, nw,                                        &
                    antu_at_w, antv_at_w, antw_at_w,              &
                    ansu_at_w, ansv_at_w, answ_at_w,              &
                    ids, ide, jds, jde, kds, kde,                 &
                    ims, ime, jms, jme, kms, kme,                 &
                    its, ite, jts, jte, kts, kte )

!#ifdef DM_PARALLEL
! ! figure out how to gather this
!#else

 IF (config_flags%write_ibm_data) THEN
    write(*,'(A)') "DJW[module_ibm/start_vel_recon_ibm_part2]: calling write_ibm_data for stag=u"
    CALL write_ibm_data ( 'u', uside,                      &
                          utop_img, uside_img,             &
                          utop_bound, uside_bound,         &
                          utop_neigh, uside_neigh(0:3*n-1,:),  &
                          n, nu,                           &
                          ids, ide, jds, jde, kds, kde,    &
                          ims, ime, jms, jme, kms, kme,    &
                          its, ite, jts, jte, kts, kte,    &
                          antu_at_u, antv_at_u, antw_at_u, &
                          ansu_at_u, ansv_at_u, answ_at_u )
    write(*,'(A)') "DJW[module_ibm/start_vel_recon_ibm_part2]: calling write_ibm_data for stag=v"
    CALL write_ibm_data ( 'v', vside,                      &
                          vtop_img, vside_img,             &
                          vtop_bound, vside_bound,         &
                          vtop_neigh, vside_neigh(3*n:6*n-1,:),  &
                          n, nv,                           &
                          ids, ide, jds, jde, kds, kde,    &
                          ims, ime, jms, jme, kms, kme,    &
                          its, ite, jts, jte, kts, kte,    &
                          antu_at_v, antv_at_v, antw_at_v, &
                          ansu_at_v, ansv_at_v, answ_at_v )
    write(*,'(A)') "DJW[module_ibm/start_vel_recon_ibm_part2]: calling write_ibm_data for stag=w"
    CALL write_ibm_data ( 'w', wside,                      &
                          wtop_img, wside_img,             &
                          wtop_bound, wside_bound,         &
                          wtop_neigh, wside_neigh(6*n:9*n-1,:),  &
                          n, nw,                           &
                          ids, ide, jds, jde, kds, kde,    &
                          ims, ime, jms, jme, kms, kme,    &
                          its, ite, jts, jte, kts, kte,    &
                          antu_at_w, antv_at_w, antw_at_w, &
                          ansu_at_w, ansv_at_w, answ_at_w )
 ENDIF
!#endif								 

 allgood = .TRUE.
 CALL neighbors_check( 'u', allgood, nu,                &
                       antu_at_u, antv_at_u, antw_at_u, &
                       ansu_at_u, ansv_at_u, answ_at_u, &
                       utop_img, uside_img,             &
                       utop_bound, uside_bound,         &
                       ibm_ht_u, ibm_ht_v,              &
                       ibm_ht_w, ibm_ht_c,              &
                       ids, ide, jds, jde, kds, kde,    &
                       ims, ime, jms, jme, kms, kme,    &
                       its, ite, jts, jte, kts, kte )
 CALL neighbors_check( 'v', allgood, nv,                &
                       antu_at_v, antv_at_v, antw_at_v, &
                       ansu_at_v, ansv_at_v, answ_at_v, &
                       vtop_img, vside_img,             &
                       vtop_bound, vside_bound,         &
                       ibm_ht_u, ibm_ht_v,              &
                       ibm_ht_w, ibm_ht_c,              &
                       ids, ide, jds, jde, kds, kde,    &
                       ims, ime, jms, jme, kms, kme,    &
                       its, ite, jts, jte, kts, kte )
 CALL neighbors_check( 'w', allgood, nw,                &
                       antu_at_w, antv_at_w, antw_at_w, &
                       ansu_at_w, ansv_at_w, answ_at_w, &
                       wtop_img, wside_img,             &
                       wtop_bound, wside_bound,         &
                       ibm_ht_u, ibm_ht_v,              &
                       ibm_ht_w, ibm_ht_c,              &
                       ids, ide, jds, jde, kds, kde,    &
                       ims, ime, jms, jme, kms, kme,    &
                       its, ite, jts, jte, kts, kte )
 IF (allgood .EQ. .FALSE.) THEN
    CALL wrf_error_fatal("--- ERROR: found IBM points with insufficient number of valid neighbors")
 ENDIF

 IF (config_flags%ibm_temp .EQ. 1) THEN
   CALL terrain_check( top_u, top_v, top_w,          &
                       ids, ide, jds, jde, kds, kde, &
                       ims, ime, jms, jme, kms, kme, &
                       its, ite, jts, jte, kts, kte )
 ENDIF

 !RSA *_in are copies of * before any updates are made at the immersed boundary.
 !this allows reconstruction pts to be used as nearest neighbors without being
 !continuously updated during the loop.
 u_1_in = u_1
 v_1_in = v_1
 w_1_in = w_1
 u_2_in = u_2
 v_2_in = v_2
 w_2_in = w_2

 CALL vel_recon_inverse_dist ( config_flags%z_rough,               &
                               'u', u_1, v_1, w_1,                 &
                               u_1_in, v_1_in, w_1_in,             & !RSA for using recon pts as nearest neighbors
                               top_u, uside,                       &
                               utop_neigh, uside_neigh,            &
                               utop_neigh_i, uside_neigh_i,        &
                               n, nu,                              &
                               config_flags%vrm_bound_pt_as_neigh, &
                               utop_norm, utop_dist,               &
                               uside_norm, uside_dist,             &
                               antu_at_u, antv_at_u, antw_at_u,    &
                               ansu_at_u, ansv_at_u, answ_at_u,    &
                               ids, ide, jds, jde, kds, kde,       &
                               ims, ime, jms, jme, kms, kme,       &
                               its, ite, jts, jte, kts, kte )

 CALL vel_recon_inverse_dist ( config_flags%z_rough,               &
                               'u', u_2, v_2, w_2,                 &
                               u_2_in, v_2_in, w_2_in,             & !RSA for using recon pts as nearest neighbors
                               top_u, uside,                       &
                               utop_neigh, uside_neigh,            &
                               utop_neigh_i, uside_neigh_i,        &
                               n, nu,                              &
                               config_flags%vrm_bound_pt_as_neigh, &
                               utop_norm, utop_dist,               &
                               uside_norm, uside_dist,             &
                               antu_at_u, antv_at_u, antw_at_u,    &
                               ansu_at_u, ansv_at_u, answ_at_u,    &
                               ids, ide, jds, jde, kds, kde,       &
                               ims, ime, jms, jme, kms, kme,       &
                               its, ite, jts, jte, kts, kte )

 CALL vel_recon_inverse_dist ( config_flags%z_rough,               &
                               'v', u_1, v_1, w_1,                 &
                               u_1_in, v_1_in, w_1_in,             & !RSA for using recon pts as nearest neighbors
                               top_v, vside,                       &
                               vtop_neigh, vside_neigh,            &
                               vtop_neigh_i, vside_neigh_i,        &
                               n, nv,                              &
                               config_flags%vrm_bound_pt_as_neigh, &
                               vtop_norm, vtop_dist,               &
                               vside_norm, vside_dist,             &
                               antu_at_v, antv_at_v, antw_at_v,    &
                               ansu_at_v, ansv_at_v, answ_at_v,    &
                               ids, ide, jds, jde, kds, kde,       &
                               ims, ime, jms, jme, kms, kme,       &
                               its, ite, jts, jte, kts, kte )

 CALL vel_recon_inverse_dist ( config_flags%z_rough,               &
                               'v', u_2, v_2, w_2,                 &
                               u_2_in, v_2_in, w_2_in,             & !RSA for using recon pts as nearest neighbors
                               top_v, vside,                       &
                               vtop_neigh, vside_neigh,            &
                               vtop_neigh_i, vside_neigh_i,        &
                               n, nv,                              &
                               config_flags%vrm_bound_pt_as_neigh, &
                               vtop_norm, vtop_dist,               &
                               vside_norm, vside_dist,             &
                               antu_at_v, antv_at_v, antw_at_v,    &
                               ansu_at_v, ansv_at_v, answ_at_v,    &
                               ids, ide, jds, jde, kds, kde,       &
                               ims, ime, jms, jme, kms, kme,       &
                               its, ite, jts, jte, kts, kte )

 CALL vel_recon_inverse_dist ( config_flags%z_rough,               &
                               'w', u_1, v_1, w_1,                 &
                               u_1_in, v_1_in, w_1_in,             & !RSA for using recon pts as nearest neighbors
                               top_w, wside,                       &
                               wtop_neigh, wside_neigh,            &
                               wtop_neigh_i, wside_neigh_i,        &
                               n, nw,                              &
                               config_flags%vrm_bound_pt_as_neigh, &
                               wtop_norm, wtop_dist,               &
                               wside_norm, wside_dist,             &
                               antu_at_w, antv_at_w, antw_at_w,    &
                               ansu_at_w, ansv_at_w, answ_at_w,    &
                               ids, ide, jds, jde, kds, kde,       &
                               ims, ime, jms, jme, kms, kme,       &
                               its, ite, jts, jte, kts, kte )

 CALL vel_recon_inverse_dist ( config_flags%z_rough,               &
                               'w', u_2, v_2, w_2,                 &
                               u_2_in, v_2_in, w_2_in,             & !RSA for using recon pts as nearest neighbors
                               top_w, wside,                       &
                               wtop_neigh, wside_neigh,            &
                               wtop_neigh_i, wside_neigh_i,        &
                               n, nw,                              &
                               config_flags%vrm_bound_pt_as_neigh, &
                               wtop_norm, wtop_dist,               &
                               wside_norm, wside_dist,             &
                               antu_at_w, antv_at_w, antw_at_w,    &
                               ansu_at_w, ansv_at_w, answ_at_w,    &
                               ids, ide, jds, jde, kds, kde,       &
                               ims, ime, jms, jme, kms, kme,       &
                               its, ite, jts, jte, kts, kte )

 !deallocate
 CALL wrf_debug(100,'deallocate dyn_em/module_ibm.F/subroutine start_vel_recon_ibm_part2')
 
 DEALLOCATE (uside)
 DEALLOCATE (uside_img)
 DEALLOCATE (uside_bound)
 DEALLOCATE (uside_neigh)
 DEALLOCATE (uside_neigh_i)
 DEALLOCATE (uside_norm)
 DEALLOCATE (uside_dist)
 DEALLOCATE (ansu_at_u)
 DEALLOCATE (ansv_at_u)
 DEALLOCATE (answ_at_u)
 DEALLOCATE (vside)
 DEALLOCATE (vside_img)
 DEALLOCATE (vside_bound)
 DEALLOCATE (vside_neigh)
 DEALLOCATE (vside_neigh_i)
 DEALLOCATE (vside_norm)
 DEALLOCATE (vside_dist)
 DEALLOCATE (ansu_at_v)
 DEALLOCATE (ansv_at_v)
 DEALLOCATE (answ_at_v)
 DEALLOCATE (wside)
 DEALLOCATE (wside_img)
 DEALLOCATE (wside_bound)
 DEALLOCATE (wside_neigh)
 DEALLOCATE (wside_neigh_i)
 DEALLOCATE (wside_norm)
 DEALLOCATE (wside_dist)
 DEALLOCATE (ansu_at_w)
 DEALLOCATE (ansv_at_w)
 DEALLOCATE (answ_at_w)
 
 END SUBROUTINE start_vel_recon_ibm_part2

!---------------------------------------------------------------------------------  

 SUBROUTINE start_mom_flux_ibm ( config_flags,                  &
                                 u_1, v_1, w_1,                 &
                                 u_2, v_2, w_2,                 &
                                 ibm_ht_u, ibm_ht_v,            &
                                 ibm_ht_w, ibm_ht_c,            &
                                 ht_u, ht_v, ht_w,              &
                                 top_u, top_v, top_w,           &
                                 prox_u, prox_v,prox_w,         &
                                 inside_u, inside_v, inside_w,  &
                                 inside_all_u, inside_all_v, inside_all_w,  &
                                 n,                             &
                                 ids, ide, jds, jde, kds, kde,  &
                                 ims, ime, jms, jme, kms, kme,  &
                                 its, ite, jts, jte, kts, kte )
 IMPLICIT NONE
 !input data
 TYPE(grid_config_rec_type), INTENT(IN   )               :: config_flags
 REAL, DIMENSION(ims:ime,kms:kme,jms:jme), INTENT(INOUT) :: u_1, v_1, w_1,  &  
                                                            u_2, v_2, w_2
 REAL, DIMENSION(ims:ime,jms:jme), INTENT(IN   )         :: ibm_ht_u,       & ! ibm terrain height at velocity points
                                                            ibm_ht_v,       & ! terrain height has twice the resolution of
                                                            ibm_ht_w,       & ! the computational grid							    
                                                            ibm_ht_c          ! ibm terrain height at corners
 REAL, DIMENSION(ims:ime,kms:kme,jms:jme), INTENT(IN   ) :: ht_u,           & ! this is the total height
                                                            ht_v,           & ! at u, v, and w points
                                                            ht_w
 INTEGER, DIMENSION(ims:ime,jms:jme), INTENT(IN   )      :: top_u,     &     !'top boundary' ghost points
                                                            top_v,     &
                                                            top_w,     &
                                                            prox_u,    &
                                                            prox_v,    &
                                                            prox_w
 INTEGER, DIMENSION(ims:ime,kms:kme,jms:jme), INTENT(IN) :: inside_u,  &     ! one if the pt is inside boundary, zero if it is outside
                                                            inside_v,  &
                                                            inside_w
 INTEGER, DIMENSION(ims:ime,kms:kme,jms:jme), INTENT(IN) :: inside_all_u,  & ! RSA inside includes recon pts, inside_all does not
                                                            inside_all_v,  &
                                                            inside_all_w
 INTEGER, INTENT(IN   )                                  :: n               ! desired number of nearest neighbors  							    		
 INTEGER, INTENT(IN   )                                  :: ids, ide, jds, jde, kds, kde, &  ! d: domain m:memory p:patch t:tile 
                                                            ims, ime, jms, jme, kms, kme, &
                                                            its, ite, jts, jte, kts, kte   

!local data
 INTEGER                                                 :: nu,nv,nw        ! number of 'side boundary' ghost point                                                      
 INTEGER, DIMENSION(ims:ime,jms:jme)                     :: antu_at_u,   &  ! actual number of nearest neighbors for top points
                                                            antv_at_u,   &
                                                            antw_at_u,   &
                                                            antu_at_v,   &
                                                            antv_at_v,   &
                                                            antw_at_v,   &
                                                            antu_at_w,   &
                                                            antv_at_w,   &
                                                            antw_at_w 
 REAL, DIMENSION(ims:ime,jms:jme)                        :: grad,        &  ! gradient at boundary   
                                                            utop_dist,   &  ! distance of reconstruction and interpolation pt from boundary 
                                                            vtop_dist,   &
                                                            wtop_dist
 REAL, DIMENSION(ims:ime,jms:jme,6)                      :: utop_img,    &  ! (x,y,z) location of ghost point
                                                            vtop_img,    &  ! and image point of the 'top boundary' ghost points
                                                            wtop_img
 REAL, DIMENSION(ims:ime,jms:jme,3)                      :: utop_norm,   &  ! normal vector to the terrain surface
                                                            vtop_norm,   &
                                                            wtop_norm,   &
                                                            utop_bound,  &  ! keep the (x,y,z) location of the
                                                            vtop_bound,  &  ! boundary points for the no-slip bc
                                                            wtop_bound
 REAL, DIMENSION(ims:ime,jms:jme,0:9*n-1)                :: utop_neigh,  &  ! (x,y,z) location of top neighbors
                                                            vtop_neigh,  &
                                                            wtop_neigh 
 INTEGER, DIMENSION(ims:ime,jms:jme,0:9*n-1)             :: utop_neigh_i,&  ! (i,j,k) index of top neighbors
                                                            vtop_neigh_i,&
                                                            wtop_neigh_i
 INTEGER, DIMENSION(:), ALLOCATABLE                      :: ansu_at_u,   &  ! actual number of nearest neighbors for side points
                                                            ansv_at_u,   &
                                                            answ_at_u,   &
                                                            ansu_at_v,   &
                                                            ansv_at_v,   &
                                                            answ_at_v,   &
                                                            ansu_at_w,   &
                                                            ansv_at_w,   &
                                                            answ_at_w 
 INTEGER, DIMENSION(:,:), ALLOCATABLE                    :: uside,       &  !'side boundary' ghost points
                                                            vside,       &
                                                            wside
 REAL, DIMENSION(:,:), ALLOCATABLE                       :: uside_img,   &  ! (x,y,z) location of ghost point
                                                            vside_img,   &  ! and image point of the 'side boundary' ghost points
                                                            wside_img,   &
                                                            uside_bound, &  ! (x,y,z) location of the boundary for side points
                                                            vside_bound, &
                                                            wside_bound, &  
                                                            uside_neigh, &  ! (x,y,z) location of side neighbors
                                                            vside_neigh, &
                                                            wside_neigh, &
                                                            uside_norm,  & 
                                                            vside_norm,  &
                                                            wside_norm
 REAL, DIMENSION(:), ALLOCATABLE                         :: uside_dist,  &  
                                                            vside_dist,  &  
                                                            wside_dist 
 INTEGER, DIMENSION(:,:), ALLOCATABLE                    :: uside_neigh_i,& ! (i,j,k) index of side neighbors
                                                            vside_neigh_i,&
                                                            wside_neigh_i
 LOGICAL                                                 :: in_vel_recon !RSA for now, only use recon pts as nearest neighbors from vel_recon routines

!---------------------------------------------------------------------------------
! this subroutine is called from start_em.F.  
! the executable begins here
 CALL wrf_debug(100,'dyn_em/module_ibm.F/subroutine start_mom_flux_ibm')
!---------------------------------------------------------------------------------  
! initialize momentum fluxes
 grad = 0.  

 CALL count_side_pts ( 'u', top_u, nu,                          &
                       ids, ide, jds, jde, kds, kde,            &
                       ims, ime, jms, jme, kms, kme,            &
                       its, ite, jts, jte, kts, kte )
 CALL count_side_pts ( 'v', top_v, nv,                          &
                       ids, ide, jds, jde, kds, kde,            &
                       ims, ime, jms, jme, kms, kme,            &
                       its, ite, jts, jte, kts, kte )
 CALL count_side_pts ( 'w', top_w, nw,                          &
                       ids, ide, jds, jde, kds, kde,            &
                       ims, ime, jms, jme, kms, kme,            &
                       its, ite, jts, jte, kts, kte )
 
 ! allocate and store side ghost points
 ALLOCATE (uside(3,nu))
 ALLOCATE (uside_img(6,nu))
 ALLOCATE (uside_bound(3,nu))
 ALLOCATE (uside_neigh(0:9*n-1,nu))
 ALLOCATE (uside_neigh_i(0:9*n-1,nu))
 ALLOCATE (uside_norm(3,nu))
 ALLOCATE (uside_dist(nu))
 ALLOCATE (ansu_at_u(nu))
 ALLOCATE (ansv_at_u(nu))
 ALLOCATE (answ_at_u(nu))
 ALLOCATE (vside(3,nv))
 ALLOCATE (vside_img(6,nv))
 ALLOCATE (vside_bound(3,nv))
 ALLOCATE (vside_neigh(0:9*n-1,nv))
 ALLOCATE (vside_neigh_i(0:9*n-1,nv))
 ALLOCATE (vside_norm(3,nv))
 ALLOCATE (vside_dist(nv))
 ALLOCATE (ansu_at_v(nv))
 ALLOCATE (ansv_at_v(nv))
 ALLOCATE (answ_at_v(nv))
 ALLOCATE (wside(3,nw))
 ALLOCATE (wside_img(6,nw))
 ALLOCATE (wside_bound(3,nw))
 ALLOCATE (wside_neigh(0:9*n-1,nw))
 ALLOCATE (wside_neigh_i(0:9*n-1,nw))
 ALLOCATE (wside_norm(3,nw))
 ALLOCATE (wside_dist(nw))
 ALLOCATE (ansu_at_w(nw))
 ALLOCATE (ansv_at_w(nw))
 ALLOCATE (answ_at_w(nw))

 if (nu > 0) then
    CALL ghost_pts_side ( 'u', top_u, uside, nu,        &
                          ids, ide, jds, jde, kds, kde, &
                          ims, ime, jms, jme, kms, kme, &
                          its, ite, jts, jte, kts, kte )
 endif ! end of side ghost points
 if (nv > 0) then
    CALL ghost_pts_side ( 'v', top_v, vside, nv,        &
                          ids, ide, jds, jde, kds, kde, &
                          ims, ime, jms, jme, kms, kme, &
                          its, ite, jts, jte, kts, kte )
 endif ! end of side ghost points
 if (nw > 0) then
    CALL ghost_pts_side ( 'w', top_w, wside, nw,        &
                          ids, ide, jds, jde, kds, kde, &
                          ims, ime, jms, jme, kms, kme, &
                          its, ite, jts, jte, kts, kte )
 endif ! end of side ghost points

 ! only zero if this is the first run (not a restart)
 ! and if it is the no slip boundary condition
 !if ((.NOT. config_flags%restart).AND.(config_flags%ibm_opt == 2)) then
 IF ((.NOT. config_flags%restart) .AND. (config_flags%zero_interior)) THEN
      CALL zero_interior( config_flags%ibm_opt,         &
                          u_1, v_1, w_1,                &
                          top_u, top_v, top_w,          &
                          ids, ide, jds, jde, kds, kde, &
                          ims, ime, jms, jme, kms, kme, &
                          its, ite, jts, jte, kts, kte )
      CALL zero_interior( config_flags%ibm_opt,         &
                          u_2, v_2, w_2,                &
                          top_u, top_v, top_w,          &
                          ids, ide, jds, jde, kds, kde, &
                          ims, ime, jms, jme, kms, kme, &
                          its, ite, jts, jte, kts, kte )
 ENDIF

 CALL image_pts ( 'u', config_flags%interp_opt, 2,       &
                  config_flags%dx, config_flags%dy,      &  !The variable top_slope can be calculated in this
                  ht_u,                                  &  !subroutine. It is used for the free slip
                  ibm_ht_u, ibm_ht_v,                    &  !boundary condition (right now just 2d terrain)
                  ibm_ht_w, ibm_ht_c,                    &
                  top_u, uside,                          &
                  utop_img, utop_bound,                  &
                  uside_img, uside_bound,                &
                  prox_u, nu, utop_norm, uside_norm,     & !top_norm and side_norm are only used for the neumann bd
                  utop_dist, uside_dist,                 & !top_dist and side_dist are only used for the neumann bc
                  ids, ide, jds, jde, kds, kde,          &
                  ims, ime, jms, jme, kms, kme,          &
                  its, ite, jts, jte, kts, kte )
 CALL image_pts ( 'v', config_flags%interp_opt, 2,       &
                  config_flags%dx, config_flags%dy,      &  
                  ht_v,                                  &  
                  ibm_ht_u, ibm_ht_v,                    &  
                  ibm_ht_w, ibm_ht_c,                    &
                  top_v, vside,                          &
                  vtop_img, vtop_bound,                  &
                  vside_img, vside_bound,                &
                  prox_v, nv, vtop_norm, vside_norm,     & !top_norm and side_norm are only used for the neumann bd
                  vtop_dist, vside_dist,                 & !top_dist and side_dist are only used for the neumann bc
                  ids, ide, jds, jde, kds, kde,          &
                  ims, ime, jms, jme, kms, kme,          &
                  its, ite, jts, jte, kts, kte )
 CALL image_pts ( 'w', config_flags%interp_opt, 2,       &
                  config_flags%dx, config_flags%dy,      &  
                  ht_w,                                  &  
                  ibm_ht_u, ibm_ht_v,                    &  
                  ibm_ht_w, ibm_ht_c,                    &
                  top_w, wside,                          &
                  wtop_img, wtop_bound,                  &
                  wside_img, wside_bound,                &
                  prox_w, nw, wtop_norm, wside_norm,     & !top_norm and side_norm are only used for the neumann bd
                  wtop_dist, wside_dist,                 & !top_dist and side_dist are only used for the neumann bc
                  ids, ide, jds, jde, kds, kde,          &
                  ims, ime, jms, jme, kms, kme,          &
                  its, ite, jts, jte, kts, kte ) 

 in_vel_recon = .false. !RSA for now, only use recon pts as nearest neighbors from vel_recon routines
 CALL neighbors_fs( config_flags%ibm_opt,                    &
                    config_flags%interp_opt,                 &
                    config_flags%dim_terrain, 'u', 2,        &
                    config_flags%ibm_nn_horz,                &
                    config_flags%ibm_nn_vert,                &
                    config_flags%dx, config_flags%dy,        &
                    ibm_ht_u, ibm_ht_v,                      &
                    ibm_ht_w, ibm_ht_c,                      &
                    ht_u, ht_v, ht_w,                        &
                    inside_u, inside_v, inside_w,            &
                    inside_all_u, inside_all_v, inside_all_w,& !RSA for using recon pts as neighbors
                    config_flags%recon_pts_as_neigh,         & !RSA for using recon pts as neighbors
                    in_vel_recon,                            & !RSA for using recon pts as neighbors
                    uside,                                   &
                    utop_img, uside_img,                     &
                    utop_bound, uside_bound,                 &
                    utop_neigh, utop_neigh_i,                &
                    uside_neigh, uside_neigh_i,              &
                    n, nu,                                   &
                    antu_at_u, antv_at_u, antw_at_u,         &
                    ansu_at_u, ansv_at_u, answ_at_u,         &
                    ids, ide, jds, jde, kds, kde,            &
                    ims, ime, jms, jme, kms, kme,            &
                    its, ite, jts, jte, kts, kte )

 CALL neighbors_fs( config_flags%ibm_opt,                    &
                    config_flags%interp_opt,                 &
                    config_flags%dim_terrain, 'v', 2,        &
                    config_flags%ibm_nn_horz,                &
                    config_flags%ibm_nn_vert,                &
                    config_flags%dx, config_flags%dy,        &
                    ibm_ht_u, ibm_ht_v,                      &
                    ibm_ht_w, ibm_ht_c,                      &
                    ht_u, ht_v, ht_w,                        &
                    inside_u, inside_v, inside_w,            &
                    inside_all_u, inside_all_v, inside_all_w,& !RSA for using recon pts as neighbors
                    config_flags%recon_pts_as_neigh,         & !RSA for using recon pts as neighbors
                    in_vel_recon,                            & !RSA for using recon pts as neighbors
                    vside,                                   &
                    vtop_img, vside_img,                     &
                    vtop_bound, vside_bound,                 &
                    vtop_neigh, vtop_neigh_i,                &
                    vside_neigh, vside_neigh_i,              &
                    n, nv,                                   &
                    antu_at_v, antv_at_v, antw_at_v,         &
                    ansu_at_v, ansv_at_v, answ_at_v,         &
                    ids, ide, jds, jde, kds, kde,            &
                    ims, ime, jms, jme, kms, kme,            &
                    its, ite, jts, jte, kts, kte )

 CALL neighbors_fs( config_flags%ibm_opt,                    &
                    config_flags%interp_opt,                 &
                    config_flags%dim_terrain, 'w', 2,        &
                    config_flags%ibm_nn_horz,                &
                    config_flags%ibm_nn_vert,                &
                    config_flags%dx, config_flags%dy,        &
                    ibm_ht_u, ibm_ht_v,                      &
                    ibm_ht_w, ibm_ht_c,                      &
                    ht_u, ht_v, ht_w,                        &
                    inside_u, inside_v, inside_w,            &
                    inside_all_u, inside_all_v, inside_all_w,& !RSA for using recon pts as neighbors
                    config_flags%recon_pts_as_neigh,         & !RSA for using recon pts as neighbors
                    in_vel_recon,                            & !RSA for using recon pts as neighbors
                    wside,                                   &
                    wtop_img, wside_img,                     &
                    wtop_bound, wside_bound,                 &
                    wtop_neigh, wtop_neigh_i,                &
                    wside_neigh, wside_neigh_i,              &
                    n, nw,                                   &
                    antu_at_w, antv_at_w, antw_at_w,         &
                    ansu_at_w, ansv_at_w, answ_at_w,         &
                    ids, ide, jds, jde, kds, kde,            &
                    ims, ime, jms, jme, kms, kme,            &
                    its, ite, jts, jte, kts, kte )

!#ifdef DM_PARALLEL
! ! figure out how to gather this
!#else
 IF (config_flags%write_ibm_data) THEN
    write(*,'(A)') "DJW[module_ibm/start_mom_flux_ibm]: calling write_ibm_data for stag=u"
    CALL write_ibm_data ( 'u', uside,                   &
                          utop_img, uside_img,          &
                          utop_bound, uside_bound,      &
                          utop_neigh, uside_neigh,      &
                          n, nu,                        &
                          ids, ide, jds, jde, kds, kde, &
                          ims, ime, jms, jme, kms, kme, &
                          its, ite, jts, jte, kts, kte )
    write(*,'(A)') "DJW[module_ibm/start_mom_flux_ibm]: calling write_ibm_data for stag=v"
    CALL write_ibm_data ( 'v', vside,                   &
                          vtop_img, vside_img,          &
                          vtop_bound, vside_bound,      &
                          vtop_neigh, vside_neigh,      &
                          n, nv,                        &
                          ids, ide, jds, jde, kds, kde, &
                          ims, ime, jms, jme, kms, kme, &
                          its, ite, jts, jte, kts, kte )
    write(*,'(A)') "DJW[module_ibm/start_mom_flux_ibm]: calling write_ibm_data for stag=w"
    CALL write_ibm_data ( 'w', wside,                   &
                          wtop_img, wside_img,          &
                          wtop_bound, wside_bound,      &
                          wtop_neigh, wside_neigh,      &
                          n, nw,                        &
                          ids, ide, jds, jde, kds, kde, &
                          ims, ime, jms, jme, kms, kme, &
                          its, ite, jts, jte, kts, kte )
 ENDIF
!#endif

 CALL terrain_check( top_u, top_v, top_w,          &
                     ids, ide, jds, jde, kds, kde, &
                     ims, ime, jms, jme, kms, kme, &
                     its, ite, jts, jte, kts, kte )

 CALL mom_flux_inverse_dist ( grad,                                 &                             
                             'u', u_1, v_1, w_1,                    &
                             top_u, uside, prox_u,                  &
                             utop_img, utop_bound,                  &
                             uside_img, uside_bound,                &
                             utop_neigh, uside_neigh,               &
                             utop_neigh_i, uside_neigh_i,           &
                             n, nu,                                 &
                             utop_norm, utop_dist,                  &
                             uside_norm, uside_dist,                &
                             antu_at_u, antv_at_u, antw_at_u,       &
                             ansu_at_u, ansv_at_u, answ_at_u,       &
                             ids, ide, jds, jde, kds, kde,          &
                             ims, ime, jms, jme, kms, kme,          &
                             its, ite, jts, jte, kts, kte )

 CALL mom_flux_inverse_dist ( grad,                                 &
                             'u', u_2, v_2, w_2,                    &
                             top_u, uside, prox_u,                  &
                             utop_img, utop_bound,                  &
                             uside_img, uside_bound,                &
                             utop_neigh, uside_neigh,               &
                             utop_neigh_i, uside_neigh_i,           &
                             n, nu,                                 &
                             utop_norm, utop_dist,                  &
                             uside_norm, uside_dist,                &
                             antu_at_u, antv_at_u, antw_at_u,       &
                             ansu_at_u, ansv_at_u, answ_at_u,       &
                             ids, ide, jds, jde, kds, kde,          &
                             ims, ime, jms, jme, kms, kme,          &
                             its, ite, jts, jte, kts, kte )

 CALL mom_flux_inverse_dist ( grad,                                 &
                             'v', u_1, v_1, w_1,                    &
                             top_v, vside, prox_v,                  &
                             vtop_img, vtop_bound,                  &
                             vside_img, vside_bound,                &
                             vtop_neigh, vside_neigh,               &
                             vtop_neigh_i, vside_neigh_i,           &
                             n, nv,                                 &
                             vtop_norm, vtop_dist,                  &
                             vside_norm, vside_dist,                &
                             antu_at_v, antv_at_v, antw_at_v,       &
                             ansu_at_v, ansv_at_v, answ_at_v,       &
                             ids, ide, jds, jde, kds, kde,          &
                             ims, ime, jms, jme, kms, kme,          &
                             its, ite, jts, jte, kts, kte )

 CALL mom_flux_inverse_dist ( grad,                                 &
                             'v', u_2, v_2, w_2,                    &
                             top_v, vside, prox_v,                  &
                             vtop_img, vtop_bound,                  &
                             vside_img, vside_bound,                &
                             vtop_neigh, vside_neigh,               &
                             vtop_neigh_i, vside_neigh_i,           &
                             n, nv,                                 &
                             vtop_norm, vtop_dist,                  &
                             vside_norm, vside_dist,                &
                             antu_at_v, antv_at_v, antw_at_v,       &
                             ansu_at_v, ansv_at_v, answ_at_v,       &
                             ids, ide, jds, jde, kds, kde,          &
                             ims, ime, jms, jme, kms, kme,          &
                             its, ite, jts, jte, kts, kte )

 CALL mom_flux_inverse_dist ( grad,                                 &
                             'w', u_1, v_1, w_1,                    &
                             top_w, wside, prox_w,                  &
                             wtop_img, wtop_bound,                  &
                             wside_img, wside_bound,                &
                             wtop_neigh, wside_neigh,               &
                             wtop_neigh_i, wside_neigh_i,           &
                             n, nw,                                 &
                             wtop_norm, wtop_dist,                  &
                             wside_norm, wside_dist,                &
                             antu_at_w, antv_at_w, antw_at_w,       &
                             ansu_at_w, ansv_at_w, answ_at_w,       &
                             ids, ide, jds, jde, kds, kde,          &
                             ims, ime, jms, jme, kms, kme,          &
                             its, ite, jts, jte, kts, kte )

 CALL mom_flux_inverse_dist ( grad,                                 &
                             'w', u_2, v_2, w_2,                    &
                             top_w, wside, prox_w,                  &
                             wtop_img, wtop_bound,                  &
                             wside_img, wside_bound,                &
                             wtop_neigh, wside_neigh,               &
                             wtop_neigh_i, wside_neigh_i,           &
                             n, nw,                                 &
                             wtop_norm, wtop_dist,                  &
                             wside_norm, wside_dist,                &
                             antu_at_w, antv_at_w, antw_at_w,       &
                             ansu_at_w, ansv_at_w, answ_at_w,       &
                             ids, ide, jds, jde, kds, kde,          &
                             ims, ime, jms, jme, kms, kme,          &
                             its, ite, jts, jte, kts, kte )

 DEALLOCATE (uside)
 DEALLOCATE (uside_img)
 DEALLOCATE (uside_bound)
 DEALLOCATE (uside_neigh)
 DEALLOCATE (uside_neigh_i)
 DEALLOCATE (uside_norm)
 DEALLOCATE (uside_dist)
 DEALLOCATE (ansu_at_u)
 DEALLOCATE (ansv_at_u)
 DEALLOCATE (answ_at_u)
 DEALLOCATE (vside)
 DEALLOCATE (vside_img)
 DEALLOCATE (vside_bound)
 DEALLOCATE (vside_neigh)
 DEALLOCATE (vside_neigh_i)
 DEALLOCATE (vside_norm)
 DEALLOCATE (vside_dist)
 DEALLOCATE (ansu_at_v)
 DEALLOCATE (ansv_at_v)
 DEALLOCATE (answ_at_v)
 DEALLOCATE (wside)
 DEALLOCATE (wside_img)
 DEALLOCATE (wside_bound)
 DEALLOCATE (wside_neigh)
 DEALLOCATE (wside_neigh_i)
 DEALLOCATE (wside_norm)
 DEALLOCATE (wside_dist)
 DEALLOCATE (ansu_at_w)
 DEALLOCATE (ansv_at_w)
 DEALLOCATE (answ_at_w)
 
 END SUBROUTINE start_mom_flux_ibm

!-------------------------------------------------------------------------------

 SUBROUTINE start_shear_stress_ibm ( config_flags,                  &
                                     u_1, v_1, w_1,                 &
                                     u_2, v_2, w_2,                 &
                                     top_u, top_v, top_w,           &
                                     ids, ide, jds, jde, kds, kde,  &
                                     ims, ime, jms, jme, kms, kme,  &
                                     its, ite, jts, jte, kts, kte )
 IMPLICIT NONE
 !input data
 TYPE(grid_config_rec_type), INTENT(IN   )               :: config_flags
 REAL, DIMENSION(ims:ime,kms:kme,jms:jme), INTENT(INOUT) :: u_1, v_1, w_1,  &  
                                                            u_2, v_2, w_2
 INTEGER, DIMENSION(ims:ime,jms:jme), INTENT(IN   )      :: top_u,     &     !'top boundary' ghost points
                                                            top_v,     &
                                                            top_w
 INTEGER, INTENT(IN   )                                  :: ids, ide, jds, jde, kds, kde, &  ! d: domain m:memory p:patch t:tile 
                                                            ims, ime, jms, jme, kms, kme, &
                                                            its, ite, jts, jte, kts, kte   

!---------------------------------------------------------------------------------
! this subroutine is called from start_em.F.  
! the executable begins here
 CALL wrf_debug(100,'dyn_em/module_ibm.F/subroutine start_shear_stress_ibm')
!---------------------------------------------------------------------------------  

 ! only zero if this is the first run (not a restart)
 ! regardless of whether zero_interior is true or false
 IF (.NOT. config_flags%restart) THEN
      CALL zero_interior ( config_flags%ibm_opt,         &
                           u_1, v_1, w_1,                &
                           top_u, top_v, top_w,          &
                           ids, ide, jds, jde, kds, kde, &
                           ims, ime, jms, jme, kms, kme, &
                           its, ite, jts, jte, kts, kte)
      CALL zero_interior ( config_flags%ibm_opt,         &
                           u_2, v_2, w_2,                &
                           top_u, top_v, top_w,          &
                           ids, ide, jds, jde, kds, kde, &
                           ims, ime, jms, jme, kms, kme, &
                           its, ite, jts, jte, kts, kte)
 ENDIF

 END SUBROUTINE start_shear_stress_ibm
 
!-------------------------------------------------------------------------------

 SUBROUTINE solve_ibm_init ( config_flags,                           &
                             full_s, full_u, full_v, full_w,         &
                             t_save, t_2, u_save, u_2,               &
                             v_save, v_2, w_save, w_2,               &
                             mut, muu, muv, muts,                    &
                             h_diabatic,                             &
                             number_of_small_timesteps,dts,          &
                             rk_step, rk_order,                      &
                             ibm_ht_u, ibm_ht_v,                     &
                             ibm_ht_w, ibm_ht_c,                     &
                             phb, phsave, ph,                        &
                             ht_s, ht_u, ht_v, ht_w,                 &
                             top_s, top_u, top_v, top_w,             &
                             prox_s, prox_u, prox_v, prox_w,         &
                             inside_s, inside_u, inside_v, inside_w, &
                             inside_all_s,                           &
                             inside_all_u,                           &
                             inside_all_v,                           &
                             inside_all_w,                           &
                             ids, ide, jds, jde, kds, kde,           &
                             ims, ime, jms, jme, kms, kme,           &
                             its, ite, jts, jte, kts, kte )
 IMPLICIT NONE
 !input data
 TYPE(grid_config_rec_type),               INTENT(IN   ) :: config_flags
 REAL, DIMENSION(ims:ime,kms:kme,jms:jme), INTENT(IN   ) :: t_save,      &
                                                            h_diabatic,  & 
                                                            phb,         &
                                                            phsave,      &
                                                            ph
 REAL, DIMENSION(ims:ime,kms:kme,jms:jme), INTENT(INOUT) :: u_save,      &
                                                            u_2,         &
                                                            v_save,      &
                                                            v_2,         &
                                                            w_save,      &
                                                            w_2,         &
                                                            t_2
 REAL, DIMENSION(ims:ime,jms:jme), INTENT(IN   )         :: mut,         &
                                                            muu,         &
                                                            muv,         &
                                                            muts,        &
                                                            ibm_ht_u,    &
                                                            ibm_ht_v,    &
                                                            ibm_ht_w,    &
                                                            ibm_ht_c
 REAL, INTENT(IN   )                                     :: dts
 INTEGER, INTENT(IN   )                                  :: number_of_small_timesteps, &
                                                            rk_step,     &
                                                            rk_order
 REAL, DIMENSION(ims:ime,kms:kme,jms:jme), INTENT(  OUT) :: full_s,      &
                                                            full_u,      &
                                                            full_v,      &
                                                            full_w,      &
                                                            ht_s,        & !this is the total geopotential
                                                            ht_u,        & !at center, u, v, and w points
                                                            ht_v,        & 
                                                            ht_w
 INTEGER, DIMENSION(ims:ime,jms:jme), INTENT(  OUT)      :: top_s,       & !'top boundary' ghost points
                                                            top_u,       &  
                                                            top_v,       & 
                                                            top_w,       &
                                                            prox_s,      & !one if the pt is outside of the terrain
                                                            prox_u,      & !meaning that the location has been changed due to proximity
                                                            prox_v,      &
                                                            prox_w
 INTEGER, DIMENSION(ims:ime,kms:kme,jms:jme), INTENT(OUT):: inside_s,    & !one if the pt is inside boundary, zero if it is outside
                                                            inside_u,    &
                                                            inside_v,    &
                                                            inside_w
 INTEGER, DIMENSION(ims:ime,kms:kme,jms:jme), INTENT(OUT):: inside_all_s, & !RSA inside includes recon pts, inside_all does not
                                                            inside_all_u, &
                                                            inside_all_v, &
                                                            inside_all_w
 INTEGER, INTENT(IN   )                                  :: ids, ide, jds, jde, kds, kde, & !d: domain
                                                            ims, ime, jms, jme, kms, kme, & !m: memory
                                                            its, ite, jts, jte, kts, kte    !p: patch, t: tile
 !local

!---------------------------------------------------------------------------------
 !this subroutine is called from solve_em.F.  !the executable begins here
 CALL wrf_debug(100,'dyn_em/module_ibm.F/subroutine solve_ibm_init')
!---------------------------------------------------------------------------------  

 CALL calc_ht_small( 't', phb, phsave, ph, ht_s,   &
                     ids, ide, jds, jde, kds, kde, &
                     ims, ime, jms, jme, kms, kme, &
                     its, ite, jts, jte, kts, kte )
 CALL calc_ht_small( 'u', phb, phsave, ph, ht_u,   &
                     ids, ide, jds, jde, kds, kde, &
                     ims, ime, jms, jme, kms, kme, &
                     its, ite, jts, jte, kts, kte )
 CALL calc_ht_small( 'v', phb, phsave, ph, ht_v,   &
                     ids, ide, jds, jde, kds, kde, &
                     ims, ime, jms, jme, kms, kme, &
                     its, ite, jts, jte, kts, kte )
 CALL calc_ht_small( 'w', phb, phsave, ph, ht_w,   &
                     ids, ide, jds, jde, kds, kde, &
                     ims, ime, jms, jme, kms, kme, &
                     its, ite, jts, jte, kts, kte )
 IF ( (config_flags%ibm_temp .EQ. 1) .OR. &
      (config_flags%ibm_scalar .EQ. 1) ) THEN
    CALL ghost_pts_top( 't', ht_s, ibm_ht_w,          &
                        top_s, prox_s, inside_s,      &
                        ids, ide, jds, jde, kds, kde, &
                        ims, ime, jms, jme, kms, kme, &
                        its, ite, jts, jte, kts, kte )
 ELSEIF ( (config_flags%ibm_temp .EQ. 2) .OR. &
          (config_flags%ibm_temp .EQ. 3) .OR. &
          (config_flags%ibm_scalar .EQ. 2) ) THEN
    CALL reconstruct_pts_top( 't', ht_s, ibm_ht_w,          &
                              top_s, inside_s,              &
                              inside_all_s,                 & !RSA for using recon pts as neighbors
                              config_flags%z_rough,         &
                              .true.,                       & !zero_within_z_rough
                              config_flags%recon_pt_bump_tol,           & !RSA
                              config_flags%bump_up_recon_pt_within_tol, & !RSA
                              ids, ide, jds, jde, kds, kde, &
                              ims, ime, jms, jme, kms, kme, &
                              its, ite, jts, jte, kts, kte )
    IF (config_flags%zero_interior) THEN
       CALL zero_interior_t( t_2, top_s,                   &
                             ids, ide, jds, jde, kds, kde, &
                             ims, ime, jms, jme, kms, kme, &
                             its, ite, jts, jte, kts, kte )
    ENDIF
 ENDIF
 IF ( (config_flags%ibm_opt .EQ. 1) .OR. &
      (config_flags%ibm_opt .EQ. 2) .OR. &
      (config_flags%ibm_opt .EQ. 4) .OR. &
      (config_flags%ibm_opt .EQ. 6) ) THEN
    CALL ghost_pts_top( 'u', ht_u, ibm_ht_u,          &
                        top_u, prox_u, inside_u,      &
                        ids, ide, jds, jde, kds, kde, &
                        ims, ime, jms, jme, kms, kme, &
                        its, ite, jts, jte, kts, kte )
    CALL ghost_pts_top( 'v', ht_v, ibm_ht_v,          &
                        top_v, prox_v, inside_v,      &
                        ids, ide, jds, jde, kds, kde, &
                        ims, ime, jms, jme, kms, kme, &
                        its, ite, jts, jte, kts, kte )
    CALL ghost_pts_top( 'w', ht_w, ibm_ht_w,          &
                        top_w, prox_w, inside_w,      &
                        ids, ide, jds, jde, kds, kde, &
                        ims, ime, jms, jme, kms, kme, &
                        its, ite, jts, jte, kts, kte )  
 ELSEIF (config_flags%ibm_opt .EQ. 3) THEN
    CALL reconstruct_pts_top( 'u', ht_u, ibm_ht_u,          &
                              top_u, inside_u,              &
                              inside_all_u,                 & !RSA for using recon pts as neighbors
                              config_flags%z_rough,         &
                              config_flags%zero_within_z_rough, &
                              config_flags%recon_pt_bump_tol,           & !RSA
                              config_flags%bump_up_recon_pt_within_tol, & !RSA
                              ids, ide, jds, jde, kds, kde, &
                              ims, ime, jms, jme, kms, kme, &
                              its, ite, jts, jte, kts, kte )
    CALL reconstruct_pts_top( 'v', ht_v, ibm_ht_v,          &
                              top_v, inside_v,              &
                              inside_all_v,                 & !RSA for using recon pts as neighbors
                              config_flags%z_rough,         &
                              config_flags%zero_within_z_rough, &
                              config_flags%recon_pt_bump_tol,           & !RSA
                              config_flags%bump_up_recon_pt_within_tol, & !RSA
                              ids, ide, jds, jde, kds, kde, &
                              ims, ime, jms, jme, kms, kme, &
                              its, ite, jts, jte, kts, kte )
    CALL reconstruct_pts_top( 'w', ht_w, ibm_ht_w,          &
                              top_w, inside_w,              &
                              inside_all_w,                 & !RSA for using recon pts as neighbors
                              config_flags%z_rough,         &
                              config_flags%zero_within_z_rough, &
                              config_flags%recon_pt_bump_tol,           & !RSA
                              config_flags%bump_up_recon_pt_within_tol, & !RSA
                              ids, ide, jds, jde, kds, kde, &
                              ims, ime, jms, jme, kms, kme, &
                              its, ite, jts, jte, kts, kte )
    IF ((config_flags%ibm_opt .EQ. 3) .AND. (config_flags%zero_interior)) THEN
       !KAL right now having zero interior here isnt working in parallel,
       !    another halo exchange would need to be added somewhere if you
       !    want to zero below the terrain
       CALL zero_interior( config_flags%ibm_opt,         &
                           u_2, v_2, w_2,                &
                           top_u, top_v, top_w,          &
                           ids, ide, jds, jde, kds, kde, &
                           ims, ime, jms, jme, kms, kme, &
                           its, ite, jts, jte, kts, kte )
       !DJW zeroing out the interior for the *_save velocities is problematic
       !    as the values are needed at top and side points in
       !    vel_recon_inverse_dist_ss. With zeros, the resulting velocities at
       !    top and side points are excessive and nonphysical.
!       CALL zero_interior( config_flags%ibm_opt,         &
!                           u_save, v_save, w_save,       &
!                           top_u, top_v, top_w,          &
!                           ids, ide, jds, jde, kds, kde, &
!                           ims, ime, jms, jme, kms, kme, &
!                           its, ite, jts, jte, kts, kte )
    ENDIF
 ELSEIF (config_flags%ibm_opt .EQ. 5) THEN
    CALL ghost_pts_top_ss( 'u', ht_u, ibm_ht_u,          &
                           top_u, inside_u,              &
                           ids, ide, jds, jde, kds, kde, &
                           ims, ime, jms, jme, kms, kme, &
                           its, ite, jts, jte, kts, kte )
    CALL ghost_pts_top_ss( 'v', ht_v, ibm_ht_v,          &
                           top_v, inside_v,              &
                           ids, ide, jds, jde, kds, kde, &
                           ims, ime, jms, jme, kms, kme, &
                           its, ite, jts, jte, kts, kte )
    CALL ghost_pts_top_ss( 'w', ht_w, ibm_ht_w,          &
                           top_w, inside_w,              &
                           ids, ide, jds, jde, kds, kde, &
                           ims, ime, jms, jme, kms, kme, &
                           its, ite, jts, jte, kts, kte )  
    !RSA for shear stress reconstruction, velocities are zeroed 
    !underneath the terrain regardless of whether zero_interior
    !is true or false.
    CALL zero_interior( config_flags%ibm_opt,         &
                        u_2, v_2, w_2,                &
                        top_u, top_v, top_w,          &
                        ids, ide, jds, jde, kds, kde, &
                        ims, ime, jms, jme, kms, kme, &
                        its, ite, jts, jte, kts, kte )
 ENDIF

 CALL calc_var_full( 't', full_s,                   &
                     t_2, t_save,                   &
                     mut, muts,                     &
                     h_diabatic,                    &
                     number_of_small_timesteps,dts, &
                     rk_step, rk_order,             &
                     ids, ide, jds, jde, kds, kde,  &
                     ims, ime, jms, jme, kms, kme,  &
                     its, ite, jts, jte, kts, kte )
 CALL calc_var_full( 'u', full_u,                   &
                     u_2, u_save,                   &
                     muu, muts,                     &
                     h_diabatic,                    &
                     number_of_small_timesteps,dts, &
                     rk_step, rk_order,             &
                     ids, ide, jds, jde, kds, kde,  &
                     ims, ime, jms, jme, kms, kme,  &
                     its, ite, jts, jte, kts, kte )
 CALL calc_var_full( 'v', full_v,                   &
                     v_2, v_save,                   &
                     muv, muts,                     &
                     h_diabatic,                    &
                     number_of_small_timesteps,dts, &
                     rk_step, rk_order,             &
                     ids, ide, jds, jde, kds, kde,  &
                     ims, ime, jms, jme, kms, kme,  &
                     its, ite, jts, jte, kts, kte )
 CALL calc_var_full( 'w', full_w,                   &
                     w_2, w_save,                   &
                     mut, muts,                     &
                     h_diabatic,                    &
                     number_of_small_timesteps,dts, &
                     rk_step, rk_order,             &
                     ids, ide, jds, jde, kds, kde,  &
                     ims, ime, jms, jme, kms, kme,  &
                     its, ite, jts, jte, kts, kte )

 END SUBROUTINE solve_ibm_init

!--------------------------------------------------------------------------------------------------------------

 SUBROUTINE vel_ns_ibm( config_flags, stag, start, bc_type, &
                        ht_p,                               &
                        top, prox, inside,                  &
                        inside_all,                         &
                        varfull, varsave, var,              &
                        mu, mus,                            &
                        ibm_ht_u, ibm_ht_v,                 &
                        ibm_ht_w, ibm_ht_c,                 &
                        n,                                  &
                        ids, ide, jds, jde, kds, kde,       &
                        ims, ime, jms, jme, kms, kme,       &
                        its, ite, jts, jte, kts, kte )
 IMPLICIT NONE
 !input data
 TYPE(grid_config_rec_type), INTENT(IN   )               :: config_flags
 CHARACTER, INTENT(IN   )                                :: stag
 INTEGER , INTENT(IN   )                                 :: start,       &
                                                            bc_type         ! 1 = dirchlet 2 = neumann							              
 INTEGER, DIMENSION(ims:ime,jms:jme), INTENT(IN   )      :: top,         &  !'top boundary' ghost points
                                                            prox
 INTEGER, DIMENSION(ims:ime,kms:kme,jms:jme), INTENT(IN) :: inside          ! one if the pt is inside boundary, zero if it is outside
 INTEGER, DIMENSION(ims:ime,kms:kme,jms:jme), INTENT(IN) :: inside_all      ! RSA inside includes recon pts, inside_all does not
 REAL, DIMENSION(ims:ime,kms:kme,jms:jme), INTENT(IN   ) :: ht_p,        &
                                                            varsave
 REAL, DIMENSION(ims:ime,kms:kme,jms:jme), INTENT(INOUT) :: varfull,     &
                                                            var
 REAL, DIMENSION(ims:ime,jms:jme), INTENT(IN   )         :: mu,          &
                                                            mus,         &
                                                            ibm_ht_u,    &
                                                            ibm_ht_v,    &
                                                            ibm_ht_w,    &
                                                            ibm_ht_c
 INTEGER, INTENT(IN   )                                  :: n               ! desired number of nearest neighbors							    
 INTEGER, INTENT(IN   )                                  :: ids, ide, jds, jde, kds, kde, & !d: domain 
                                                            ims, ime, jms, jme, kms, kme, & !m: memory
                                                            its, ite, jts, jte, kts, kte    !p: patch, t: tile
 !local data
 INTEGER                                                 :: ns              ! number of 'side boundary' ghost points
 INTEGER, DIMENSION(ims:ime,jms:jme)                     :: ant             ! actual number of nearest neighbors for top points
 REAL, DIMENSION(ims:ime,jms:jme)                        :: top_dist
                                                           ! grad           ! gradient at boundary
 REAL, DIMENSION(ims:ime,jms:jme,6)                      :: top_img         ! (x,y,z) location of ghost point and image point of the 'top boundary' ghost points
 REAL, DIMENSION(ims:ime,jms:jme,3)                      :: top_bound,   &  ! keep the (x,y,z) location of the boundary points for the no-slip bc
                                                            top_norm
 REAL, DIMENSION(ims:ime,jms:jme,0:3*n-1)                :: top_neigh       ! (x,y,z) location of top neighbors
 INTEGER, DIMENSION(ims:ime,jms:jme,0:3*n-1)             :: top_neigh_i     ! (i,j,k) index of top neighbors							    
 INTEGER, DIMENSION(:), ALLOCATABLE                      :: ans             ! acutal number of nearest neighbors for side points
 INTEGER, DIMENSION(:,:), ALLOCATABLE                    :: side            !'side boundary' ghost points
 REAL, DIMENSION(:,:), ALLOCATABLE                       :: side_img,    &  ! (x,y,z) location of ghost point
                                                            side_bound,  &  ! (x,y,z) location of the boundary for side points
                                                            side_neigh,  &  ! (x,y,z) location of side neighbors
                                                            side_norm
 REAL, DIMENSION(:), ALLOCATABLE                         :: side_dist
 INTEGER, DIMENSION(:,:), ALLOCATABLE                    :: side_neigh_i    ! (i,j,k) index of side neighbors							    
 LOGICAL                                                 :: in_scalar !RSA flag for neighbors_ns (true for temp or scalar, false for velocity)
 LOGICAL                                                 :: in_vel_recon !RSA for now, only use recon pts as nearest neighbors from vel_recon routines
! KAL added these to play around with timing
!      integer rsl_internal_microclock
!      external rsl_internal_microclock
!      REAL :: time_test
!KAL
!---------------------------------------------------------------------------------
! the executable begins here
 CALL wrf_debug(100,'dyn_em/module_ibm.F/subroutine vel_ns_ibm')
!---------------------------------------------------------------------------------
! initalize the scalar fluxes at the surface
! grad = 0.0

 CALL count_side_pts ( stag, top, ns,                &
                       ids, ide, jds, jde, kds, kde, &
                       ims, ime, jms, jme, kms, kme, &
                       its, ite, jts, jte, kts, kte )

 ! allocate and store side ghost points
 ALLOCATE (side(3,ns))
 ALLOCATE (side_img(6,ns))
 ALLOCATE (side_bound(3,ns))
 ALLOCATE (side_neigh(0:3*n-1,ns))
 ALLOCATE (side_neigh_i(0:3*n-1,ns))
 ALLOCATE (side_norm(3,ns))
 ALLOCATE (side_dist(ns))
 ALLOCATE (ans(ns))
 
 IF (ns .GT. 0) THEN
    CALL ghost_pts_side ( stag, top, side, ns,          &
                          ids, ide, jds, jde, kds, kde, &
                          ims, ime, jms, jme, kms, kme, &
                          its, ite, jts, jte, kts, kte )
 ENDIF ! end of get side points

 CALL image_pts ( stag,config_flags%interp_opt, bc_type, &
                  config_flags%dx, config_flags%dy,      &
                  ht_p,                                  &
                  ibm_ht_u, ibm_ht_v,                    &
                  ibm_ht_w, ibm_ht_c,                    &
                  top, side,                             &
                  top_img, top_bound,                    &
                  side_img, side_bound,                  &
                  prox, ns, top_norm, side_norm,         &
                  top_dist, side_dist,                   &
                  ids, ide, jds, jde, kds, kde,          &
                  ims, ime, jms, jme, kms, kme,          &
                  its, ite, jts, jte, kts, kte )

!time_test = rsl_internal_microclock()
 in_scalar = .false. !RSA flag for neighbors_ns (true for temp or scalar, false for velocity)
 in_vel_recon = .false. !RSA for now, only use recon pts as nearest neighbors from vel_recon routines
 CALL neighbors_ns( config_flags%ibm_opt,                    &
                    config_flags%ibm_scalar,                 & !RSA for using VRM with ghost pt scalar BC
                    in_scalar,                               & !RSA for using VRM with ghost pt scalar BC
                    config_flags%interp_opt,                 &
                    config_flags%dim_terrain, stag, bc_type, &
                    config_flags%ibm_nn_horz,                &
                    config_flags%ibm_nn_vert,                &
                    config_flags%dx, config_flags%dy,        &
                    prox,                                    &
                    ibm_ht_u, ibm_ht_v,                      &
                    ibm_ht_w, ibm_ht_c,                      &
                    ht_p, inside,                            &
                    inside_all,                              & !RSA for using recon pts as neighbors
                    config_flags%recon_pts_as_neigh,         & !RSA for using recon pts as neighbors
                    in_vel_recon,                            & !RSA for using recon pts as neighbors
                    top, side, top_img, side_img,            &
                    top_bound, side_bound,                   &
                    top_neigh, top_neigh_i,                  &
                    side_neigh, side_neigh_i,                &
                    n, ns, ant, ans,                         &
                    ids, ide, jds, jde, kds, kde,            &
                    ims, ime, jms, jme, kms, kme,            &
                    its, ite, jts, jte, kts, kte )
!time_test = rsl_internal_microclock() - time_test
!write(0,*) 'neighbors',time_test
 IF ((start .EQ. 1) .AND. (config_flags%write_ibm_data)) THEN
    write(*,'(A,A)') "DJW[module_ibm/vel_ns_ibm]: calling write_ibm_data for stag=",stag
    CALL write_ibm_data ( stag, side,                   &
                          top_img, side_img,            &
                          top_bound, side_bound,        &
                          top_neigh, side_neigh,        &
                          n, ns,                        &
                          ids, ide, jds, jde, kds, kde, &
                          ims, ime, jms, jme, kms, kme, &
                          its, ite, jts, jte, kts, kte )
    CALL write_ht_data ( stag, ht_p,                   &
                         ids, ide, jds, jde, kds, kde, &
                         ims, ime, jms, jme, kms, kme, &
                         its, ite, jts, jte, kts, kte )
 ENDIF
 
 ! pert values are calculated from full values in these subroutines
 ! and put into var
! time_test = rsl_internal_microclock()
 IF (bc_type .EQ. 1) THEN
    IF (config_flags%interp_opt .EQ. 1) THEN
       CALL no_slip_lin_ss ( stag, prox, config_flags%dim_terrain, &
                             var, varfull, varsave,                &
                             mu, mus,                              &
                             top, top_img,                         &
                             side, side_img,                       &
                             top_neigh, side_neigh,                &
                             top_neigh_i, side_neigh_i,            &
                             n, ns,                                &
                             ids, ide, jds, jde, kds, kde,         &
                             ims, ime, jms, jme, kms, kme,         &
                             its, ite, jts, jte, kts, kte )
    ELSEIF ((config_flags%interp_opt .EQ. 2) .OR. (config_flags%interp_opt .EQ. 3)) THEN
       CALL no_slip_inverse_dist_ss ( stag, prox, config_flags%dim_terrain, &
                                      var, varfull, varsave,                &
                                      mu, mus,                              &
                                      top,                                  &
                                      side,                                 &
                                      top_neigh, side_neigh,                &
                                      top_neigh_i, side_neigh_i,            &
                                      n, ns, ant, ans,                      &
                                      ids, ide, jds, jde, kds, kde,         &
                                      ims, ime, jms, jme, kms, kme,         &
                                      its, ite, jts, jte, kts, kte )
    ENDIF
!time_test = rsl_internal_microclock() - time_test
!write(0,*) 'solve    ',time_test
 ELSEIF (bc_type .EQ. 2) THEN  
    write(0,*) 'Neumann Boundary Condition not set for Velocity'
!    CALL neumann_lin_ss( grad, prox, config_flags%dim_terrain, &
!                         var, varfull, varsave,	        &
!			  mu, mus,			        &
!			  h_diabatic,			        &
!                         number_of_small_timesteps,dts,        &
!                         rk_step, rk_order,		        &
!                         top_norm, side_norm,  	        &
!			  top_dist, side_dist,  	        &
!                         top, top_img, 		        &
!			  side, side_img,		        &
!			  top_neigh, side_neigh,	        &
!			  top_neigh_i, side_neigh_i,	        &
!			  n, ns,			        &
!			  ids, ide, jds, jde, kds, kde,         &
!			  ims, ime, jms, jme, kms, kme,         &
!			  its, ite, jts, jte, kts, kte)       
 ENDIF

 ! allocate and store side ghost points
 CALL wrf_debug(100,'deallocate dyn_em/module_ibm.F/subroutine velocity_ibm')
 DEALLOCATE (side)
 DEALLOCATE (side_img)
 DEALLOCATE (side_bound)
 DEALLOCATE (side_neigh)
 DEALLOCATE (side_neigh_i)
 DEALLOCATE (side_norm)
 DEALLOCATE (side_dist)
 DEALLOCATE (ans)

 END SUBROUTINE vel_ns_ibm

!--------------------------------------------------------------------------------------------------------

 SUBROUTINE vel_recon_ibm_temp( config_flags, stag, start,    &
                                ht, inside,                   &
                                inside_all,                   &
                                top,                          &
                                varsave, var, varfull,        &
                                mut, muts,                    &
                                h_diabatic,                   &
                                number_of_small_timesteps,    &
                                dts, rk_step, rk_order,       &
                                qv, rho,                      &
                                xkhv, hfx,                    &
                                ibm_ht_u, ibm_ht_v,           &
                                ibm_ht_w, ibm_ht_c,           &
                                n,                            &
                                ids, ide, jds, jde, kds, kde, &
                                ims, ime, jms, jme, kms, kme, &
                                its, ite, jts, jte, kts, kte )
 IMPLICIT NONE
 !input data
 TYPE(grid_config_rec_type), INTENT(IN   )               :: config_flags
 CHARACTER, INTENT(IN   )                                :: stag
 REAL, DIMENSION(ims:ime,kms:kme,jms:jme), INTENT(IN   ) :: ht,         &
                                                            varsave,    &
                                                            h_diabatic, &
                                                            qv,         &
                                                            rho,        &
                                                            xkhv
 REAL, DIMENSION(ims:ime,kms:kme,jms:jme), INTENT(INOUT) :: var,        &
                                                            varfull
 REAL, DIMENSION(ims:ime,jms:jme), INTENT(IN   )         :: mut,        &
                                                            muts,       &
                                                            ibm_ht_u,   &
                                                            ibm_ht_v,   &
                                                            ibm_ht_w,   &
                                                            ibm_ht_c
 REAL, DIMENSION(ims:ime,jms:jme), INTENT(INOUT)         :: hfx
 REAL, INTENT(IN   )                                     :: dts
 INTEGER, DIMENSION(ims:ime,kms:kme,jms:jme), INTENT(IN) :: inside        !1 if the pt is inside boundary, 0 if it is outside
 INTEGER, DIMENSION(ims:ime,kms:kme,jms:jme), INTENT(IN) :: inside_all    !RSA inside includes recon pts, inside_all does not
 INTEGER, DIMENSION(ims:ime,jms:jme), INTENT(IN   )      :: top           !'top boundary' ghost points
 INTEGER, INTENT(IN   )                                  :: start,      &
                                                            n,          & !desired number of nearest neighbors
                                                            number_of_small_timesteps, &
                                                            rk_step,    &
                                                            rk_order,   &
                                                            ids, ide, jds, jde, kds, kde, & !d: domain 
                                                            ims, ime, jms, jme, kms, kme, & !m:memory
                                                            its, ite, jts, jte, kts, kte    !p: patch, t: tile
 !local data
 INTEGER                                                 :: ns,         & !number of 'side boundary' ghost points
                                                            i, j
 REAL                                                    :: cpm
 INTEGER, DIMENSION(ims:ime,jms:jme)                     :: antt_at_s     !actual number of nearest neighbors for top points
 REAL, DIMENSION(ims:ime,jms:jme)                        :: grad
 REAL, DIMENSION(ims:ime,jms:jme,2)                      :: top_dist
 REAL, DIMENSION(ims:ime,jms:jme,6)                      :: top_img       !(x,y,z) location of ghost point and image point of the 'top boundary' ghost points
 REAL, DIMENSION(ims:ime,jms:jme,3)                      :: top_bound,  & !keep the (x,y,z) location of the boundary points for the no-slip bc
                                                            top_norm
 REAL, DIMENSION(ims:ime,jms:jme,0:9*n-1)                :: top_neigh     !(x,y,z) location of top neighbors
 INTEGER, DIMENSION(ims:ime,jms:jme,0:9*n-1)             :: top_neigh_i   !(i,j,k) index of top neighbors
 INTEGER, DIMENSION(:), ALLOCATABLE                      :: anst_at_s     !acutal number of nearest neighbors for side points
 INTEGER, DIMENSION(:,:), ALLOCATABLE                    :: side,       & !'side boundary' ghost points
                                                            side_neigh_i  !(i,j,k) index of side neighbors
 REAL, DIMENSION(:,:), ALLOCATABLE                       :: side_img,   & !(x,y,z) location of ghost point
                                                            side_bound, & !(x,y,z) location of the boundary for side points
                                                            side_neigh, & !(x,y,z) location of side neighbors
                                                            side_norm,  &
                                                            side_dist
 INTEGER :: S, nC !DJW for debugging, remove later
 LOGICAL                                                 :: in_vel_recon !RSA for now, only use recon pts as nearest neighbors from vel_recon routines

!---------------------------------------------------------------------------------
 !the executable begins here
 CALL wrf_debug(100,'dyn_em/module_ibm.F/subroutine vel_recon_ibm_temp')
!---------------------------------------------------------------------------------

 CALL count_side_pts( stag, top, ns,                         &
                      ids, ide, jds, jde, kds, kde,          &
                      ims, ime, jms, jme, kms, kme,          &
                      its, ite, jts, jte, kts, kte )

 !allocate and store side reconstruction points
 ALLOCATE (side(3,ns))
 ALLOCATE (side_img(6,ns))
 ALLOCATE (side_bound(3,ns))
 ALLOCATE (side_neigh(0:3*n-1,ns))
 ALLOCATE (side_neigh_i(0:3*n-1,ns))
 ALLOCATE (side_norm(3,ns))
 ALLOCATE (side_dist(2,ns))
 ALLOCATE (anst_at_s(ns))
 IF (ns .GT. 0) THEN
    CALL reconstruct_pts_side( stag, top, side, ns,          &
                               ids, ide, jds, jde, kds, kde, &
                               ims, ime, jms, jme, kms, kme, &
                               its, ite, jts, jte, kts, kte )
 ENDIF
 !finsihed finding the side reconstruction points

 !find the interpolation points by projecting the reconstruction points across
 !the immersed boundary. The IPs are set to be on the face of the cell that is
 !cut by the IB. There is no guarantee that the IPs will be well conditioned.
 CALL interpolation_pts( stag,                               &
                         config_flags%dx, config_flags%dy,   &
                         ht,                                 &
                         ibm_ht_u, ibm_ht_v,                 &
                         ibm_ht_w, ibm_ht_c,                 &
                         inside, top, side,                  &
                         top_img, top_bound,                 &
                         side_img, side_bound,               &
                         ns, top_norm, side_norm,            &
                         top_dist, side_dist,                &
                         config_flags%ibm_nn_horz,           &
                         config_flags%ibm_nn_vert,           &
                         ids, ide, jds, jde, kds, kde,       &
                         ims, ime, jms, jme, kms, kme,       &
                         its, ite, jts, jte, kts, kte )

 !find the nearest neighbors to the IPs. Search through a 4x4x4 box of points
 !centered about each IP and rank each point based upon distance from the IP.
 in_vel_recon = .true. !RSA for now, only use recon pts as nearest neighbors from vel_recon routines
 CALL neighbors_fs_temp( config_flags%ibm_opt,               &
                         config_flags%ibm_temp,              &
                         config_flags%ibm_nn_horz,           &
                         config_flags%ibm_nn_vert,           &
                         config_flags%dx, config_flags%dy,   &
                         ibm_ht_u, ibm_ht_v,                 &
                         ibm_ht_w, ibm_ht_c,                 &
                         ht, inside,                         &
                         inside_all,                         & !RSA for using reconstruction pts as nearest neighbors
                         config_flags%recon_pts_as_neigh,    & !RSA for using reconstruction pts as nearest neighbors
                         in_vel_recon,                       & !RSA for using reconstruction pts as nearest neighbors
                         side,                               &
                         top_img, side_img,                  &
                         top_bound, side_bound,              &
                         top_neigh, top_neigh_i,             &
                         side_neigh, side_neigh_i,           &
                         n, ns,                              &
                         antt_at_s, anst_at_s,               &
                         ids, ide, jds, jde, kds, kde,       &
                         ims, ime, jms, jme, kms, kme,       &
                         its, ite, jts, jte, kts, kte )

 !if this is the first time through this subroutine, then write information
 !about the RPs, IPs, and nearest neighbors to text files that can be found in
 !the run directory.
 IF ((start .EQ. 1) .AND. (config_flags%write_ibm_data)) THEN
    write(*,'(A,A)') "DJW[module_ibm/vel_recon_ibm_temp]: calling write_ibm_data for stag=",stag
    CALL write_ibm_data( stag, side,                         &
                         top_img, side_img,                  &
                         top_bound, side_bound,              &
                         top_neigh, side_neigh,              &
                         n, ns,                              &
                         ids, ide, jds, jde, kds, kde,       &
                         ims, ime, jms, jme, kms, kme,       &
                         its, ite, jts, jte, kts, kte )
    write(*,'(A,A)') "DJW[module_ibm/vel_recon_ibm_temp]: calling write_ht_data for stag=",stag
    CALL write_ht_data( stag, ht,                            &
                        ids, ide, jds, jde, kds, kde,        &
                        ims, ime, jms, jme, kms, kme,        &
                        its, ite, jts, jte, kts, kte )
 ENDIF

 grad = 0.0
 !set the heat flux gradient boundary condition at the immersed boundary
 !using the vertical eddy diffusivity below.  Eventually I need to change this
 !to be a combination of vertical and horizontal components based on the 
 !normal vector to the surface
 IF ((config_flags%heat_flux_function) .OR. (config_flags%sf_surface_physics .NE. 0)) THEN !assign grad only, hfx already calculated
    DO j=jts,MIN(jte,jde-1)
    DO i=its,MIN(ite,ide-1)
       cpm = cp*(1.0+0.8*qv(i,top(i,j)+1,j)) 
       grad(i,j) = -hfx(i,j)/cpm/rho(i,top(i,j)+1,j)/xkhv(i,top(i,j)+1,j)
    ENDDO
    ENDDO
 ELSEIF (config_flags%tke_heat_flux .GT. 0.0) THEN !assign grad and hfx
    DO j=jts,MIN(jte,jde-1)
    DO i=its,MIN(ite,ide-1)
       grad(i,j) = -config_flags%tke_heat_flux/xkhv(i,top(i,j)+1,j)
       cpm = cp*(1.0+0.8*qv(i,top(i,j)+1,j))
       hfx(i,j) = config_flags%tke_heat_flux*cpm*rho(i,top(i,j)+1,j)
    ENDDO
    ENDDO
 ENDIF

 IF ( (config_flags%ibm_temp .EQ. 2) .OR. &
      (config_flags%ibm_temp .EQ. 3) ) THEN
    CALL vel_recon_inverse_dist_temp( config_flags%ibm_temp,        &
                                      config_flags%ibm_temp_3,      &
                                      varsave, var, varfull,        &
                                      mut, muts, grad,              &
                                      h_diabatic,                   &
                                      number_of_small_timesteps,    &
                                      dts, rk_step, rk_order,       &
                                      top, side,                    &
                                      top_neigh(:,:,6*n:9*n-1),     &
                                      side_neigh,                   &
                                      top_neigh_i(:,:,6*n:9*n-1),   &
                                      side_neigh_i,                 &
                                      n, ns,                        &
                                      top_norm, top_dist,           &
                                      side_norm, side_dist,         &
                                      antt_at_s, anst_at_s,         &
                                      ids, ide, jds, jde, kds, kde, &
                                      ims, ime, jms, jme, kms, kme, &
                                      its, ite, jts, jte, kts, kte ) 
 ENDIF

 DEALLOCATE (side)
 DEALLOCATE (side_img)
 DEALLOCATE (side_bound)
 DEALLOCATE (side_neigh)
 DEALLOCATE (side_neigh_i)
 DEALLOCATE (side_norm)
 DEALLOCATE (side_dist)
 DEALLOCATE (anst_at_s)

 END SUBROUTINE vel_recon_ibm_temp

!-------------------------------------------------------------------------------

 SUBROUTINE vel_recon_ibm_eddy_init ( config_flags,                     &
                                      ibm_ht_w,                         &
                                      phb, phsave, ph,                  &
                                      ht_s, top_s, inside_s,            &
                                      inside_all_s,                     &
                                      ids, ide, jds, jde, kds, kde,     &
                                      ims, ime, jms, jme, kms, kme,     &
                                      its, ite, jts, jte, kts, kte )
 IMPLICIT NONE
 !input data
 TYPE(grid_config_rec_type),               INTENT(IN   ) :: config_flags
 REAL, DIMENSION(ims:ime,kms:kme,jms:jme), INTENT(IN   ) :: phb,         &
                                                            phsave,      &
                                                            ph
 REAL, DIMENSION(ims:ime,jms:jme), INTENT(IN   )         :: ibm_ht_w
 REAL, DIMENSION(ims:ime,kms:kme,jms:jme), INTENT(  OUT) :: ht_s           !this is the total geopotential
 INTEGER, DIMENSION(ims:ime,jms:jme), INTENT(  OUT)      :: top_s          !'top boundary' ghost points
 INTEGER, DIMENSION(ims:ime,kms:kme,jms:jme), INTENT(OUT):: inside_s, &    !one if the pt is inside boundary, zero if it is outside
                                                            inside_all_s   !RSA inside includes recon pts, inside_all does not
 INTEGER, INTENT(IN   )                                  :: ids, ide, jds, jde, kds, kde, & !d: domain
                                                            ims, ime, jms, jme, kms, kme, & !m: memory
                                                            its, ite, jts, jte, kts, kte    !p: patch, t: tile
 !local
 LOGICAL                                                 :: zero_within_z_rough

!---------------------------------------------------------------------------------
 !this subroutine is called from module_first_rk_step_part2.F.  !the executable begins here
 CALL wrf_debug(100,'dyn_em/module_ibm.F/subroutine vel_recon_ibm_eddy_init')
!---------------------------------------------------------------------------------  

 CALL calc_ht_small( 't', phb, phsave, ph, ht_s,   &
                     ids, ide, jds, jde, kds, kde, &
                     ims, ime, jms, jme, kms, kme, &
                     its, ite, jts, jte, kts, kte )

 zero_within_z_rough = .true.
 CALL reconstruct_pts_top( 't', ht_s, ibm_ht_w,           &
                            top_s, inside_s,              &
                            inside_all_s,                 & !RSA for using recon pts as neighbors
                            config_flags%z_rough,         &
                            zero_within_z_rough,          &
                            config_flags%recon_pt_bump_tol,           & !RSA
                            config_flags%bump_up_recon_pt_within_tol, & !RSA
                            ids, ide, jds, jde, kds, kde, &
                            ims, ime, jms, jme, kms, kme, &
                            its, ite, jts, jte, kts, kte )

 END SUBROUTINE vel_recon_ibm_eddy_init

!-------------------------------------------------------------------------------

 SUBROUTINE vel_recon_ibm_eddy_part1 ( config_flags,                 &
                                       top_s, inside_s,              &
                                       ids, ide, jds, jde, kds, kde, &
                                       ims, ime, jms, jme, kms, kme, &
                                       its, ite, jts, jte, kts, kte )
 IMPLICIT NONE
 !input data
 TYPE(grid_config_rec_type), INTENT(IN   )                  :: config_flags
 INTEGER, DIMENSION(ims:ime,jms:jme), INTENT(IN   )         :: top_s     !'top boundary' ghost points
 INTEGER, DIMENSION(ims:ime,kms:kme,jms:jme), INTENT(INOUT) :: inside_s  !one if the pt is inside boundary, zero if it is outside
 INTEGER, INTENT(IN   )                                      :: ids, ide, jds, jde, kds, kde, & !d: domain 
                                                                ims, ime, jms, jme, kms, kme, & !m: memory
                                                                its, ite, jts, jte, kts, kte    !p: patch, t: tile
 !local data

!---------------------------------------------------------------------------------
 !this subroutine is called from module_first_rk_step_part2.F.  
 !the executable begins here
 CALL wrf_debug(100,'dyn_em/module_ibm.F/subroutine vel_recon_ibm_eddy_part1')
!---------------------------------------------------------------------------------  

 CALL label_side_pts_inside ( 't', inside_s, top_s,         &
                              ids, ide, jds, jde, kds, kde, &
                              ims, ime, jms, jme, kms, kme, &
                              its, ite, jts, jte, kts, kte )
 
 END SUBROUTINE vel_recon_ibm_eddy_part1

!--------------------------------------------------------------------------------------------------------

 SUBROUTINE vel_recon_ibm_eddy_part2 ( config_flags, stag, start,    &
                                       ht, inside, inside_all,       &
                                       top,                          &
                                       xkmh, xkmv,                   & 
                                       xkhh, xkhv,                   &
                                       ibm_ht_u, ibm_ht_v,           &
                                       ibm_ht_w, ibm_ht_c,           &
                                       n,                            &
                                       msftx, msfty, rdzw,           &
                                       dx, dy, dt,                   &
                                       mix_upper_bound,              &
                                       ids, ide, jds, jde, kds, kde, &
                                       ims, ime, jms, jme, kms, kme, &
                                       its, ite, jts, jte, kts, kte )
 IMPLICIT NONE
 !input data
 TYPE(grid_config_rec_type), INTENT(IN   )                 :: config_flags
 CHARACTER, INTENT(IN   )                                  :: stag
 REAL, DIMENSION(ims:ime,kms:kme,jms:jme), INTENT(IN   )   :: ht
 REAL, DIMENSION(ims:ime,kms:kme,jms:jme), INTENT(INOUT)   :: xkmh,       &
                                                              xkmv,       &
                                                              xkhh,       &
                                                              xkhv
 REAL, DIMENSION(ims:ime,jms:jme), INTENT(IN   )           :: ibm_ht_u,   &
                                                              ibm_ht_v,   &
                                                              ibm_ht_w,   &
                                                              ibm_ht_c
 INTEGER, DIMENSION(ims:ime,kms:kme,jms:jme), INTENT(IN)   :: inside,     & !1 if the pt is inside boundary, 0 if it is outside
                                                              inside_all    !RSA inside includes recon pts, inside_all does not 
 INTEGER, DIMENSION(ims:ime,jms:jme), INTENT(IN   )        :: top           !'top boundary' ghost points
 REAL, DIMENSION(ims:ime, jms:jme), INTENT(IN   )          :: msftx,       & !DJW map scale factor on mass grid in x-direction
                                                              msfty          !DJW map scale factor on mass grid in y-direction
 REAL, DIMENSION(ims:ime, kms:kme, jms:jme), INTENT(IN   ) :: rdzw           !DJW dz**-1 at W-levels
 REAL, INTENT(IN   )                                       :: dx,          & !DJW grid spacing in x-direction
                                                              dy,          & !DJW grid spacing in y-direction
                                                              dt,          & !DJW timestep
                                                              mix_upper_bound !non-dimensional limit for mixing
 INTEGER, INTENT(IN   )                                    :: n,          & !desired number of nearest neighbors
                                                              start,      & !diagnostic for ibm
                                                              ids, ide, jds, jde, kds, kde, & !d: domain 
                                                              ims, ime, jms, jme, kms, kme, & !m:memory
                                                              its, ite, jts, jte, kts, kte    !p: patch, t: tile
 !local data
 INTEGER                                                   :: ns,         & !number of 'side boundary' ghost points
                                                              i, j
 REAL                                                      :: cpm
 INTEGER, DIMENSION(ims:ime,jms:jme)                       :: antt_at_s     !actual number of nearest neighbors for top points
 REAL, DIMENSION(ims:ime,jms:jme,2)                        :: top_dist
 REAL, DIMENSION(ims:ime,jms:jme,6)                        :: top_img       !(x,y,z) location of ghost point and image point of the 'top boundary' ghost points
 REAL, DIMENSION(ims:ime,jms:jme,3)                        :: top_bound,  & !keep the (x,y,z) location of the boundary points for the no-slip bc
                                                              top_norm
 REAL, DIMENSION(ims:ime,jms:jme,0:9*n-1)                  :: top_neigh     !(x,y,z) location of top neighbors
 INTEGER, DIMENSION(ims:ime,jms:jme,0:9*n-1)               :: top_neigh_i   !(i,j,k) index of top neighbors
 INTEGER, DIMENSION(:), ALLOCATABLE                        :: anst_at_s     !acutal number of nearest neighbors for side points
 INTEGER, DIMENSION(:,:), ALLOCATABLE                      :: side,       & !'side boundary' ghost points
                                                              side_neigh_i  !(i,j,k) index of side neighbors
 REAL, DIMENSION(:,:), ALLOCATABLE                         :: side_img,   & !(x,y,z) location of ghost point
                                                              side_bound, & !(x,y,z) location of the boundary for side points
                                                              side_neigh, & !(x,y,z) location of side neighbors
                                                              side_norm,  &
                                                              side_dist
 INTEGER :: S, nC !DJW for debugging, remove later
 LOGICAL                                                   :: in_vel_recon !RSA for now, only use recon pts as nearest neighbors from vel_recon routines

!---------------------------------------------------------------------------------
 !the executable begins here
 CALL wrf_debug(100,'dyn_em/module_ibm.F/subroutine vel_recon_ibm_eddy_part2')
!---------------------------------------------------------------------------------

 CALL count_side_pts( stag, top, ns,                         &
                      ids, ide, jds, jde, kds, kde,          &
                      ims, ime, jms, jme, kms, kme,          &
                      its, ite, jts, jte, kts, kte )

 !allocate and store side reconstruction points
 ALLOCATE (side(3,ns))
 ALLOCATE (side_img(6,ns))
 ALLOCATE (side_bound(3,ns))
 ALLOCATE (side_neigh(0:3*n-1,ns))
 ALLOCATE (side_neigh_i(0:3*n-1,ns))
 ALLOCATE (side_norm(3,ns))
 ALLOCATE (side_dist(2,ns))
 ALLOCATE (anst_at_s(ns))
 IF (ns .GT. 0) THEN
    CALL reconstruct_pts_side( stag, top, side, ns,          &
                               ids, ide, jds, jde, kds, kde, &
                               ims, ime, jms, jme, kms, kme, &
                               its, ite, jts, jte, kts, kte )
 ENDIF
 !finsihed finding the side reconstruction points

 !find the interpolation points by projecting the reconstruction points across
 !the immersed boundary. The IPs are set to be on the face of the cell that is
 !cut by the IB. There is no guarantee that the IPs will be well conditioned.
 CALL interpolation_pts( stag,                               &
                         config_flags%dx, config_flags%dy,   &
                         ht,                                 &
                         ibm_ht_u, ibm_ht_v,                 &
                         ibm_ht_w, ibm_ht_c,                 &
                         inside, top, side,                  &
                         top_img, top_bound,                 &
                         side_img, side_bound,               &
                         ns, top_norm, side_norm,            &
                         top_dist, side_dist,                &
                         config_flags%ibm_nn_horz,           &
                         config_flags%ibm_nn_vert,           &
                         ids, ide, jds, jde, kds, kde,       &
                         ims, ime, jms, jme, kms, kme,       &
                         its, ite, jts, jte, kts, kte )

 !find the nearest neighbors to the IPs. Search through a 4x4x4 box of points
 !centered about each IP and rank each point based upon distance from the IP.
 in_vel_recon = .true. !RSA for now, only use recon pts as nearest neighbors from vel_recon routines
 CALL neighbors_fs_temp( config_flags%ibm_opt,               &
                         3,                                  & !RSA this is ibm_temp flag, set to 3 here so that the boundary IS included as a nearest neighbor
                         config_flags%ibm_nn_horz,           &
                         config_flags%ibm_nn_vert,           &
                         config_flags%dx, config_flags%dy,   &
                         ibm_ht_u, ibm_ht_v,                 &
                         ibm_ht_w, ibm_ht_c,                 &
                         ht, inside,                         &
                         inside_all,                         & !RSA for using reconstruction pts as nearest neighbors
                         config_flags%recon_pts_as_neigh,    & !RSA for using reconstruction pts as nearest neighbors
                         in_vel_recon,                       & !RSA for using reconstruction pts as nearest neighbors
                         side,                               &
                         top_img, side_img,                  &
                         top_bound, side_bound,              &
                         top_neigh, top_neigh_i,             &
                         side_neigh, side_neigh_i,           &
                         n, ns,                              &
                         antt_at_s, anst_at_s,               &
                         ids, ide, jds, jde, kds, kde,       &
                         ims, ime, jms, jme, kms, kme,       &
                         its, ite, jts, jte, kts, kte )

 !if this is the first time through this subroutine, then write information
 !about the RPs, IPs, and nearest neighbors to text files that can be found in
 !the run directory.
 IF ((start .EQ. 1) .AND. (config_flags%write_ibm_data)) THEN
    write(*,'(A,A)') "DJW[module_ibm/vel_recon_ibm_eddy_part2]: calling write_ibm_data for stag=",stag
    CALL write_ibm_data( stag, side,                         &
                         top_img, side_img,                  &
                         top_bound, side_bound,              &
                         top_neigh, side_neigh,              &
                         n, ns,                              &
                         ids, ide, jds, jde, kds, kde,       &
                         ims, ime, jms, jme, kms, kme,       &
                         its, ite, jts, jte, kts, kte )
    write(*,'(A,A)') "DJW[module_ibm/vel_recon_ibm_eddy_part2]: calling write_ht_data for stag=",stag
    CALL write_ht_data( stag, ht,                            &
                        ids, ide, jds, jde, kds, kde,        &
                        ims, ime, jms, jme, kms, kme,        &
                        its, ite, jts, jte, kts, kte )
 ENDIF

 CALL vel_recon_inverse_dist_eddy( xkmh, xkmv, xkhh, xkhv,       & 
                                   top, side,                    &
                                   top_neigh(:,:,6*n:9*n-1),     &
                                   side_neigh,                   &
                                   top_neigh_i(:,:,6*n:9*n-1),   &
                                   side_neigh_i,                 &
                                   n, ns,                        &
                                   top_norm, top_dist,           &
                                   side_norm, side_dist,         &
                                   antt_at_s, anst_at_s,         &
                                   msftx, msfty, rdzw,           & !DJW 190930
                                   dx, dy, dt,                   & !DJW 190930
                                   mix_upper_bound,              & !DJW 190930
                                   ids, ide, jds, jde, kds, kde, &
                                   ims, ime, jms, jme, kms, kme, &
                                   its, ite, jts, jte, kts, kte ) 

 DEALLOCATE (side)
 DEALLOCATE (side_img)
 DEALLOCATE (side_bound)
 DEALLOCATE (side_neigh)
 DEALLOCATE (side_neigh_i)
 DEALLOCATE (side_norm)
 DEALLOCATE (side_dist)
 DEALLOCATE (anst_at_s)

 END SUBROUTINE vel_recon_ibm_eddy_part2

!--------------------------------------------------------------------------------------------------------

 SUBROUTINE vel_recon_ibm_scalar( config_flags, start, ht,      &
                                  top, prox, inside,            &
                                  inside_all,                   &
                                  t,                            &
                                  num_moist, moist,             &
                                  num_scalar, scalar,           &
                                  rho, xkhh, xkhv, qfx,         &
                                  ibm_ht_u, ibm_ht_v,           &
                                  ibm_ht_w, ibm_ht_c,           &
                                  n, ibm_opt,                   &
                                  ids, ide, jds, jde, kds, kde, &
                                  ims, ime, jms, jme, kms, kme, &
                                  its, ite, jts, jte, kts, kte )
 IMPLICIT NONE
 !input data
 TYPE(grid_config_rec_type), INTENT(IN   )                          :: config_flags
 REAL, DIMENSION(ims:ime,kms:kme,jms:jme), INTENT(IN   )            :: ht,          &
                                                                       rho,         &
                                                                       xkhh,        &
                                                                       xkhv
 INTEGER, DIMENSION(ims:ime,jms:jme), INTENT(IN   )                 :: top,         &
                                                                       prox           !'top boundary' ghost points
 INTEGER, DIMENSION(ims:ime,kms:kme,jms:jme), INTENT(IN   )         :: inside         !1 if the pt is inside boundary, 0 if it is outside
 INTEGER, DIMENSION(ims:ime,kms:kme,jms:jme), INTENT(IN   )         :: inside_all     !RSA inside includes recon pts, inside_all does not
 REAL, DIMENSION(ims:ime,kms:kme,jms:jme), INTENT(INOUT)            :: t
 REAL, DIMENSION(ims:ime,kms:kme,jms:jme,num_moist), INTENT(INOUT)  :: moist
 REAL, DIMENSION(ims:ime,kms:kme,jms:jme,num_scalar), INTENT(INOUT) :: scalar
 REAL, DIMENSION(ims:ime,jms:jme), INTENT(IN   )                    :: qfx,         &
                                                                       ibm_ht_u,    &
                                                                       ibm_ht_v,    &
                                                                       ibm_ht_w,    &
                                                                       ibm_ht_c
 INTEGER, INTENT(IN   )                                             :: start,       &
                                                                       num_moist,   &
                                                                       num_scalar,  &
                                                                       n,           &
                                                                       ibm_opt,     &
                                                                       ids, ide, jds, jde, kds, kde, &
                                                                       ims, ime, jms, jme, kms, kme, &
                                                                       its, ite, jts, jte, kts, kte
 !local data
 INTEGER                                                            :: ns,          &
                                                                       is,          &
                                                                       i, j
 INTEGER, DIMENSION(:), ALLOCATABLE                                 :: anst_at_s      !acutal number of nearest neighbors for side points
 INTEGER, DIMENSION(:,:), ALLOCATABLE                               :: side,        & !'side boundary' ghost points
                                                                       side_neigh_i   !(i,j,k) index of side neighbors
 REAL, DIMENSION(:,:), ALLOCATABLE                                  :: side_img,    & !(x,y,z) location of ghost point
                                                                       side_bound,  & !(x,y,z) location of the boundary for side points
                                                                       side_neigh,  & !(x,y,z) location of side neighbors
                                                                       side_norm,   &
                                                                       side_dist

 REAL                                                    :: cpm
 INTEGER, DIMENSION(ims:ime,jms:jme)                     :: antt_at_s     !actual number of nearest neighbors for top points
 REAL, DIMENSION(ims:ime,jms:jme)                        :: grad
 REAL, DIMENSION(ims:ime,jms:jme,2)                      :: top_dist
 REAL, DIMENSION(ims:ime,jms:jme,6)                      :: top_img       !(x,y,z) location of ghost point and image point of the 'top boundary' ghost points
 REAL, DIMENSION(ims:ime,jms:jme,3)                      :: top_bound,  & !keep the (x,y,z) location of the boundary points for the no-slip bc
                                                            top_norm
 REAL, DIMENSION(ims:ime,jms:jme,0:3*n-1)                :: top_neigh     !(x,y,z) location of top neighbors
 INTEGER, DIMENSION(ims:ime,jms:jme,0:3*n-1)             :: top_neigh_i   !(i,j,k) index of top neighbors
 LOGICAL                                                 :: in_vel_recon !RSA for now, only use recon pts as nearest neighbors from vel_recon routines

!---------------------------------------------------------------------------------
 CALL wrf_debug(100, 'dyn_em/module_ibm.F/subroutine vel_recon_ibm_scalar')
!---------------------------------------------------------------------------------

 !initialize the scalar fluxes at the surface
 grad = 0.0

 CALL count_side_pts( 't', top, ns,                 &
                      ids, ide, jds, jde, kds, kde, &
                      ims, ime, jms, jme, kms, kme, &
                      its, ite, jts, jte, kts, kte )

 !allocate and store side reconstruction points
 ALLOCATE (side(3,ns))
 ALLOCATE (side_img(6,ns))
 ALLOCATE (side_bound(3,ns))
 ALLOCATE (side_neigh(0:3*n-1,ns))
 ALLOCATE (side_neigh_i(0:3*n-1,ns))
 ALLOCATE (side_norm(3,ns))
 ALLOCATE (side_dist(2,ns))
 ALLOCATE (anst_at_s(ns))
 IF (ns .GT. 0) THEN
    CALL reconstruct_pts_side( 't', top, side, ns,           &
                               ids, ide, jds, jde, kds, kde, &
                               ims, ime, jms, jme, kms, kme, &
                               its, ite, jts, jte, kts, kte )
 ENDIF
 !finsihed finding the side reconstruction points

 !find the interpolation points by projecting the reconstruction points across
 !the immersed boundary. The IPs are set to be on the face of the cell that is
 !cut by the IB. There is no guarantee that the IPs will be well conditioned.
 CALL interpolation_pts( 't',                                &
                         config_flags%dx, config_flags%dy,   &
                         ht,                                 &
                         ibm_ht_u, ibm_ht_v,                 &
                         ibm_ht_w, ibm_ht_c,                 &
                         inside, top, side,                  &
                         top_img, top_bound,                 &
                         side_img, side_bound,               &
                         ns, top_norm, side_norm,            &
                         top_dist, side_dist,                &
                         config_flags%ibm_nn_horz,           &
                         config_flags%ibm_nn_vert,           &
                         ids, ide, jds, jde, kds, kde,       &
                         ims, ime, jms, jme, kms, kme,       &
                         its, ite, jts, jte, kts, kte )

 !find the nearest neighbors to the IPs. Search through a 4x4x4 box of points
 !centered about each IP and rank each point based upon distance from the IP.
  in_vel_recon = .true. !RSA for now, only use recon pts as nearest neighbors from vel_recon routines
  CALL get_top_pts_idw_3d( ibm_opt,                              &
                           3, 3, 1,                              &
                           config_flags%ibm_nn_horz,             &
                           config_flags%ibm_nn_vert,             &
                           config_flags%dx, config_flags%dy,     &
                           ht, inside,                           &
                           inside_all,                           & !RSA for using reconstruction pts as nearest neighbors
                           config_flags%recon_pts_as_neigh,      & !RSA for using reconstruction pts as nearest neighbors
                           in_vel_recon,                         & !RSA for using reconstruction pts as nearest neighbors
                           top_img, top_bound,                   &
                           top_neigh(ims:ime,jms:jme,0:3*n-1),   &
                           top_neigh_i(ims:ime,jms:jme,0:3*n-1), &
                           n, antt_at_s,                         &
                           ids, ide, jds, jde, kds, kde,         &
                           ims, ime, jms, jme, kms, kme,         &
                           its, ite, jts, jte, kts, kte )
 IF (ns > 0) THEN
    !get side points for a neumann BC (omits the boundary point)
    CALL get_side_pts_idw_3d( 3, 2,                                &
                              config_flags%ibm_nn_horz,            &
                              config_flags%ibm_nn_vert,            &
                              config_flags%dx, config_flags%dy,    &
                              ht, inside,                          &
                              inside_all,                          & !RSA for using reconstruction pts as nearest neighbors
                              config_flags%recon_pts_as_neigh,     & !RSA for using reconstruction pts as nearest neighbors
                              in_vel_recon,                        & !RSA for using reconstruction pts as nearest neighbors
                              side, side_img, side_bound,          &
                              side_neigh,                          &
                              side_neigh_i,                        &
                              n, ns, anst_at_s,                    &
                              ids, ide, jds, jde, kds, kde,        &
                              ims, ime, jms, jme, kms, kme,        &
                              its, ite, jts, jte, kts, kte )
 ENDIF

 IF ( (start .EQ. 1) .AND. (config_flags%ibm_temp .NE. 0) ) THEN
    DO j=jts,MIN(jte,jde-1)
    DO i=its,MIN(ite,ide-1)
       grad(i,j) = 0.0
    ENDDO
    ENDDO
    CALL vel_recon_inverse_dist_scalar( t,                                 &
                                        grad,                              &
                                        top, side,                         &
                                        top_neigh, side_neigh,             &
                                        top_neigh_i, side_neigh_i,         &
                                        n, ns,                             &
                                        top_norm, top_dist,                &
                                        side_norm, side_dist,              &
                                        antt_at_s, anst_at_s,              &
                                        ids, ide, jds, jde, kds, kde,      &
                                        ims, ime, jms, jme, kms, kme,      &
                                        its, ite, jts, jte, kts, kte )
 ENDIF

! IF (num_moist .GE. PARAM_FIRST_SCALAR) THEN
!    IF ((config_flags%sf_surface_physics .NE. 0) .AND. (start .EQ. 0)) THEN
!       DO j=jts,MIN(jte,jde-1)
!       DO i=its,MIN(ite,ide-1)
!          grad(i,j) = -qfx(i,j)/rho(i,top(i,j),j)/(1.0+moist(i,top(i,j),j,P_QV))/xkhv(i,top(i,j),j)
!       ENDDO
!       ENDDO
!    ELSE
!       DO j=jts,MIN(jte,jde-1)
!       DO i=its,MIN(ite,ide-1)
!          grad(i,j) = 0.0
!       ENDDO
!       ENDDO
!    ENDIF
!    DO is=PARAM_FIRST_SCALAR,num_moist
!       CALL vel_recon_inverse_dist_scalar( moist(ims:ime,kms:kme,jms:jme,is), &
!                                           grad,                              &
!                                           top, side,                         &
!                                           top_neigh, side_neigh,             &
!                                           top_neigh_i, side_neigh_i,         &
!                                           n, ns,                             &
!                                           top_norm, top_dist,                &
!                                           side_norm, side_dist,              &
!                                           antt_at_s, anst_at_s,              &
!                                           ids, ide, jds, jde, kds, kde,      &
!                                           ims, ime, jms, jme, kms, kme,      &
!                                           its, ite, jts, jte, kts, kte )
!    ENDDO
! ENDIF

 IF ( (num_scalar .GE. PARAM_FIRST_SCALAR) .AND. &
      (config_flags%ibm_scalar .NE. 0) )THEN
    DO j=jts,MIN(jte,jde-1)
    DO i=its,MIN(ite,ide-1)
       grad(i,j) = 0.0
    ENDDO
    ENDDO
    DO is=PARAM_FIRST_SCALAR,num_scalar
       CALL vel_recon_inverse_dist_scalar( scalar(ims:ime,kms:kme,jms:jme,is), &
                                           grad,                               &
                                           top, side,                          &
                                           top_neigh, side_neigh,              &
                                           top_neigh_i, side_neigh_i,          &
                                           n, ns,                              &
                                           top_norm, top_dist,                 &
                                           side_norm, side_dist,               &
                                           antt_at_s, anst_at_s,               &
                                           ids, ide, jds, jde, kds, kde,       &
                                           ims, ime, jms, jme, kms, kme,       &
                                           its, ite, jts, jte, kts, kte )
    ENDDO
 ENDIF

 IF (ALLOCATED(side))         DEALLOCATE (side)
 IF (ALLOCATED(side_img))     DEALLOCATE (side_img)
 IF (ALLOCATED(side_bound))   DEALLOCATE (side_bound)
 IF (ALLOCATED(side_neigh))   DEALLOCATE (side_neigh)
 IF (ALLOCATED(side_neigh_i)) DEALLOCATE (side_neigh_i)
 IF (ALLOCATED(side_norm))    DEALLOCATE (side_norm)
 IF (ALLOCATED(side_dist))    DEALLOCATE (side_dist)
 IF (ALLOCATED(anst_at_s))    DEALLOCATE (anst_at_s)

 END SUBROUTINE vel_recon_ibm_scalar

!--------------------------------------------------------------------------------------------------------

 SUBROUTINE vel_recon_inverse_dist_scalar( var,                          &
                                           grad,                         &
                                           top, side,                    &
                                           top_neigh, side_neigh,        &
                                           top_neigh_i, side_neigh_i,    &
                                           n, np,                        &
                                           top_norm, top_dist,           &
                                           side_norm, side_dist,         &
                                           antt_at_s, anst_at_s,         &
                                           ids, ide, jds, jde, kds, kde, &
                                           ims, ime, jms, jme, kms, kme, &
                                           its, ite, jts, jte, kts, kte )
 IMPLICIT NONE
 !input data
 REAL, DIMENSION(ims:ime,kms:kme,jms:jme), INTENT(INOUT)     :: var
 REAL, DIMENSION(ims:ime,jms:jme), INTENT(IN   )             :: grad
 INTEGER, DIMENSION(ims:ime,jms:jme), INTENT(IN   )          :: top,        &
                                                                antt_at_s     !actual number of nearest neighbors for top points
 INTEGER, DIMENSION(3,np), INTENT(IN   )                     :: side          !'side boundary' ghost points
 REAL, DIMENSION(ims:ime,jms:jme,0:3*n-1), INTENT(IN   )     :: top_neigh     !(x,y,z) location of  neighbors
 REAL, DIMENSION(0:3*n-1,np), INTENT(IN   )                  :: side_neigh    !(x,y,z) location of neighbors
 INTEGER, DIMENSION(ims:ime,jms:jme,0:3*n-1), INTENT(IN   )  :: top_neigh_i   !(i,j,k) index of top neighbors
 INTEGER, DIMENSION(0:3*n-1,np), INTENT(IN   )               :: side_neigh_i  !(i,j,k) location of neighbors
 INTEGER, INTENT(IN   )                                      :: n,          & !desired number of nearest neighbors
                                                                np            !number of side ghost points
 REAL, DIMENSION(ims:ime,jms:jme,3), INTENT(IN   )           :: top_norm      !surface normal vector
 REAL, DIMENSION(ims:ime,jms:jme,2), INTENT(IN   )           :: top_dist      !distance of reconstruction and interpolation points from boundary
 REAL, DIMENSION(3,np), INTENT(IN   )                        :: side_norm     !surface normal vector
 REAL, DIMENSION(2,np), INTENT(IN   )                        :: side_dist     !distance from surface normal to reconstruction and interpolation point
 INTEGER, DIMENSION(np), INTENT(IN   )                       :: anst_at_s     !actual number of nearest neighbors for side points
 INTEGER, INTENT(IN   )                    :: ids, ide, jds, jde, kds, kde, & !d: domain
                                              ims, ime, jms, jme, kms, kme, & !m: memory
                                              its, ite, jts, jte, kts, kte    !p: patch, t: tile
 !local data
 INTEGER                                                     :: i, j,        &
                                                                nC, S,       &
                                                                i_end,       &
                                                                j_end
 DOUBLE PRECISION                                            :: max_rad,     &
                                                                var_ip
 DOUBLE PRECISION, DIMENSION(0:n-1)                          :: weight, radius

!---------------------------------------------------------------------------------
 !the executable begins here
 CALL wrf_debug(100, 'dyn_em/module_ibm.F/subroutine vel_recon_inverse_dist_scalar')
!---------------------------------------------------------------------------------

 i_end = MIN(ite,ide-1)
 j_end = MIN(jte,jde-1)
 DO i=its,i_end
 DO j=jts,j_end
    radius = 0.0
    DO nC=0,antt_at_s(i,j)-1
       radius(nC) = SQRT(top_neigh(i,j,3*nC)**2+top_neigh(i,j,3*nC+1)**2+top_neigh(i,j,3*nC+2)**2)
       IF (radius(nC) .EQ. 0.0) radius(nC) = epsilon
    ENDDO
    max_rad = MAXVAL(radius)
    weight = 0.0
    var_ip = 0.0
    DO nC=0,antt_at_s(i,j)-1
       weight(nC) = ((max_rad-radius(nC))/(max_rad*radius(nC)))**(0.5)
       var_ip = var_ip+weight(nC)*var(top_neigh_i(i,j,3*nC),top_neigh_i(i,j,3*nC+2),top_neigh_i(i,j,3*nC+1))
    ENDDO
    var_ip = var_ip/SUM(weight)
    var(i,top(i,j),j) = var_ip-(top_dist(i,j,2)-top_dist(i,j,1))*grad(i,j)
 ENDDO
 ENDDO

 !loop over each side point
 IF (np .GT. 0) THEN
    DO S=1,np
       radius = 0.0
       DO nC=0,anst_at_s(S)-1
          radius(nC) = SQRT(side_neigh(3*nC,S)**2+side_neigh(3*nC+1,S)**2+side_neigh(3*nC+2,S)**2)
          IF (radius(nC) .EQ. 0.0) radius(nC) = epsilon
       ENDDO
       max_rad = MAXVAL(radius)
       weight = 0.0
       var_ip = 0.0
       DO nC=0,anst_at_s(S)-1
          weight(nC) = ((max_rad-radius(nC))/(max_rad*radius(nC)))**(0.5)
          var_ip = var_ip+weight(nC)*var(side_neigh_i(3*nC,S),side_neigh_i(3*nC+2,S),side_neigh_i(3*nC+1,S))
       ENDDO
       var_ip = var_ip/SUM(weight)
       var(side(1,S),side(3,S),side(2,S)) = var_ip-(side_dist(2,S)-side_dist(1,S))*grad(side(1,S),side(2,S))
    ENDDO
 ENDIF

 END SUBROUTINE vel_recon_inverse_dist_scalar

!--------------------------------------------------------------------------------------------------------

 SUBROUTINE vel_recon_ibm_part2( config_flags, stag, start,                &
                                 u, v, w,                                  &
                                 u_in, v_in, w_in,                         &
                                 ht_u, ht_v, ht_w,                         &
                                 inside_u, inside_v, inside_w,             &
                                 inside_all_u, inside_all_v, inside_all_w, &
                                 varsave, var, top,                        &
                                 mu, mus,                                  &
                                 ibm_ht_u, ibm_ht_v,                       &
                                 ibm_ht_w, ibm_ht_c,                       &
                                 z0_phys,                                  &
                                 n,                                        &
                                 ids, ide, jds, jde, kds, kde,             &
                                 ims, ime, jms, jme, kms, kme,             &
                                 its, ite, jts, jte, kts, kte )
 IMPLICIT NONE
 !input data
 TYPE(grid_config_rec_type), INTENT(IN   )               :: config_flags
 CHARACTER, INTENT(IN   )                                :: stag
 INTEGER, INTENT(IN   )                                  :: start
 INTEGER, DIMENSION(ims:ime,jms:jme), INTENT(IN   )      :: top             !'top boundary' ghost points
 INTEGER, DIMENSION(ims:ime,kms:kme,jms:jme), INTENT(IN) :: inside_u,    &  !1 if the pt is inside boundary, 0 if it is outside
                                                            inside_v,    &
                                                            inside_w
 INTEGER, DIMENSION(ims:ime,kms:kme,jms:jme), INTENT(IN) :: inside_all_u, & !RSA inside includes recon pts, inside_all does not
                                                            inside_all_v, &
                                                            inside_all_w
 REAL, DIMENSION(ims:ime,kms:kme,jms:jme), INTENT(IN   ) :: ht_u,        &
                                                            ht_v,        &
                                                            ht_w,        &
                                                            varsave
 REAL, DIMENSION(ims:ime,kms:kme,jms:jme), INTENT(INOUT) :: u, v,  w
 REAL, DIMENSION(ims:ime,kms:kme,jms:jme), INTENT(IN   ) :: u_in,        &
                                                            v_in,        &
                                                            w_in           !RSA copies of u, v, w before update begins. 
                                                                           !Enables reconstruction pts to be used as nearest neighbors
 REAL, DIMENSION(ims:ime,kms:kme,jms:jme), INTENT(INOUT) :: var
 REAL, DIMENSION(ims:ime,jms:jme), INTENT(IN   )         :: mu,          &
                                                            mus,         &
                                                            ibm_ht_u,    &
                                                            ibm_ht_v,    &
                                                            ibm_ht_w,    &
                                                            ibm_ht_c
 INTEGER, INTENT(IN   )                                  :: n               !desired number of nearest neighbors
 REAL, DIMENSION(ims:ime,jms:jme), INTENT(IN   )         :: z0_phys !RSA z0 from land surface data
 INTEGER, INTENT(IN   )                                  :: ids, ide, jds, jde, kds, kde, & !d: domain 
                                                            ims, ime, jms, jme, kms, kme, & !m: memory
                                                            its, ite, jts, jte, kts, kte    !p: patch, t: tile
 !local data
 INTEGER                                                 :: j !KAL for debugging, can remove
 INTEGER                                                 :: ns              !number of 'side boundary' ghost points
 INTEGER, DIMENSION(ims:ime,jms:jme)                     :: antu_at_p,   &  !actual number of nearest neighbors for top points
                                                            antv_at_p,   &
                                                            antw_at_p
 REAL, DIMENSION(ims:ime,jms:jme,2)                      :: top_dist
 REAL, DIMENSION(ims:ime,jms:jme,6)                      :: top_img         !(x,y,z) location of ghost point and image point of the 'top boundary' ghost points
 REAL, DIMENSION(ims:ime,jms:jme,3)                      :: top_bound,   &  !keep the (x,y,z) location of the boundary points for the no-slip bc
                                                            top_norm
 REAL, DIMENSION(ims:ime,jms:jme,0:9*n-1)                :: top_neigh       !(x,y,z) location of top neighbors
 INTEGER, DIMENSION(ims:ime,jms:jme,0:9*n-1)             :: top_neigh_i     !(i,j,k) index of top neighbors							    
 REAL, DIMENSION(ims:ime,kms:kme,jms:jme)                :: ht_p
 INTEGER, DIMENSION(:), ALLOCATABLE                      :: ansu_at_p,   &  !acutal number of nearest neighbors for side points
                                                            ansv_at_p,   &
                                                            answ_at_p
 INTEGER, DIMENSION(:,:), ALLOCATABLE                    :: side            !'side boundary' ghost points
 REAL, DIMENSION(:,:), ALLOCATABLE                       :: side_img,    &  !(x,y,z) location of ghost point
                                                            side_bound,  &  !(x,y,z) location of the boundary for side points
                                                            side_neigh,  &  !(x,y,z) location of side neighbors
                                                            side_norm,   &
                                                            side_dist
 INTEGER, DIMENSION(:,:), ALLOCATABLE                    :: side_neigh_i    !(i,j,k) index of side neighbors
 INTEGER, DIMENSION(ims:ime,kms:kme,jms:jme)             :: inside          !one if the pt is inside boundary, zero if it is outside
 INTEGER                                                 :: i !DJW for debugging
 LOGICAL                                                 :: in_vel_recon !RSA for now, only use recon pts as nearest neighbors from vel_recon routines
! KAL added these to play around with timing
!      integer rsl_internal_microclock
!      external rsl_internal_microclock
!      REAL :: time_test
!KAL
!---------------------------------------------------------------------------------
 !the executable begins here
 CALL wrf_debug(100,'dyn_em/module_ibm.F/subroutine vel_recon_ibm_part2')
!---------------------------------------------------------------------------------
 IF (stag == 'u') THEN
    ht_p = ht_u
    inside = inside_u
 ELSEIF (stag == 'v') THEN
    ht_p = ht_v
    inside = inside_v
 ELSEIF (stag == 'w') THEN
    ht_p = ht_w
    inside = inside_w
 ENDIF

 CALL count_side_pts ( stag, top, ns,                           &
                       ids, ide, jds, jde, kds, kde,            &
                       ims, ime, jms, jme, kms, kme,            &
                       its, ite, jts, jte, kts, kte )

 !allocate and store side ghost points
 ALLOCATE (side(3,ns))
 ALLOCATE (side_img(6,ns))
 ALLOCATE (side_bound(3,ns))
 ALLOCATE (side_neigh(0:9*n-1,ns))
 ALLOCATE (side_neigh_i(0:9*n-1,ns))
 ALLOCATE (side_norm(3,ns))
 ALLOCATE (side_dist(2,ns))
 ALLOCATE (ansu_at_p(ns))
 ALLOCATE (ansv_at_p(ns))
 ALLOCATE (answ_at_p(ns))

 IF (ns .GT. 0) THEN
    CALL reconstruct_pts_side ( stag, top, side, ns,                &
                                ids, ide, jds, jde, kds, kde,       &
                                ims, ime, jms, jme, kms, kme,       &
                                its, ite, jts, jte, kts, kte )
 ENDIF !end of get side points

 CALL interpolation_pts ( stag,                                       &
                          config_flags%dx, config_flags%dy,           &
                          ht_p,                                       &
                          ibm_ht_u, ibm_ht_v,                         &
                          ibm_ht_w, ibm_ht_c,                         &
                          inside, top, side,                          &
                          top_img, top_bound,                         &
                          side_img, side_bound,                       &
                          ns, top_norm, side_norm,                    &
                          top_dist, side_dist,                        &
                          config_flags%ibm_nn_horz,                   &
                          config_flags%ibm_nn_vert,                   &
                          ids, ide, jds, jde, kds, kde,               &
                          ims, ime, jms, jme, kms, kme,               &
                          its, ite, jts, jte, kts, kte )

 in_vel_recon = .true. !RSA for now, only use recon pts as nearest neighbors from vel_recon routines
 CALL neighbors_fs( config_flags%ibm_opt,                     &
                    config_flags%interp_opt,                  &
                    config_flags%dim_terrain, stag, 1,        &
                    config_flags%ibm_nn_horz,                 &
                    config_flags%ibm_nn_vert,                 &
                    config_flags%dx, config_flags%dy,         &
                    ibm_ht_u, ibm_ht_v,                       &
                    ibm_ht_w, ibm_ht_c,                       &
                    ht_u, ht_v, ht_w,                         &
                    inside_u, inside_v, inside_w,             &
                    inside_all_u, inside_all_v, inside_all_w, & !RSA for using reconstruction pts as nearest neighbors
                    config_flags%recon_pts_as_neigh,          & !RSA for using reconstruction pts as nearest neighbors
                    in_vel_recon,                             & !RSA for using reconstruction pts as nearest neighbors
                    side,                                     &
                    top_img, side_img,                        &
                    top_bound, side_bound,                    &
                    top_neigh, top_neigh_i,                   &
                    side_neigh, side_neigh_i,                 &
                    n, ns,                                    &
                    antu_at_p, antv_at_p, antw_at_p,          &
                    ansu_at_p, ansv_at_p, answ_at_p,          &
                    ids, ide, jds, jde, kds, kde,             &
                    ims, ime, jms, jme, kms, kme,             &
                    its, ite, jts, jte, kts, kte )

 IF ((start .EQ. 1) .AND. (config_flags%write_ibm_data)) THEN
    write(*,'(A,A)') "DJW[module_ibm/vel_recon_ibm_part2]: calling write_ibm_data for stag=",stag
    CALL write_ibm_data ( stag, side,                   &
                          top_img, side_img,            &
                          top_bound, side_bound,        &
                          top_neigh, side_neigh,        &
                          n, ns,                        &
                          ids, ide, jds, jde, kds, kde, &
                          ims, ime, jms, jme, kms, kme, &
                          its, ite, jts, jte, kts, kte )
    CALL write_ht_data ( stag, ht_p,                   &
                         ids, ide, jds, jde, kds, kde, &
                         ims, ime, jms, jme, kms, kme, &
                         its, ite, jts, jte, kts, kte )
 ENDIF

 CALL vel_recon_inverse_dist_ss ( config_flags%z_rough,               &
                                  z0_phys,                            & !RSA to use realistic z0 values based on land surface data
                                  config_flags%ideal_terrain,         & !RSA to use realistic z0 values based on land surface data
                                  stag, u, v, w,                      &
                                  u_in, v_in, w_in,                   & !RSA for using reconstruction pts as nearest neighbors
                                  var, varsave,                       &
                                  mu, mus,                            &
                                  top, side,                          &
                                  top_neigh, side_neigh,              &
                                  top_neigh_i, side_neigh_i,          &
                                  n, ns,                              &
                                  config_flags%vrm_bound_pt_as_neigh, &
                                  config_flags%zero_within_z_rough,   &
                                  top_norm, top_dist,                 &
                                  side_norm, side_dist,               &
                                  antu_at_p, antv_at_p, antw_at_p,    &
                                  ansu_at_p, ansv_at_p, answ_at_p,    &
                                  ids, ide, jds, jde, kds, kde,       &
                                  ims, ime, jms, jme, kms, kme,       &
                                  its, ite, jts, jte, kts, kte ) 

 DEALLOCATE (side)
 DEALLOCATE (side_img)
 DEALLOCATE (side_bound)
 DEALLOCATE (side_neigh)
 DEALLOCATE (side_neigh_i)
 DEALLOCATE (side_norm)
 DEALLOCATE (side_dist)
 DEALLOCATE (ansu_at_p)
 DEALLOCATE (ansv_at_p)
 DEALLOCATE (answ_at_p)

 END SUBROUTINE vel_recon_ibm_part2

!--------------------------------------------------------------------------------------------------------

 SUBROUTINE mom_flux_ibm( top_s,                                  & !KAL which viscosity to use
                          config_flags, stag, start,              &
                          u, v, w,                                &
                          ht_u, ht_v, ht_w,                       &
			  inside_u, inside_v, inside_w,           &
			  inside_all_u, inside_all_v, inside_all_w, &
			  varsave, var, top,                      &  
			  prox,                                   &
			  mu, mus,				  &
			  xkmh, xkmv,                             &  
                          ibm_ht_u, ibm_ht_v,			  &  
			  ibm_ht_w, ibm_ht_c,			  &  
			  n,					  &  
			  ids, ide, jds, jde, kds, kde, 	  &  
                          ims, ime, jms, jme, kms, kme, 	  &  
                          its, ite, jts, jte, kts, kte  )	        
 IMPLICIT NONE
 ! input data
 TYPE(grid_config_rec_type), INTENT(IN   )               :: config_flags
 CHARACTER, INTENT(IN   )                                :: stag
 INTEGER , INTENT(IN   )                                 :: start						              
 INTEGER, DIMENSION(ims:ime,jms:jme), INTENT(IN   )  	 :: top_s,       &
                                                            top,         &  !'top boundary' ghost points
                                                            prox
 INTEGER, DIMENSION(ims:ime,kms:kme,jms:jme), INTENT(IN) :: inside_u,    &  ! one if the pt is inside boundary, zero if it is outside
                                                            inside_v,    &
							    inside_w
 INTEGER, DIMENSION(ims:ime,kms:kme,jms:jme), INTENT(IN) :: inside_all_u,    &  !RSA inside includes recon pts, inside all does not
                                                            inside_all_v,    &
							    inside_all_w
 REAL, DIMENSION(ims:ime,kms:kme,jms:jme), INTENT(IN   ) :: ht_u,        &
                                                            ht_v,        &
							    ht_w,        &
							    varsave,     &
							    xkmh,        &
							    xkmv
 REAL, DIMENSION(ims:ime,kms:kme,jms:jme), INTENT(INOUT) :: u, v,  w
 REAL, DIMENSION(ims:ime,kms:kme,jms:jme), INTENT(INOUT) :: var
 REAL, DIMENSION(ims:ime,jms:jme), INTENT(IN   )         :: mu,          &
                                                            mus,         &
                                                            ibm_ht_u,    &
                                                            ibm_ht_v,    &
							    ibm_ht_w,    &
							    ibm_ht_c
 INTEGER, INTENT(IN   )			                 :: n               ! desired number of nearest neighbors							    
 INTEGER, INTENT(IN   )                                  :: ids, ide, jds, jde, kds, kde, &  ! d: domain m:memory p:patch t:tile 
                                                            ims, ime, jms, jme, kms, kme, &
                                                            its, ite, jts, jte, kts, kte   
   
!local data
 INTEGER                                                 :: i,k
 INTEGER                                                 :: ns              ! number of 'side boundary' ghost points
 INTEGER, DIMENSION(ims:ime,jms:jme)                     :: antu_at_p,   &  ! actual number of nearest neighbors for top points
                                                            antv_at_p,   &
							    antw_at_p
 REAL, DIMENSION(ims:ime,jms:jme)                        :: top_dist
 REAL, DIMENSION(ims:ime,jms:jme,6)                      :: top_img         ! (x,y,z) location of ghost point and image point of the 'top boundary' ghost points
 REAL, DIMENSION(ims:ime,jms:jme,3)                      :: top_bound,   &  ! keep the (x,y,z) location of the boundary points for the no-slip bc
                                                            top_norm
 REAL, DIMENSION(ims:ime,jms:jme,0:9*n-1)                :: top_neigh       ! (x,y,z) location of top neighbors
 INTEGER, DIMENSION(ims:ime,jms:jme,0:9*n-1)             :: top_neigh_i     ! (i,j,k) index of top neighbors							    
 REAL, DIMENSION(ims:ime,kms:kme,jms:jme)                :: ht_p
 INTEGER, DIMENSION(:), ALLOCATABLE                      :: ansu_at_p,   &  ! acutal number of nearest neighbors for side points
                                                            ansv_at_p,   &
							    answ_at_p
 INTEGER, DIMENSION(:,:), ALLOCATABLE                    :: side            !'side boundary' ghost points
 REAL, DIMENSION(:,:), ALLOCATABLE                       :: side_img,    &  ! (x,y,z) location of ghost point
							    side_bound,  &  ! (x,y,z) location of the boundary for side points
                                                            side_neigh,  &  ! (x,y,z) location of side neighbors
							    side_norm
 REAL, DIMENSION(:), ALLOCATABLE                         :: side_dist
 INTEGER, DIMENSION(:,:), ALLOCATABLE	                 :: side_neigh_i    ! (i,j,k) index of side neighbors							    
 LOGICAL                                                 :: in_vel_recon !RSA for now, only use recon pts as nearest neighbors from vel_recon routines
! KAL added these to play around with timing
!      integer rsl_internal_microclock
!      external rsl_internal_microclock
!      REAL :: time_test
!KAL
!---------------------------------------------------------------------------------
! the executable begins here
 CALL wrf_debug(100,'dyn_em/module_ibm.F/subroutine mom_flux_ibm')
!---------------------------------------------------------------------------------  

 IF (stag == 'u') THEN
    ht_p = ht_u
 ELSEIF (stag == 'v') THEN
    ht_p = ht_v
 ELSEIF (stag == 'w') THEN
    ht_p = ht_w
 ENDIF

 CALL count_side_pts ( stag, top, ns,                           &
                       ids, ide, jds, jde, kds, kde,            &			 	
                       ims, ime, jms, jme, kms, kme,            &
	               its, ite, jts, jte, kts, kte ) 		    	

 ! allocate and store side ghost points
 ALLOCATE (side(3,ns))
 ALLOCATE (side_img(6,ns))
 ALLOCATE (side_bound(3,ns))
 ALLOCATE (side_neigh(0:9*n-1,ns))
 ALLOCATE (side_neigh_i(0:9*n-1,ns))
 ALLOCATE (side_norm(3,ns))
 ALLOCATE (side_dist(ns))
 ALLOCATE (ansu_at_p(ns))
 ALLOCATE (ansv_at_p(ns))
 ALLOCATE (answ_at_p(ns))

 if (ns > 0) then   
    CALL ghost_pts_side ( stag, top, side, ns,                &
	        	  ids, ide, jds, jde, kds, kde,       &			 	
                	  ims, ime, jms, jme, kms, kme,       &
	        	  its, ite, jts, jte, kts, kte )
 endif ! end of get side points

 CALL image_pts ( stag,config_flags%interp_opt, 2,            &
                  config_flags%dx, config_flags%dy,           &
                  ht_p,                                       &
		  ibm_ht_u, ibm_ht_v,                         &
		  ibm_ht_w, ibm_ht_c,                         &
		  top, side,                                  &
		  top_img, top_bound,                         &
		  side_img, side_bound,                       &
		  prox, ns, top_norm, side_norm,              &
		  top_dist, side_dist,                        &
                  ids, ide, jds, jde, kds, kde,               &			 	
                  ims, ime, jms, jme, kms, kme,               &
 	          its, ite, jts, jte, kts, kte )

 in_vel_recon = .false. !RSA for now, only use recon pts as nearest neighbors from vel_recon routines
 CALL neighbors_fs( config_flags%ibm_opt,                    &
                    config_flags%interp_opt,	             &
 		    config_flags%dim_terrain, stag, 2,       &
                    config_flags%ibm_nn_horz,                &
                    config_flags%ibm_nn_vert,                &
 		    config_flags%dx, config_flags%dy,        &
 		    ibm_ht_u, ibm_ht_v,		             &
 		    ibm_ht_w, ibm_ht_c,		             &
 		    ht_u, ht_v, ht_w,		             &
 		    inside_u, inside_v, inside_w,            &
                    inside_all_u, inside_all_v, inside_all_w, &
                    config_flags%recon_pts_as_neigh,          &
                    in_vel_recon,                             &
 		    side, 			             &
 		    top_img, side_img,	      	             &
 		    top_bound, side_bound,	             &
 		    top_neigh, top_neigh_i,	             &
 		    side_neigh, side_neigh_i,	             &
 		    n, ns,                                   &
		    antu_at_p, antv_at_p, antw_at_p,         &
		    ansu_at_p, ansv_at_p, answ_at_p,         &
 		    ids, ide, jds, jde, kds, kde,            &
 		    ims, ime, jms, jme, kms, kme,            &
 		    its, ite, jts, jte, kts, kte )

 IF ((start == 1) .AND. (config_flags%write_ibm_data)) THEN
     write(*,'(A,A)') "DJW[module_ibm/mom_flux_ibm]: calling write_ibm_data for stag=",stag
     CALL write_ibm_data ( stag, side,                   &
                           top_img, side_img,            &
                           top_bound, side_bound,        &
                           top_neigh, side_neigh,        &
                           n, ns,                        &
                           ids, ide, jds, jde, kds, kde, &
                           ims, ime, jms, jme, kms, kme, &
                           its, ite, jts, jte, kts, kte )
     CALL write_ht_data ( stag, ht_p,                   &
                          ids, ide, jds, jde, kds, kde, &
                          ims, ime, jms, jme, kms, kme, &
                          its, ite, jts, jte, kts, kte )
 ENDIF
 
 ! gradient at the surface is not calculated here, instead it is calculated in mom_flux_inverse_dist_ss
 ! right now the options are programmed for tke_drag_coefficient and z_rough, however, the roughness representation is
 ! not yet coupled to the land surface models (i think through ust)
 
 CALL mom_flux_inverse_dist_ss ( top_s,                                 &
                                 config_flags%ibm_opt,                  &
                                 config_flags%tke_drag_coefficient,     &
                                 config_flags%z_rough,                  &
                                 stag, u, v, w,	                        &
				 var, varsave,  		        &
				 mu, mus,			        &
				 top, side, prox,                       &
				 top_img, top_bound,                    &
				 side_img, side_bound,                  &
				 top_neigh, side_neigh,		        &
				 top_neigh_i, side_neigh_i,	        &
				 n, ns,                                 &
				 top_norm, top_dist,                    &
				 side_norm, side_dist,                  &
				 xkmh, xkmv,                            &
				 antu_at_p, antv_at_p, antw_at_p,       &
				 ansu_at_p, ansv_at_p, answ_at_p,       &
				 ids, ide, jds, jde, kds, kde,	        &
				 ims, ime, jms, jme, kms, kme,	        &
				 its, ite, jts, jte, kts, kte)


! IF (stag == 'u') THEN
! print *, 'after'
! print *, stag
! print *, 'u'
! print intlong, top(ims:ime,30)
! DO i=ims,ime
!  test(i) = xkmv(i,top(i,30)+1,30)
! enddo
! print fplong, test(ims:ime)
! DO k=1,15
!    print fplong, u(ims:ime,k,30)
! enddo
! endif

 DEALLOCATE (side)
 DEALLOCATE (side_img)
 DEALLOCATE (side_bound)
 DEALLOCATE (side_neigh)
 DEALLOCATE (side_neigh_i)
 DEALLOCATE (side_norm)
 DEALLOCATE (side_dist)
 DEALLOCATE (ansu_at_p)
 DEALLOCATE (ansv_at_p)
 DEALLOCATE (answ_at_p)

 END SUBROUTINE mom_flux_ibm

!-------------------------------------------------------------------------------

 SUBROUTINE shear_stress_recon_ibm_init ( config_flags,                           &
                                          ibm_ht_u, ibm_ht_v,                     &
                                          ibm_ht_w, ibm_ht_c,                     &
                                          phb, phsave, ph,                        &
                                          ht_u, ht_v, ht_w,                       &
                                          ht_tauii, ht_tau12,                     & 
                                          ht_tau13, ht_tau23,                     &
                                          top_u, top_v, top_w,                    &
                                          top_tauii, top_tau12,                   &
                                          top_tau13, top_tau23,                   &
                                          inside_u, inside_v, inside_w,           &
                                          inside_tauii, inside_tau12,             &
                                          inside_tau13, inside_tau23,             &
                                          inside_all_tauii, inside_all_tau12,     &
                                          inside_all_tau13, inside_all_tau23,     &
                                          ids, ide, jds, jde, kds, kde,           &
                                          ims, ime, jms, jme, kms, kme,           &
                                          its, ite, jts, jte, kts, kte )
 IMPLICIT NONE
 !input data
 TYPE(grid_config_rec_type),               INTENT(IN   ) :: config_flags
 REAL, DIMENSION(ims:ime,kms:kme,jms:jme), INTENT(IN   ) :: phb,         &
                                                            phsave,      &
                                                            ph
 REAL, DIMENSION(ims:ime,jms:jme), INTENT(IN   )         :: ibm_ht_u,    &
                                                            ibm_ht_v,    &
                                                            ibm_ht_w,    &
                                                            ibm_ht_c
 REAL, DIMENSION(ims:ime,kms:kme,jms:jme), INTENT(  OUT) :: ht_u,            & !this is the total geopotential
                                                            ht_v,            & !at center, u, v, and w points
                                                            ht_w,            &
                                                            ht_tauii,        &
                                                            ht_tau12,        &
                                                            ht_tau13,        & 
                                                            ht_tau23
 INTEGER, DIMENSION(ims:ime,jms:jme), INTENT(  OUT)      :: top_u,           & !'top boundary' ghost points
                                                            top_v,           &
                                                            top_w,           &
                                                            top_tauii,       &
                                                            top_tau12,       &  
                                                            top_tau13,       & 
                                                            top_tau23
 INTEGER, DIMENSION(ims:ime,kms:kme,jms:jme), INTENT(OUT):: inside_u,        & !one if the pt is inside boundary, zero if it is outside
                                                            inside_v,        &
                                                            inside_w,        &
                                                            inside_tauii,    &
                                                            inside_tau12,    &
                                                            inside_tau13,    &
                                                            inside_tau23,    &
                                                            inside_all_tauii,& !RSA inside includes recon points, inside all does not
                                                            inside_all_tau12,&
                                                            inside_all_tau13,&
                                                            inside_all_tau23
 INTEGER, INTENT(IN   )                                  :: ids, ide, jds, jde, kds, kde, & !d: domain
                                                            ims, ime, jms, jme, kms, kme, & !m: memory
                                                            its, ite, jts, jte, kts, kte    !p: patch, t: tile
 !local
 LOGICAL                                                 :: zero_within_z_rough

!---------------------------------------------------------------------------------
 !this subroutine is called from module_first_rk_step_part2.F.  !the executable begins here
 CALL wrf_debug(100,'dyn_em/module_ibm.F/subroutine shear_stress_recon_ibm_init')
!---------------------------------------------------------------------------------  

 CALL calc_ht_small( 'u', phb, phsave, ph, ht_u,       &
                     ids, ide, jds, jde, kds, kde,     &
                     ims, ime, jms, jme, kms, kme,     &
                     its, ite, jts, jte, kts, kte )
 CALL calc_ht_small( 'v', phb, phsave, ph, ht_v,       &
                     ids, ide, jds, jde, kds, kde,     &
                     ims, ime, jms, jme, kms, kme,     &
                     its, ite, jts, jte, kts, kte )
 CALL calc_ht_small( 'w', phb, phsave, ph, ht_w,       &
                     ids, ide, jds, jde, kds, kde,     &
                     ims, ime, jms, jme, kms, kme,     &
                     its, ite, jts, jte, kts, kte )
 CALL calc_ht_small( 't', phb, phsave, ph, ht_tauii,   &
                     ids, ide, jds, jde, kds, kde,     &
                     ims, ime, jms, jme, kms, kme,     &
                     its, ite, jts, jte, kts, kte )
 CALL calc_ht_small( 'd', phb, phsave, ph, ht_tau12,   &
                     ids, ide, jds, jde, kds, kde,     &
                     ims, ime, jms, jme, kms, kme,     &
                     its, ite, jts, jte, kts, kte )
 CALL calc_ht_small( 'e', phb, phsave, ph, ht_tau13,   &
                     ids, ide, jds, jde, kds, kde,     &
                     ims, ime, jms, jme, kms, kme,     &
                     its, ite, jts, jte, kts, kte )
 CALL calc_ht_small( 'f', phb, phsave, ph, ht_tau23,   &
                     ids, ide, jds, jde, kds, kde,     &
                     ims, ime, jms, jme, kms, kme,     &
                     its, ite, jts, jte, kts, kte )

 CALL ghost_pts_top_ss( 'u', ht_u, ibm_ht_u,          &
                        top_u, inside_u,              &
                        ids, ide, jds, jde, kds, kde, &
                        ims, ime, jms, jme, kms, kme, &
                        its, ite, jts, jte, kts, kte )
 CALL ghost_pts_top_ss( 'v', ht_v, ibm_ht_v,          &
                        top_v, inside_v,              &
                        ids, ide, jds, jde, kds, kde, &
                        ims, ime, jms, jme, kms, kme, &
                        its, ite, jts, jte, kts, kte )
 CALL ghost_pts_top_ss( 'w', ht_w, ibm_ht_w,          &
                        top_w, inside_w,              &
                        ids, ide, jds, jde, kds, kde, &
                        ims, ime, jms, jme, kms, kme, &
                        its, ite, jts, jte, kts, kte )

 zero_within_z_rough = .true.
 CALL reconstruct_pts_top( 't', ht_tauii, ibm_ht_w,        &
                            top_tauii, inside_tauii,       &
                            inside_all_tauii,              & !RSA for using recon pts as neighbors
                            config_flags%z_rough,          &
                            zero_within_z_rough,           &
                            config_flags%recon_pt_bump_tol,           & !RSA
                            config_flags%bump_up_recon_pt_within_tol, & !RSA
                            ids, ide, jds, jde, kds, kde,  &
                            ims, ime, jms, jme, kms, kme,  &
                            its, ite, jts, jte, kts, kte )
 CALL reconstruct_pts_top( 'd', ht_tau12, ibm_ht_c,        &
                            top_tau12, inside_tau12,       &
                            inside_all_tau12,              & !RSA for using recon pts as neighbors
                            config_flags%z_rough,          &
                            zero_within_z_rough,           &
                            config_flags%recon_pt_bump_tol,           & !RSA
                            config_flags%bump_up_recon_pt_within_tol, & !RSA
                            ids, ide, jds, jde, kds, kde,  &
                            ims, ime, jms, jme, kms, kme,  &
                            its, ite, jts, jte, kts, kte )
 CALL reconstruct_pts_top( 'e', ht_tau13, ibm_ht_u,        &
                            top_tau13, inside_tau13,       &
                            inside_all_tau13,              & !RSA for using recon pts as neighbors
                            config_flags%z_rough,          &
                            zero_within_z_rough,           &
                            config_flags%recon_pt_bump_tol,           & !RSA
                            config_flags%bump_up_recon_pt_within_tol, & !RSA
                            ids, ide, jds, jde, kds, kde,  &
                            ims, ime, jms, jme, kms, kme,  &
                            its, ite, jts, jte, kts, kte )
 CALL reconstruct_pts_top( 'f', ht_tau23, ibm_ht_v,        &
                            top_tau23, inside_tau23,       &
                            inside_all_tau23,              & !RSA for using recon pts as neighbors
                            config_flags%z_rough,          &
                            zero_within_z_rough,           &
                            config_flags%recon_pt_bump_tol,           & !RSA
                            config_flags%bump_up_recon_pt_within_tol, & !RSA
                            ids, ide, jds, jde, kds, kde,  &
                            ims, ime, jms, jme, kms, kme,  &
                            its, ite, jts, jte, kts, kte )

 END SUBROUTINE shear_stress_recon_ibm_init

!-------------------------------------------------------------------------------

 SUBROUTINE shear_stress_recon_ibm_part1 ( config_flags,                 &
                                           top_tauii, top_tau12,         &
                                           top_tau13, top_tau23,         &
                                           inside_tauii, inside_tau12,   &
                                           inside_tau13, inside_tau23,   &
                                           ids, ide, jds, jde, kds, kde, &
                                           ims, ime, jms, jme, kms, kme, &
                                           its, ite, jts, jte, kts, kte )
 IMPLICIT NONE
 !input data
 TYPE(grid_config_rec_type), INTENT(IN   )                  :: config_flags
 INTEGER, DIMENSION(ims:ime,jms:jme), INTENT(IN   )         :: top_tauii,    & !'top boundary' ghost points
                                                               top_tau12,    &
                                                               top_tau13,    &
                                                               top_tau23
 INTEGER, DIMENSION(ims:ime,kms:kme,jms:jme), INTENT(INOUT) :: inside_tauii, & !one if the pt is inside boundary, zero if it is outside
                                                               inside_tau12, &
                                                               inside_tau13, &
                                                               inside_tau23
 INTEGER, INTENT(IN   )                                      :: ids, ide, jds, jde, kds, kde, & !d: domain 
                                                                ims, ime, jms, jme, kms, kme, & !m: memory
                                                                its, ite, jts, jte, kts, kte    !p: patch, t: tile
 !local data

!---------------------------------------------------------------------------------
 !this subroutine is called from module_first_rk_step_part2.F.  
 !the executable begins here
 CALL wrf_debug(100,'dyn_em/module_ibm.F/subroutine shear_stress_recon_ibm_part1')
!---------------------------------------------------------------------------------  

 CALL label_side_pts_inside ( 't', inside_tauii, top_tauii, &
                              ids, ide, jds, jde, kds, kde, &
                              ims, ime, jms, jme, kms, kme, &
                              its, ite, jts, jte, kts, kte )
 CALL label_side_pts_inside ( 'd', inside_tau12, top_tau12, &
                              ids, ide, jds, jde, kds, kde, &
                              ims, ime, jms, jme, kms, kme, &
                              its, ite, jts, jte, kts, kte )
 CALL label_side_pts_inside ( 'e', inside_tau13, top_tau13, &
                              ids, ide, jds, jde, kds, kde, &
                              ims, ime, jms, jme, kms, kme, &
                              its, ite, jts, jte, kts, kte )
 CALL label_side_pts_inside ( 'f', inside_tau23, top_tau23, &
                              ids, ide, jds, jde, kds, kde, &
                              ims, ime, jms, jme, kms, kme, &
                              its, ite, jts, jte, kts, kte )

 END SUBROUTINE shear_stress_recon_ibm_part1 

!--------------------------------------------------------------------------------------------------------

 SUBROUTINE shear_stress_recon_ibm_part2( config_flags, stag, start,                &
                                          u, v, w,                                  &
                                          xkmv, fnm, fnp,                           &  
                                          defor11, defor22, defor33,                &
                                          defor12, defor13, defor23,                &
                                          ht_u, ht_v, ht_w, ht_tau,                 &
                                          inside_u, inside_v, inside_w,             &
                                          inside_all_u, inside_all_v, inside_all_w, &
                                          inside_tau, top,                          &
                                          ibm_ht_u, ibm_ht_v,                       &
                                          ibm_ht_w, ibm_ht_c,                       &
                                          n,                                        &
                                          ids, ide, jds, jde, kds, kde,             &
                                          ims, ime, jms, jme, kms, kme,             &
                                          its, ite, jts, jte, kts, kte )
 IMPLICIT NONE
 !input data
 TYPE(grid_config_rec_type), INTENT(IN   )               :: config_flags
 CHARACTER, INTENT(IN   )                                :: stag
 INTEGER, INTENT(IN   )                                  :: start
 INTEGER, DIMENSION(ims:ime,jms:jme), INTENT(IN   )      :: top             !'top boundary' ghost points
 INTEGER, DIMENSION(ims:ime,kms:kme,jms:jme), INTENT(IN) :: inside_u,    &  !1 if the pt is inside boundary, 0 if it is outside
                                                            inside_v,    &
                                                            inside_w,    &
                                                            inside_tau,  &
                                                            inside_all_u,& !RSA inside includes recon pts, inside_all does not
                                                            inside_all_v,&
                                                            inside_all_w
 REAL, DIMENSION(ims:ime,kms:kme,jms:jme), INTENT(IN   ) :: ht_u,        &
                                                            ht_v,        &
                                                            ht_w,        &
                                                            ht_tau
 REAL, DIMENSION(ims:ime,kms:kme,jms:jme), INTENT(IN   ) :: u, v,  w,    &
                                                            xkmv
 REAL, DIMENSION( kms:kme ), INTENT( IN )                :: fnm, fnp
 REAL, DIMENSION(ims:ime,kms:kme,jms:jme), INTENT(INOUT) :: defor11,     &
                                                            defor22,     &
                                                            defor33,     &
                                                            defor12,     &
                                                            defor13,     &
                                                            defor23
 REAL, DIMENSION(ims:ime,jms:jme), INTENT(IN   )         :: ibm_ht_u,    &
                                                            ibm_ht_v,    &
                                                            ibm_ht_w,    &
                                                            ibm_ht_c
 INTEGER, INTENT(IN   )                                  :: n               !desired number of nearest neighbors
 INTEGER, INTENT(IN   )                                  :: ids, ide, jds, jde, kds, kde, & !d: domain 
                                                            ims, ime, jms, jme, kms, kme, & !m: memory
                                                            its, ite, jts, jte, kts, kte    !p: patch, t: tile
 !local data
 INTEGER                                                 :: j !KAL for debugging, can remove
 INTEGER                                                 :: ns              !number of 'side boundary' ghost points
 INTEGER, DIMENSION(ims:ime,jms:jme)                     :: antu_at_p,   &  !actual number of nearest neighbors for top points
                                                            antv_at_p,   &
                                                            antw_at_p
 REAL, DIMENSION(ims:ime,jms:jme,2)                      :: top_dist
 REAL, DIMENSION(ims:ime,jms:jme,6)                      :: top_img         !(x,y,z) location of ghost point and image point of the 'top boundary' ghost points
 REAL, DIMENSION(ims:ime,jms:jme,3)                      :: top_bound,   &  !keep the (x,y,z) location of the boundary points for the no-slip bc
                                                            top_norm
 REAL, DIMENSION(ims:ime,jms:jme,0:9*n-1)                :: top_neigh       !(x,y,z) location of top neighbors
 INTEGER, DIMENSION(ims:ime,jms:jme,0:9*n-1)             :: top_neigh_i     !(i,j,k) index of top neighbors							    
 INTEGER, DIMENSION(:), ALLOCATABLE                      :: ansu_at_p,   &  !acutal number of nearest neighbors for side points
                                                            ansv_at_p,   &
                                                            answ_at_p
 INTEGER, DIMENSION(:,:), ALLOCATABLE                    :: side            !'side boundary' ghost points
 REAL, DIMENSION(:,:), ALLOCATABLE                       :: side_img,    &  !(x,y,z) location of ghost point
                                                            side_bound,  &  !(x,y,z) location of the boundary for side points
                                                            side_neigh,  &  !(x,y,z) location of side neighbors
                                                            side_norm,   &
                                                            side_dist
 INTEGER, DIMENSION(:,:), ALLOCATABLE                    :: side_neigh_i    !(i,j,k) index of side neighbors
 INTEGER                                                 :: i !DJW for debugging
 LOGICAL                                                 :: in_vel_recon !RSA for now, only use recon pts as nearest neighbors from vel_recon routines

!---------------------------------------------------------------------------------
 !the executable begins here
 CALL wrf_debug(100,'dyn_em/module_ibm.F/subroutine shear_stress_recon_ibm_part2')
!---------------------------------------------------------------------------------

 CALL count_side_pts ( stag, top, ns,                           &
                       ids, ide, jds, jde, kds, kde,            &
                       ims, ime, jms, jme, kms, kme,            &
                       its, ite, jts, jte, kts, kte )

 !allocate and store side points for tau
 ALLOCATE (side(3,ns))
 ALLOCATE (side_img(6,ns))
 ALLOCATE (side_bound(3,ns))
 ALLOCATE (side_neigh(0:9*n-1,ns))
 ALLOCATE (side_neigh_i(0:9*n-1,ns))
 ALLOCATE (side_norm(3,ns))
 ALLOCATE (side_dist(2,ns))
 ALLOCATE (ansu_at_p(ns))
 ALLOCATE (ansv_at_p(ns))
 ALLOCATE (answ_at_p(ns))

 IF (ns .GT. 0) THEN
    CALL reconstruct_pts_side ( stag, top, side, ns,                &
                                ids, ide, jds, jde, kds, kde,       &
                                ims, ime, jms, jme, kms, kme,       &
                                its, ite, jts, jte, kts, kte )
 ENDIF !end of get side points

 CALL shear_stress_recon_interp_pts ( stag,                                       &
                                      config_flags%dx, config_flags%dy,           &
                                      ht_tau,                                     &
                                      ibm_ht_u, ibm_ht_v,                         &
                                      ibm_ht_w, ibm_ht_c,                         &
                                      inside_tau, top, side,                      &
                                      top_img, top_bound,                         &
                                      side_img, side_bound,                       &
                                      ns, top_norm, side_norm,                    &
                                      top_dist, side_dist,                        &
                                      config_flags%delta_ss_recon,                &
                                      ids, ide, jds, jde, kds, kde,               &
                                      ims, ime, jms, jme, kms, kme,               &
                                      its, ite, jts, jte, kts, kte )

 in_vel_recon = .false. !RSA for now, only use recon pts as nearest neighbors from vel_recon routines
 CALL neighbors_fs( config_flags%ibm_opt,                    &
                    config_flags%interp_opt,                 &
                    config_flags%dim_terrain, stag, 1,       &
                    config_flags%ibm_nn_horz,                &
                    config_flags%ibm_nn_vert,                &
                    config_flags%dx, config_flags%dy,        &
                    ibm_ht_u, ibm_ht_v,                      &
                    ibm_ht_w, ibm_ht_c,                      &
                    ht_u, ht_v, ht_w,                        &
                    inside_u, inside_v, inside_w,            &
                    inside_all_u, inside_all_v, inside_all_w,& !RSA for using reconstruction pts as nearest neighbors
                    config_flags%recon_pts_as_neigh,         & !RSA for using reconstruction pts as nearest neighbors
                    in_vel_recon,                            & !RSA for using reconstruction pts as nearest neighbors
                    side,                                    &
                    top_img, side_img,                       &
                    top_bound, side_bound,                   &
                    top_neigh, top_neigh_i,                  &
                    side_neigh, side_neigh_i,                &
                    n, ns,                                   &
                    antu_at_p, antv_at_p, antw_at_p,         &
                    ansu_at_p, ansv_at_p, answ_at_p,         &
                    ids, ide, jds, jde, kds, kde,            &
                    ims, ime, jms, jme, kms, kme,            &
                    its, ite, jts, jte, kts, kte )

 IF ((start .EQ. 1) .AND. (config_flags%write_ibm_data)) THEN
    write(*,'(A,A)') "DJW[module_ibm/shear_stress_recon_ibm_part2]: calling write_ibm_data for stag=",stag
    CALL write_ibm_data ( stag, side,                   &
                          top_img, side_img,            &
                          top_bound, side_bound,        &
                          top_neigh, side_neigh,        &
                          n, ns,                        &
                          ids, ide, jds, jde, kds, kde, &
                          ims, ime, jms, jme, kms, kme, &
                          its, ite, jts, jte, kts, kte )
    CALL write_ht_data ( stag, ht_tau,                  &
                         ids, ide, jds, jde, kds, kde, &
                         ims, ime, jms, jme, kms, kme, &
                         its, ite, jts, jte, kts, kte )
 ENDIF

 CALL shear_stress_recon_inverse_dist ( config_flags%z_rough, stag,      &
                                        u, v, w,                         &
                                        xkmv, fnm, fnp,                  &
                                        defor11, defor22, defor33,       &
                                        defor12, defor13, defor23,       &
                                        top, side,                       &
                                        top_neigh, side_neigh,           &
                                        top_neigh_i, side_neigh_i,       &
                                        n, ns,                           &
                                        top_norm, top_dist,              &
                                        side_norm, side_dist,            &
                                        antu_at_p, antv_at_p, antw_at_p, &
                                        ansu_at_p, ansv_at_p, answ_at_p, &
                                        ids, ide, jds, jde, kds, kde,    &
                                        ims, ime, jms, jme, kms, kme,    &
                                        its, ite, jts, jte, kts, kte ) 

 DEALLOCATE (side)
 DEALLOCATE (side_img)
 DEALLOCATE (side_bound)
 DEALLOCATE (side_neigh)
 DEALLOCATE (side_neigh_i)
 DEALLOCATE (side_norm)
 DEALLOCATE (side_dist)
 DEALLOCATE (ansu_at_p)
 DEALLOCATE (ansv_at_p)
 DEALLOCATE (answ_at_p)

 END SUBROUTINE shear_stress_recon_ibm_part2

!----------------------------------------------------------------------------------

 SUBROUTINE shear_stress_extrap_ibm_init ( config_flags,                           &
                                           ibm_ht_u, ibm_ht_v,                     &
                                           ibm_ht_w, ibm_ht_c,                     &
                                           ht_tauii, ht_tau12,                     & 
                                           ht_tau13, ht_tau23,                     &
                                           top_tauii, top_tau12,                   &
                                           top_tau13, top_tau23,                   &
                                           inside_tauii, inside_tau12,             &
                                           inside_tau13, inside_tau23,             &
                                           ids, ide, jds, jde, kds, kde,           &
                                           ims, ime, jms, jme, kms, kme,           &
                                           its, ite, jts, jte, kts, kte )
 IMPLICIT NONE
 !input data
 TYPE(grid_config_rec_type),               INTENT(IN   ) :: config_flags
 REAL, DIMENSION(ims:ime,jms:jme), INTENT(IN   )         :: ibm_ht_u,    &
                                                            ibm_ht_v,    &
                                                            ibm_ht_w,    &
                                                            ibm_ht_c
 REAL, DIMENSION(ims:ime,kms:kme,jms:jme), INTENT(IN   ) :: ht_tauii,        &
                                                            ht_tau12,        &
                                                            ht_tau13,        & 
                                                            ht_tau23
 INTEGER, DIMENSION(ims:ime,jms:jme), INTENT(  OUT)      :: top_tauii,       &
                                                            top_tau12,       &  
                                                            top_tau13,       & 
                                                            top_tau23
 INTEGER, DIMENSION(ims:ime,kms:kme,jms:jme), INTENT(OUT):: inside_tauii,    &
                                                            inside_tau12,    &
                                                            inside_tau13,    &
                                                            inside_tau23
 INTEGER, INTENT(IN   )                                  :: ids, ide, jds, jde, kds, kde, & !d: domain
                                                            ims, ime, jms, jme, kms, kme, & !m: memory
                                                            its, ite, jts, jte, kts, kte    !p: patch, t: tile
 !local

!---------------------------------------------------------------------------------
 !this subroutine is called from module_first_rk_step_part2.F.  !the executable begins here
 CALL wrf_debug(100,'dyn_em/module_ibm.F/subroutine shear_stress_extrap_ibm_init')
!---------------------------------------------------------------------------------  

 CALL ghost_pts_top_ss( 't', ht_tauii, ibm_ht_w,              &
                        top_tauii, inside_tauii,              &
                        ids, ide, jds, jde, kds, kde,         &
                        ims, ime, jms, jme, kms, kme,         &
                        its, ite, jts, jte, kts, kte )
 CALL ghost_pts_top_ss( 'd', ht_tau12, ibm_ht_c,              &
                        top_tau12, inside_tau12,              &
                        ids, ide, jds, jde, kds, kde,         &
                        ims, ime, jms, jme, kms, kme,         &
                        its, ite, jts, jte, kts, kte )
 CALL ghost_pts_top_ss( 'e', ht_tau13, ibm_ht_u,              &
                        top_tau13, inside_tau13,              &
                        ids, ide, jds, jde, kds, kde,         &
                        ims, ime, jms, jme, kms, kme,         &
                        its, ite, jts, jte, kts, kte )
 CALL ghost_pts_top_ss( 'f', ht_tau23, ibm_ht_v,              &
                        top_tau23, inside_tau23,              &
                        ids, ide, jds, jde, kds, kde,         &
                        ims, ime, jms, jme, kms, kme,         &
                        its, ite, jts, jte, kts, kte )

END SUBROUTINE shear_stress_extrap_ibm_init

!--------------------------------------------------------------------------------------------------------------

 SUBROUTINE shear_stress_extrap_ibm( config_flags, stag, start,          &
                                     xkmv, fnm, fnp,                     &
                                     defor11, defor22, defor33,          &
                                     defor12, defor13, defor23,          &
                                     ht_p, inside, inside_all, top,      & 
                                     ibm_ht_u, ibm_ht_v,                 &
                                     ibm_ht_w, ibm_ht_c,                 &
                                     n,                                  &
                                     ids, ide, jds, jde, kds, kde,       &
                                     ims, ime, jms, jme, kms, kme,       &
                                     its, ite, jts, jte, kts, kte )
 IMPLICIT NONE
 !input data
 TYPE(grid_config_rec_type), INTENT(IN   )               :: config_flags
 CHARACTER, INTENT(IN   )                                :: stag
 INTEGER , INTENT(IN   )                                 :: start
 INTEGER, DIMENSION(ims:ime,jms:jme), INTENT(IN   )      :: top             !'top boundary' ghost points
 INTEGER, DIMENSION(ims:ime,kms:kme,jms:jme), INTENT(IN) :: inside,      &  ! one if the pt is inside boundary, zero if it is outside
                                                            inside_all      !RSA inside includes recon pts, inside_all does not
 REAL, DIMENSION(ims:ime,kms:kme,jms:jme), INTENT(IN   ) :: ht_p,        &
                                                            xkmv
 REAL, DIMENSION( kms:kme ), INTENT( IN )                :: fnm, fnp
 REAL, DIMENSION(ims:ime,kms:kme,jms:jme), INTENT(INOUT) :: defor11,     &
                                                            defor22,     &
                                                            defor33,     &
                                                            defor12,     &
                                                            defor13,     &
                                                            defor23
 REAL, DIMENSION(ims:ime,jms:jme), INTENT(IN   )         :: ibm_ht_u,    &
                                                            ibm_ht_v,    &
                                                            ibm_ht_w,    &
                                                            ibm_ht_c
 INTEGER, INTENT(IN   )                                  :: n               ! desired number of nearest neighbors							    
 INTEGER, INTENT(IN   )                                  :: ids, ide, jds, jde, kds, kde, & !d: domain 
                                                            ims, ime, jms, jme, kms, kme, & !m: memory
                                                            its, ite, jts, jte, kts, kte    !p: patch, t: tile
 !local data
 INTEGER                                                 :: ns              ! number of 'side boundary' ghost points
 INTEGER, DIMENSION(ims:ime,jms:jme)                     :: ant_1,       &  ! actual number of nearest neighbors for 3 extrapolation points
                                                            ant_2,       &
                                                            ant_3
 REAL, DIMENSION(ims:ime,jms:jme)                        :: top_dist
                                                           ! grad           ! gradient at boundary
 REAL, DIMENSION(ims:ime,jms:jme,6)                      :: top_img_1,   &  ! (x,y,z) location of ghost point and 3 extrapolation pts
                                                            top_img_2,   &
                                                            top_img_3
 REAL, DIMENSION(ims:ime,jms:jme,3)                      :: top_bound,   &  ! keep the (x,y,z) location of the boundary points for the no-slip bc
                                                            top_norm
 REAL, DIMENSION(ims:ime,jms:jme,0:9*n-1)                :: top_neigh       ! (x,y,z) location of neighbors for 3 extrapolation pts
 INTEGER, DIMENSION(ims:ime,jms:jme,0:9*n-1)             :: top_neigh_i     ! (i,j,k) index of neighbors for 3 extrapolation pts
 INTEGER, DIMENSION(:), ALLOCATABLE                      :: ans_1,       &  ! acutal number of nearest neighbors for side points
                                                            ans_2,       &
                                                            ans_3
 INTEGER, DIMENSION(:,:), ALLOCATABLE                    :: side            !'side boundary' ghost points
 REAL, DIMENSION(:,:), ALLOCATABLE                       :: side_img_1,  &  ! (x,y,z) location of ghost point
                                                            side_img_2,  &
                                                            side_img_3,  &
                                                            side_bound,  &  ! (x,y,z) location of the boundary for side points
                                                            side_norm
 REAL, DIMENSION(:), ALLOCATABLE                         :: side_dist
 REAL, DIMENSION(:,:), ALLOCATABLE                       :: side_neigh      ! (x,y,z) location of side neighbors
 INTEGER, DIMENSION(:,:), ALLOCATABLE                    :: side_neigh_i    ! (i,j,k) index of side neighbors							    
 LOGICAL                                                 :: in_vel_recon !for now, only use recon pts as nearest neighbors from vel_recon routines

!---------------------------------------------------------------------------------
! the executable begins here
 CALL wrf_debug(100,'dyn_em/module_ibm.F/subroutine shear_stress_extrap_ibm')
!---------------------------------------------------------------------------------

 CALL count_side_pts ( stag, top, ns,                &
                       ids, ide, jds, jde, kds, kde, &
                       ims, ime, jms, jme, kms, kme, &
                       its, ite, jts, jte, kts, kte )

 ! allocate and store side ghost points
 ALLOCATE (side(3,ns))
 ALLOCATE (side_img_1(6,ns))
 ALLOCATE (side_img_2(6,ns))
 ALLOCATE (side_img_3(6,ns))
 ALLOCATE (side_bound(3,ns))
 ALLOCATE (side_neigh(0:9*n-1,ns))
 ALLOCATE (side_neigh_i(0:9*n-1,ns))
 ALLOCATE (side_norm(3,ns))
 ALLOCATE (side_dist(ns))
 ALLOCATE (ans_1(ns))
 ALLOCATE (ans_2(ns))
 ALLOCATE (ans_3(ns))
 
 IF (ns .GT. 0) THEN
    CALL ghost_pts_side ( stag, top, side, ns,          &
                          ids, ide, jds, jde, kds, kde, &
                          ims, ime, jms, jme, kms, kme, &
                          its, ite, jts, jte, kts, kte )
 ENDIF ! end of get side points

 CALL shear_stress_extrap_pts( stag,                                           &
                               config_flags%dx, config_flags%dy,               &
                               ht_p,                                           &
                               ibm_ht_u, ibm_ht_v,                             &
                               ibm_ht_w, ibm_ht_c,                             &
                               top, side,                                      &
                               top_img_1, top_img_2, top_img_3, top_bound,     &
                               side_img_1, side_img_2, side_img_3, side_bound, &
                               ns, top_norm, side_norm,                        &
                               top_dist, side_dist,                            &
                               config_flags%delta_ss_extrap,                   &
                               ids, ide, jds, jde, kds, kde,                   &
                               ims, ime, jms, jme, kms, kme,                   &
                               its, ite, jts, jte, kts, kte )

 in_vel_recon = .false. !RSA for now, only use recon pts as nearest neighbors from vel_recon routines
 CALL neighbors_ss_extrap( config_flags%ibm_opt,                    &
                           config_flags%interp_opt,                 &
                           config_flags%dim_terrain, stag, 1,       &
                           config_flags%ibm_nn_horz,                &
                           config_flags%ibm_nn_vert,                &
                           config_flags%dx, config_flags%dy,        &
                           ibm_ht_u, ibm_ht_v,                      &
                           ibm_ht_w, ibm_ht_c,                      &
                           ht_p, inside,                            &
                           inside_all,                              & !RSA for using reconstruction pts as nearest neighbors
                           config_flags%recon_pts_as_neigh,         & !RSA for using reconstruction pts as nearest neighbors
                           in_vel_recon,                            & !RSA for using reconstruction pts as nearest neighbors
                           side,                                    &
                           top_img_1, top_img_2, top_img_3,         &
                           side_img_1, side_img_2, side_img_3,      &
                           top_bound, side_bound,                   &
                           top_neigh, top_neigh_i,                  &
                           side_neigh, side_neigh_i,                &
                           n, ns,                                   &
                           ant_1, ant_2, ant_3,                     &
                           ans_1, ans_2, ans_3,                     &
                           ids, ide, jds, jde, kds, kde,            &
                           ims, ime, jms, jme, kms, kme,            &
                           its, ite, jts, jte, kts, kte )

 IF ((start .EQ. 1) .AND. (config_flags%write_ibm_data)) THEN
    write(*,'(A,A)') "DJW[module_ibm/shear_stress_extrap_ibm]: calling write_ibm_data for stag=",stag
    CALL write_ibm_data ( stag, side,                   &
                          top_img_1, side_img_1,        &
                          top_bound, side_bound,        &
                          top_neigh, side_neigh,        &
                          n, ns,                        &
                          ids, ide, jds, jde, kds, kde, &
                          ims, ime, jms, jme, kms, kme, &
                          its, ite, jts, jte, kts, kte )
    CALL write_ht_data ( stag, ht_p,                   &
                         ids, ide, jds, jde, kds, kde, &
                         ims, ime, jms, jme, kms, kme, &
                         its, ite, jts, jte, kts, kte )
 ENDIF

 CALL shear_stress_extrap_inverse_dist ( stag,                            &
                                         xkmv, fnm, fnp,                  &
                                         defor11, defor22, defor33,       &
                                         defor12, defor13, defor23,       &
                                         top, side,                       &
                                         top_neigh, side_neigh,           &
                                         top_neigh_i, side_neigh_i,       &
                                         n, ns,                           &
                                         top_norm, top_dist,              &
                                         side_norm, side_dist,            &
                                         ant_1, ant_2, ant_3,             &
                                         ans_1, ans_2, ans_3,             &
                                         ids, ide, jds, jde, kds, kde,    &
                                         ims, ime, jms, jme, kms, kme,    &
                                         its, ite, jts, jte, kts, kte ) 
 
 DEALLOCATE (side)
 DEALLOCATE (side_img_1)
 DEALLOCATE (side_img_2)
 DEALLOCATE (side_img_3)
 DEALLOCATE (side_bound)
 DEALLOCATE (side_neigh)
 DEALLOCATE (side_neigh_i)
 DEALLOCATE (side_norm)
 DEALLOCATE (side_dist)
 DEALLOCATE (ans_1)
 DEALLOCATE (ans_2)
 DEALLOCATE (ans_3)

 END SUBROUTINE shear_stress_extrap_ibm

!----------------------------------------------------------------------------------

SUBROUTINE shear_stress_ibm_1D ( config_flags,                 &
                                 mut,                          &
                                 defor13, defor23,             &
                                 nba_mij, n_nba_mij,           & !JDM
                                 xkmv, fnm, fnp,               &
                                 rho,                          & !DJW needed for cal_titau_* in v3.8.1
                                 u, v,                         &
                                 ht_u, ht_v, ht_w,             &
                                 ibm_ht_u, ibm_ht_v,           &
                                 top_u, top_v, top_w,          &
                                 ru_tendf, rv_tendf,           &
                                 ids, ide, jds, jde, kds, kde, &
                                 ims, ime, jms, jme, kms, kme, &
                                 its, ite, jts, jte, kts, kte )
   IMPLICIT NONE
   !input data
   TYPE(grid_config_rec_type), INTENT(IN   )               :: config_flags
   INTEGER ,       INTENT(IN   ) :: ids, ide, jds, jde, kds, kde, & !d: domain
                                    ims, ime, jms, jme, kms, kme, & !m: memory
                                    its, ite, jts, jte, kts, kte    !p: patch, t: tile
   INTEGER,  INTENT(  IN ) :: n_nba_mij !JDM
   REAL , DIMENSION( kms:kme ), INTENT(IN   )              :: fnm, &
                                                              fnp
   REAL, DIMENSION(ims:ime,kms:kme,jms:jme), INTENT(IN   ) :: rho !DJW needed for cal_titau_* in v3.8.1
   REAL, DIMENSION(ims:ime,kms:kme,jms:jme), INTENT(IN   ) :: defor13,  &
                                                              defor23,  &
                                                              xkmv,     &
                                                              u,        &
                                                              v,        &
                                                              ht_u,     &
                                                              ht_v,     &
                                                              ht_w
   REAL, DIMENSION(ims:ime,jms:jme), INTENT(IN   )         :: mut,      &
                                                              ibm_ht_u, &
                                                              ibm_ht_v
   INTEGER, DIMENSION(ims:ime,jms:jme), INTENT(IN   )      :: top_u,    &
                                                              top_v,    &
                                                              top_w    
   REAL , DIMENSION(ims:ime, kms:kme, jms:jme, n_nba_mij),  INTENT(INOUT) :: nba_mij
   REAL , DIMENSION( ims:ime, kms:kme, jms:jme), INTENT(INOUT) :: ru_tendf, &
                                                                  rv_tendf

   !local data							      
   INTEGER                                                 :: i,j,k,    &
                                                              is_ext,   &
                                                              ie_ext,   &
                                                              js_ext,   &
                                                              je_ext
   REAL                                                    :: V0
   REAL, DIMENSION(ims:ime,jms:jme)                        :: Cd_u,     &
                                                              Cd_v,     &
                                                              tau_xz,   &
                                                              tau_yz
   REAL, DIMENSION( its-1:ite+1, kts:kte, jts-1:jte+1 )    :: titau

!----------------------------------------------------------------------------------
   !the executable begins here
   !this subroutine is only called if rk_step is one
   CALL wrf_debug(100,'dyn_em/module_ibm.F/subroutine shear_stress_ibm_1D')
!----------------------------------------------------------------------------------
   tau_xz = 0.0
   tau_yz = 0.0

   !find the drag coefficient for the immersed boundary
   DO j = jts,jte
   DO i = its,ite
      Cd_u(i,j)= (KARMAN / &
                  LOG((ht_u(i,top_u(i,j)+1,j)-ibm_ht_u(i,j))/config_flags%z_rough))**2
      Cd_v(i,j)= (KARMAN / &
                  LOG((ht_v(i,top_v(i,j)+1,j)-ibm_ht_v(i,j))/config_flags%z_rough))**2
   ENDDO
   ENDDO

   !calculate the shear stress at the surface, based on the 
   !first u value above the surface               
   DO j = jts,MIN(jte,jde-1)
   DO i = its,ite
      V0 = sqrt((u(i,top_u(i,j)+1,j)**2)+          &
              (((v(i  ,top_u(i,j)+1,j  )+          &
                 v(i  ,top_u(i,j)+1,j+1)+          &
                 v(i-1,top_u(i,j)+1,j  )+          &
                 v(i-1,top_u(i,j)+1,j+1))/4)**2))+epsilon
      tau_xz(i,j)= -0.5*(mut(i-1,j)+mut(i,j))*Cd_u(i,j)*V0*u(i,top_u(i,j)+1,j)
   ENDDO
   ENDDO
   
   DO j = jts,jte
   DO i = its,MIN(ite,ide-1) 
      V0=   sqrt((v(i,top_v(i,j)+1,j)**2) +         &
               (((u(i  ,top_v(i,j)+1,j  )+          &
                  u(i  ,top_v(i,j)+1,j-1)+          &
                  u(i+1,top_v(i,j)+1,j  )+          &
                  u(i+1,top_v(i,j)+1,j-1))/4)**2))+epsilon
      tau_yz(i,j)=-0.5*(mut(i,j-1)+mut(i,j))*Cd_v(i,j)*V0*v(i,top_v(i,j)+1,j)
   ENDDO
   ENDDO

   !get tau values at computational nodes, so that we can extrapolate
 
   !titau = titau13
   titau=0.0
   is_ext=0
   ie_ext=0
   js_ext=0
   je_ext=0
      
   CALL cal_titau_13_31( config_flags, titau, defor13,    &
                         nba_mij(ims,kms,jms,P_m13),      & !JDM
                         mut, xkmv, fnm, fnp,             &
                         rho,                             & !DJW needed for cal_titau_* in v3.8.1
                         is_ext, ie_ext, js_ext, je_ext,  &
                         ids, ide, jds, jde, kds, kde,    &
                         ims, ime, jms, jme, kms, kme,    &
                         its, ite, jts, jte, kts, kte     )
 
   !now extrapoate or interpolate using point above surface and surface value to
   !determine the tau value that needs to be set, which can be just above or
   !below the surface.
   DO j = jts,MIN(jte,jde-1)
   DO i = its,ite  
      titau(i,top_u(i,j)+1,j) =  titau(i,top_u(i,j)+2,j)- &
                                 (titau(i,top_u(i,j)+2,j)-tau_xz(i,j))* &
                                 ((ht_w(i,top_u(i,j)+2,j)-ht_w(i,top_u(i,j)+1,j))/ &
                                 (ht_w(i,top_u(i,j)+2,j)-ibm_ht_u(i,j))) 
      titau(i,top_u(i,j),j) =  titau(i,top_u(i,j)+2,j)- &
                               (titau(i,top_u(i,j)+2,j)-tau_xz(i,j))* &
                               ((ht_w(i,top_u(i,j)+2,j)-ht_w(i,top_u(i,j),j))/ &
                               (ht_w(i,top_u(i,j)+2,j)-ibm_ht_u(i,j)))
      nba_mij(i,top_u(i,j)+1,j,P_m13) = titau(i,top_u(i,j)+1,j)/(0.5*(mut(i-1,j)+mut(i,j)))
      nba_mij(i,top_u(i,j),j,P_m13) = titau(i,top_u(i,j),j)/(0.5*(mut(i-1,j)+mut(i,j)))

      !this code sets tau below the surface (i.e. a ghost point), and never above the surface.
      !titau(i,top_w(i,j),j) =  titau(i,top_w(i,j)+1,j)- &
      !                         (titau(i,top_w(i,j)+1,j)-tau_xz(i,j))* &
      !                         ((ht_w(i,top_w(i,j)+1,j)-ht_w(i,top_w(i,j),j))/ &
      !                         (ht_w(i,top_w(i,j)+1,j)-ibm_ht_u(i,j))) 	
      !nba_mij(i,top_w(i,j),j,P_m13) = titau(i,top_w(i,j),j)/(0.5*(mut(i-1,j)+mut(i,j)))	          		       
   ENDDO
   ENDDO
   
   !now recalculate the tendency
   DO j = jts,MIN(jte,jde-1)
   DO i = its,ite  
      ru_tendf(i,top_u(i,j)+1,j) = -(titau(i,top_u(i,j)+2,j)-titau(i,top_u(i,j)+1,j)) / &
                                    (ht_w(i,top_u(i,j)+2,j)-ht_w(i,top_u(i,j)+1,j))  
      ru_tendf(i,top_u(i,j),j) = -(titau(i,top_u(i,j)+1,j)-titau(i,top_u(i,j),j)) / &
                                  (ht_w(i,top_u(i,j)+1,j)-ht_w(i,top_u(i,j),j)) 

      !ru_tendf(i,top_w(i,j),j) = -(titau(i,top_w(i,j)+1,j)-titau(i,top_w(i,j),j)) / &
      !                            (ht_w(i,top_w(i,j)+1,j)-ht_w(i,top_w(i,j),j))
      !ru_tendf(i,top_w(i,j)-1,j) = -(titau(i,top_w(i,j),j)-titau(i,top_w(i,j)-1,j)) / &
      !                              (ht_w(i,top_w(i,j),j)-ht_w(i,top_w(i,j)-1,j))
   ENDDO
   ENDDO

   !titau = titau23
   titau=0.0
   is_ext=0
   ie_ext=0
   js_ext=0
   je_ext=0
   CALL cal_titau_23_32( config_flags, titau, defor23,    &
                         nba_mij(ims,kms,jms,P_m23),      & !JDM
                         mut, xkmv, fnm, fnp,             &
                         rho,                             & !DJW needed for cal_titau_* in v3.8.1
                         is_ext, ie_ext, js_ext, je_ext,  &
                         ids, ide, jds, jde, kds, kde,    &
                         ims, ime, jms, jme, kms, kme,    &
                         its, ite, jts, jte, kts, kte     ) 

   DO j = jts,jte
   DO i = its,MIN(ite,ide-1)
      titau(i,top_u(i,j)+1,j) =  titau(i,top_u(i,j)+2,j)- &
                                 (titau(i,top_u(i,j)+2,j)-tau_yz(i,j))* &
                                 ((ht_w(i,top_u(i,j)+2,j)-ht_w(i,top_u(i,j)+1,j))/ &
                                 (ht_w(i,top_u(i,j)+2,j)-ibm_ht_u(i,j)))
      titau(i,top_u(i,j),j) =  titau(i,top_u(i,j)+2,j)- &
                               (titau(i,top_u(i,j)+2,j)-tau_yz(i,j))* &
                               ((ht_w(i,top_u(i,j)+2,j)-ht_w(i,top_u(i,j),j))/ &
                               (ht_w(i,top_u(i,j)+2,j)-ibm_ht_u(i,j)))
      nba_mij(i,top_u(i,j)+1,j,P_m23) = titau(i,top_u(i,j)+1,j)/(0.5*(mut(i,j-1)+mut(i,j)))
      nba_mij(i,top_u(i,j),j,P_m23) = titau(i,top_u(i,j),j)/(0.5*(mut(i,j-1)+mut(i,j)))
   ENDDO
   ENDDO

   DO j = jts,jte
   DO i = its,MIN(ite,ide-1) 
      rv_tendf(i,top_u(i,j)+1,j) = -(titau(i,top_u(i,j)+2,j)-titau(i,top_u(i,j)+1,j)) / &
                                    (ht_w(i,top_u(i,j)+2,j)-ht_w(i,top_u(i,j)+1,j))
      rv_tendf(i,top_u(i,j),j) = -(titau(i,top_u(i,j)+1,j)-titau(i,top_u(i,j),j)) / &
                                  (ht_w(i,top_u(i,j)+1,j)-ht_w(i,top_u(i,j),j))

      !rv_tendf(i,top_w(i,j),j) = -(titau(i,top_w(i,j)+1,j)-titau(i,top_w(i,j),j)) / &
      !                            (ht_w(i,top_w(i,j)+1,j)-ht_w(i,top_w(i,j),j))
      !rv_tendf(i,top_w(i,j)-1,j) = -(titau(i,top_w(i,j),j)-titau(i,top_w(i,j)-1,j)) / &
      !                              (ht_w(i,top_w(i,j),j)-ht_w(i,top_w(i,j)-1,j))
   ENDDO
   ENDDO
   
END SUBROUTINE shear_stress_ibm_1D

!----------------------------------------------------------------------------------

 SUBROUTINE temp_ibm( config_flags, stag, start, bc_type, &
                      ht_p,                               &
                      top, prox, inside,                  &
                      inside_all,                         &
                      varfull, varsave, var,              &
                      mu, mus,                            &
                      h_diabatic,                         &
                      number_of_small_timesteps,dts,      &
                      rk_step, rk_order,                  &
                      qv, rho,                            &
                      xkhh, xkhv, hfx,                    &
                      ibm_ht_u, ibm_ht_v,                 &
                      ibm_ht_w, ibm_ht_c,                 &
                      n,                                  &
                      ids, ide, jds, jde, kds, kde,       &
                      ims, ime, jms, jme, kms, kme,       &
                      its, ite, jts, jte, kts, kte )
 IMPLICIT NONE
 !input data
 TYPE(grid_config_rec_type), INTENT(IN   )               :: config_flags
 CHARACTER, INTENT(IN   )                                :: stag
 INTEGER , INTENT(IN   )                                 :: start,       &
                                                            bc_type        !1 = dirchlet 2 = neumann							              
 INTEGER, DIMENSION(ims:ime,jms:jme), INTENT(IN   )      :: top,         & !'top boundary' ghost points
                                                            prox
 INTEGER, DIMENSION(ims:ime,kms:kme,jms:jme), INTENT(IN) :: inside         !one if the pt is inside boundary, zero if it is outside
 INTEGER, DIMENSION(ims:ime,kms:kme,jms:jme), INTENT(IN) :: inside_all     !RSA inside includes recon pts, inside_all does not
 REAL, DIMENSION(ims:ime,kms:kme,jms:jme), INTENT(IN   ) :: ht_p,        &
                                                            varsave,     &
                                                            h_diabatic,  &
                                                            qv,          &
                                                            rho,         &
                                                            xkhh,        &
                                                            xkhv
 REAL, DIMENSION(ims:ime,kms:kme,jms:jme), INTENT(INOUT) :: varfull,     &
                                                            var
 REAL, DIMENSION(ims:ime,jms:jme), INTENT(INOUT)         :: hfx
 REAL, DIMENSION(ims:ime,jms:jme), INTENT(IN   )         :: mu,          &
                                                            mus,         &
                                                            ibm_ht_u,    &
                                                            ibm_ht_v,    &
                                                            ibm_ht_w,    &
                                                            ibm_ht_c
 REAL, INTENT(IN   )                                     :: dts
 INTEGER, INTENT(IN   )                                  :: number_of_small_timesteps, &
                                                            rk_step,     &
                                                            rk_order,    &
                                                            n              !desired number of nearest neighbors							    
 INTEGER, INTENT(IN   )                                  :: ids, ide, jds, jde, kds, kde, & !d: domain 
                                                            ims, ime, jms, jme, kms, kme, & !m: memory
                                                            its, ite, jts, jte, kts, kte    !p: patch, t: tile

 !local data
 INTEGER                                                 :: ns,          & !number of 'side boundary' ghost points
                                                            im,          & !counter for scalar loops
                                                            i, j, k
 INTEGER, DIMENSION(ims:ime,jms:jme)                     :: ant            !actual number of nearest neighbors for top points
 REAL                                                    :: cpm
 REAL, DIMENSION(ims:ime,jms:jme)                        :: grad,        & !gradient at boundary
                                                            top_dist
 REAL, DIMENSION(ims:ime,jms:jme,6)                      :: top_img        !(x,y,z) location of ghost point and image point of the 'top boundary' ghost points
 REAL, DIMENSION(ims:ime,jms:jme,3)                      :: top_bound,   & !keep the (x,y,z) location of the boundary points for the no-slip bc
                                                            top_norm 
 REAL, DIMENSION(ims:ime,jms:jme,0:3*n-1)                :: top_neigh      !(x,y,z) location of top neighbors
 INTEGER, DIMENSION(ims:ime,jms:jme,0:3*n-1)             :: top_neigh_i    !(i,j,k) index of top neighbors							    
 INTEGER, DIMENSION(:,:), ALLOCATABLE                    :: side           !'side boundary' ghost points
 REAL, DIMENSION(:,:), ALLOCATABLE                       :: side_img,    & !(x,y,z) location of ghost point
                                                            side_bound,  & !(x,y,z) location of the boundary for side points
                                                            side_neigh,  & !(x,y,z) location of side neighbors
                                                            side_norm
 REAL, DIMENSION(:), ALLOCATABLE                         :: side_dist
 INTEGER, DIMENSION(:,:), ALLOCATABLE                    :: side_neigh_i   !(i,j,k) index of side neighbors							    
 INTEGER, DIMENSION(:), ALLOCATABLE                      :: ans            !actual number of nearest neighbors for side points
 LOGICAL                                                 :: in_scalar !RSA flag for neighbors_ns (true for temp or scalar, false for velocity)
 LOGICAL                                                 :: in_vel_recon !RSA for now, only use recon pts as nearest neighbors from vel_recon routines

!---------------------------------------------------------------------------------
 !the executable begins here
 CALL wrf_debug(100,'dyn_em/module_ibm.F/subroutine temp_ibm')
!---------------------------------------------------------------------------------
 !initalize the scalar fluxes at the surface
 grad = 0.0

 CALL count_side_pts ( stag, top, ns,                &
                       ids, ide, jds, jde, kds, kde, &
                       ims, ime, jms, jme, kms, kme, &
                       its, ite, jts, jte, kts, kte )

 !allocate and store side ghost points
 ALLOCATE (side(3,ns))
 ALLOCATE (side_img(6,ns))
 ALLOCATE (side_bound(3,ns))
 ALLOCATE (side_neigh(0:3*n-1,ns))
 ALLOCATE (side_neigh_i(0:3*n-1,ns))
 ALLOCATE (side_norm(3,ns))
 ALLOCATE (side_dist(ns))
 ALLOCATE (ans(ns))
 
 IF (ns .GT. 0) THEN   
    CALL ghost_pts_side ( stag, top, side, ns,          &
                          ids, ide, jds, jde, kds, kde, &
                          ims, ime, jms, jme, kms, kme, &
                          its, ite, jts, jte, kts, kte )
 ENDIF !end of get side points	

 CALL image_pts ( stag,config_flags%interp_opt, bc_type, &
                  config_flags%dx, config_flags%dy,      &
                  ht_p,                                  &
                  ibm_ht_u, ibm_ht_v,                    &
                  ibm_ht_w, ibm_ht_c,                    &
                  top, side,                             &
                  top_img, top_bound,                    &
                  side_img, side_bound,                  &
                  prox, ns, top_norm, side_norm,         &
                  top_dist, side_dist,                   &
                  ids, ide, jds, jde, kds, kde,          &
                  ims, ime, jms, jme, kms, kme,          &
                  its, ite, jts, jte, kts, kte )

 in_scalar = .true. !RSA flag for neighbors_ns (true for temp or scalar, false for velocity)
 in_vel_recon = .false. !RSA for now, only use recon pts as nearest neighbors from vel_recon routines
 CALL neighbors_ns( config_flags%ibm_opt,                    &
                    config_flags%ibm_temp,                   & !RSA for using VRM with ghost pt temp BC
                    in_scalar,                               & !RSA for using VRM with ghost pt temp BC
                    config_flags%interp_opt,                 &
                    config_flags%dim_terrain, stag, bc_type, &
                    config_flags%ibm_nn_horz,                &
                    config_flags%ibm_nn_vert,                &
                    config_flags%dx, config_flags%dy,        &
                    prox,                                    &
                    ibm_ht_u, ibm_ht_v,                      &
                    ibm_ht_w, ibm_ht_c,                      &
                    ht_p, inside,                            &
                    inside_all,                              & !RSA for using recon pts as neighbors
                    config_flags%recon_pts_as_neigh,         & !RSA for using recon pts as neighbors
                    in_vel_recon,                            & !RSA for using recon pts as neighbors
                    top, side, top_img, side_img,            &
                    top_bound, side_bound,                   &
                    top_neigh, top_neigh_i,                  &
                    side_neigh, side_neigh_i,                &
                    n, ns, ant, ans,                         &
                    ids, ide, jds, jde, kds, kde,            &
                    ims, ime, jms, jme, kms, kme,            &
                    its, ite, jts, jte, kts, kte )

 CALL wrf_debug(100,'subroutine temp_ibm return from neigbors')
 
 IF ((start .EQ. 1) .AND. (config_flags%write_ibm_data)) THEN
    write(*,'(A,A)') "DJW[module_ibm/temp_ibm]: calling write_ibm_data for stag=",stag
    CALL write_ibm_data ( stag, side,                   &
                          top_img, side_img,            &
                          top_bound, side_bound,        &
                          top_neigh, side_neigh,        &
                          n, ns,                        &
                          ids, ide, jds, jde, kds, kde, &
                          ims, ime, jms, jme, kms, kme, &
                          its, ite, jts, jte, kts, kte )
    CALL write_ht_data ( stag, ht_p,                   &
                         ids, ide, jds, jde, kds, kde, &
                         ims, ime, jms, jme, kms, kme, &
                         its, ite, jts, jte, kts, kte )
 ENDIF

 !set the heat flux gradient boundary condition at the immersed boundary
 !using the vertical eddy diffusivity below.  Eventually I need to change this
 !to be a combination of vertical and horizontal components based on the 
 !normal vector to the surface
 IF (config_flags%tke_heat_flux .GT. 0.0) THEN !assign grad and hfx
    DO j = jts,MIN(jte,jde-1)
    DO i = its,MIN(ite,ide-1)
       grad(i,j) = -config_flags%tke_heat_flux / xkhv(i,top(i,j)+1,j)
       cpm = cp * (1. + 0.8 * qv(i,top(i,j)+1,j)) 
       hfx(i,j) = config_flags%tke_heat_flux*cpm*rho(i,top(i,j)+1,j) 
    ENDDO
    ENDDO    
 ENDIF
 IF ((config_flags%heat_flux_function) .OR. (config_flags%sf_surface_physics .NE. 0)) THEN !assign grad only, hfx already calculated
    DO j = jts,MIN(jte,jde-1)
    DO i = its,MIN(ite,ide-1)
       cpm = cp * (1. + 0.8 * qv(i,top(i,j)+1,j)) 
       grad(i,j) = -hfx(i,j)/cpm/rho(i,top(i,j)+1,j)/xkhv(i,top(i,j)+1,j)
    ENDDO
    ENDDO 
 ENDIF
 
   !pert values are calculated from full values in these subroutines
   !and put into var
   IF (bc_type .EQ. 1) THEN  
      write (*,*) 'Boundary condition not assigned'
!      CALL no_slip_lin_ss ( stag, prox, config_flags%dim_terrain, &
!                            var, varfull, varsave,                &
!                            mu, mus,                              &
!                            top, top_img,                         &
!                            side, side_img,                       &
!                            top_neigh, side_neigh,                &
!                            top_neigh_i, side_neigh_i,            &
!                            n, ns,                                &
!                            ids, ide, jds, jde, kds, kde,         &
!                            ims, ime, jms, jme, kms, kme,         &
!                            its, ite, jts, jte, kts, kte )
   ELSEIF (bc_type .EQ. 2) THEN
      IF (config_flags%interp_opt .EQ. 1) THEN
         CALL neumann_lin_ss( grad, prox, config_flags%dim_terrain, &
                              var, varfull, varsave,                &
                              mu, mus,                              &
                              h_diabatic,                           &
                              number_of_small_timesteps,dts,        &
                              rk_step, rk_order,                    &
                              top_norm, side_norm,                  &
                              top_dist, side_dist,                  &
                              top, top_img,                         &
                              side, side_img,                       &
                              top_neigh, side_neigh,                &
                              top_neigh_i, side_neigh_i,            &
                              n, ns,                                &
                              ids, ide, jds, jde, kds, kde,         &
                              ims, ime, jms, jme, kms, kme,         &
                              its, ite, jts, jte, kts, kte )
      ELSEIF ((config_flags%interp_opt .EQ. 2) .OR. (config_flags%interp_opt .EQ. 3)) THEN
         CALL neumann_inverse_dist_ss( grad, prox, config_flags%dim_terrain, &
                              var, varfull, varsave,                         &
                              mu, mus,                                       &
                              h_diabatic,                                    &
                              number_of_small_timesteps,dts,                 &
                              rk_step, rk_order,                             &
                              top_norm, side_norm,                           &
                              top_dist, side_dist,                           &
                              top, top_img,                                  &
                              side, side_img,                                &
                              top_neigh, side_neigh,                         &
                              top_neigh_i, side_neigh_i,                     &
                              n, ns, ant, ans,                               &
                              ids, ide, jds, jde, kds, kde,                  &
                              ims, ime, jms, jme, kms, kme,                  &
                              its, ite, jts, jte, kts, kte )
      ENDIF !interp_opt
   ENDIF !bc_type

 !deallocate side ghost points
 CALL wrf_debug(100,'deallocate dyn_em/module_ibm.F/subroutine temp_ibm')
 DEALLOCATE (side)
 DEALLOCATE (side_img)
 DEALLOCATE (side_bound)
 DEALLOCATE (side_neigh)
 DEALLOCATE (side_neigh_i)
 DEALLOCATE (side_norm)
 DEALLOCATE (side_dist)
 DEALLOCATE (ans)

 END SUBROUTINE temp_ibm

!--------------------------------------------------------------------------------------------------------

 SUBROUTINE scalar_ibm( config_flags, start, stag, bc_type, &
                        ht_p,                               &
                        top, prox, inside,                  &
                        inside_all,                         &
                        num_moist, moist,                   &
                        num_scalar, scalar,                 &
                        rho,                                &
                        xkhh, xkhv, qfx,                    &
                        ibm_ht_u, ibm_ht_v,                 &
                        ibm_ht_w, ibm_ht_c,                 &
                        n,                                  &
                        ids, ide, jds, jde, kds, kde,       &
                        ims, ime, jms, jme, kms, kme,       &
                        its, ite, jts, jte, kts, kte )
 IMPLICIT NONE
 !input data
 TYPE(grid_config_rec_type), INTENT(IN   )               :: config_flags
 INTEGER, INTENT(IN   )                                  :: start,       &
                                                            bc_type,     &  ! 1 = dirchlet, 2 = neumann 
                                                            num_moist,   &
                                                            num_scalar
 CHARACTER, INTENT(IN   )                                :: stag
 INTEGER, DIMENSION(ims:ime,jms:jme), INTENT(IN   )      :: top,         &  !'top boundary' ghost points
                                                            prox
 INTEGER, DIMENSION(ims:ime,kms:kme,jms:jme), INTENT(IN) :: inside          ! one if the pt is inside boundary, zero if it is outside
 INTEGER, DIMENSION(ims:ime,kms:kme,jms:jme), INTENT(IN) :: inside_all      ! RSA inside includes recon pts, inside_all does not
 REAL, DIMENSION(ims:ime,kms:kme,jms:jme), INTENT(IN   ) :: ht_p,        &
                                                            rho,         &
                                                            xkhh,        &
                                                            xkhv
 REAL, DIMENSION(ims:ime,kms:kme,jms:jme,num_moist),                     &
                                           INTENT(INOUT) :: moist
 REAL, DIMENSION(ims:ime,kms:kme,jms:jme,num_scalar),                    &
                                           INTENT(INOUT) :: scalar
 REAL, DIMENSION(ims:ime,jms:jme),         INTENT(IN   ) :: qfx,         &
                                                            ibm_ht_u,    &
                                                            ibm_ht_v,    &
                                                            ibm_ht_w,    &
                                                            ibm_ht_c
 INTEGER, INTENT(IN   )                                  :: n               ! desired number of nearest neighbors							    
 INTEGER, INTENT(IN   )                                  :: ids, ide, jds, jde, kds, kde, &  ! d: domain m:memory p:patch t:tile 
                                                            ims, ime, jms, jme, kms, kme, &
                                                            its, ite, jts, jte, kts, kte   
   
 !local data
 INTEGER                                                 :: ns,          &  ! number of 'side boundary' ghost points
                                                            is,          &  ! counter for scalar loops
                                                            i, j, k
 INTEGER, DIMENSION(ims:ime,jms:jme)                     :: ant             ! actual number of nearest neighbors for top points
 REAL, DIMENSION(ims:ime,jms:jme)                        :: grad,        &  ! gradient at boundary
                                                            top_dist
 REAL, DIMENSION(ims:ime,jms:jme,6)                      :: top_img         ! (x,y,z) location of ghost point and image point of the 'top boundary' ghost points
 REAL, DIMENSION(ims:ime,jms:jme,3)                      :: top_bound,   &  ! keep the (x,y,z) location of the boundary points for the no-slip bc
                                                            top_norm
 REAL, DIMENSION(ims:ime,jms:jme,0:3*n-1)                :: top_neigh       ! (x,y,z) location of top neighbors
 INTEGER, DIMENSION(ims:ime,jms:jme,0:3*n-1)             :: top_neigh_i     ! (i,j,k) index of top neighbors							    
 INTEGER, DIMENSION(:,:), ALLOCATABLE                    :: side            !'side boundary' ghost points
 REAL, DIMENSION(:,:), ALLOCATABLE                       :: side_img,    &  ! (x,y,z) location of ghost point
                                                            side_bound,  &  ! (x,y,z) location of the boundary for side points
                                                            side_neigh,  &  ! (x,y,z) location of side neighbors
                                                            side_norm
 REAL, DIMENSION(:), ALLOCATABLE                         :: side_dist
 INTEGER, DIMENSION(:,:), ALLOCATABLE                    :: side_neigh_i    ! (i,j,k) index of side neighbors
 INTEGER, DIMENSION(:), ALLOCATABLE                      :: ans             ! actual number of nearest neighbors for side points							    
 LOGICAL                                                 :: in_scalar       !RSA flag for neighbors_ns (true for temp or scalar, false for velocity)
 LOGICAL                                                 :: in_vel_recon    !RSA for now, only use recon pts as nearest neighbors from vel_recon routines
!---------------------------------------------------------------------------------
! the executable begins here
 CALL wrf_debug(100,'dyn_em/module_ibm.F/subroutine scalar_ibm')
!---------------------------------------------------------------------------------
! initalize the scalar fluxes at the surface
 grad = 0. 

 CALL count_side_pts ( stag, top, ns,                &
                       ids, ide, jds, jde, kds, kde, &
                       ims, ime, jms, jme, kms, kme, &
                       its, ite, jts, jte, kts, kte )

 ! allocate and store side ghost points
 ALLOCATE (side(3,ns))
 ALLOCATE (side_img(6,ns))
 ALLOCATE (side_bound(3,ns))
 ALLOCATE (side_neigh(0:3*n-1,ns))
 ALLOCATE (side_neigh_i(0:3*n-1,ns))
 ALLOCATE (side_norm(3,ns))
 ALLOCATE (side_dist(ns))
 ALLOCATE (ans(ns))
 
 if (ns > 0) then 
    CALL ghost_pts_side ( stag, top, side, ns,          &
                          ids, ide, jds, jde, kds, kde, &
                          ims, ime, jms, jme, kms, kme, &
                          its, ite, jts, jte, kts, kte )
 endif ! end of get side points
 
 CALL image_pts ( stag,config_flags%interp_opt, bc_type, &
                  config_flags%dx, config_flags%dy,      &
                  ht_p,                                  &
                  ibm_ht_u, ibm_ht_v,                    &
                  ibm_ht_w, ibm_ht_c,                    &
                  top, side,                             &
                  top_img, top_bound,                    &
                  side_img, side_bound,                  &
                  prox, ns, top_norm, side_norm,         &
                  top_dist, side_dist,                   &
                  ids, ide, jds, jde, kds, kde,          &
                  ims, ime, jms, jme, kms, kme,          &
                  its, ite, jts, jte, kts, kte )

 in_scalar = .true. !RSA flag for neighbors_ns (true for temp or scalar, false for velocity)
 in_vel_recon = .false. !RSA for now, only use recon pts as nearest neighbors from vel_recon routines
 CALL neighbors_ns( config_flags%ibm_opt,                    &
                    config_flags%ibm_scalar,                 & !RSA for using VRM with ghost pt scalar BC
                    in_scalar,                               & !RSA for using VRM with ghost pt scalar BC
                    config_flags%interp_opt,                 &
                    config_flags%dim_terrain, stag, bc_type, &
                    config_flags%ibm_nn_horz,                &
                    config_flags%ibm_nn_vert,                &
                    config_flags%dx, config_flags%dy,        &
                    prox,                                    &
                    ibm_ht_u, ibm_ht_v,                      &
                    ibm_ht_w, ibm_ht_c,                      &
                    ht_p, inside,                            &
                    inside_all,                              & !RSA for using recon pts as neighbors
                    config_flags%recon_pts_as_neigh,         & !RSA for using recon pts as neighbors
                    in_vel_recon,                            & !RSA for using recon pts as neighbors
                    top, side, top_img, side_img,            &
                    top_bound, side_bound,                   &
                    top_neigh, top_neigh_i,                  &
                    side_neigh, side_neigh_i,                &
                    n, ns, ant, ans,                         &
                    ids, ide, jds, jde, kds, kde,            &
                    ims, ime, jms, jme, kms, kme,            &
                    its, ite, jts, jte, kts, kte )

! if (start == 1) then
!    CALL write_ibm_data ( stag, side,                   &
!                          top_img, side_img,            &
!                          top_bound, side_bound,        &
!                          top_neigh, side_neigh,        &
!                          n, ns,                        &
!                          ids, ide, jds, jde, kds, kde, &
!                          ims, ime, jms, jme, kms, kme, &
!                          its, ite, jts, jte, kts, kte )
! endif
 
 if (bc_type == 1) then
    print *, 'dirchlet boundary condition not assigned for scalar'
 elseif (bc_type == 2) then  
   
    IF (num_moist >= PARAM_FIRST_SCALAR) THEN
       IF (config_flags%sf_surface_physics /= 0) THEN  ! assign grad only, qfx already calculated
          DO j = jts,MIN(jte,jde-1)
          DO i = its,MIN(ite,ide-1)
             grad(i,j) = -qfx(i,j)/rho(i,top(i,j)+1,j)/(1.+moist(i,top(i,j)+1,j,P_QV))/xkhv(i,top(i,j)+1,j)
          ENDDO
          ENDDO
       ENDIF
       DO is = PARAM_FIRST_SCALAR, num_moist
          if (config_flags%interp_opt == 1) then
             CALL neumann_lin( moist(ims:ime,kms:kme,jms:jme,is), &
                               prox, config_flags%dim_terrain,    &
                               grad,                              &
                               top_norm, side_norm,               &
                               top_dist, side_dist,               &
                               top, top_img,                      &
                               side, side_img,                    &
                               top_neigh, side_neigh,             &
                               top_neigh_i, side_neigh_i,         &
                               n, ns,                             &
                               ids, ide, jds, jde, kds, kde,      &
                               ims, ime, jms, jme, kms, kme,      &
                               its, ite, jts, jte, kts, kte )
          elseif ((config_flags%interp_opt == 2).OR.(config_flags%interp_opt == 3)) then
             CALL neumann_inverse_dist( moist(ims:ime,kms:kme,jms:jme,is), &
                                        prox, config_flags%dim_terrain,    &
                                        grad,                              &
                                        top_norm, side_norm,               &
                                        top_dist, side_dist,               &
                                        top, top_img,                      &
                                        side, side_img,                    &
                                        top_neigh, side_neigh,             &
                                        top_neigh_i, side_neigh_i,         &
                                        n, ns, ant, ans,                   &
                                        ids, ide, jds, jde, kds, kde,      &
                                        ims, ime, jms, jme, kms, kme,      &
                                        its, ite, jts, jte, kts, kte )
          endif
       ENDDO 
    ENDIF
    IF (num_scalar >= PARAM_FIRST_SCALAR) THEN 
       DO is = PARAM_FIRST_SCALAR, num_scalar
!          DO i=its,MIN(ite,ide-1)
!          DO j=jts,MIN(jte,jde-1)
!          DO k=kts,s_top(i,j)
!             scalar(i,k,j,is)=0.
!          ENDDO
!          ENDDO
!          ENDDO
          DO j = jts,MIN(jte,jde-1)
          DO i = its,MIN(ite,ide-1)
             grad(i,j) = 0.
          ENDDO
          ENDDO 
          if (config_flags%interp_opt == 1) then
             CALL neumann_lin( scalar(ims:ime,kms:kme,jms:jme,is), &
                               prox, config_flags%dim_terrain,     &
                               grad,                               &
                               top_norm, side_norm,                &
                               top_dist, side_dist,                &
                               top, top_img,                       &
                               side, side_img,                     &
                               top_neigh, side_neigh,              &
                               top_neigh_i, side_neigh_i,          &
                               n, ns,                              &
                               ids, ide, jds, jde, kds, kde,       &
                               ims, ime, jms, jme, kms, kme,       &
                               its, ite, jts, jte, kts, kte )
          elseif ((config_flags%interp_opt == 2).OR.(config_flags%interp_opt == 3)) then
             CALL neumann_inverse_dist( scalar(ims:ime,kms:kme,jms:jme,is), &
                                        prox, config_flags%dim_terrain,     &
                                        grad,                               &
                                        top_norm, side_norm,                &
                                        top_dist, side_dist,                &
                                        top, top_img,                       &
                                        side, side_img,                     &
                                        top_neigh, side_neigh,              &
                                        top_neigh_i, side_neigh_i,          &
                                        n, ns, ant, ans,                    &
                                        ids, ide, jds, jde, kds, kde,       &
                                        ims, ime, jms, jme, kms, kme,       &
                                        its, ite, jts, jte, kts, kte )
          endif
       ENDDO
    ENDIF
 endif
 
 ! deallocate side ghost points
 CALL wrf_debug(100,'deallocate dyn_em/module_ibm.F/subroutine scalar_ibm')
 DEALLOCATE (side)
 DEALLOCATE (side_img)
 DEALLOCATE (side_bound)
 DEALLOCATE (side_neigh)
 DEALLOCATE (side_neigh_i)
 DEALLOCATE (side_norm)
 DEALLOCATE (side_dist)
 DEALLOCATE (ans)

 END SUBROUTINE scalar_ibm

!--------------------------------------------------------------------------------------------------------------

 SUBROUTINE ibm_terrain ( config_flags,                 &
                          ibm_ht_u, ibm_ht_v,           &
                          ibm_ht_w, ibm_ht_c,           &
                          ibm_z0,                       &
                          ids, ide, jds, jde, kds, kde, &
                          ims, ime, jms, jme, kms, kme, &
                          its, ite, jts, jte, kts, kte )
  IMPLICIT NONE
  !input data
  TYPE(grid_config_rec_type), INTENT(IN   )           :: config_flags
  REAL, DIMENSION(ims:ime,jms:jme), INTENT(  OUT)     :: ibm_ht_u, &
                                                         ibm_ht_v, &
                                                         ibm_ht_w, &
                                                         ibm_ht_c, &
                                                         ibm_z0
  INTEGER, INTENT(IN   ) :: ids, ide, jds, jde, kds, kde, & !d: domain 
                            ims, ime, jms, jme, kms, kme, & !m:memory 
                            its, ite, jts, jte, kts, kte    !p:patch t:tile 
   
  !local data   
  INTEGER                                             :: i, j, k, &
                                                         icm,jcm   !mountain position in domain
  REAL                                                :: hm, xa,  & !mountain height, mountain half width
                                                         offset,  & !offset to make mountain terrain higher than 2nd grid pt.
                                                         slope,   & !RSA
                                                         xa1,     &
                                                         x_dist, y_dist, &
                                                         pi,      &
                                                         ru, rv, rw, rc, du, dv, dw, dc, dmid !DJW added for smoothing to zero near edges
  INTEGER                                             :: width, ista, iend, jsta, jend !DJW added for putting ridges on terrain
  REAL                                                :: height !DJW added for putting ridges on terrain
!---------------------------------------------------------------------------------
! this subroutine calculates the terrain height and is called once from start_em.F
! The terrain height has twice the resolution of the computational grid
! the terrain height is assigned on u,v,and w points.  It is also assigned at corners.
! Corners are located between v points in the x direction and between u points in the 
! y direction.
! the executable begins here
  CALL wrf_debug(100,'dyn_em/module_ibm.F/subroutine ibm_terrain')
!---------------------------------------------------------------------------------   

  pi = 2.*asin(1.0)

! ideal_terrain 0 = none 
! 1 = X m flat plate 
! 2 = 2d witch of agnesi hill in x
! 21 = 2d gaussian hill in x
! 3 = 3d witch of agnesi hill 
! 31 = 3d gaussian hill
! 4 = 2d ridge or isolated cube 
! 5 = 3d cube
! 6 = 2d idealized t-rex valley
! 7 = 3d idealized t-rex valley
! 8 = v shaped valley and ridges
! 81 = sinusoidal valley and ridges RSA
! 9 = Schar idealized advection test
! 10 = read data (1-d ht array)
! 11 = 2d witch of agnesi hill in y
! 13 = DJW OKC read from file
! 14 = RSA Granite Mountain read from file
! 15 = RSA/JB Askervein read from file

  IF (config_flags%ideal_terrain .EQ. 1) THEN    
    DO j=jts,jte
    DO i=its,ite
        IF (j .NE. jde) ibm_ht_u(i,j) = config_flags%ibm_flat_plate_ht
        IF (i .NE. ide) ibm_ht_v(i,j) = config_flags%ibm_flat_plate_ht
        IF ((i .NE. ide) .AND. (j .NE. jde)) ibm_ht_w(i,j) = config_flags%ibm_flat_plate_ht
        ibm_ht_c(i,j) = config_flags%ibm_flat_plate_ht
    ENDDO
    ENDDO

  ELSEIF (config_flags%ideal_terrain .EQ. 111) THEN
     !DJW a flat plate with added bumps to trip turbulence
     DO j=jts,jte
     DO i=its,ite
        IF (j .NE. jde) ibm_ht_u(i,j) = 0.0
        IF (i .NE. ide) ibm_ht_v(i,j) = 0.0
        IF ((i .NE. ide) .AND. (j .NE. jde)) ibm_ht_w(i,j) = 0.0
        ibm_ht_c(i,j) = 0.0
     ENDDO
     ENDDO
     height = 6.0
     width = 6
     write(*,'(A,I3,A,F5.1)') "DJW[module_ibm/ibm_terrain]: adding a cross to the flat plate with width=",width," and height=",height
     ista = (ide-ids)/2+ids-width
     iend = (ide-ids)/2+ids+width
     DO i=its,ite
        IF ((i .GE. ista) .AND. (i .LE. iend)) THEN
           DO j=jts,jte
              IF (j .NE. jde) ibm_ht_u(i,j) = height
              IF (i .NE. ide) ibm_ht_v(i,j) = height
              IF ((i .NE. ide) .AND. (j .NE. jde)) ibm_ht_w(i,j) = height
              ibm_ht_c(i,j) = height
           ENDDO
        ENDIF
     ENDDO
     jsta = (jde-jds)/2+jds-width
     jend = (jde-jds)/2+jds+width
     DO j=jts,jte
        IF ((j .GE. jsta) .AND. (j .LE. jend)) THEN
           DO i=its,ite
              IF (j .NE. jde) ibm_ht_u(i,j) = height
              IF (i .NE. ide) ibm_ht_v(i,j) = height
              IF ((i .NE. ide) .AND. (j .NE. jde)) ibm_ht_w(i,j) = height
              ibm_ht_c(i,j) = height
           ENDDO
        ENDIF
     ENDDO
     DO i=its,ite
        DO j=jts,jte
           IF ((i .LT. ids+2*config_flags%spec_bdy_width) .OR. &
               (i .GE. ide-2*config_flags%spec_bdy_width) .OR. &
               (j .LT. jds+2*config_flags%spec_bdy_width) .OR. &
               (j .GE. jde-2*config_flags%spec_bdy_width)) THEN
              IF (i .NE. ide) ibm_ht_u(i,j) = 0.0
              IF (j .NE. jde) ibm_ht_v(i,j) = 0.0
              IF ((i .NE. ide) .AND. (j .NE. jde)) ibm_ht_w(i,j) = 0.0
              ibm_ht_c(i,j) = 0.0
           ENDIF
        ENDDO
     ENDDO

!     write(*,'(A,I3,A,F5.1)') "DJW[module_ibm/ibm_terrain]: adding bumps to the flat plate with width=",width," and height=",height
!     ista = (ide-ids)/2+ids-width
!     iend = (ide-ids)/2+ids+width
!     DO i=its,ite
!        IF ((i .GE. ista) .AND. (i .LE. iend)) THEN
!           DO j=jts,jte
!              jsta = width*(j/width)
!              jend = jsta+width
!              IF ((j .NE. jde) .AND. (i .NE. ista) .AND. (j .NE. jsta)) THEN
!                 ibm_ht_u(i,j) = height*(1.0-ABS((ide-ids)/2.0+ids-(i-0.5))/width)*(1.0-ABS(jsta+width/2.0-j)/(width/2.0))
!              ENDIF
!              IF ((i .NE. ide) .AND. (i .NE. ista) .AND. (j .NE. jsta)) THEN
!                 ibm_ht_v(i,j) = height*(1.0-ABS((ide-ids)/2.0+ids-i)/width)*(1.0-ABS(jsta+width/2.0-(j-0.5))/(width/2.0))
!              ENDIF
!              IF ((j .NE. jde) .AND. (i .NE. ista)) THEN
!                 ibm_ht_w(i,j) = height*(1.0-ABS((ide-ids)/2.0+ids-i)/width)*(1.0-ABS(jsta+width/2.0-j)/(width/2.0))
!              ENDIF
!              ibm_ht_c(i,j) = height*(1.0-ABS((ide-ids)/2.0+ids-(i-0.5))/width)*(1.0-ABS(jsta+width/2.0-(j-0.5))/(width/2.0))
!           ENDDO
!        ENDIF
!     ENDDO
!     DO i=its,ite
!        DO j=jts,jte
!           IF ((i .LT. ids+config_flags%spec_bdy_width) .OR. &
!               (i .GE. ide-config_flags%spec_bdy_width) .OR. &
!               (j .LT. jds+config_flags%spec_bdy_width) .OR. &
!               (j .GE. jde-config_flags%spec_bdy_width)) THEN
!              IF (i .NE. ide) ibm_ht_u(i,j) = 0.0
!              IF (j .NE. jde) ibm_ht_v(i,j) = 0.0
!              IF ((i .NE. ide) .AND. (j .NE. jde)) ibm_ht_w(i,j) = 0.0
!              ibm_ht_c(i,j) = 0.0
!           ENDIF
!        ENDDO
!     ENDDO

  ELSEIF (config_flags%ideal_terrain .EQ. 112) THEN    
    DO j=jts,jte
    DO i=its,ite
       IF (j .NE. jde) ibm_ht_u(i,j) = 0.0
       IF (i .NE. ide) ibm_ht_v(i,j) = 0.0
       IF ((i .NE. ide) .AND. (j .NE. jde)) ibm_ht_w(i,j) = 0.0
       ibm_ht_c(i,j) = 0.0
    ENDDO
    ENDDO

    DO j=jts,jte
    DO i=its,ite
       IF ( (MOD(i/10, 2) .EQ. 1) .AND. (MOD(j/10, 2) .EQ. 1) ) THEN
          IF (j .NE. jde) ibm_ht_u(i,j) = 25.0
          IF (i .NE. ide) ibm_ht_v(i,j) = 25.0
          IF ((i .NE. ide) .AND. (j .NE. jde)) ibm_ht_w(i,j) = 25.0
          ibm_ht_c(i,j) = 25.0
       ENDIF
    ENDDO
    ENDDO

    DO j=jts,jte
    DO i=its,ite
!       IF ( ((i .GE. 10*(30/10)) .AND. (i .LE. ide-10*(30/10))) .AND. &
!            ((j .GE. 10*(34/10)) .AND. (j .LE. jde-10*(34/10))) ) THEN
!          IF (j .NE. jde) ibm_ht_u(i,j) = 0.0
!          IF (i .NE. ide) ibm_ht_v(i,j) = 0.0
!          IF ((i .NE. ide) .AND. (j .NE. jde)) ibm_ht_w(i,j) = 0.0
!          ibm_ht_c(i,j) = 0.0
!       ENDIF
       IF ( (i .LE. 5) .OR. (i .GE. 10*ide/10-6 ) .OR. &
            (j .LE. 5) .OR. (j .GE. 10*jde/10-6 ) ) THEN
          IF (j .NE. jde) ibm_ht_u(i,j) = 0.0
          IF (i .NE. ide) ibm_ht_v(i,j) = 0.0
          IF ((i .NE. ide) .AND. (j .NE. jde)) ibm_ht_w(i,j) = 0.0
          ibm_ht_c(i,j) = 0.0
       ENDIF
    ENDDO
    ENDDO    

  ELSEIF (config_flags%ideal_terrain .EQ. 113) THEN    
    DO j=jts,jte
    DO i=its,ite
       IF (j .NE. jde) ibm_ht_u(i,j) = 0.0
       IF (i .NE. ide) ibm_ht_v(i,j) = 0.0
       IF ((i .NE. ide) .AND. (j .NE. jde)) ibm_ht_w(i,j) = 0.0
       ibm_ht_c(i,j) = 0.0
    ENDDO
    ENDDO

    DO j=jts,jte
    DO i=its,ite
       IF ( (MOD(i/10, 2) .EQ. 1) .AND. (MOD(j/10, 2) .EQ. 1) ) THEN
          IF (j .NE. jde) ibm_ht_u(i,j) = 25.0
          IF (i .NE. ide) ibm_ht_v(i,j) = 25.0
          IF ((i .NE. ide) .AND. (j .NE. jde)) ibm_ht_w(i,j) = 25.0
          ibm_ht_c(i,j) = 25.0
       ENDIF
    ENDDO
    ENDDO

    write(*,'(A,I1)') "model_config_rec%max_dom = ",model_config_rec%max_dom

    DO j=jts,jte
    DO i=its,ite
!       IF ( ((i .GE. 10*(30/10)) .AND. (i .LE. ide-10*(30/10))) .AND. &
!            ((j .GE. 10*(34/10)) .AND. (j .LE. jde-10*(34/10))) ) THEN
!          IF (j .NE. jde) ibm_ht_u(i,j) = 0.0
!          IF (i .NE. ide) ibm_ht_v(i,j) = 0.0
!          IF ((i .NE. ide) .AND. (j .NE. jde)) ibm_ht_w(i,j) = 0.0
!          ibm_ht_c(i,j) = 0.0
!       ENDIF
       IF ( (i .LE. 5) .OR. (i .GE. 10*ide/10-6 ) .OR. &
            (j .LE. 5) .OR. (j .GE. 10*jde/10-6 ) ) THEN
          IF (j .NE. jde) ibm_ht_u(i,j) = 0.0
          IF (i .NE. ide) ibm_ht_v(i,j) = 0.0
          IF ((i .NE. ide) .AND. (j .NE. jde)) ibm_ht_w(i,j) = 0.0
          ibm_ht_c(i,j) = 0.0
       ENDIF
    ENDDO
    ENDDO    

  ELSEIF ((config_flags%ideal_terrain .EQ. 2) .OR. &
          (config_flags%ideal_terrain .EQ. 3) .OR. &
          (config_flags%ideal_terrain .EQ. 33) .OR. &
          (config_flags%ideal_terrain .EQ. 11)) THEN
     !set the dimensions for the gaussian shaped hill 

     ! xa = 3000.0 
     ! 10 degree slope
     ! hm = 830.0   
     ! offset = -32.0
     ! 30 degree slope
     ! hm = 2720.0
     ! offset = -108.0
     ! 50 degree slope
     ! hm = 5615.0
     ! offset = -223.0

     !xa = 200.0
     !hm = 100.0 ! was 75. for 3d hill cases
     !offset = 0.0

     ! 10 degree slope
     ! hm = 218.0
     ! offset = -14.0
     ! 20 degree slope
     ! hm = 451.0
     ! offset = -30.0
     ! 30 degree slope
     !    hm = 716.0
     !   offset = -25.0
     ! 40 degree slope
     ! hm = 1041.0
     ! offset = -71.0
     !xa = 1900.0
     !hm = 2300.0
     !offset = 0.0

     ! for Zangl 2003/2004 case
!     hm = 1500.0
!     xa = 5000.0
     ! for more severe Zangl type atmosphere at rest case
!     hm = 4554.0
!     xa = 5000.0

!     xa = 90.0
!     hm = 180.0
!     offset = 0.0

!     xa = 60.0
!     hm = 30.0
!     offset = 0.0

     !RSA for Lundquist et al. (2012) case
!     hm = 350.0
!     xa = 800.0
!     offset = 0.0

!     hm = 50.0
!     xa = 25.0
!     offset = 0.0

     !DJW for grid resolution study 2019
     hm = 250.0
     xa = 800.0
     offset = 0.0

     icm = ide/2
     jcm = jde/2
     IF (config_flags%ideal_terrain .EQ. 2) THEN
        DO j=jts,jte
        DO i=its,ite

           !! the height function at u and v levels could be specified by with an 
           !! equation or by averaging.  These are the equations.
           !if (j /= jde) ibm_ht_u(i,j) = offset + hm/(1.+((float(i-icm)-0.5)/xa)**2)
           !if (i /= ide) ibm_ht_v(i,j) = offset + hm/(1.+(float(i-icm)/xa)**2)   
           !if ((i /= ide) .AND. (j /= jde)) ibm_ht_w(i,j) = offset + hm/(1.+(float(i-icm)/xa)**2)
           !ibm_ht_c(i,j) = offset + hm/(1.+((float(i-icm)-0.5)/xa)**2)

           ! hill in the y direction
           ! if (j /= jde) ibm_ht_u(i,j) = offset + hm/(1.+(float(j-jcm)/xa)**2)
           ! if (i /= ide) ibm_ht_v(i,j) = offset + hm/(1.+((float(j-jcm)-0.5)/xa)**2)
           ! ibm_ht_w(i,j) = offset + hm/(1.+(float(j-jcm)/xa)**2)
           ! ibm_ht_c(i,j) = offset + hm/(1.+((float(j-jcm)-0.5)/xa)**2)

           ! hill in the x direction
           x_dist = (-ide/2.)*config_flags%dx + i*config_flags%dx
           if ((i /= ide) .AND. (j /= jde)) ibm_ht_w(i,j) = offset + hm/(1.+(x_dist/xa)**2)
           if (i /= ide) ibm_ht_v(i,j) = offset + hm/(1.+(x_dist/xa)**2)
           x_dist = (-ide/2.)*config_flags%dx - config_flags%dx/2. + i*config_flags%dx
           if (j /= jde) ibm_ht_u(i,j) = offset + hm/(1.+(x_dist/xa)**2)
           ibm_ht_c(i,j) = offset + hm/(1.+(x_dist/xa)**2)
           ! hill in the y direction
           ! y_dist = (-jde/2.)*config_flags%dy + j*config_flags%dy
           ! if ((i /= ide) .AND. (j /= jde)) ibm_ht_w(i,j) = offset + hm/(1.+(y_dist/xa)**2)
           ! if (j /= jde) ibm_ht_u(i,j) = offset + hm/(1.+(y_dist/xa)**2)
           ! y_dist = (-jde/2.)*config_flags%dy - config_flags%dy/2. + j*config_flags%dy
           ! if (i /= ide) ibm_ht_v(i,j) = offset + hm/(1.+(y_dist/xa)**2)
           ! ibm_ht_c(i,j) = offset + hm/(1.+(y_dist/xa)**2)

        ENDDO
        ENDDO
     ELSEIF (config_flags%ideal_terrain .EQ. 11) THEN
        DO j=jts,jte
        DO i=its,ite

           !! the height function at u and v levels could be specified by with an 
           !! equation or by averaging.  These are the equations.
           !if (j /= jde) ibm_ht_u(i,j) = offset + hm/(1.+((float(i-icm)-0.5)/xa)**2)
           !if (i /= ide) ibm_ht_v(i,j) = offset + hm/(1.+(float(i-icm)/xa)**2)   
           !if ((i /= ide) .AND. (j /= jde)) ibm_ht_w(i,j) = offset + hm/(1.+(float(i-icm)/xa)**2)
           !ibm_ht_c(i,j) = offset + hm/(1.+((float(i-icm)-0.5)/xa)**2)

           ! hill in the y direction
           ! if (j /= jde) ibm_ht_u(i,j) = offset + hm/(1.+(float(j-jcm)/xa)**2)
           ! if (i /= ide) ibm_ht_v(i,j) = offset + hm/(1.+((float(j-jcm)-0.5)/xa)**2)
           ! ibm_ht_w(i,j) = offset + hm/(1.+(float(j-jcm)/xa)**2)
           ! ibm_ht_c(i,j) = offset + hm/(1.+((float(j-jcm)-0.5)/xa)**2)

           x_dist = (-jde/2.)*config_flags%dy + j*config_flags%dy
           if ((i /= ide) .AND. (j /= jde)) ibm_ht_w(i,j) = offset + hm/(1.+(x_dist/xa)**2)
           if (j /= jde) ibm_ht_u(i,j) = offset + hm/(1.+(x_dist/xa)**2)
           x_dist = (-jde/2.)*config_flags%dy - config_flags%dy/2. + j*config_flags%dy
           if (i /= ide) ibm_ht_v(i,j) = offset + hm/(1.+(x_dist/xa)**2)
           ibm_ht_c(i,j) = offset + hm/(1.+(x_dist/xa)**2)

        ENDDO
        ENDDO
     ELSEIF ((config_flags%ideal_terrain .EQ. 3) .OR. (config_flags%ideal_terrain .EQ. 33)) THEN
        DO j=jts,jte
        DO i=its,ite
           ! use this for gaussian bump
           !if (j /= jde) ibm_ht_u(i,j) = hm/(1.+((float(i-icm)-0.5)/xa)**2+(float(j-jcm)/xa)**2)
           !if (i /= ide) ibm_ht_v(i,j) = hm/(1.+(float(i-icm)/xa)**2+((float(j-jcm)-0.5)/xa)**2) 
           !if ((i /= ide) .AND. (j /= jde)) then
           !    ibm_ht_w(i,j) = hm/(1.+(float(i-icm)/xa)**2+(float(j-jcm)/xa)**2)
           !endif 
           !ibm_ht_c(i,j) = hm/(1.+((float(i-icm)-0.5)/xa)**2+((float(j-jcm)-0.5)/xa)**2)

           x_dist = (-ide/2.0)*config_flags%dx + i*config_flags%dx
           y_dist = (-jde/2.0)*config_flags%dy + j*config_flags%dy
           IF ((i .NE. ide) .AND. (j .NE. jde)) THEN
              ibm_ht_w(i,j) = offset + hm/(1.0+(x_dist/xa)**2+(y_dist/xa)**2)
           ENDIF

           x_dist = (-ide/2.0)*config_flags%dx + i*config_flags%dx
           y_dist = (-jde/2.0)*config_flags%dy - config_flags%dy/2.0 + j*config_flags%dy
           IF (i .NE. ide) THEN
              ibm_ht_v(i,j) = offset + hm/(1.0+(x_dist/xa)**2+(y_dist/xa)**2)
           ENDIF

           x_dist = (-ide/2.0)*config_flags%dx - config_flags%dx/2.0 + i*config_flags%dx
           y_dist = (-jde/2.0)*config_flags%dy + j*config_flags%dy
           IF (j .NE. jde) THEN
              ibm_ht_u(i,j) = offset + hm/(1.0+(x_dist/xa)**2+(y_dist/xa)**2)
           ENDIF

           x_dist = (-ide/2.0)*config_flags%dx - config_flags%dx/2.0 + i*config_flags%dx
           y_dist = (-jde/2.0)*config_flags%dy - config_flags%dy/2.0 + j*config_flags%dy
           ibm_ht_c(i,j) = offset + hm/(1.0+(x_dist/xa)**2+(y_dist/xa)**2)
        ENDDO
        ENDDO

        IF (config_flags%ideal_terrain .EQ. 33) THEN
            !DJW smooth the edges so that they linearly approach zero at the boundary-zone and
            !    are zero within the boundary-zone.
            dmid = MIN(config_flags%dx*ide, config_flags%dy*jde)/2.0 - config_flags%spec_bdy_width*MAX(config_flags%dx, config_flags%dy)
            offset = (config_flags%spec_bdy_width * MAX(config_flags%dx, config_flags%dy))
            DO j=jts,jte
                DO i=its,ite
                    dw = ( (config_flags%dy*(j-(jde-jds)/2))**2 + &
                           (config_flags%dx*(i-(ide-ids)/2))**2 )**(1.0/2.0)
                    du = ( (config_flags%dy*(j-(jde-jds)/2))**2 + &
                           (config_flags%dx*(i-0.5-(ide-ids)/2))**2 )**(1.0/2.0)
                    dv = ( (config_flags%dy*(j-0.5-(jde-jds)/2))**2 + &
                           (config_flags%dx*(i-(ide-ids)/2))**2 )**(1.0/2.0)
                    dc = ( (config_flags%dy*(j-0.5-(jde-jds)/2))**2 + &
                           (config_flags%dx*(i-0.5-(ide-ids)/2))**2 )**(1.0/2.0)
                    rc = MIN(1.0, MAX((dmid-dc)/offset, 0.0))
                    rw = MIN(1.0, MAX((dmid-dw)/offset, 0.0))
                    ru = MIN(1.0, MAX((dmid-du)/offset, 0.0))
                    rv = MIN(1.0, MAX((dmid-dv)/offset, 0.0))
                    ibm_ht_c(i,j) = ibm_ht_c(i,j)*rc
                    IF ((i .NE. ide) .AND. (j .NE. jde)) ibm_ht_w(i,j) = ibm_ht_w(i,j)*rw
                    IF (i .NE. ide) ibm_ht_v(i,j) = ibm_ht_v(i,j)*rv
                    IF (j .NE. jde) ibm_ht_u(i,j) = ibm_ht_u(i,j)*ru
                ENDDO
            ENDDO
            write(*,'(4(A,I3),A)') "DJW[module_ibm/ibm_terrain]: ibm_ht_w(",its,":",ite,", ",jts,":",jte,") is below,"
            write(*,'(A)',ADVANCE='NO') "      "
            DO i=its,ite-1
               write(*,'(I5,A)',ADVANCE='NO') i," "
            ENDDO
            write(*,'(I5)') ite
            DO j=jte,jts,-1
               write(*,'(I3,A)',ADVANCE='NO') j,"   "
               DO i=its,ite-1
                  write(*,'(F5.1,A)',ADVANCE='NO') ibm_ht_w(i,j)," "
               ENDDO
               write(*,'(F5.1)') ibm_ht_w(ite,j)
            ENDDO
        ENDIF

     ENDIF !end of ideal_terrain == 2 or 3
  ELSEIF (config_flags%ideal_terrain .EQ. 21) THEN
     !RSA 2d gaussian hill to roughly match Askervein transect A
     xa = 150.0
     hm = 100.0
     offset = 0.0
     DO j=jts,jte
     DO i=its,ite
        x_dist = (-ide/2.)*config_flags%dx + i*config_flags%dx
        if ((i /= ide) .AND. (j /= jde)) ibm_ht_w(i,j) = offset + hm*exp(-0.5*(x_dist/xa)**2)
        if (i /= ide) ibm_ht_v(i,j) = offset + hm*exp(-0.5*(x_dist/xa)**2)
        x_dist = (-ide/2.)*config_flags%dx - config_flags%dx/2. + i*config_flags%dx
        if (j /= jde) ibm_ht_u(i,j) = offset + hm*exp(-0.5*(x_dist/xa)**2)
        ibm_ht_c(i,j) = offset + hm*exp(-0.5*(x_dist/xa)**2)
     ENDDO
     ENDDO
  ELSEIF (config_flags%ideal_terrain .EQ. 31) THEN
     !RSA 3d gaussian hill roughly the scale of Askervein
     xa = 150.0
     hm = 100.0
     offset = 0.0

     DO j=jts,jte
     DO i=its,ite
        x_dist = (-ide/2.0)*config_flags%dx + i*config_flags%dx
        y_dist = (-jde/2.0)*config_flags%dy + j*config_flags%dy
        IF ((i .NE. ide) .AND. (j .NE. jde)) THEN
           ibm_ht_w(i,j) = offset + hm*exp(-0.5*((x_dist/xa)**2+(y_dist/xa)**2))
        ENDIF

        x_dist = (-ide/2.0)*config_flags%dx + i*config_flags%dx
        y_dist = (-jde/2.0)*config_flags%dy - config_flags%dy/2.0 + j*config_flags%dy
        IF (i .NE. ide) THEN
           ibm_ht_v(i,j) = offset + hm*exp(-0.5*((x_dist/xa)**2+(y_dist/xa)**2))
        ENDIF

        x_dist = (-ide/2.0)*config_flags%dx - config_flags%dx/2.0 + i*config_flags%dx
        y_dist = (-jde/2.0)*config_flags%dy + j*config_flags%dy
        IF (j .NE. jde) THEN
           ibm_ht_u(i,j) = offset + hm*exp(-0.5*((x_dist/xa)**2+(y_dist/xa)**2))
        ENDIF

        x_dist = (-ide/2.0)*config_flags%dx - config_flags%dx/2.0 + i*config_flags%dx
        y_dist = (-jde/2.0)*config_flags%dy - config_flags%dy/2.0 + j*config_flags%dy
        ibm_ht_c(i,j) = offset + hm*exp(-0.5*((x_dist/xa)**2+(y_dist/xa)**2))
     ENDDO
     ENDDO
  ELSEIF (config_flags%ideal_terrain .EQ. 4) THEN
     ! This is for the 2d isolated cube (ridge) case

     ! parameters used for the bolund case
     !xa = 20.0
     !hm = 10.0
     !offset = 0.75

     ! parameters used for the 3d hill case
     xa = 150.0
     hm = 50.0
     offset = 0.0
    
     DO j=jts,jte
     DO i=its,ite
        if (j /= jde) ibm_ht_u(i,j)=offset
        if (i /= ide) ibm_ht_v(i,j)=offset
        if ((i /= ide) .AND. (j /= jde)) ibm_ht_w(i,j)=offset
        ibm_ht_c(i,j)=offset
        icm = jde/4
        x_dist = -icm*config_flags%dy + j*config_flags%dy
        if (ABS(x_dist)<=xa) then
           if ((i /= ide) .AND. (j /= jde)) ibm_ht_w(i,j) = offset + hm
           if (i /= ide) ibm_ht_v(i,j) = offset + hm
        endif  
        x_dist = -icm*config_flags%dy - config_flags%dy/2.0 + j*config_flags%dy
        if (ABS(x_dist)<=xa) then
           if (j /= jde) ibm_ht_u(i,j) = offset + hm
           ibm_ht_c(i,j) = offset + hm
        endif  
     ENDDO
     ENDDO

  ELSEIF (config_flags%ideal_terrain .EQ. 5) THEN   

     ! This is for the 3d isolated cube case
     xa = 48.0
     hm = 60.0
     !hm = 74.6385
     offset = 50.0
     icm = ide/2
     jcm = jde/2
     DO j=jts,jte
     DO i=its,ite    
        x_dist = -icm*config_flags%dx + i*config_flags%dx
        y_dist = -jcm*config_flags%dy + j*config_flags%dy
        IF ((ABS(x_dist) .LE. xa) .AND. (ABS(y_dist) .LE. xa)) THEN
           IF ((i .NE. ide) .AND. (j .NE. jde)) ibm_ht_w(i,j) = offset + hm
        ELSE
           IF ((i .NE. ide) .AND. (j .NE. jde)) ibm_ht_w(i,j) = offset
        ENDIF
        y_dist = -jcm*config_flags%dy - config_flags%dy/2.0 + j*config_flags%dy
        IF ((ABS(x_dist) .LE. xa) .AND. (ABS(y_dist) .LE. xa)) THEN
           IF (i .NE. ide) ibm_ht_v(i,j) = offset + hm
        ELSE
           IF (i .NE. ide) ibm_ht_v(i,j) = offset
        ENDIF     
        x_dist = -icm*config_flags%dx - config_flags%dx/2.0 + i*config_flags%dx
        y_dist = -jcm*config_flags%dy + j*config_flags%dy
        IF ((ABS(x_dist) .LE. xa) .AND. (ABS(y_dist) .LE. xa)) THEN
           IF (j .NE. jde) ibm_ht_u(i,j) = offset + hm
        ELSE
           IF (j .NE. jde) ibm_ht_u(i,j) = offset
        ENDIF     
        y_dist = -jcm*config_flags%dy - config_flags%dy/2.0 + j*config_flags%dy
        IF ((ABS(x_dist) .LE. xa) .AND. (ABS(y_dist) .LE. xa)) THEN
           ibm_ht_c(i,j) = offset + hm
        ELSE
           ibm_ht_c(i,j) = offset
        ENDIF
     ENDDO      
     ENDDO 

!  ! This is for the 3d array of cubes case
!  xa = 30.
!  hm = 150.
!  offset = 25.
!  DO j=jts,jte
!  DO i=its,ite  
!     ! set the base terrain
!     if ((i /= ide) .AND. (j /= jde)) ibm_ht_w(i,j) = offset
!     if (i /= ide) ibm_ht_v(i,j) = offset
!     if (j /= jde) ibm_ht_u(i,j) = offset
!     ibm_ht_c(i,j) = offset	 
!
!     icm = ide/4.
!     jcm = jde/4.  
!     x_dist = -icm*config_flags%dx + i*config_flags%dx
!     y_dist = -jcm*config_flags%dy + j*config_flags%dy
!     if ((ABS(x_dist)<=xa).AND.(ABS(y_dist)<=xa)) then
!	  if ((i /= ide) .AND. (j /= jde)) ibm_ht_w(i,j) = offset + hm
!     endif
!     y_dist = -jcm*config_flags%dy - config_flags%dy/2. + j*config_flags%dy
!     if ((ABS(x_dist)<=xa).AND.(ABS(y_dist)<=xa)) then
!	  if (i /= ide) ibm_ht_v(i,j) = offset + hm
!     endif	 
!     x_dist = -icm*config_flags%dx - config_flags%dx/2. + i*config_flags%dx
!     y_dist = -jcm*config_flags%dy + j*config_flags%dy
!     if ((ABS(x_dist)<=xa).AND.(ABS(y_dist)<=xa)) then
!	  if (j /= jde) ibm_ht_u(i,j) = offset + hm
!     endif	 
!     y_dist = -jcm*config_flags%dy - config_flags%dy/2. + j*config_flags%dy
!     if ((ABS(x_dist)<=xa).AND.(ABS(y_dist)<=xa)) then
!	  ibm_ht_c(i,j) = offset + hm
!     endif
!
!     icm = ide/4.
!     jcm = jde/2.  
!     x_dist = -icm*config_flags%dx + i*config_flags%dx
!     y_dist = -jcm*config_flags%dy + j*config_flags%dy
!     if ((ABS(x_dist)<=xa).AND.(ABS(y_dist)<=xa)) then
!	  if ((i /= ide) .AND. (j /= jde)) ibm_ht_w(i,j) = offset + hm
!     endif
!     y_dist = -jcm*config_flags%dy - config_flags%dy/2. + j*config_flags%dy
!     if ((ABS(x_dist)<=xa).AND.(ABS(y_dist)<=xa)) then
!	  if (i /= ide) ibm_ht_v(i,j) = offset + hm
!     endif	 
!     x_dist = -icm*config_flags%dx - config_flags%dx/2. + i*config_flags%dx
!     y_dist = -jcm*config_flags%dy + j*config_flags%dy
!     if ((ABS(x_dist)<=xa).AND.(ABS(y_dist)<=xa)) then
!	  if (j /= jde) ibm_ht_u(i,j) = offset + hm
!     endif	 
!     y_dist = -jcm*config_flags%dy - config_flags%dy/2. + j*config_flags%dy
!     if ((ABS(x_dist)<=xa).AND.(ABS(y_dist)<=xa)) then
!	  ibm_ht_c(i,j) = offset + hm
!     endif	 
!
!     icm = ide/4.
!     jcm = 3*jde/4.  
!     x_dist = -icm*config_flags%dx + i*config_flags%dx
!     y_dist = -jcm*config_flags%dy + j*config_flags%dy
!     if ((ABS(x_dist)<=xa).AND.(ABS(y_dist)<=xa)) then
!	  if ((i /= ide) .AND. (j /= jde)) ibm_ht_w(i,j) = offset + hm
!     endif
!     y_dist = -jcm*config_flags%dy - config_flags%dy/2. + j*config_flags%dy
!     if ((ABS(x_dist)<=xa).AND.(ABS(y_dist)<=xa)) then
!	  if (i /= ide) ibm_ht_v(i,j) = offset + hm
!     endif	 
!     x_dist = -icm*config_flags%dx - config_flags%dx/2. + i*config_flags%dx
!     y_dist = -jcm*config_flags%dy + j*config_flags%dy
!     if ((ABS(x_dist)<=xa).AND.(ABS(y_dist)<=xa)) then
!	  if (j /= jde) ibm_ht_u(i,j) = offset + hm
!     endif	 
!     y_dist = -jcm*config_flags%dy - config_flags%dy/2. + j*config_flags%dy
!     if ((ABS(x_dist)<=xa).AND.(ABS(y_dist)<=xa)) then
!	  ibm_ht_c(i,j) = offset + hm
!     endif   
!
!     icm = ide/2.
!     jcm = jde/4.  
!     x_dist = -icm*config_flags%dx + i*config_flags%dx
!     y_dist = -jcm*config_flags%dy + j*config_flags%dy
!     if ((ABS(x_dist)<=xa).AND.(ABS(y_dist)<=xa)) then
!	  if ((i /= ide) .AND. (j /= jde)) ibm_ht_w(i,j) = offset + hm
!     endif
!     y_dist = -jcm*config_flags%dy - config_flags%dy/2. + j*config_flags%dy
!     if ((ABS(x_dist)<=xa).AND.(ABS(y_dist)<=xa)) then
!	  if (i /= ide) ibm_ht_v(i,j) = offset + hm
!     endif	 
!     x_dist = -icm*config_flags%dx - config_flags%dx/2. + i*config_flags%dx
!     y_dist = -jcm*config_flags%dy + j*config_flags%dy
!     if ((ABS(x_dist)<=xa).AND.(ABS(y_dist)<=xa)) then
!	  if (j /= jde) ibm_ht_u(i,j) = offset + hm
!     endif	 
!     y_dist = -jcm*config_flags%dy - config_flags%dy/2. + j*config_flags%dy
!     if ((ABS(x_dist)<=xa).AND.(ABS(y_dist)<=xa)) then
!	  ibm_ht_c(i,j) = offset + hm
!     endif
!
!     icm = ide/2.
!     jcm = jde/2.  
!     x_dist = -icm*config_flags%dx + i*config_flags%dx
!     y_dist = -jcm*config_flags%dy + j*config_flags%dy
!     if ((ABS(x_dist)<=xa).AND.(ABS(y_dist)<=xa)) then
!	  if ((i /= ide) .AND. (j /= jde)) ibm_ht_w(i,j) = offset + hm
!     endif
!     y_dist = -jcm*config_flags%dy - config_flags%dy/2. + j*config_flags%dy
!     if ((ABS(x_dist)<=xa).AND.(ABS(y_dist)<=xa)) then
!	  if (i /= ide) ibm_ht_v(i,j) = offset + hm
!     endif	 
!     x_dist = -icm*config_flags%dx - config_flags%dx/2. + i*config_flags%dx
!     y_dist = -jcm*config_flags%dy + j*config_flags%dy
!     if ((ABS(x_dist)<=xa).AND.(ABS(y_dist)<=xa)) then
!	  if (j /= jde) ibm_ht_u(i,j) = offset + hm
!     endif	 
!     y_dist = -jcm*config_flags%dy - config_flags%dy/2. + j*config_flags%dy
!     if ((ABS(x_dist)<=xa).AND.(ABS(y_dist)<=xa)) then
!	  ibm_ht_c(i,j) = offset + hm
!     endif	 
!
!     icm = ide/2.
!     jcm = 3*jde/4.  
!     x_dist = -icm*config_flags%dx + i*config_flags%dx
!     y_dist = -jcm*config_flags%dy + j*config_flags%dy
!     if ((ABS(x_dist)<=xa).AND.(ABS(y_dist)<=xa)) then
!	  if ((i /= ide) .AND. (j /= jde)) ibm_ht_w(i,j) = offset + hm
!     endif
!     y_dist = -jcm*config_flags%dy - config_flags%dy/2. + j*config_flags%dy
!     if ((ABS(x_dist)<=xa).AND.(ABS(y_dist)<=xa)) then
!	  if (i /= ide) ibm_ht_v(i,j) = offset + hm
!     endif	 
!     x_dist = -icm*config_flags%dx - config_flags%dx/2. + i*config_flags%dx
!     y_dist = -jcm*config_flags%dy + j*config_flags%dy
!     if ((ABS(x_dist)<=xa).AND.(ABS(y_dist)<=xa)) then
!	  if (j /= jde) ibm_ht_u(i,j) = offset + hm
!     endif	 
!     y_dist = -jcm*config_flags%dy - config_flags%dy/2. + j*config_flags%dy
!     if ((ABS(x_dist)<=xa).AND.(ABS(y_dist)<=xa)) then
!	  ibm_ht_c(i,j) = offset + hm
!     endif   
!
!     icm = 3*ide/4.
!     jcm = jde/4.  
!     x_dist = -icm*config_flags%dx + i*config_flags%dx
!     y_dist = -jcm*config_flags%dy + j*config_flags%dy
!     if ((ABS(x_dist)<=xa).AND.(ABS(y_dist)<=xa)) then
!	  if ((i /= ide) .AND. (j /= jde)) ibm_ht_w(i,j) = offset + hm
!     endif
!     y_dist = -jcm*config_flags%dy - config_flags%dy/2. + j*config_flags%dy
!     if ((ABS(x_dist)<=xa).AND.(ABS(y_dist)<=xa)) then
!	  if (i /= ide) ibm_ht_v(i,j) = offset + hm
!     endif	 
!     x_dist = -icm*config_flags%dx - config_flags%dx/2. + i*config_flags%dx
!     y_dist = -jcm*config_flags%dy + j*config_flags%dy
!     if ((ABS(x_dist)<=xa).AND.(ABS(y_dist)<=xa)) then
!	  if (j /= jde) ibm_ht_u(i,j) = offset + hm
!     endif	 
!     y_dist = -jcm*config_flags%dy - config_flags%dy/2. + j*config_flags%dy
!     if ((ABS(x_dist)<=xa).AND.(ABS(y_dist)<=xa)) then
!	  ibm_ht_c(i,j) = offset + hm
!     endif
!
!     icm = 3*ide/4.
!     jcm = jde/2.  
!     x_dist = -icm*config_flags%dx + i*config_flags%dx
!     y_dist = -jcm*config_flags%dy + j*config_flags%dy
!     if ((ABS(x_dist)<=xa).AND.(ABS(y_dist)<=xa)) then
!	  if ((i /= ide) .AND. (j /= jde)) ibm_ht_w(i,j) = offset + hm
!     endif
!     y_dist = -jcm*config_flags%dy - config_flags%dy/2. + j*config_flags%dy
!     if ((ABS(x_dist)<=xa).AND.(ABS(y_dist)<=xa)) then
!	  if (i /= ide) ibm_ht_v(i,j) = offset + hm
!     endif	 
!     x_dist = -icm*config_flags%dx - config_flags%dx/2. + i*config_flags%dx
!     y_dist = -jcm*config_flags%dy + j*config_flags%dy
!     if ((ABS(x_dist)<=xa).AND.(ABS(y_dist)<=xa)) then
!	  if (j /= jde) ibm_ht_u(i,j) = offset + hm
!     endif	 
!     y_dist = -jcm*config_flags%dy - config_flags%dy/2. + j*config_flags%dy
!     if ((ABS(x_dist)<=xa).AND.(ABS(y_dist)<=xa)) then
!	  ibm_ht_c(i,j) = offset + hm
!     endif	 
!
!     icm = 3*ide/4.
!     jcm = 3*jde/4.  
!     x_dist = -icm*config_flags%dx + i*config_flags%dx
!     y_dist = -jcm*config_flags%dy + j*config_flags%dy
!     if ((ABS(x_dist)<=xa).AND.(ABS(y_dist)<=xa)) then
!	  if ((i /= ide) .AND. (j /= jde)) ibm_ht_w(i,j) = offset + hm
!     endif
!     y_dist = -jcm*config_flags%dy - config_flags%dy/2. + j*config_flags%dy
!     if ((ABS(x_dist)<=xa).AND.(ABS(y_dist)<=xa)) then
!	  if (i /= ide) ibm_ht_v(i,j) = offset + hm
!     endif	 
!     x_dist = -icm*config_flags%dx - config_flags%dx/2. + i*config_flags%dx
!     y_dist = -jcm*config_flags%dy + j*config_flags%dy
!     if ((ABS(x_dist)<=xa).AND.(ABS(y_dist)<=xa)) then
!	  if (j /= jde) ibm_ht_u(i,j) = offset + hm
!     endif	 
!     y_dist = -jcm*config_flags%dy - config_flags%dy/2. + j*config_flags%dy
!     if ((ABS(x_dist)<=xa).AND.(ABS(y_dist)<=xa)) then
!	  ibm_ht_c(i,j) = offset + hm
!     endif		   
!
!   ENDDO      
!   ENDDO	  
  ELSEIF (config_flags%ideal_terrain .EQ. 6) THEN
     hm = 1500.0
     DO j=jts,jte
     DO i=its,ite 
        !calculate x with x=0 as the middle of the domain
        x_dist = (-ide/2.0)*config_flags%dx + i*config_flags%dx
        IF (ABS(x_dist) .LE. 500.0) THEN
           IF ((i .NE. ide) .AND. (j .NE. jde)) ibm_ht_w(i,j) = 0.0
           IF (i .NE. ide) ibm_ht_v(i,j) = 0.0
        ELSEIF ((ABS(x_dist) .GT. 500.0) .AND. (ABS(x_dist) .LT. 9500.0)) THEN
           IF ((i .NE. ide) .AND. (j .NE. jde)) ibm_ht_w(i,j) = hm*(0.5 - 0.5*COS((pi*(ABS(x_dist)-500.0))/9000.0))
           IF (i .NE. ide) ibm_ht_v(i,j) = hm*(0.5 - 0.5*COS((pi*(ABS(x_dist)-500.0))/9000.0))
        ELSEIF ((ABS(x_dist) .GE. 9500.0) .AND. (ABS(x_dist) .LE. 10500.0)) THEN
           IF ((i .NE. ide) .AND. (j .NE. jde)) ibm_ht_w(i,j) = hm
           IF (i .NE. ide) ibm_ht_v(i,j) = hm
        ELSEIF ((ABS(x_dist) .GT. 10500.0) .AND. (ABS(x_dist) .LT. 19500.0)) THEN
           IF ((i .NE. ide) .AND. (j .NE. jde)) ibm_ht_w(i,j) = hm*(0.5 + 0.5*COS((pi*(ABS(x_dist)-10500.0))/9000.0))
           IF (i .NE. ide) ibm_ht_v(i,j) = hm*(0.5 + 0.5*COS((pi*(ABS(x_dist)-10500.0))/9000.0))
        ELSEIF (ABS(x_dist).GE. 19500.0) then
           IF ((i .NE. ide) .AND. (j .NE. jde)) ibm_ht_w(i,j) = 0.0
           IF (i .NE. ide) ibm_ht_v(i,j) = 0.0
        ENDIF
     ENDDO
     ENDDO
     DO j=jts,jte
     DO i=its,ite 
        !calculate x with x=0 as the middle of the domain
        x_dist = (-ide/2.0)*config_flags%dx - config_flags%dx/2.0 + i*config_flags%dx
        IF (ABS(x_dist) .LE. 500.0) THEN
           IF (j .NE. jde) ibm_ht_u(i,j) = 0.0
           ibm_ht_c(i,j) = 0.0
        ELSEIF ((ABS(x_dist) .GT. 500.0) .AND. (ABS(x_dist) .LT. 9500.0)) THEN
           IF (j .NE. jde) ibm_ht_u(i,j) = hm*(0.5 - 0.5*COS((pi*(ABS(x_dist)-500.0))/9000.0))
           ibm_ht_c(i,j) = hm*(0.5 - 0.5*COS((pi*(ABS(x_dist)-500.0))/9000.0))
        ELSEIF ((ABS(x_dist) .GE. 9500.0) .AND. (ABS(x_dist) .LE. 10500.0)) THEN
           IF (j .NE. jde) ibm_ht_u(i,j) = hm
           ibm_ht_c(i,j) = hm
        ELSEIF ((ABS(x_dist) .GT. 10500.0) .AND. (ABS(x_dist) .LT. 19500.0)) THEN
           IF (j .NE. jde) ibm_ht_u(i,j) = hm*(0.5 + 0.5*COS((pi*(ABS(x_dist)-10500.0))/9000.0))
           ibm_ht_c(i,j) = hm*(0.5 + 0.5*COS((pi*(ABS(x_dist)-10500.0))/9000.0))
        ELSEIF (ABS(x_dist) .GE. 19500.0) THEN
           IF (j .NE. jde) ibm_ht_u(i,j) = 0.0
           ibm_ht_c(i,j) = 0.0
        ENDIF
     ENDDO
     ENDDO
  ELSEIF (config_flags%ideal_terrain .EQ. 7) THEN
  ELSEIF (config_flags%ideal_terrain .EQ. 8) THEN
     !RSA v-shaped valley case
     offset = 0.0
     slope = 0.2126 !RSA 12 degrees
     xa = 1000.0 !side ridges
     write(*,*) "ide=",ide,"ide/2=",ide/2
     write(*,*) "dx=",config_flags%dx
     DO j=jts,jte
     DO i=its,ite 
        ! v and w points
        ! calculate x with x=0 as the middle of the domain
        x_dist = (-ide/2)*config_flags%dx - config_flags%dx/2. + i*config_flags%dx
        IF (ABS(x_dist) .LT. (ide/2)*config_flags%dx - xa) THEN
           if ((i /= ide) .AND. (j /= jde)) ibm_ht_w(i,j) = offset + slope*ABS(x_dist)
           if (i /= ide) ibm_ht_v(i,j) = offset + slope*ABS(x_dist)
        ELSE
           if ((i /= ide) .AND. (j /= jde)) ibm_ht_w(i,j) = offset + slope*((ide/2)*config_flags%dx - xa)
           if (i /= ide) ibm_ht_v(i,j) = offset + slope*((ide/2)*config_flags%dx - xa)
        ENDIF
        if (j .eq. jts) write(*,*) "i=",i,"xdist=",x_dist,"ht_w=",ibm_ht_w(i,j)
        ! u and c points
        ! calculate x with x=0 as the middle of the domain
        x_dist = (-ide/2)*config_flags%dx + (i-1)*config_flags%dx
        IF (ABS(x_dist) .LT. (ide/2)*config_flags%dx - xa) THEN
           if (j /= jde) ibm_ht_u(i,j) = offset + slope*ABS(x_dist)
           ibm_ht_c(i,j) = offset + slope*ABS(x_dist)
        ELSE
           if (j /= jde) ibm_ht_u(i,j) = offset + slope*((ide/2)*config_flags%dx - xa)
           ibm_ht_c(i,j) = offset + slope*((ide/2)*config_flags%dx - xa)
        ENDIF
        if (j .eq. jts) write(*,*) "i=",i,"xdist=",x_dist,"ht_u=",ibm_ht_u(i,j)
     ENDDO
     ENDDO 
     ! offset = 100.
     ! DO j=jts,jte
     ! DO i=its,ite 
     !    ! 0.0875 for 5 degree slope comparing with WRF 0.5774 for a 30 degree slope
     !    ! calculate x with x=0 as the middle of the domain
     !    x_dist = (-ide/2.)*config_flags%dx + i*config_flags%dx
     !    if ((i /= ide) .AND. (j /= jde)) ibm_ht_w(i,j) = offset + 0.0875*ABS(x_dist)
     !    if (i /= ide) ibm_ht_v(i,j) = offset + 0.0875*ABS(x_dist)
     !    ! calculate x with x=0 as the middle of the domain
     !    x_dist = (-ide/2.)*config_flags%dx - config_flags%dx/2 + i*config_flags%dx
     !    if (j /= jde) ibm_ht_u(i,j) = offset + 0.0875*ABS(x_dist)
     !    ibm_ht_c(i,j) = offset + 0.0875*ABS(x_dist)
     ! ENDDO
     ! ENDDO 
     ! !KAL flatten the terrain at the east/west boundary- for using periodic boundary conditions and comparing to IBM
     ! DO j=jts,jte 
     !    if (j /= jde) ibm_ht_w(1,j) = ibm_ht_w(2,j)
     !    if (j /= jde) ibm_ht_w(ite-1,j) = ibm_ht_w(ite-2,j) 
     !    ibm_ht_v(1,j) = ibm_ht_v(2,j)
     !    ibm_ht_v(ite-1,j) = ibm_ht_v(ite-2,j) 
     !    if (j /= jde) ibm_ht_u(1,j) = ibm_ht_w(2,j)
     !    if (j /= jde) ibm_ht_u(2,j) = ibm_ht_w(2,j)
     !    if (j /= jde) ibm_ht_u(ite,j) = ibm_ht_w(ite-2,j) 
     !    if (j /= jde) ibm_ht_u(ite-1,j) = ibm_ht_w(ite-2,j)      
     !    ibm_ht_c(1,j) = ibm_ht_w(2,j)
     !    ibm_ht_c(2,j) = ibm_ht_w(2,j)
     !    ibm_ht_c(ite,j) = ibm_ht_w(ite-2,j) 
     !    ibm_ht_c(ite-1,j) = ibm_ht_w(ite-2,j)     
     ! ENDDO 
  ELSEIF (config_flags%ideal_terrain .EQ. 81) THEN
     !RSA sinusoidal valley case
     offset = 550.0
     xa = 1000.0 !side ridges
     write(*,*) "ide=",ide,"ide/2=",ide/2
     write(*,*) "dx=",config_flags%dx
     DO j=jts,jte
     DO i=its,ite 
        ! v and w points
        ! calculate x with x=0 as the middle of the domain
        x_dist = (-ide/2)*config_flags%dx - config_flags%dx/2. + i*config_flags%dx
        IF (ABS(x_dist) .LT. (ide/2)*config_flags%dx - xa) THEN
           if ((i /= ide) .AND. (j /= jde)) ibm_ht_w(i,j) = offset/2 - offset/2*COS(2*pi*ABS(x_dist)/((ide-1)*config_flags%dx-2*xa))
           if (i /= ide) ibm_ht_v(i,j) = offset/2 - offset/2*COS(2*pi*ABS(x_dist)/((ide-1)*config_flags%dx-2*xa))
        ELSE
           if ((i /= ide) .AND. (j /= jde)) ibm_ht_w(i,j) = offset
           if (i /= ide) ibm_ht_v(i,j) = offset
        ENDIF
        if (j .eq. jts) write(*,*) "i=",i,"xdist=",x_dist,"ht_w=",ibm_ht_w(i,j)
        ! u and c points
        ! calculate x with x=0 as the middle of the domain
        x_dist = (-ide/2)*config_flags%dx + (i-1)*config_flags%dx
        IF (ABS(x_dist) .LT. (ide/2)*config_flags%dx - xa) THEN
           if (j /= jde) ibm_ht_u(i,j) = offset/2 - offset/2*COS(2*pi*ABS(x_dist)/((ide-1)*config_flags%dx-2*xa))
           ibm_ht_c(i,j) = offset/2 - offset/2*COS(2*pi*ABS(x_dist)/((ide-1)*config_flags%dx-2*xa))
        ELSE
           if (j /= jde) ibm_ht_u(i,j) = offset
           ibm_ht_c(i,j) = offset
        ENDIF
        if (j .eq. jts) write(*,*) "i=",i,"xdist=",x_dist,"ht_u=",ibm_ht_u(i,j)
     ENDDO
     ENDDO 
  ELSEIF (config_flags%ideal_terrain .EQ. 9) THEN
     hm = 3000.
     xa = 25000.
     xa1  = 8000.
     DO j=jts,jte
     DO i=its,ite
        ! calculate x with x=0 as the middle of the domain
        x_dist = (-ide/2.)*config_flags%dx + i*config_flags%dx
        if (ABS(x_dist) <= xa) then
           if ((i /= ide) .AND. (j /= jde)) ibm_ht_w(i,j) = hm*COS((pi*x_dist)/(2*xa))*COS((pi*x_dist)/(2*xa))*COS((pi*x_dist)/(xa1))*COS((pi*x_dist)/(xa1))
           if (i /= ide) ibm_ht_v(i,j) = hm*COS((pi*x_dist)/(2*xa))*COS((pi*x_dist)/(2*xa))*COS((pi*x_dist)/(xa1))*COS((pi*x_dist)/(xa1))
        elseif (ABS(x_dist) > xa) then
           if ((i /= ide) .AND. (j /= jde)) ibm_ht_w(i,j) = 0.
           if (i /= ide) ibm_ht_v(i,j) = 0.
        endif        
     ENDDO
     ENDDO   
     DO j=jts,jte
     DO i=its,ite
        ! calculate x with x=0 as the middle of the domain
        x_dist = (-ide/2.)*config_flags%dx - config_flags%dx/2. + i*config_flags%dx
        if (ABS(x_dist) <= xa) then
           if (j /= jde) ibm_ht_u(i,j) = hm*COS((pi*x_dist)/(2*xa))*COS((pi*x_dist)/(2*xa))*COS((pi*x_dist)/(xa1))*COS((pi*x_dist)/(xa1))
           ibm_ht_c(i,j) = hm*COS((pi*x_dist)/(2*xa))*COS((pi*x_dist)/(2*xa))*COS((pi*x_dist)/(xa1))*COS((pi*x_dist)/(xa1))
        elseif (ABS(x_dist) > xa) then
           if (j /= jde) ibm_ht_u(i,j) = 0.
           ibm_ht_c(i,j) = 0.
        endif        
     ENDDO
     ENDDO         
  ELSEIF (config_flags%ideal_terrain .EQ. 10) then
     CALL read_terrain_data( ibm_ht_u, ibm_ht_v,           &
                             ibm_ht_w, ibm_ht_c,           &
                             ibm_z0,                       &
                             ids, ide, jds, jde, kds, kde, &
                             ims, ime, jms, jme, kms, kme, &
                             its, ite, jts, jte, kts, kte )

!     offset = 0.0    
!     DO j=jts,jte
!     DO i=its,ite
!        if (j /= jde) ibm_ht_u(i,j)= offset + ibm_ht_u(i,j)
!        if (i /= ide) ibm_ht_v(i,j)= offset + ibm_ht_v(i,j)
!        if ((i /= ide) .AND. (j /= jde)) ibm_ht_w(i,j)=offset + ibm_ht_w(i,j)
!        ibm_ht_c(i,j) = offset + ibm_ht_c(i,j)
!     ENDDO
!     ENDDO     		   			   

  ELSEIF (config_flags%ideal_terrain .EQ. 12) THEN
     !This is for the 2d isolated ridge case
!     xa = 48.0
     xa = 51.0
     hm = 60.0
     !hm = 74.6385
     offset = 50.0
     icm = ide/2
     DO j=jts,jte
     DO i=its,ite    
        x_dist = -icm*config_flags%dx + i*config_flags%dx
        IF (ABS(x_dist) .LE. xa) THEN
           IF ((i .NE. ide) .AND. (j .NE. jde)) ibm_ht_w(i,j) = offset + hm
           IF (i .NE. ide) ibm_ht_v(i,j) = offset + hm
        ELSE
           IF ((i .NE. ide) .AND. (j .NE. jde)) ibm_ht_w(i,j) = offset
           IF (i .NE. ide) ibm_ht_v(i,j) = offset
        ENDIF
        x_dist = -icm*config_flags%dx - config_flags%dx/2.0 + i*config_flags%dx
        IF (ABS(x_dist) .LE. xa) THEN
           IF (j .NE. jde) ibm_ht_u(i,j) = offset + hm
           ibm_ht_c(i,j) = offset + hm
        ELSE
           IF (j .NE. jde) ibm_ht_u(i,j) = offset
           ibm_ht_c(i,j) = offset
        ENDIF
     ENDDO      
     ENDDO 

  ELSEIF (config_flags%ideal_terrain .EQ. 13) THEN
     !read in data for the OKC domain
     write(*,'(A,I1)') "DJW[module_ibm]: calling read_terrain_data_okc for grid%id=",config_flags%grid_id
     CALL read_terrain_data_okc( ibm_ht_u, ibm_ht_v, &
                                 ibm_ht_w, ibm_ht_c, &
                                 ids, ide, jds, jde, kds, kde, &
                                 ims, ime, jms, jme, kms, kme, &
                                 its, ite, jts, jte, kts, kte )
     write(*,'(A,I1)') "DJW[module_ibm]: returned from read_terrain_data_okc for grid%id=",config_flags%grid_id

  ELSEIF (config_flags%ideal_terrain .EQ. 14) THEN
     !read in data for the Granite Mountain domain
     write(*,'(A,I1)') "RSA[module_ibm]: calling read_terrain_data_gm for grid%id=",config_flags%grid_id
     CALL read_terrain_data_gm( ibm_ht_u, ibm_ht_v, &
                                 ibm_ht_w, ibm_ht_c, &
                                 ids, ide, jds, jde, kds, kde, &
                                 ims, ime, jms, jme, kms, kme, &
                                 its, ite, jts, jte, kts, kte )
     write(*,'(A,I1)') "RSA[module_ibm]: returned from read_terrain_data_gm for grid%id=",config_flags%grid_id

  ELSEIF (config_flags%ideal_terrain .EQ. 15) THEN
     !read in data for the Askervein domain
     write(*,'(A,I1)') "RSA[module_ibm]: calling read_terrain_data_askervein for grid%id=",config_flags%grid_id
     CALL read_terrain_data_askervein( ibm_ht_u, ibm_ht_v, &
                                       ibm_ht_w, ibm_ht_c, &
                                       ids, ide, jds, jde, kds, kde, &
                                       ims, ime, jms, jme, kms, kme, &
                                       its, ite, jts, jte, kts, kte )
     write(*,'(A,I1)') "RSA[module_ibm]: returned from read_terrain_data_askervein for grid%id=",config_flags%grid_id

  ENDIF ! end of ideal_terrain option			   
  
!  print intlong, [ims:ime]
!  print *, 'ibm_ht_w'
!  DO j=jms,jme
!      print fpshort, ibm_ht_w(ims:ime,j)
!  ENDDO
!  print *, ''	
!  print *, 'ibm_ht_v'
!  DO j=jms,jme
!      print fpshort, ibm_ht_v(ims:ime,j)
!  ENDDO
!  print *, ''		   	 
!  print *, 'ibm_ht_u'
!  DO j=jms,jme
!      print fpshort, ibm_ht_u(ims:ime,j)
!  ENDDO
!  print *, ''	
!  print *, 'ibm_ht_c'
!  DO j=jms,jme
!      print fpshort, ibm_ht_c(ims:ime,j)
!  ENDDO
   
 END SUBROUTINE ibm_terrain
 
!------------------------------------------------------------------------------

 SUBROUTINE read_terrain_data_okc( ibm_ht_u, ibm_ht_v, &
                                   ibm_ht_w, ibm_ht_c, &
                                   ids, ide, jds, jde, kds, kde, &
                                   ims, ime, jms, jme, kms, kme, &
                                   its, ite, jts, jte, kts, kte )
 IMPLICIT NONE
 INCLUDE "netcdf.inc"
 !input data
 REAL, DIMENSION(ims:ime,jms:jme), INTENT(INOUT) :: ibm_ht_u, &
                                                    ibm_ht_v, &
                                                    ibm_ht_w, &
                                                    ibm_ht_c
 INTEGER, INTENT(IN   ) :: ids, ide, jds, jde, kds, kde, & !d: domain 
                           ims, ime, jms, jme, kms, kme, & !m: memory
                           its, ite, jts, jte, kts, kte    !p: patch, t: tile
 !local data
 INTEGER                                         :: NCID, & !identifier for a netcdf file
                                                    VID,  & !identifier for a netcdf variable
                                                    STATUS
 INTEGER                                         :: i, j, nx, nxs, ny, nys
 REAL, DIMENSION(:,:), ALLOCATABLE               :: terrain
 CHARACTER(len=265)                              :: wrf_err_message

!------------------------------------------------------------------------------
 !the executable begins here
 CALL wrf_debug(100,'dyn_em/module_ibm.F/subroutine read_terrain_data_okc')
!------------------------------------------------------------------------------

 STATUS = NF_OPEN("okc_bld.nc", nf_nowrite, ncid)
 STATUS = NF_INQ_DIMID(NCID, "WEST-EAST_PATCH_END_STAG", VID)
 STATUS = NF_INQ_DIMLEN(NCID, VID, nxs)
 STATUS = NF_INQ_DIMID(NCID, "WEST-EAST_PATCH_END_UNSTAG", VID)
 STATUS = NF_INQ_DIMLEN(NCID, VID, nx)
 STATUS = NF_INQ_DIMID(NCID, "SOUTH-NORTH_PATCH_END_STAG", VID)
 STATUS = NF_INQ_DIMLEN(NCID, VID, nys)
 STATUS = NF_INQ_DIMID(NCID, "SOUTH-NORTH_PATCH_END_UNSTAG", VID)
 STATUS = NF_INQ_DIMLEN(NCID, VID, ny)

 IF ((nx .NE. (ide-ids)) .OR. (ny .NE. (jde-jds))) THEN
    write(wrf_err_message,'(4(A,I3))')  &
          "--- ERROR: okc_bld.nc has dimensions ",nx," x ",ny, &
          " while WRF has dimensions ",(ide-ids)," x ",(jde-jds)
    CALL wrf_error_fatal(TRIM(wrf_err_message))
 ENDIF

 !retrieve immersed boundary heights at corner-points
 STATUS = NF_INQ_VARID(NCID, "IBM_HT_C", VID)
 IF (.NOT. ALLOCATED(terrain)) ALLOCATE(terrain(nys,nxs))
 IF (KIND(terrain) .EQ. 4) THEN
    STATUS = NF_GET_VARA_REAL(NCID, VID, [1, 1], [nys,nxs], terrain)
 ELSEIF (KIND(terrain) .EQ. 8) THEN
    STATUS = NF_GET_VARA_DOUBLE(NCID, VID, [1, 1], [nys,nxs], terrain)
 ENDIF
 DO i=its,ite
 DO j=jts,jte
   ibm_ht_c(i,j) = terrain(j,i)
 ENDDO
 ENDDO
 IF (ALLOCATED(terrain)) DEALLOCATE(terrain)

 !retrieve immersed boundary heights at U-points
 STATUS = NF_INQ_VARID(NCID, "IBM_HT_U", VID)
 IF (.NOT. ALLOCATED(terrain)) ALLOCATE(terrain(ny,nxs))
 IF (KIND(terrain) .EQ. 4) THEN
    STATUS = NF_GET_VARA_REAL(NCID, VID, [1, 1], [ny,nxs], terrain)
 ELSEIF (KIND(terrain) .EQ. 8) THEN
    STATUS = NF_GET_VARA_DOUBLE(NCID, VID, [1, 1], [ny,nxs], terrain)
 ENDIF
 DO i=its,ite
 DO j=jts,MIN(jte,ny)
   ibm_ht_u(i,j) = terrain(j,i)
 ENDDO
 ENDDO
 IF (ALLOCATED(terrain)) DEALLOCATE(terrain)

 !retrieve immersed boundary heights at V-points
 STATUS = NF_INQ_VARID(NCID, "IBM_HT_V", VID)
 IF (.NOT. ALLOCATED(terrain)) ALLOCATE(terrain(nys,nx))
 IF (KIND(terrain) .EQ. 4) THEN
    STATUS = NF_GET_VARA_REAL(NCID, VID, [1, 1], [nys,nx], terrain)
 ELSEIF (KIND(terrain) .EQ. 8) THEN
    STATUS = NF_GET_VARA_DOUBLE(NCID, VID, [1, 1], [nys,nx], terrain)
 ENDIF
 DO i=its,MIN(ite,nx)
 DO j=jts,jte
   ibm_ht_v(i,j) = terrain(j,i)
 ENDDO
 ENDDO
 IF (ALLOCATED(terrain)) DEALLOCATE(terrain)

 !retrieve immersed boundary heights at W-points
 STATUS = NF_INQ_VARID(NCID, "IBM_HT_W", VID)
 IF (.NOT. ALLOCATED(terrain)) ALLOCATE(terrain(ny,nx))
 IF (KIND(terrain) .EQ. 4) THEN
    STATUS = NF_GET_VARA_REAL(NCID, VID, [1, 1], [ny,nx], terrain)
 ELSEIF (KIND(terrain) .EQ. 8) THEN
    STATUS = NF_GET_VARA_DOUBLE(NCID, VID, [1, 1], [ny,nx], terrain)
 ENDIF
 DO i=its,MIN(ite,nx)
 DO j=jts,MIN(jte,ny)
   ibm_ht_w(i,j) = terrain(j,i)
 ENDDO
 ENDDO
 IF (ALLOCATED(terrain)) DEALLOCATE(terrain)

 END SUBROUTINE read_terrain_data_okc

!------------------------------------------------------------------------------

 SUBROUTINE read_terrain_data_gm(ibm_ht_u, ibm_ht_v,  &
                                 ibm_ht_w, ibm_ht_c,  &
                                 ids, ide, jds, jde, kds, kde, &
                                 ims, ime, jms, jme, kms, kme, &
                                 its, ite, jts, jte, kts, kte )
 IMPLICIT NONE
 INCLUDE "netcdf.inc"
! input data
 REAL, DIMENSION(ims:ime,jms:jme), INTENT(INOUT)      ::  ibm_ht_u, &
                                                          ibm_ht_v, &
                                                          ibm_ht_w, &
                                                          ibm_ht_c
 INTEGER, INTENT(IN   ) :: ids, ide, jds, jde, kds, kde, &               ! d: domain m:memory p:patch t:tile 
                           ims, ime, jms, jme, kms, kme, &
                           its, ite, jts, jte, kts, kte 
   
! local data 
   INTEGER                                         :: ncid, & ! identifier for netcdf file
                                                      vid,  & !                netcdf variable
                                                      status 
   INTEGER                                         :: i,j,k,idstart,idend,jdstart,jdend,itstart,itend,jtstart,jtend
   INTEGER                                         :: nx,ny
   REAL,DIMENSION(:,:),ALLOCATABLE                 :: terrain_ht, terrain_zo
!---------------------------------------------------------------------------------
! the executable begins here
!  print *, 'dyn_em/module_ibm.F/subroutine read_terrain_data'
!---------------------------------------------------------------------------------

!RSA for Granite Mountain
status = NF_OPEN("granite_mtn.nc", nf_nowrite, ncid)
status = NF_INQ_DIMID(ncid, 'nx', vid)
status = NF_INQ_DIMLEN(ncid, vid, nx)
status = NF_INQ_DIMID(ncid, 'ny', vid)
status = NF_INQ_DIMLEN(ncid, vid, ny) 
status = NF_INQ_VARID(ncid, "IBM_HT", vid)
ALLOCATE(terrain_ht(nx,ny))
terrain_ht = 0. 
! the A in VARA stands for array
if (KIND(terrain_ht) == 4) then
    status = NF_GET_VARA_REAL(ncid, vid, [1, 1], [nx,ny],  terrain_ht) 
    if (status .ne. NF_NOERR) print *, NF_STRERROR(status)
elseif (KIND(terrain_ht) == 8) then    
    status = NF_GET_VARA_DOUBLE(ncid, vid, [1, 1], [nx,ny],  terrain_ht)
    if (status .ne. NF_NOERR) print *, NF_STRERROR(status)
endif
status = NF_CLOSE(ncid)

! put the terrain in the middle
idstart = (ide-(nx/2))/2 + 1
idend = idstart+(nx/2)
jdstart = (jde-(ny/2))/2 + 1
jdend = jdstart+(ny/2)

write(0,*) 'In read_terrain_data for RSA Granite Mountain'
write(0,'(7i10)') nx, ids,ide,its,ite,idstart, idend
write(0,'(7i10)') ny, jds,jde,jts,jte,jdstart, jdend

itstart = max(idstart,its)
itend = min(idend,ite)
jtstart = max(jdstart,jts)
jtend = min(jdend,jte)

DO j=jtstart,jtend
DO i=itstart,itend
   if (j /= jdend) ibm_ht_u(i,j) = terrain_ht((2*i)-(2*idstart)+1,(2*j)-(2*jdstart)+2)
   if (i /= idend) ibm_ht_v(i,j) = terrain_ht((2*i)-(2*idstart)+2,(2*j)-(2*jdstart)+1)
   if ((i /= idend) .AND. (j /= jdend)) ibm_ht_w(i,j) = terrain_ht((2*i)-(2*idstart)+2,(2*j)-(2*jdstart)+2)
   ibm_ht_c(i,j) = terrain_ht((2*i)-(2*idstart)+1,(2*j)-(2*jdstart)+1)
ENDDO
ENDDO

DEALLOCATE(terrain_ht)

END SUBROUTINE read_terrain_data_gm 

!------------------------------------------------------------------------------- 

 SUBROUTINE read_terrain_data_askervein(ibm_ht_u, ibm_ht_v,  &
                                        ibm_ht_w, ibm_ht_c,  &
                                        ids, ide, jds, jde, kds, kde, &
                                        ims, ime, jms, jme, kms, kme, &
                                        its, ite, jts, jte, kts, kte )
 IMPLICIT NONE
 INCLUDE "netcdf.inc"
! input data
 REAL, DIMENSION(ims:ime,jms:jme), INTENT(INOUT)      ::  ibm_ht_u, &
                                                          ibm_ht_v, &
                                                          ibm_ht_w, &
                                                          ibm_ht_c
 INTEGER, INTENT(IN   ) :: ids, ide, jds, jde, kds, kde, &               ! d: domain m:memory p:patch t:tile 
                           ims, ime, jms, jme, kms, kme, &
                           its, ite, jts, jte, kts, kte 
   
! local data 
   INTEGER                                         :: ncid, & ! identifier for netcdf file
                                                      vid,  & ! netcdf variable
                                                      status 
   INTEGER                                         :: i,j,k,idstart,idend,jdstart,jdend,itstart,itend,jtstart,jtend
   INTEGER                                         :: nx,ny
   REAL,DIMENSION(:,:),ALLOCATABLE                 :: terrain_ht
!------------------------------------------------------------------------------
 !the executable begins here
 CALL wrf_debug(100,'dyn_em/module_ibm.F/subroutine read_terrain_data_askervein')
!------------------------------------------------------------------------------

   status = NF_OPEN("./Ask_hill.nc", nf_nowrite, ncid)
   status = NF_INQ_DIMID(ncid, 'nx', vid)
   status = NF_INQ_DIMLEN(ncid, vid, nx)
   status = NF_INQ_DIMID(ncid, 'ny', vid)
   status = NF_INQ_DIMLEN(ncid, vid, ny) 
   status = NF_INQ_VARID(ncid, "HT", vid)
   ALLOCATE(terrain_ht(nx,ny))
   terrain_ht = 10. 
   ! the A in VARA stands for array
   if (KIND(terrain_ht) == 4) then
   status = NF_GET_VARA_REAL(ncid, vid, [1, 1], [nx,ny],  terrain_ht) 
   elseif (KIND(terrain_ht) == 8) then    
       status = NF_GET_VARA_DOUBLE(ncid, vid, [1, 1], [nx,ny],  terrain_ht)
   endif
   status = NF_CLOSE(ncid)

   idstart = (ide-(nx/2))/2 + 1
   idend = idstart+(nx/2)
   jdstart = (jde-(ny/2))/2 + 1
   jdend = jdstart+(ny/2)
   
   itstart = max(idstart,its)
   itend = min(idend,ite)
   jtstart = max(jdstart,jts)
   jtend = min(jdend,jte)

   !RSA/JB note this is assuming dx,dy of the terrain is 1/2 that of the model
   DO j=jtstart,jtend
   DO i=itstart,itend
      if (j /= jdend) ibm_ht_u(i,j) = terrain_ht((2*i)-(2*idstart)+1,(2*j)-(2*jdstart)+2)
      if (i /= idend) ibm_ht_v(i,j) = terrain_ht((2*i)-(2*idstart)+2,(2*j)-(2*jdstart)+1)
      if ((i /= idend) .AND. (j /= jdend)) ibm_ht_w(i,j) = terrain_ht((2*i)-(2*idstart)+2,(2*j)-(2*jdstart)+2)
      ibm_ht_c(i,j) = terrain_ht((2*i)-(2*idstart)+1,(2*j)-(2*jdstart)+1)
   ENDDO
   ENDDO
   
   DEALLOCATE(terrain_ht)

 END SUBROUTINE read_terrain_data_askervein

!------------------------------------------------------------------------------

 SUBROUTINE read_terrain_data(ibm_ht_u, ibm_ht_v,  &
                              ibm_ht_w, ibm_ht_c,  &
                              ibm_z0,              &
                              ids, ide, jds, jde, kds, kde, &
                              ims, ime, jms, jme, kms, kme, &
                              its, ite, jts, jte, kts, kte )
 IMPLICIT NONE
 INCLUDE "netcdf.inc"
! input data
 REAL, DIMENSION(ims:ime,jms:jme), INTENT(INOUT)      ::  ibm_ht_u, &
                                                          ibm_ht_v, &
                                                          ibm_ht_w, &
                                                          ibm_ht_c, &
                                                          ibm_z0
 INTEGER, INTENT(IN   ) :: ids, ide, jds, jde, kds, kde, &               ! d: domain m:memory p:patch t:tile 
                           ims, ime, jms, jme, kms, kme, &
                           its, ite, jts, jte, kts, kte 
   
! local data 
!   INTEGER, PARAMETER                              :: nl_max = 4000
   INTEGER                                         :: ncid, & ! identifier for netcdf file
                                                      vid,  & !                netcdf variable
                                                      status 
!   LOGICAL					   :: end_of_file
   INTEGER                                         :: i,j,k,idstart,idend,jdstart,jdend,itstart,itend,jtstart,jtend
   INTEGER                                         :: nx,ny
!   REAL, DIMENSION(nl_max)                         :: terrain_ht
   REAL,DIMENSION(:,:),ALLOCATABLE                 :: terrain_ht, terrain_zo
!---------------------------------------------------------------------------------
! the executable begins here
!  print *, 'dyn_em/module_ibm.F/subroutine read_terrain_data'
!---------------------------------------------------------------------------------

! Bolund notes- the Bolund terrain file describes an area with SW/NE corners of (-98, -132)/(192, 118) m.
! In the native file at 0.25 m resolution, the number of grid points are (1161,1001).
! In the matlab processed file at 1 m resolution, the number of grid points is (291,251)
! The minimum domain size for the Bolund blind comparison was x = -400 m to 400 m.  I can not find a minimum given for y.
 
      status = NF_OPEN("bolund_topo_1m.nc", nf_nowrite, ncid) !Bolund
      !status = NF_OPEN("Askervein_30m_hgt.nc", nf_nowrite, ncid) !Askervein
      !status = NF_OPEN("Building_v5_1m.nc", nf_nowrite, ncid) !Oklahoma City
      status = NF_INQ_DIMID(ncid, 'nx', vid)
      status = NF_INQ_DIMLEN(ncid, vid, nx)
      status = NF_INQ_DIMID(ncid, 'ny', vid)
      status = NF_INQ_DIMLEN(ncid, vid, ny) 
      !status = NF_INQ_VARID(ncid, "IBM_HT", vid) !use for OKC and Askervein
      status = NF_INQ_VARID(ncid, "FILE_HT", vid) !use for Bolund
      ALLOCATE(terrain_ht(nx,ny))
      terrain_ht = 0. 
      ! the A in VARA stands for array
      if (KIND(terrain_ht) == 4) then
          status = NF_GET_VARA_REAL(ncid, vid, [1, 1], [nx,ny],  terrain_ht) 
      elseif (KIND(terrain_ht) == 8) then    
          status = NF_GET_VARA_DOUBLE(ncid, vid, [1, 1], [nx,ny],  terrain_ht)
      endif
      
      status = NF_INQ_VARID(ncid, "FILE_ZO", vid) !use for Bolund
      ALLOCATE(terrain_zo(nx,ny))
      terrain_zo = 0. 
      ! the A in VARA stands for array
      if (KIND(terrain_zo) == 4) then
          status = NF_GET_VARA_REAL(ncid, vid, [1, 1], [nx,ny],  terrain_zo) 
      elseif (KIND(terrain_ht) == 8) then    
          status = NF_GET_VARA_DOUBLE(ncid, vid, [1, 1], [nx,ny],  terrain_zo)
      endif      
      status = NF_CLOSE(ncid)   
     
! this is the code for 2d slices like nyc2dskyline.dat and owensvalley2dslice 
!          open(unit=10,file='nyc2dskyline.dat',status='OLD',action='READ')
!          open(unit=10,file='nyc2dskyline_filled.dat',status='OLD',action='READ')
!          open(unit=10,file='owensvalley2dslice',status='OLD',action='READ')
!	   rewind(10)
!	   end_of_file = .false.
!	   k = 1  
!	   do while (.not. end_of_file)
!	     read(10,*,end=100) terrain_ht(k)
!	     k = k+1
!	     go to 110
!     100    end_of_file = .true.
!     110    continue
!	   enddo
!	   nl = k-1
!	   close(unit=10,status = 'keep')
!
!	   i_start = (ite-(nl/2))/2
!	   i_end = i_start+(nl/2)-2
!
!	   !print *, i_start, i_end, nl
!
!	   DO j=jts,jte
!	   DO i=its,ite
!	      ui = (2*i) - (2*i_start) + 1
!	      !ui = (2*i) - 1
!	      wi = ui + 1
!	      if (j /= jde) ibm_ht_u(i,j) = terrain_ht(ui)
!	      if (i /= ide) ibm_ht_v(i,j) = terrain_ht(wi)
!	      if ((i /= ide) .AND. (j /= jde)) ibm_ht_w(i,j) = terrain_ht(wi)
!	      ibm_ht_c(i,j) = terrain_ht(ui)
!	   ENDDO
!	   ENDDO 
!

! this is the code for 3d cases like sample_OKC_bldg 
!     open(unit=10,file='sample_okc_bldg_large',status='OLD',action='READ')   
!     rewind(10)
!     end_of_file = .false.
!     ! data is dx,dy,nx,ny, but dx and dy are not needed
!     read(10,*,end=100) nx, ny, nx, ny
!     k = 1 
!     do while (.not. end_of_file)
!	read(10,*,end=100) terrain_ht(k)
!	k = k+1
!	go to 110
!100	end_of_file = .true.
!110	continue
!     enddo
!     nl = k-1
!     close(unit=10,status = 'keep')
!     
!     put the terrain in the middle
!      idstart = (ide-(nx/2))/2 + 1
!      idend = idstart+(nx/2)
!      jdstart = (jde-(ny/2))/2 + 1
!      jdend = jdstart+(ny/2)

!     offset the terrain to the east (Bolund)
!      start for the first domain that I tried
!      idstart = 3*(ide-(nx/2))/4 + 1
!     start for the larger domain
      idstart = 153
      idend = idstart+(nx/2)
      jdstart = (jde-(ny/2))/2 + 1
      jdend = jdstart+(ny/2)
            
      write(0,*) 'In read_terrain_data'
      write(0,'(7i10)') nx, ids,ide,its,ite,idstart, idend
      write(0,'(7i10)') ny, jds,jde,jts,jte,jdstart, jdend
      
      itstart = max(idstart,its)
      itend = min(idend,ite)
      jtstart = max(jdstart,jts)
      jtend = min(jdend,jte)

      !write(6,'(2i10)') itstart, itend
      !write(6,'(2i10)') jtstart, jtend

      DO j=jts,jte
      DO i=its,ite
         ! fill terrain to 0.75 m for Bolund
         ! fill roughness length to 0.0003 m for Bolund
         if (j /= jde) ibm_ht_u(i,j)=0.75
         if (i /= ide) ibm_ht_v(i,j)=0.75
         if ((i /= ide) .AND. (j /= jde)) ibm_ht_w(i,j)=0.75
         ibm_ht_c(i,j)=0.75
         ibm_z0=0.0003
      ENDDO
      ENDDO 


      DO j=jtstart,jtend
      DO i=itstart,itend
         !ci = (2*i)-(2*i_start)+1 + ((2*j)-(2*j_start))*nx
         !vi = ci + 1
         !ui = ci + nx
         !wi = ui + 1
         ! this is for terrain where dx,dy of the terrain description is equal to that of the model
         ! ???
         ! this if for terrain where dx,dy of the terrain is 1/2 of that of the model
         if (j /= jdend) ibm_ht_u(i,j) = terrain_ht((2*i)-(2*idstart)+1,(2*j)-(2*jdstart)+2)
         if (i /= idend) ibm_ht_v(i,j) = terrain_ht((2*i)-(2*idstart)+2,(2*j)-(2*jdstart)+1)
         if ((i /= idend) .AND. (j /= jdend)) ibm_ht_w(i,j) = terrain_ht((2*i)-(2*idstart)+2,(2*j)-(2*jdstart)+2)
         ibm_ht_c(i,j) = terrain_ht((2*i)-(2*idstart)+1,(2*j)-(2*jdstart)+1)
         if ((i /= idend) .AND. (j /= jdend)) ibm_z0(i,j) = terrain_zo((2*i)-(2*idstart)+2,(2*j)-(2*jdstart)+2)
      ENDDO
      ENDDO
      
      DEALLOCATE(terrain_ht)

 END SUBROUTINE read_terrain_data 

!------------------------------------------------------------------------------- 

 SUBROUTINE calc_ht_all_init ( phb, ph,                      &
                               ht_s, ht_u, ht_v, ht_w,       &
                               ids, ide, jds, jde, kds, kde, &
                               ims, ime, jms, jme, kms, kme, &
                               its, ite, jts, jte, kts, kte )   
 IMPLICIT NONE
 !input data
 REAL, DIMENSION(ims:ime,kms:kme,jms:jme), INTENT(IN   )    :: phb,  &
                                                               ph 
 REAL, DIMENSION(ims:ime,kms:kme,jms:jme), INTENT(  OUT)    :: ht_s, &
                                                               ht_u, & !this is the total height
                                                               ht_v, & !at s, u, v, and w points
                                                               ht_w
 INTEGER, INTENT(IN   )          :: ids, ide, jds, jde, kds, kde,    & !d: domain 
                                    ims, ime, jms, jme, kms, kme,    & !m: memory
                                    its, ite, jts, jte, kts, kte       !p: patch, t: tile
 !local data
 INTEGER                                                    :: i, j, k  
!---------------------------------------------------------------------------------
 !the executable begins here
 CALL wrf_debug(100,'dyn_em/module_ibm.F/subroutine calc_ht_all_init')
!--------------------------------------------------------------------------------- 

! average the geopotential at u and v levels
 DO i=its,ite
 DO k=kts,kte 
 DO j=jts,jte
    IF ((i .NE. ide) .AND. (j .NE. jde) .AND. (k .NE. kde)) THEN
       ht_s(i,k,j) = (phb(i,k,j)+ph(i,k,j)+phb(i,k+1,j)+ph(i,k+1,j))/(2.0*g)
    ENDIF
    IF ((j .NE. jde) .AND. (k .NE. kde)) THEN
       ht_u(i,k,j) = ((phb(i-1,k,j)+ph(i-1,k,j)+phb(i-1,k+1,j)+ph(i-1,k+1,j) &
                      +phb(i,k,j)+ph(i,k,j)+phb(i,k+1,j)+ph(i,k+1,j)))/(4.0*g)
    ENDIF
    IF ((i .NE. ide) .AND. (k .NE. kde)) THEN
       ht_v(i,k,j) = ((phb(i,k,j-1)+ph(i,k,j-1)+phb(i,k+1,j-1)+ph(i,k+1,j-1) &
                      +phb(i,k,j)+ph(i,k,j)+phb(i,k+1,j)+ph(i,k+1,j)))/(4.0*g)
    ENDIF
    IF ((i .NE. ide) .AND. (j .NE. jde)) THEN
       ht_w(i,k,j) = (phb(i,k,j)+ph(i,k,j))/g
    ENDIF
 ENDDO
 ENDDO
 ENDDO
 
 END SUBROUTINE calc_ht_all_init

!-------------------------------------------------------------------------------
 
 SUBROUTINE calc_ht_small ( stag, phb, phsave, ph, ht_p,  &
                            ids, ide, jds, jde, kds, kde, &
                            ims, ime, jms, jme, kms, kme, &
                            its, ite, jts, jte, kts, kte )   
 IMPLICIT NONE
 !input data
 CHARACTER, INTENT(IN   )                                   :: stag
 REAL, DIMENSION(ims:ime,kms:kme,jms:jme), INTENT(IN   )    :: phb,     &
                                                               phsave,  &
                                                               ph 
 REAL, DIMENSION(ims:ime,kms:kme,jms:jme), INTENT(  OUT)    :: ht_p       !this is the total height					      							           			     
 INTEGER, INTENT(IN   )                :: ids, ide, jds, jde, kds, kde, & !d: domain 
                                          ims, ime, jms, jme, kms, kme, & !m: memory
                                          its, ite, jts, jte, kts, kte    !p: patch, t: tile
 !local data
 INTEGER                                                    :: i, j, k  
!---------------------------------------------------------------------------------
 !the executable begins here
 CALL wrf_debug(100,'dyn_em/module_ibm.F/subroutine calc_ht_small')
!--------------------------------------------------------------------------------- 

 IF (stag == 'u') THEN
    DO i=its,ite
    DO k=kts,MIN(kte,kde-1) 
    DO j=jts,MIN(jte,jde-1)
       ht_p(i,k,j) = ((phb(i-1,k,j)+phsave(i-1,k,j)+ph(i-1,k,j)+phb(i-1,k+1,j)+phsave(i-1,k+1,j)+ph(i-1,k+1,j) &
                      +phb(i,k,j)+phsave(i,k,j)+ph(i,k,j)+phb(i,k+1,j)+phsave(i,k+1,j)+ph(i,k+1,j)))/(4.0*g)
    ENDDO
    ENDDO
    ENDDO
 ELSEIF (stag == 'v') THEN
    DO i=its,MIN(ite,ide-1)
    DO k=kts,MIN(kte,kde-1) 
    DO j=jts,jte
       ht_p(i,k,j) = ((phb(i,k,j-1)+phsave(i,k,j-1)+ph(i,k,j-1)+phb(i,k+1,j-1)+phsave(i,k+1,j-1)+ph(i,k+1,j-1) &
                      +phb(i,k,j)+phsave(i,k,j)+ph(i,k,j)+phb(i,k+1,j)+phsave(i,k+1,j)+ph(i,k+1,j)))/(4.0*g)
    ENDDO
    ENDDO
    ENDDO
 ELSEIF (stag == 'w') THEN  
    DO i=its,MIN(ite,ide-1)
    DO k=kts,kte
    DO j=jts,MIN(jte,jde-1)
       ht_p(i,k,j) = (phb(i,k,j)+phsave(i,k,j)+ph(i,k,j))/g
    ENDDO
    ENDDO
    ENDDO
 ELSEIF (stag == 't') THEN
    DO i=its,MIN(ite,ide-1)
    DO k=kts,MIN(kte,kde-1) 
    DO j=jts,MIN(jte,jde-1)
       ht_p(i,k,j) = (phb(i,k,j)+phsave(i,k,j)+ph(i,k,j)+phb(i,k+1,j)+phsave(i,k+1,j)+ph(i,k+1,j))/(2.0*g)
    ENDDO
    ENDDO
    ENDDO
 ELSEIF (stag == 'd') THEN
    DO i=its,ite
    DO k=kts,MIN(kte,kde-1)
    DO j=jts,jte
       ht_p(i,k,j) = (phb(i-1,k,j)+phsave(i-1,k,j)+ph(i-1,k,j)+phb(i-1,k+1,j)+phsave(i-1,k+1,j)+ph(i-1,k+1,j) &
                     +phb(i,k,j)+phsave(i,k,j)+ph(i,k,j)+phb(i,k+1,j)+phsave(i,k+1,j)+ph(i,k+1,j) &
                     +phb(i-1,k,j-1)+phsave(i-1,k,j-1)+ph(i-1,k,j-1)+phb(i-1,k+1,j-1)+phsave(i-1,k+1,j-1)+ph(i-1,k+1,j-1) &
                     +phb(i,k,j-1)+phsave(i,k,j-1)+ph(i,k,j-1)+phb(i,k+1,j-1)+phsave(i,k+1,j-1)+ph(i,k+1,j-1))/(8.0*g)
    ENDDO
    ENDDO
    ENDDO
 ELSEIF (stag == 'e') THEN
    DO i=its,ite
    DO k=kts,kte
    DO j=jts,MIN(jte,jde-1)
       ht_p(i,k,j) = (phb(i,k,j)+phsave(i,k,j)+ph(i,k,j)+phb(i-1,k,j)+phsave(i-1,k,j)+ph(i-1,k,j))/(2.0*g)
    ENDDO
    ENDDO
    ENDDO
 ELSEIF (stag == 'f') THEN
    DO i=its,MIN(ite,ide-1)
    DO k=kts,kte
    DO j=jts,jte
       ht_p(i,k,j) = (phb(i,k,j)+phsave(i,k,j)+ph(i,k,j)+phb(i,k,j-1)+phsave(i,k,j-1)+ph(i,k,j-1))/(2.0*g)
    ENDDO
    ENDDO
    ENDDO
 ENDIF   

 END SUBROUTINE calc_ht_small

!-------------------------------------------------------------------------------   

 SUBROUTINE calc_var_full(stag, varfull,                             &
                          var, varsave,                              &
                          mu, mus,                                   &
                          h_diabatic,                                &
                          number_of_small_timesteps,dts,             &
                          rk_step, rk_order,                         &
                          ids, ide, jds, jde, kds, kde,              &
                          ims, ime, jms, jme, kms, kme,              &
                          its, ite, jts, jte, kts, kte  )
 IMPLICIT NONE
 !input data
 CHARACTER, INTENT(IN   )                                :: stag
 REAL, DIMENSION(ims:ime,kms:kme,jms:jme), INTENT(OUT)   :: varfull
 REAL, DIMENSION(ims:ime,kms:kme,jms:jme), INTENT(IN   ) :: var,         &
                                                            varsave,     &
                                                            h_diabatic
 REAL, DIMENSION(ims:ime,jms:jme), INTENT(IN   )         :: mu,          &
                                                            mus
 REAL, INTENT(IN   )                                     :: dts
 INTEGER, INTENT(IN   )                                  :: number_of_small_timesteps, &
                                                            rk_step,     &
                                                            rk_order
 INTEGER, INTENT(IN   )                                  :: ids, ide, jds, jde, kds, kde, & !d: domain 
                                                            ims, ime, jms, jme, kms, kme, & !m: memory
                                                            its, ite, jts, jte, kts, kte    !p: patch, t: tile
   
 !local data
 INTEGER                                                 :: i, j, k

!---------------------------------------------------------------------------------
 !the executable begins here
 CALL wrf_debug(100,'dyn_em/module_ibm.F/subroutine calc_var_full')
!---------------------------------------------------------------------------------	  

 IF (stag == 't') THEN
    IF ( rk_step < rk_order ) THEN
       DO j=jts,MIN(jte,jde-1)
       DO k=kts,MIN(kte,kde-1)
       DO i=its,MIN(ite,ide-1)
          varfull(i,k,j) = (var(i,k,j) + varsave(i,k,j)*mu(i,j))/mus(i,j)
       ENDDO
       ENDDO
       ENDDO
    ELSE
       DO j=jts,MIN(jte,jde-1)
       DO k=kts,MIN(kte,kde-1)
       DO i=its,MIN(ite,ide-1)
          varfull(i,k,j) = (var(i,k,j) - dts*number_of_small_timesteps*mu(i,j)*h_diabatic(i,k,j) &
                       + varsave(i,k,j)*mu(i,j))/mus(i,j)
       ENDDO
       ENDDO
       ENDDO
    ENDIF
  ELSEIF (stag == 'u') THEN
    DO j=jts,MIN(jte,jde-1)
    DO k=kts,kde-1
    DO i=its,MIN(ite,ide)
       varfull(i,k,j) = 2*(var(i,k,j) + varsave(i,k,j)*mu(i,j))/(mus(i,j)+mus(i-1,j))
    ENDDO
    ENDDO
    ENDDO
 ELSEIF (stag == 'v') THEN 
    DO j=jts,MIN(jte,jde)
    DO k=kts,kde-1
    DO i=its,MIN(ite,ide-1)
       varfull(i,k,j) = 2*(var(i,k,j) + varsave(i,k,j)*mu(i,j))/(mus(i,j)+mus(i,j-1))
    ENDDO
    ENDDO
    ENDDO  
 ELSEIF (stag == 'w')THEN
    DO j=jts,MIN(jte,jde-1)
    DO k=kts,kde
    DO i=its,MIN(ite,ide-1)
       varfull(i,k,j) = (var(i,k,j) + varsave(i,k,j)*mu(i,j))/mus(i,j)
    ENDDO
    ENDDO
    ENDDO    
 ENDIF

 END SUBROUTINE calc_var_full 

!-------------------------------------------------------------------------------   
   
 SUBROUTINE ghost_pts_top ( stag, ht_p, ibm_ht,           &
                            top, prox, inside,            &
                            ids, ide, jds, jde, kds, kde, &
                            ims, ime, jms, jme, kms, kme, &
                            its, ite, jts, jte, kts, kte )

 IMPLICIT NONE
 !input data
 CHARACTER, INTENT(IN   )                                 :: stag
 REAL, DIMENSION(ims:ime,kms:kme,jms:jme), INTENT(IN   )  :: ht_p       !this is the height of grid points
 REAL, DIMENSION(ims:ime,jms:jme), INTENT(IN   )          :: ibm_ht
 INTEGER, DIMENSION(ims:ime,jms:jme), INTENT(  OUT)       :: top,     & !store the 'top boundary' ghost points here
                                                             prox
 INTEGER, DIMENSION(ims:ime,kms:kme,jms:jme), INTENT(OUT) :: inside     !one if the pt is inside boundary, zero if it is outside				     							      							           			     
 INTEGER, INTENT(IN   )        :: ids, ide, jds, jde, kds, kde,       & !d: domain 
                                  ims, ime, jms, jme, kms, kme,       & !m: memory
                                  its, ite, jts, jte, kts, kte          !p: patch, t: tile

 !local data
 INTEGER                                                  :: i, j, k, &
                                                             i_end,   &
                                                             j_end,   &
                                                             k_end
 REAL                                                     :: dist

!---------------------------------------------------------------------------------
 !the executable begins here
 CALL wrf_debug(100,'dyn_em/module_ibm.F/subroutine ghost_pts_top')
!--------------------------------------------------------------------------------- 
 
 IF (stag .EQ. 'u') THEN
    i_end = ite
    j_end = MIN(jte,jde-1)
    k_end = MIN(kte,kde-1)
 ELSEIF (stag .EQ. 'v') THEN
    i_end = MIN(ite,ide-1)
    j_end = jte
    k_end = MIN(kte,kde-1)
 ELSEIF (stag .EQ. 'w') THEN
    i_end = MIN(ite,ide-1)
    j_end = MIN(jte,jde-1)
    k_end = kte
 ELSEIF (stag .EQ. 't') THEN
    i_end = MIN(ite,ide-1)
    j_end = MIN(jte,jde-1)
    k_end = MIN(kte,kde-1)
 ENDIF

 inside = 0   
 prox = 0  
 top = 0 
 
 !start the searching algorithm to find the points inside of the terrain profile  
 DO i=its,i_end
    DO j=jts,j_end
       DO k=kts,k_end
          IF (ibm_ht(i,j) .GE. ht_p(i,k,j)) THEN
             inside(i,k,j) = 1 !the point is inside	     
          ENDIF
          IF (k .NE. kts) THEN
             IF (inside(i,k-1,j)-inside(i,k,j) .NE. 0) THEN
                top(i,j) = k-1 !k index just inside w boundary
                GOTO 205 
             ENDIF 
          ENDIF
       ENDDO !end of k loop
       205 CONTINUE
       !check for x% proximity to top(i,k)+1
       !if proxmity is close enough, move the point up one
       dist = (ht_p(i,top(i,j)+1,j)-ibm_ht(i,j))/(ht_p(i,top(i,j)+1,j)-ht_p(i,top(i,j),j))  
       IF (dist .LE. 0.10) THEN
       !IF (dist .LE. 0.15) THEN
          top(i,j) = top(i,j)+1
          inside(i,top(i,j),j) = 1
          prox(i,j) = 1
       ENDIF    
    ENDDO ! end of j loop
 ENDDO ! end of i loop      
   
 END SUBROUTINE ghost_pts_top

!-------------------------------------------------------------------------------   
   
 SUBROUTINE ghost_pts_top_ss ( stag, ht_p, ibm_ht,           &
                               top, inside,                  &
                               ids, ide, jds, jde, kds, kde, &
                               ims, ime, jms, jme, kms, kme, &
                               its, ite, jts, jte, kts, kte )

 IMPLICIT NONE
 !input data
 CHARACTER, INTENT(IN   )                                 :: stag
 REAL, DIMENSION(ims:ime,kms:kme,jms:jme), INTENT(IN   )  :: ht_p       !this is the height of grid points
 REAL, DIMENSION(ims:ime,jms:jme), INTENT(IN   )          :: ibm_ht
 INTEGER, DIMENSION(ims:ime,jms:jme), INTENT(  OUT)       :: top        !store the 'top boundary' ghost points here
 INTEGER, DIMENSION(ims:ime,kms:kme,jms:jme), INTENT(OUT) :: inside     !one if the pt is inside boundary, zero if it is outside				     							      							           			     
 INTEGER, INTENT(IN   )        :: ids, ide, jds, jde, kds, kde,       & !d: domain 
                                  ims, ime, jms, jme, kms, kme,       & !m: memory
                                  its, ite, jts, jte, kts, kte          !p: patch, t: tile

 !local data
 INTEGER                                                  :: i, j, k, &
                                                             i_end,   &
                                                             j_end,   &
                                                             k_end
 REAL                                                     :: dist

!---------------------------------------------------------------------------------
 !the executable begins here
 !RSA this is the same as ghost_pts_top but without 'prox'
 CALL wrf_debug(100,'dyn_em/module_ibm.F/subroutine ghost_pts_top_ss')
!--------------------------------------------------------------------------------- 
 
 IF (stag .EQ. 'u') THEN
    i_end = ite
    j_end = MIN(jte,jde-1)
    k_end = MIN(kte,kde-1)
 ELSEIF (stag .EQ. 'v') THEN
    i_end = MIN(ite,ide-1)
    j_end = jte
    k_end = MIN(kte,kde-1)
 ELSEIF (stag .EQ. 'w') THEN
    i_end = MIN(ite,ide-1)
    j_end = MIN(jte,jde-1)
    k_end = kte
 ELSEIF (stag .EQ. 't') THEN
    i_end = MIN(ite,ide-1)
    j_end = MIN(jte,jde-1)
    k_end = MIN(kte,kde-1)
 ELSEIF (stag .EQ. 'd') THEN
    i_end = ite
    j_end = jte
    k_end = MIN(kte,kde-1)
 ELSEIF (stag .EQ. 'e') THEN
    i_end = ite
    j_end = MIN(jte,jde-1)
    k_end = kte
 ELSEIF (stag .EQ. 'f') THEN
    i_end = MIN(ite,ide-1)
    j_end = jte
    k_end = kte
 ENDIF

 inside = 0   
 top = 0 
 
 !start the searching algorithm to find the points inside of the terrain profile  
 DO i=its,i_end
    DO j=jts,j_end
       DO k=kts,k_end
          IF (ibm_ht(i,j) .GE. ht_p(i,k,j)) THEN
             inside(i,k,j) = 1 !the point is inside	     
          ENDIF
          IF (k .NE. kts) THEN
             IF (inside(i,k-1,j)-inside(i,k,j) .NE. 0) THEN
                top(i,j) = k-1 !k index just inside w boundary
                GOTO 205 
             ENDIF 
          ENDIF
       ENDDO !end of k loop
       205 CONTINUE
    ENDDO ! end of j loop
 ENDDO ! end of i loop      
   
 END SUBROUTINE ghost_pts_top_ss

!------------------------------------------------------------------------------------
   
 SUBROUTINE reconstruct_pts_top ( stag, ht_p, ibm_ht,           &
                                  top, inside,                  &
                                  inside_all,                   &
                                  z_rough,                      &
                                  zero_within_z_rough,          &
                                  recon_pt_bump_tol,            & !RSA
                                  bump_up_recon_pt_within_tol,  & !RSA
                                  ids, ide, jds, jde, kds, kde, &
                                  ims, ime, jms, jme, kms, kme, &
                                  its, ite, jts, jte, kts, kte )

   IMPLICIT NONE
   !input data
   CHARACTER, INTENT(IN   )                                 :: stag
   REAL, DIMENSION(ims:ime,kms:kme,jms:jme), INTENT(IN   )  :: ht_p   !this is the height of grid points
   REAL, DIMENSION(ims:ime,jms:jme), INTENT(IN   )          :: ibm_ht
   INTEGER, DIMENSION(ims:ime,jms:jme), INTENT(  OUT)       :: top    !store the 'top boundary' ghost points here
   INTEGER, DIMENSION(ims:ime,kms:kme,jms:jme), INTENT(OUT) :: inside !one if the pt is inside boundary, zero if it is outside
   INTEGER, DIMENSION(ims:ime,kms:kme,jms:jme), INTENT(OUT) :: inside_all !RSA inside includes recon pts, inside_all does not
   REAL, INTENT(IN   )                                      :: z_rough, &
                                                               recon_pt_bump_tol !RSA
   LOGICAL, INTENT(IN   )                                   :: zero_within_z_rough, &
                                                               bump_up_recon_pt_within_tol !RSA

   INTEGER, INTENT(IN   )        :: ids, ide, jds, jde, kds, kde, &   !d: domain
                                    ims, ime, jms, jme, kms, kme, &   !m: memory
                                    its, ite, jts, jte, kts, kte      !p: patch, t: tile 

   !local data
   INTEGER                                                 :: i, j, k, &
                                                              i_end,   &
                                                              j_end,   &
                                                              k_end
   REAL                                                    :: dist

!---------------------------------------------------------------------------------
   !the executable begins here
   write(wrf_err_message,'(A,A)') 'dyn_em/module_ibm.F/subroutine reconstruct_pts_top stag=',stag
   CALL wrf_debug(100,TRIM(wrf_err_message))
!--------------------------------------------------------------------------------- 
 
   IF (stag .EQ. 'u') THEN
      i_end = ite
      j_end = MIN(jte,jde-1)
      k_end = MIN(kte,kde-1)
   ELSEIF (stag .EQ. 'v') THEN
      i_end = MIN(ite,ide-1)
      j_end = jte
      k_end = MIN(kte,kde-1)
   ELSEIF (stag .EQ. 'w') THEN
      i_end = MIN(ite,ide-1)
      j_end = MIN(jte,jde-1)
      k_end = kte
   ELSEIF (stag .EQ. 't') THEN
      i_end = MIN(ite,ide-1)
      j_end = MIN(jte,jde-1)
      k_end = MIN(kte,kde-1)
   ELSEIF (stag .EQ. 'd') THEN
      i_end = ite
      j_end = jte
      k_end = MIN(kte,kde-1)
   ELSEIF (stag .EQ. 'e') THEN
      i_end = ite
      j_end = MIN(jte,jde-1)
      k_end = kte
   ELSEIF (stag .EQ. 'f') THEN
      i_end = MIN(ite,ide-1)
      j_end = jte
      k_end = kte
   ENDIF
 
   inside = 0
   top = kts

   !start the searching algorithm to find the points inside of the terrain profile  
   DO i=its,i_end
      DO j=jts,j_end
         IF ((stag .EQ. 'w') .AND. (ht_p(i,kts,j) .GT. ibm_ht(i,j))) THEN
            write(wrf_err_message,'(3(A,I3),A,F16.11,2(A,I3),A,F16.11,2A)')  &
               "--- ERROR: ht_p(",i,",",kts,",",j,")=",ht_p(i,kts,j), &
               " is greater than ibm_ht(",i,",",j,")=",ibm_ht(i,j)," stag=",stag
            CALL wrf_error_fatal(TRIM(wrf_err_message))
         ELSEIF ((stag .EQ. 'w') .AND. (ht_p(i,kts,j) .EQ. ibm_ht(i,j))) THEN
            inside(i,kts,j) = 1 !the point is inside
            top(i,j) = kts
            GOTO 205
         ELSEIF ((stag .NE. 'w') .AND. (ht_p(i,kts,j) .GT. ibm_ht(i,j))) THEN
            inside(i,kts,j) = 1 !the point is inside
            top(i,j) = kts
            GOTO 205
         ELSE !ht_p(i,kts,j) .LT. ibm_ht(i,j)
            inside(i,kts,j) = 1 !the point is inside
            inside_all(i,kts,j) = 1 !RSA inside_all includes recon pts, while inside does not
            DO k=kts+1,k_end
               IF (ibm_ht(i,j) .GE. ht_p(i,k,j)) THEN
                  inside(i,k,j) = 1 !the point is inside
                  inside_all(i,k,j) = 1 !RSA inside_all includes recon pts, while inside does not
               ENDIF
               IF (inside(i,k-1,j)-inside(i,k,j) .NE. 0) THEN
                  inside(i,k,j) = 1
                  top(i,j) = k !k index just above boundary
                  GOTO 205 
               ENDIF
            ENDDO !k-loop
         ENDIF
         205 CONTINUE
         dist = ht_p(i,top(i,j),j)-ibm_ht(i,j)
         IF ((.not. zero_within_z_rough) .and. (dist .LE. z_rough)) THEN
            top(i,j) = top(i,j)+1
            inside(i,top(i,j),j) = 1
         ENDIF
         !RSA if the reconstruction pt is within a specified tolerance of the
         !boundary, move it up one level. This should only be turned on with
         !ibm_opt=3 (VRM) for now.
         IF ((bump_up_recon_pt_within_tol) .and. &
             (dist .LE. recon_pt_bump_tol*(ht_p(i,top(i,j)+1,j)-ht_p(i,top(i,j),j)))) THEN
            top(i,j) = top(i,j)+1
            inside(i,top(i,j),j) = 1
         ENDIF
         !RSA end
      ENDDO !j-loop
   ENDDO !i-loop      
   
 END SUBROUTINE reconstruct_pts_top

!------------------------------------------------------------------------------------

 SUBROUTINE count_side_pts ( stag, top, ns,                &
                             ids, ide, jds, jde, kds, kde, &
                             ims, ime, jms, jme, kms, kme, &
                             its, ite, jts, jte, kts, kte )

 IMPLICIT NONE
 !input data
 CHARACTER, INTENT(IN   )                                 :: stag
 INTEGER, DIMENSION(ims:ime,jms:jme), INTENT(IN   )       :: top  !the 'top boundary' ghost points
 INTEGER, INTENT(  OUT)                                   :: ns   !number of 'side boundary' ghost points					     							      							           			     
 INTEGER, INTENT(IN   )        :: ids, ide, jds, jde, kds, kde, & !d: domain 
                                  ims, ime, jms, jme, kms, kme, & !m: memory
                                  its, ite, jts, jte, kts, kte    !p: patch, t: tile

 !local data
 INTEGER                                                   :: i, j,  &
                                                              i_end, &
                                                              j_end

!---------------------------------------------------------------------------------
 !the executable begins here
 CALL wrf_debug(100,'dyn_em/module_ibm.F/subroutine count_side_pts')
!--------------------------------------------------------------------------------- 
 !initalize the counter for the side points
 ns = 0 
 
 IF ((stag .EQ. 'u') .OR. (stag .EQ. 'e')) THEN
    i_end = ite
    j_end = MIN(jte,jde-1)
 ELSEIF ((stag .EQ. 'v') .OR. (stag .EQ. 'f')) THEN
    i_end = MIN(ite,ide-1)
    j_end = jte
 ELSEIF (stag .EQ. 'w') THEN
    i_end = MIN(ite,ide-1)
    j_end = MIN(jte,jde-1)
 ELSEIF (stag .EQ. 't') THEN
    i_end = MIN(ite,ide-1)
    j_end = MIN(jte,jde-1)
 ELSEIF (stag .EQ. 'd') THEN
    i_end = ite
    j_end = jte
 ENDIF   
   
 DO i=its,i_end
 DO j=jts,j_end
    !check for side boundary points, and run the counter 
    !right now, I am counting some points twice, like those 
    !at corners. Meaning, the same ghost point is found in the 
    !loop over the x and y directions       
    !side points in the x direction
    IF (i .NE. ids) THEN
       IF (ABS(top(i,j)-top(i-1,j)) .GT. 1) THEN
           ns=ns+(ABS(top(i,j)-top(i-1,j))-1)
       ENDIF
    ENDIF
    !side points in the y direction	
    IF (j .NE. jds) THEN
       IF (ABS(top(i,j)-top(i,j-1)) .GT. 1) THEN
           ns=ns+(ABS(top(i,j)-top(i,j-1))-1)
       ENDIF
    ENDIF
 ENDDO !end of j loop
 ENDDO !end of i loop

! write(*,*) '  the number of side points is', ns, stag
! if (ns > 0) CALL wrf_error_fatal ('There are side points')

 END SUBROUTINE count_side_pts

!------------------------------------------------------------------------------------

 SUBROUTINE label_side_pts_inside ( stag, inside, top,            &
                                    ids, ide, jds, jde, kds, kde, &
                                    ims, ime, jms, jme, kms, kme, &
                                    its, ite, jts, jte, kts, kte )
 
 IMPLICIT NONE
 !input data
 CHARACTER, INTENT(IN   )                                   :: stag
 INTEGER, DIMENSION(ims:ime,kms:kme,jms:jme), INTENT(INOUT) :: inside
 INTEGER, DIMENSION(ims:ime,jms:jme), INTENT(IN   )         :: top     !the 'top boundary' ghost points				     							      							           			     
 INTEGER, INTENT(IN   )        :: ids, ide, jds, jde, kds, kde, &      !d: domain 
                                  ims, ime, jms, jme, kms, kme, &      !m: memory
                                  its, ite, jts, jte, kts, kte         !p: patch, t: tile
 !local data
 INTEGER                                                   :: i, j,   &
                                                              i_end,  &
                                                              j_end

!---------------------------------------------------------------------------------
 !the executable begins here
 CALL wrf_debug(100,'dyn_em/module_ibm.F/subroutine label_side_pts_inside')
!--------------------------------------------------------------------------------- 

 IF ((stag .EQ. 'u') .OR. (stag .EQ. 'e')) THEN
    i_end = ite
    j_end = MIN(jte,jde-1)
 ELSEIF ((stag .EQ. 'v') .OR. (stag .EQ. 'f')) THEN
    i_end = MIN(ite,ide-1)
    j_end = jte
 ELSEIF (stag .EQ. 'w') THEN
    i_end = MIN(ite,ide-1)
    j_end = MIN(jte,jde-1)
 ELSEIF (stag .EQ. 't') THEN
    i_end = MIN(ite,ide-1)
    j_end = MIN(jte,jde-1)
 ELSEIF (stag .EQ. 'd') THEN
    i_end = ite
    j_end = jte
 ENDIF
   
 DO i=its,i_end
 DO j=jts,j_end
    IF (i .NE. ids) THEN !start x search
       IF (top(i,j)-top(i-1,j) .GT. 1) THEN
          inside(i-1,top(i-1,j)+1:top(i,j)-1,j) = 1
       ELSEIF (top(i,j)-top(i-1,j) .LT. 1) THEN
          inside(i,top(i,j)+1:top(i-1,j)-1,j) = 1
       ENDIF
    ENDIF !end of x search

    IF (j .NE. jds) THEN !start y search
       IF (top(i,j)-top(i,j-1) .GT. 1) THEN
           inside(i,top(i,j-1)+1:top(i,j)-1,j-1) = 1
       ELSEIF (top(i,j)-top(i,j-1) .LT. 1) THEN
           inside(i,top(i,j)+1:top(i,j-1)-1,j) = 1   
       ENDIF  
    ENDIF !end of y search 	
 ENDDO !end of j loop
 ENDDO !end of i loop

 END SUBROUTINE label_side_pts_inside

!------------------------------------------------------------------------------------

 SUBROUTINE ghost_pts_side( stag, top, side, ns,          &
                            ids, ide, jds, jde, kds, kde, &
                            ims, ime, jms, jme, kms, kme, &
                            its, ite, jts, jte, kts, kte )

 IMPLICIT NONE
 !input data
 CHARACTER, INTENT(IN   )                                 :: stag
 INTEGER, DIMENSION(ims:ime,jms:jme), INTENT(IN   )       :: top  !'top boundary' ghost points
 INTEGER, DIMENSION(3,ns), INTENT(  OUT)                  :: side !'side boundary' ghost points
 INTEGER, INTENT(IN   )                                   :: ns   !number of 'side boundary' ghost points
 INTEGER, INTENT(IN   )        :: ids, ide, jds, jde, kds, kde, & !d: domain 
                                  ims, ime, jms, jme, kms, kme, & !m: memory
                                  its, ite, jts, jte, kts, kte    !p: patch, t: tile
 !local data							     
 INTEGER                                                 :: i, j, C, &
                                                            i_end,   &
                                                            j_end,   &
                                                            nsC,     & !these are the counters for side ghost points
                                                            ns1

! ---------------------------------------------------------------------------------
 !the executable begins here
 CALL wrf_debug(100,'dyn_em/module_ibm.F/subroutine ghost_pts_side')
! --------------------------------------------------------------------------------- 
 !and initialize the arrays to be computed
 side = 0     
 !initialize the counters
 nsC = 1
 ns1 = 1
 
 IF ((stag .EQ. 'u') .OR. (stag .EQ. 'e')) THEN
    i_end = ite
    j_end = MIN(jte,jde-1)
 ELSEIF ((stag .EQ. 'v') .OR. (stag .EQ. 'f')) THEN
    i_end = MIN(ite,ide-1)
    j_end = jte
 ELSEIF (stag .EQ. 'w') THEN
    i_end = MIN(ite,ide-1)
    j_end = MIN(jte,jde-1)
 ELSEIF (stag .EQ. 't') THEN
    i_end = MIN(ite,ide-1)
    j_end = MIN(jte,jde-1)
 ELSEIF (stag .EQ. 'd') THEN
    i_end = ite
    j_end = jte
 ENDIF

 DO i=its,i_end
 DO j=jts,j_end
    IF (i .NE. ids) THEN !start x search
       IF (top(i,j)-top(i-1,j) .GT. 1) THEN
           C = 1
           DO WHILE (ns1 .LE. nsC+ABS(top(i,j)-top(i-1,j))-2)
               side(1,ns1) = i
               side(2,ns1) = j
               side(3,ns1) = top(i-1,j)+C
               ns1 = ns1+1
               C = C+1
           ENDDO
           nsC = ns1
       ELSEIF (top(i,j)-top(i-1,j) .LT. 1) THEN
           C = 1
           DO WHILE (ns1 .LE. nsC+ABS(top(i,j)-top(i-1,j))-2)
               side(1,ns1) = i-1
               side(2,ns1) = j
               side(3,ns1) = top(i-1,j)-C
               ns1 = ns1+1
               C = C+1
           ENDDO
           nsC = ns1
       ENDIF
    ENDIF !end of x search

    IF (j .NE. jds) THEN !start y search
       IF (top(i,j)-top(i,j-1) .GT. 1) THEN
           C = 1
           DO WHILE (ns1 .LE. nsC+ABS(top(i,j)-top(i,j-1))-2)
               side(1,ns1) = i
               side(2,ns1) = j
               side(3,ns1) = top(i,j-1)+C
               ns1 = ns1+1
               C = C+1
           ENDDO
           nsC = ns1
       ELSEIF (top(i,j)-top(i,j-1) .LT. 1) THEN
           C = 1
           DO WHILE (ns1 .LE. nsC+ABS(top(i,j)-top(i,j-1))-2)
               side(1,ns1) = i
               side(2,ns1) = j-1
               side(3,ns1) = top(i,j-1)-C
               ns1 = ns1+1
               C = C+1
           ENDDO
           nsC = ns1
       ENDIF  
    ENDIF !end of y search 

 ENDDO !end of j loop    	   
 ENDDO !end of i loop  

 END SUBROUTINE ghost_pts_side

!-------------------------------------------------------------------------------  

 SUBROUTINE reconstruct_pts_side( stag, top, side, ns,          &
                                  ids, ide, jds, jde, kds, kde, &
                                  ims, ime, jms, jme, kms, kme, &
                                  its, ite, jts, jte, kts, kte )

 IMPLICIT NONE
 !input data
 CHARACTER, INTENT(IN   )                                 :: stag
 INTEGER, DIMENSION(ims:ime,jms:jme), INTENT(IN   )       :: top           !'top boundary' reconstruction point
 INTEGER, DIMENSION(3,ns), INTENT(  OUT)                  :: side          !'side boundary' reconstruction points
 INTEGER, INTENT(IN   )                                   :: ns            !number of 'side boundary' reconstruction points
 INTEGER, INTENT(IN   )        :: ids, ide, jds, jde, kds, kde,          & !d: domain 
                                  ims, ime, jms, jme, kms, kme,          & !m: memory
                                  its, ite, jts, jte, kts, kte             !p: patch, t: tile
   
 !local data							     
 INTEGER                                                 :: i, j, C,     &
                                                            i_end,       &
                                                            j_end,       &
                                                            nsC,         & !these are the counters for side reconstruction points
                                                            ns1

!---------------------------------------------------------------------------------
 !the executable begins here
 CALL wrf_debug(100,'dyn_em/module_ibm.F/subroutine reconstruct_pts_side')
!--------------------------------------------------------------------------------- 
 !and initialize the arrays to be computed
 side = 0     
 !initialize the counters
 nsC = 1
 ns1 = 1
 
 IF ((stag == 'u') .OR. (stag == 'e')) THEN
    i_end = ite
    j_end = MIN(jte,jde-1)
 ELSEIF ((stag == 'v') .OR. (stag == 'f')) THEN
    i_end = MIN(ite,ide-1)
    j_end = jte
 ELSEIF (stag == 'w') THEN
    i_end = MIN(ite,ide-1)
    j_end = MIN(jte,jde-1)
 ELSEIF (stag == 't') THEN
    i_end = MIN(ite,ide-1)
    j_end = MIN(jte,jde-1)
 ELSEIF (stag == 'd') THEN
    i_end = ite
    j_end = jte
 ENDIF
 
 DO i=its,i_end
 DO j=jts,j_end

    IF (i .NE. ids) THEN !start x search
       IF (top(i,j)-top(i-1,j) .GT. 1) THEN
          C = 1
          DO WHILE (ns1 .LE. nsC+ABS(top(i,j)-top(i-1,j))-2)
             side(1,ns1) = i-1
             side(2,ns1) = j
             side(3,ns1) = top(i-1,j)+C
             ns1 = ns1+1
             C = C+1
          ENDDO
          nsC = ns1
       ELSEIF (top(i,j)-top(i-1,j) .LT. 1) THEN
          C = 1
          DO WHILE (ns1 .LE. nsC+ABS(top(i,j)-top(i-1,j))-2)
             side(1,ns1) = i
             side(2,ns1) = j
             side(3,ns1) = top(i-1,j)-C
             ns1 = ns1+1
             C = C+1
          ENDDO
          nsC = ns1
       ENDIF
    ENDIF !end of x search

    IF (j .NE. jds) THEN !start y search
       IF (top(i,j)-top(i,j-1) .GT. 1) THEN
          C = 1
          DO WHILE (ns1 .LE. nsC+ABS(top(i,j)-top(i,j-1))-2)
             side(1,ns1) = i
             side(2,ns1) = j-1
             side(3,ns1) = top(i,j-1)+C
             ns1 = ns1+1
             C = C+1
          ENDDO
          nsC=ns1
       ELSEIF (top(i,j)-top(i,j-1) .LT. 1) THEN
          C = 1
          DO WHILE (ns1 .LE. nsC+ABS(top(i,j)-top(i,j-1))-2)
             side(1,ns1) = i
             side(2,ns1) = j
             side(3,ns1) = top(i,j-1)-C
             ns1 = ns1+1
             C = C+1
          ENDDO
          nsC = ns1
       ENDIF
    ENDIF !end of y search 

 ENDDO !end of j loop    	   
 ENDDO !end of i loop  

 END SUBROUTINE reconstruct_pts_side

!------------------------------------------------------------------------------- 

SUBROUTINE image_pts( stag, interp_opt, bc_type,             &
                      dx, dy, ht_p,                          &
                      ibm_ht_u, ibm_ht_v,                    &
                      ibm_ht_w, ibm_ht_c,                    &
                      top, side,                             &
                      top_img, top_bound,                    &
                      side_img, side_bound,                  &
                      prox, ns, top_norm, side_norm,         &
                      top_dist, side_dist,                   &
                      ids, ide, jds, jde, kds, kde,          &
                      ims, ime, jms, jme, kms, kme,          &
                      its, ite, jts, jte, kts, kte )

 IMPLICIT NONE
 !input data
 CHARACTER, INTENT(IN   )                                 :: stag
 INTEGER, INTENT(IN   )                                   :: interp_opt, bc_type
 REAL, INTENT(IN   )                                      :: dx, dy
 REAL, DIMENSION(ims:ime,kms:kme,jms:jme), INTENT(IN   )  :: ht_p
 REAL, DIMENSION(ims:ime,jms:jme), INTENT(IN   )          :: ibm_ht_u,  &
                                                             ibm_ht_v,  &
                                                             ibm_ht_w,  &
                                                             ibm_ht_c
 INTEGER, DIMENSION(ims:ime,jms:jme), INTENT(IN   )       :: top,       &    !'top boundary' ghost points
                                                             prox
 INTEGER, DIMENSION(3,ns), INTENT(IN   )                  :: side            !'side boundary' ghost points
 REAL, DIMENSION(ims:ime,jms:jme,6), INTENT(  OUT)        :: top_img         !(x,y,z) location of ghost point and image point of the 'top boundary' ghost points					                     
 REAL, DIMENSION(ims:ime,jms:jme,3), INTENT(  OUT)        :: top_bound, &    !(x,y,z) location of the boundary for top point
                                                             top_norm        !only used for the neumann condition
 REAL, DIMENSION(ims:ime,jms:jme), INTENT(   OUT)         :: top_dist
 REAL, DIMENSION(6,ns), INTENT(  OUT)                     :: side_img        !(x,y,z) location of ghost point and image point of the 'side boundary' ghost points
 REAL, DIMENSION(3,ns), INTENT(  OUT)                     :: side_bound,&    !(x,y,z) location of the boundary for side points
                                                             side_norm       !only used for the neumann condition
 REAL, DIMENSION(ns), INTENT(   OUT)                      :: side_dist
 INTEGER, INTENT(IN   )                                   :: ns              !number of 'side boundary' ghost points
 INTEGER ,       INTENT(IN   )   :: ids, ide, jds, jde, kds, kde, &          !d: domain
                                    ims, ime, jms, jme, kms, kme, &          !m: memory
                                    its, ite, jts, jte, kts, kte             !p: patch, t: tile
 !local data
 INTEGER                                                  :: i, j, &
                                                             S,    &
                                                             i_end,&
                                                             j_end
 REAL                                                     :: a, b, &          !coefficients of plane that represents terrain
                                                             c, d, &
                                                             mag,  &          !norm of gradient of eqn for plane SQRT(a**2+b**2+c**2)
                                                             dist             !distance (magnitude) from ghost point to terrain
 REAL, DIMENSION(3)                                       :: n,    &          !outward normal vector to terrain
                                                             GP,   &          !(x,y,z) location of ghost point
                                                             IP               !(x,y,z) location of image point						     

!---------------------------------------------------------------------------------
 !this subroutine finds the image of the immersed boundary method ghost points
 !the image is reflected across the boundary (terrain)
 CALL wrf_debug(100,'dyn_em/module_ibm.F/subroutine image_pts')
!--------------------------------------------------------------------------------

 !initialize the arrays top be computed
 top_img = 0.0
 top_bound = 0.0
 top_norm = 0.0
 top_dist = 0.0
 if (ns > 0) side_img = 0.0
 if (ns > 0) side_bound = 0.0
 if (ns > 0) side_norm = 0.0
 if (ns > 0) side_dist = 0.0
 
 IF (stag == 'u') THEN
    i_end = ite
    j_end = MIN(jte,jde-1)
 ELSEIF (stag == 'v') THEN
    i_end = MIN(ite,ide-1)
    j_end = jte
 ELSEIF ((stag == 'w') .OR. (stag == 't')) THEN
    i_end = MIN(ite,ide-1)
    j_end = MIN(jte,jde-1)
 ENDIF
 
 DO i = its,i_end
 DO j = jts,j_end
    ! find the image location for top ghost points
    ! (x,y,z) of ghost point
    IF (stag == 'u') THEN
        GP(1) = (i*dx)-(dx)  
    ELSE
        GP(1) = (i*dx)-(dx/2)
    ENDIF
    IF (stag == 'v') THEN
        GP(2) = (j*dy)-(dy)
    ELSE
        GP(2) = (j*dy)-(dy/2)
    ENDIF
    GP(3) = ht_p(i,top(i,j),j)
    ! equation for plane that represents terrain (ax+by+cz+d = 0)
    IF (stag == 'u') THEN
        a = (ibm_ht_w(i-1,j)-ibm_ht_w(i,j))/dx
        b = (ibm_ht_c(i,j)-ibm_ht_c(i,j+1))/dy
        c = 1.0
        d = ibm_ht_u(i,j)-GP(3)
    ELSEIF (stag == 'v') THEN
        a = (ibm_ht_c(i,j)-ibm_ht_c(i+1,j))/dx
        b = (ibm_ht_w(i,j-1)-ibm_ht_w(i,j))/dy
        c = 1.0
        d = ibm_ht_v(i,j)-GP(3)    
    ELSEIF ((stag == 'w') .OR. (stag == 't')) THEN    
        a = (ibm_ht_u(i,j)-ibm_ht_u(i+1,j))/dx
        b = (ibm_ht_v(i,j)-ibm_ht_v(i,j+1))/dy
        c = 1.0
        d = ibm_ht_w(i,j)-GP(3)
    ENDIF
    mag = SQRT(a**2+b**2+c**2)
    ! normal distance from ghost point to plane that represents terrain
    dist = d/mag
    ! normal vector to plane
    n(1) = a/mag
    n(2) = b/mag
    n(3) = c/mag
    ! (x,y,z) of image point
    if (prox(i,j) == 0) then
        IP = GP+2*dist*n
    elseif (prox(i,j) == 1) then
        IP = GP
    endif   
    ! extra check to make sure image is outside of terrain
    IF (stag == 'u') THEN
        IF ((IP(3) < ibm_ht_u(i,j))  .AND.  &
            (IP(3) < ibm_ht_w(i-1,j)).AND.  &
            (IP(3) < ibm_ht_w(i,j))  .AND.  &
            (IP(3) < ibm_ht_c(i,j))  .AND.  &
            (IP(3) < ibm_ht_c(i,j+1))) THEN
            ! make the x and y slope zero
            a = 0.0
            b = 0.0
            ! recalculate the normal
            mag = SQRT(a**2+b**2+c**2)
            dist = d/mag
            n(1) = a/mag
            n(2) = b/mag
            n(3) = c/mag
            ! recalculate the image point
            IP = GP+2*dist*n
        ENDIF
    ELSEIF (stag == 'v') THEN
        IF ((IP(3) < ibm_ht_v(i,j))  .AND.  &
            (IP(3) < ibm_ht_c(i,j))  .AND.  &
            (IP(3) < ibm_ht_c(i+1,j)).AND.  &
            (IP(3) < ibm_ht_w(i,j-1)).AND.  &
            (IP(3) < ibm_ht_w(i,j))) THEN
            ! make the x and y slope zero
            a = 0.0
            b = 0.0
            ! recalculate the normal
            mag = SQRT(a**2+b**2+c**2)
            dist = d/mag
            n(1) = a/mag
            n(2) = b/mag
            n(3) = c/mag
            ! recalculate the image point
            IP = GP+2*dist*n
        ENDIF
    ELSEIF ((stag == 'w').OR.(stag == 't')) THEN   
        IF ((IP(3) < ibm_ht_w(i,j))  .AND.  &
            (IP(3) < ibm_ht_u(i,j))  .AND.  &
            (IP(3) < ibm_ht_u(i+1,j)).AND.  &
            (IP(3) < ibm_ht_v(i,j))  .AND.  &
            (IP(3) < ibm_ht_v(i,j+1))) THEN
            ! make the x and y slope zero
            a = 0.0
            b = 0.0
            ! recalculate the normal
            mag = SQRT(a**2+b**2+c**2)
            dist = d/mag
            n(1) = a/mag
            n(2) = b/mag
            n(3) = c/mag
            ! recalculate the image point
            IP = GP+2*dist*n
        ENDIF
    ENDIF
    ! (x,y,z) of boundary point
    top_bound(i,j,1:3) = GP+dist*n
    ! change for interp_opt 2, bc_type 2 to put the image point on the face of the cut cell
    ! if it is 'too' close to the boundary for the Neumann boundary conditions
    ! right now only stag t uses bc_type , so it is the only stag that is programmed
    IF ((interp_opt == 2) .AND. (bc_type == 2)) THEN 
       IF ((ABS(IP(1)-GP(1)) .LT. dx) .AND. (ABS(IP(2)-GP(2)) .LT. dy) .AND. (IP(3) .LT. ht_p(i,top(i,j)+1,j))) THEN
          !DJW changed the conditional to avoid dividing by 0 if n(2)=0
          !IF (ABS(n(1)/n(2)) .GT. (dx/dy)) THEN
          IF (ABS(n(1)/dx) .GT. ABS(n(2)/dy)) THEN
             IF (ABS(n(1)/n(3)) .GT. (dx/(ht_p(i,top(i,j)+1,j)-ht_p(i,top(i,j),j)))) THEN !intersects with x side
                dist = ABS(dx/n(1))/2.0
                IP = GP+2*dist*n  
             ELSE ! intersects with top
                dist = ABS((ht_p(i,top(i,j)+1,j)-GP(3))/n(3))/2.0
                IP = GP+2*dist*n      
             ENDIF
          ELSE
             IF (ABS(n(2)/n(3)) .GT. (dy/(ht_p(i,top(i,j)+1,j)-ht_p(i,top(i,j),j)))) THEN !intersects with y side
                dist = ABS(dy/n(2))/2.0
                IP = GP+2*dist*n  
             ELSE ! intersects with top
                dist = ABS((ht_p(i,top(i,j)+1,j)-GP(3))/n(3))/2.0
                IP = GP+2*dist*n   
             ENDIF
          ENDIF
       ENDIF
    ENDIF
 
    ! change for interp_opt 3, bc_type 2 to put the image point on the face of the cut cell
    ! ALWAYS (NOT if it is 'too' close to the boundary for the Neumann boundary conditions AS ABOVE)
    ! right now only stag t uses bc_type , so it is the only stag that is programmed
    IF ((interp_opt == 3) .AND. (bc_type == 2)) THEN 
       !IF (stag == 'u') THEN

       !ELSEIF (stag == 'v') THEN

       !ELSEIF ((stag == 'w').OR.(stag == 't')) THEN
         !IF ((ABS(IP(1)-GP(1))<dx).AND.(ABS(IP(2)-GP(2))<dy).AND.(IP(3)<ht_p(i,top(i,j)+1,j))) THEN
            !print '(2i12,6f12.4)', i,j,n, ABS(n(1)/n(3)),ABS(n(2)/n(3)),ABS(n(1)/n(2))
            if (ABS(n(1)/n(2)) > (dx/dy)) then
              if (ABS(n(1)/n(3)) > (dx/(ht_p(i,top(i,j)+1,j)-ht_p(i,top(i,j),j)))) then !intersects with x side
                 !print *, i,j,'intersects with x side', n(1)		 
                 dist = ABS(dx/n(1))/2.
                 IP = GP+2*dist*n  
              else ! intersects with top
                 !print *, i,j,'intersects with top 1', n(3)
                 dist = ABS((ht_p(i,top(i,j)+1,j)-GP(3))/n(3))/2.
                 IP = GP+2*dist*n      
              endif
            else
              if (ABS(n(2)/n(3)) > (dy/(ht_p(i,top(i,j)+1,j)-ht_p(i,top(i,j),j)))) then !intersects with y side
                 !print *, i,j,'intersects with y side', n(2)
                 dist = ABS(dy/n(2))/2.
                 IP = GP+2*dist*n  
              else ! intersects with top
                 !print *, i,j,'intersects with top 2',n(3)
                 dist = ABS((ht_p(i,top(i,j)+1,j)-GP(3))/n(3))/2.
                 IP = GP+2*dist*n   
              endif
            endif
         !ENDIF
       !ENDIF
    ENDIF     

    !top_slope(i,j,3) = -n(1)/n(3)
    top_dist(i,j) = dist
    top_norm(i,j,1:3)=n
    top_img(i,j,1:3)=GP
    !if (prox(i,j)==0) then	  
       top_img(i,j,4:6)=IP
    !elseif (prox(i,j)==1) then
    !  	top_img(i,j,4:6)=GP
    !endif
    
 ENDDO !j-loop
 ENDDO !i-loop

 ! find the image of the s side ghost points
 if (ns > 0) then
    DO S=1,ns
        i = side(1,S)
        j = side(2,S) 
        ! (x,y,z) of ghost point
        IF (stag == 'u') THEN
            GP(1) = (i*dx)-(dx)  
        ELSE
            GP(1) = (i*dx)-(dx/2)
        ENDIF
        IF (stag == 'v') THEN
            GP(2) = (j*dy)-(dy)
        ELSE
            GP(2) = (j*dy)-(dy/2)
        ENDIF
        GP(3) = ht_p(i,side(3,S),j)
        ! equation for plane that represents terrain (ax+by+cz+d = 0)
        IF (stag == 'u') THEN
            d = ibm_ht_u(i,j)-GP(3)
            if ((ibm_ht_u(i-1,j) < ibm_ht_u(i,j)) .AND. (ibm_ht_u(i+1,j) < ibm_ht_u(i,j))) then ! on a ridge, figure out which way to go	    
               if (ibm_ht_u(i-1,j) == ibm_ht_u(i+1,j)) then ! the two are equal
                  if (ibm_ht_w(i-1,j) == ibm_ht_w(i,j)) then ! a=0, look closer to see if this is appropriate
                     if ((ABS(top(i,j+1)-top(i,j)) > 1) .OR. (ABS(top(i,j-1)-top(i,j)) > 1)) then ! the the side is north south and a=0 is fine
                        a = (ibm_ht_w(i-1,j)-ibm_ht_w(i,j))/dx
                     else ! this is a symetric ridge, there is a side to the left and right...fo left, this is an arbitrary choice
                        if (ibm_ht_w(i-1,j) >= ht_p(i,side(3,S)+1,j)) then 
                           a = (ibm_ht_u(i-1,j)-ibm_ht_w(i-1,j))/(dx/2)
                           d = 2*ibm_ht_w(i-1,j)-ibm_ht_u(i-1,j)-GP(3)
                        elseif (ibm_ht_w(i-1,j) > GP(3)) then
                           a = (ibm_ht_u(i-1,j)-ibm_ht_u(i,j))/dx
                        else
                           a = (ibm_ht_w(i-1,j)-ibm_ht_u(i,j))/(dx/2)
                        endif
                     endif
                  else
                     a = (ibm_ht_w(i-1,j)-ibm_ht_w(i,j))/dx
                  endif
               elseif (ibm_ht_u(i-1,j) < ibm_ht_u(i+1,j)) then ! go to the left
                  if (ibm_ht_w(i-1,j) >= ht_p(i,side(3,S)+1,j)) then 
                     a = (ibm_ht_u(i-1,j)-ibm_ht_w(i-1,j))/(dx/2)
                     d = 2*ibm_ht_w(i-1,j)-ibm_ht_u(i-1,j)-GP(3)
                  elseif (ibm_ht_w(i-1,j) > GP(3)) then
                     a = (ibm_ht_u(i-1,j)-ibm_ht_u(i,j))/dx
                  else
                     a = (ibm_ht_w(i-1,j)-ibm_ht_u(i,j))/(dx/2)
                  endif
               else ! (ibm_ht_u(i+1,j) < ibm_ht_u(i-1,j)) ! go to the right
                  if (ibm_ht_w(i,j) >= ht_p(i,side(3,S)+1,j)) then 
                     a = (ibm_ht_w(i,j)-ibm_ht_u(i+1,j))/(dx/2)
                     d = 2*ibm_ht_w(i,j)-ibm_ht_u(i+1,j)-GP(3)
                  elseif (ibm_ht_w(i,j) > GP(3)) then
                     a = (ibm_ht_u(i,j)-ibm_ht_u(i+1,j))/dx
                  else
                     a = (ibm_ht_u(i,j)-ibm_ht_w(i,j))/(dx/2)
                  endif
               endif  
            elseif (ibm_ht_u(i-1,j) < ibm_ht_u(i,j)) then !image is to the left
            !if (top(i-1,j) < top(i,j)) then !image is to the left
               ! Now, should I be calculating the x slope between u(i-1) and w(i-1),
               ! or between w(i-1) and u(i)
               if (ibm_ht_w(i-1,j) >= ht_p(i,side(3,S)+1,j)) then 
                  a = (ibm_ht_u(i-1,j)-ibm_ht_w(i-1,j))/(dx/2)
                  d = 2*ibm_ht_w(i-1,j)-ibm_ht_u(i-1,j)-GP(3)
               elseif (ibm_ht_w(i-1,j) > GP(3)) then
                  a = (ibm_ht_u(i-1,j)-ibm_ht_u(i,j))/dx
               else
                  a = (ibm_ht_w(i-1,j)-ibm_ht_u(i,j))/(dx/2)
               endif
            elseif (ibm_ht_u(i+1,j) < ibm_ht_u(i,j)) then ! image is to the right   
            !elseif (top(i+1,j) < top(i,j)) then ! image is to the right
               if (ibm_ht_w(i,j) >= ht_p(i,side(3,S)+1,j)) then 
                  a = (ibm_ht_w(i,j)-ibm_ht_u(i+1,j))/(dx/2)
                  d = 2*ibm_ht_w(i,j)-ibm_ht_u(i+1,j)-GP(3)
               elseif (ibm_ht_w(i,j) > GP(3)) then
                  a = (ibm_ht_u(i,j)-ibm_ht_u(i+1,j))/dx
               else
                  a = (ibm_ht_u(i,j)-ibm_ht_w(i,j))/(dx/2)
               endif
            else
               a = (ibm_ht_w(i-1,j)-ibm_ht_w(i,j))/dx
            endif
            if ((ibm_ht_u(i,j-1) < ibm_ht_u(i,j)) .AND. (ibm_ht_u(i,j+1) < ibm_ht_u(i,j))) then ! on a ridge
              if (ibm_ht_u(i,j-1) == ibm_ht_u(i,j+1)) then ! the two are equal
                 if (ibm_ht_c(i,j) == ibm_ht_c(i,j+1)) then ! b=0, look closer to see if this is appropriate
                    if ((ABS(top(i+1,j)-top(i,j)) > 1) .OR. (ABS(top(i-1,j)-top(i,j)) > 1)) then ! then the side is east west and b=0 is fine
                       b = (ibm_ht_c(i,j)-ibm_ht_c(i,j+1))/dy
                    else ! this is a symetric ridge, there is a side to the north and south...go south, this choice is arbitrary
                       if (ibm_ht_c(i,j) >= ht_p(i,side(3,S)+1,j)) then 
                          b = (ibm_ht_u(i,j-1)-ibm_ht_c(i,j))/(dy/2)
                          d = 2*ibm_ht_c(i,j)-ibm_ht_u(i,j-1)-GP(3)
                       elseif (ibm_ht_c(i,j) > GP(3)) then
                          b = (ibm_ht_u(i,j-1)-ibm_ht_u(i,j))/dy
                       else
                          b = (ibm_ht_c(i,j)-ibm_ht_u(i,j))/(dy/2)
                       endif
                    endif
                 else
                    b = (ibm_ht_c(i,j)-ibm_ht_c(i,j+1))/dy
                 endif
              elseif (ibm_ht_u(i,j-1) < ibm_ht_u(i,j+1)) then ! image is to the south
                 if (ibm_ht_c(i,j) >= ht_p(i,side(3,S)+1,j)) then 
                    b = (ibm_ht_u(i,j-1)-ibm_ht_c(i,j))/(dy/2)
                    d = 2*ibm_ht_c(i,j)-ibm_ht_u(i,j-1)-GP(3)
                 elseif (ibm_ht_c(i,j) > GP(3)) then
                    b = (ibm_ht_u(i,j-1)-ibm_ht_u(i,j))/dy
                 else
                    b = (ibm_ht_c(i,j)-ibm_ht_u(i,j))/(dy/2)
                 endif
              else ! image is to the north
                 if (ibm_ht_c(i,j+1) >= ht_p(i,side(3,S)+1,j)) then 
                    b = (ibm_ht_c(i,j+1)-ibm_ht_u(i,j+1))/(dy/2)
                    d = 2*ibm_ht_c(i,j+1)-ibm_ht_u(i,j+1)-GP(3)
                 elseif (ibm_ht_c(i,j+1) > GP(3)) then
                    b = (ibm_ht_u(i,j)-ibm_ht_u(i,j+1))/dy
                 else
                    b = (ibm_ht_u(i,j)-ibm_ht_c(i,j+1))/(dy/2)
                 endif
              endif
            elseif (ibm_ht_u(i,j-1) < ibm_ht_u(i,j)) then !image is to the south	    
            !if (top(i,j-1) < top(i,j)) then !image is to the south
               ! Now, should I be calculating the y slope between u(j-1) and c(j),
               ! or between c(j) and u(j)
               if (ibm_ht_c(i,j) >= ht_p(i,side(3,S)+1,j)) then 
                  b = (ibm_ht_u(i,j-1)-ibm_ht_c(i,j))/(dy/2)
                  d = 2*ibm_ht_c(i,j)-ibm_ht_u(i,j-1)-GP(3)
               elseif (ibm_ht_c(i,j) > GP(3)) then
                  b = (ibm_ht_u(i,j-1)-ibm_ht_u(i,j))/dy
               else
                  b = (ibm_ht_c(i,j)-ibm_ht_u(i,j))/(dy/2)
               endif
            elseif (ibm_ht_u(i,j+1) < ibm_ht_u(i,j)) then ! image is to the north   
            !elseif (top(i,j+1) < top(i,j)) then ! image is to the north
               if (ibm_ht_c(i,j+1) >= ht_p(i,side(3,S)+1,j)) then 
                  b = (ibm_ht_c(i,j+1)-ibm_ht_u(i,j+1))/(dy/2)
                  d = 2*ibm_ht_c(i,j+1)-ibm_ht_u(i,j+1)-GP(3)
               elseif (ibm_ht_c(i,j+1) > GP(3)) then
                  b = (ibm_ht_u(i,j)-ibm_ht_u(i,j+1))/dy
               else
                  b = (ibm_ht_u(i,j)-ibm_ht_c(i,j+1))/(dy/2)
               endif
            else
               b = (ibm_ht_c(i,j)-ibm_ht_c(i,j+1))/dy
            endif
        ELSEIF (stag == 'v') THEN
            d = ibm_ht_v(i,j)-GP(3)
            if ((ibm_ht_v(i-1,j) < ibm_ht_v(i,j)) .AND. (ibm_ht_v(i+1,j) < ibm_ht_v(i,j))) then ! if on a ridge, figure out which way to go
               if (ibm_ht_v(i-1,j) == ibm_ht_v(i+1,j)) then ! the two are equal
                  if (ibm_ht_c(i,j) == ibm_ht_c(i+1,j)) then ! a=0, look closer to see if this is appropriate
                     if ((ABS(top(i,j+1)-top(i,j)) > 1) .OR. (ABS(top(i,j-1)-top(i,j)) > 1)) then ! the the side is north south and a=0 is fine
                        a = (ibm_ht_c(i,j)-ibm_ht_c(i+1,j))/dx
                     else  ! this is a symetric ridge, there is a side to the left and right...go left, this choice is arbitrary
                        if (ibm_ht_c(i,j) >= ht_p(i,side(3,S)+1,j)) then 
                           a = (ibm_ht_v(i-1,j)-ibm_ht_c(i,j))/(dx/2)
                           d = 2*ibm_ht_c(i,j)-ibm_ht_v(i-1,j)-GP(3)
                        elseif (ibm_ht_c(i,j) > GP(3)) then
                           a = (ibm_ht_v(i-1,j)-ibm_ht_v(i,j))/dx
                        else
                           a = (ibm_ht_c(i,j)-ibm_ht_v(i,j))/(dx/2)
                        endif
                     endif
                  else
                     a = (ibm_ht_c(i,j)-ibm_ht_c(i+1,j))/dx
                  endif
               elseif (ibm_ht_v(i-1,j) < ibm_ht_v(i+1,j)) then ! go to the left
                  if (ibm_ht_c(i,j) >= ht_p(i,side(3,S)+1,j)) then 
                     a = (ibm_ht_v(i-1,j)-ibm_ht_c(i,j))/(dx/2)
                     d = 2*ibm_ht_c(i,j)-ibm_ht_v(i-1,j)-GP(3)
                  elseif (ibm_ht_c(i,j) > GP(3)) then
                     a = (ibm_ht_v(i-1,j)-ibm_ht_v(i,j))/dx
                  else
                     a = (ibm_ht_c(i,j)-ibm_ht_v(i,j))/(dx/2)
                  endif
               else   ! go to the right
                  if (ibm_ht_c(i+1,j) >= ht_p(i,side(3,S)+1,j)) then 
                     a = (ibm_ht_c(i+1,j)-ibm_ht_v(i+1,j))/(dx/2)
                     d = 2*ibm_ht_c(i+1,j)-ibm_ht_v(i+1,j)-GP(3)
                  elseif (ibm_ht_c(i+1,j) > GP(3)) then
                     a = (ibm_ht_v(i,j)-ibm_ht_v(i+1,j))/dx
                  else
                     a = (ibm_ht_v(i,j)-ibm_ht_c(i+1,j))/(dx/2)
                  endif
               endif
            elseif (ibm_ht_v(i-1,j) < ibm_ht_v(i,j)) then !image is to the left
            !if (top(i-1,j) < top(i,j)) then !image is to the left
               if (ibm_ht_c(i,j) >= ht_p(i,side(3,S)+1,j)) then 
                  a = (ibm_ht_v(i-1,j)-ibm_ht_c(i,j))/(dx/2)
                  d = 2*ibm_ht_c(i,j)-ibm_ht_v(i-1,j)-GP(3)
               elseif (ibm_ht_c(i,j) > GP(3)) then
                  a = (ibm_ht_v(i-1,j)-ibm_ht_v(i,j))/dx
               else
                  a = (ibm_ht_c(i,j)-ibm_ht_v(i,j))/(dx/2)
               endif
            elseif (ibm_ht_v(i+1,j) < ibm_ht_v(i,j)) then ! image is to the right  
            !elseif (top(i+1,j) < top(i,j)) then ! image is to the right
               if (ibm_ht_c(i+1,j) >= ht_p(i,side(3,S)+1,j)) then 
                  a = (ibm_ht_c(i+1,j)-ibm_ht_v(i+1,j))/(dx/2)
                  d = 2*ibm_ht_c(i+1,j)-ibm_ht_v(i+1,j)-GP(3)
               elseif (ibm_ht_c(i+1,j) > GP(3)) then
                  a = (ibm_ht_v(i,j)-ibm_ht_v(i+1,j))/dx
               else
                  a = (ibm_ht_v(i,j)-ibm_ht_c(i+1,j))/(dx/2)
               endif
            else
               a = (ibm_ht_c(i,j)-ibm_ht_c(i+1,j))/dx
            endif
            if ((ibm_ht_v(i,j-1) < ibm_ht_v(i,j)) .AND. (ibm_ht_v(i,j+1) < ibm_ht_v(i,j))) then ! on a ridge
               if (ibm_ht_v(i,j-1) == ibm_ht_v(i,j+1)) then ! the two are equal
                  if (ibm_ht_w(i,j-1) == ibm_ht_w(i,j)) then ! b=0, look closer to see if this is appropriate
                     if ((ABS(top(i+1,j)-top(i,j)) > 1) .OR. (ABS(top(i-1,j)-top(i,j)) > 1)) then ! then the side is east west and b=0 is fine
                        b = (ibm_ht_w(i,j-1)-ibm_ht_w(i,j))/dy
                     else ! this is a symetric ridge, there is a side to the north and south...go south, this choice is arbitrary		  
                        if (ibm_ht_w(i,j-1) >= ht_p(i,side(3,S)+1,j)) then 
                           b = (ibm_ht_v(i,j-1)-ibm_ht_w(i,j-1))/(dy/2)
                           d = 2*ibm_ht_w(i,j-1)-ibm_ht_v(i,j-1)-GP(3)
                        elseif (ibm_ht_w(i,j-1) > GP(3)) then
                           b = (ibm_ht_v(i,j-1)-ibm_ht_v(i,j))/dy
                        else
                           b = (ibm_ht_w(i,j-1)-ibm_ht_v(i,j))/(dy/2)
                        endif
                     endif
                  else
                     b = (ibm_ht_w(i,j-1)-ibm_ht_w(i,j))/dy
                  endif       
               elseif (ibm_ht_v(i,j-1) < ibm_ht_v(i,j+1)) then !image is to the south	       
                  if (ibm_ht_w(i,j-1) >= ht_p(i,side(3,S)+1,j)) then 
                     b = (ibm_ht_v(i,j-1)-ibm_ht_w(i,j-1))/(dy/2)
                     d = 2*ibm_ht_w(i,j-1)-ibm_ht_v(i,j-1)-GP(3)
                  elseif (ibm_ht_w(i,j-1) > GP(3)) then
                     b = (ibm_ht_v(i,j-1)-ibm_ht_v(i,j))/dy
                  else
                     b = (ibm_ht_w(i,j-1)-ibm_ht_v(i,j))/(dy/2)
                  endif
               else   ! image is to the north
                  if (ibm_ht_w(i,j) >= ht_p(i,side(3,S)+1,j)) then 
                     b = (ibm_ht_w(i,j)-ibm_ht_v(i,j+1))/(dy/2)
                     d = 2*ibm_ht_w(i,j)-ibm_ht_v(i,j+1)-GP(3)
                  elseif (ibm_ht_w(i,j) > GP(3)) then
                     b = (ibm_ht_v(i,j)-ibm_ht_v(i,j+1))/dy
                  else
                     b = (ibm_ht_v(i,j)-ibm_ht_w(i,j))/(dy/2)
                  endif   
               endif
            elseif (ibm_ht_v(i,j-1) < ibm_ht_v(i,j)) then !image is to the south
            !if (top(i,j-1) < top(i,j)) then !image is to the south
               ! Now, should I be calculating the y slope between v(j-1) and w(j-1),
               ! or between w(j-1) and v(j)
               if (ibm_ht_w(i,j-1) >= ht_p(i,side(3,S)+1,j)) then 
                  b = (ibm_ht_v(i,j-1)-ibm_ht_w(i,j-1))/(dy/2)
                  d = 2*ibm_ht_w(i,j-1)-ibm_ht_v(i,j-1)-GP(3)
               elseif (ibm_ht_w(i,j-1) > GP(3)) then
                  b = (ibm_ht_v(i,j-1)-ibm_ht_v(i,j))/dy
               else
                  b = (ibm_ht_w(i,j-1)-ibm_ht_v(i,j))/(dy/2)
               endif
            elseif (ibm_ht_v(i,j+1) < ibm_ht_v(i,j)) then !image is to the north       
            !elseif (top(i,j+1) < top(i,j)) then !image is to the north
               if (ibm_ht_w(i,j) >= ht_p(i,side(3,S)+1,j)) then 
                  b = (ibm_ht_w(i,j)-ibm_ht_v(i,j+1))/(dy/2)
                  d = 2*ibm_ht_w(i,j)-ibm_ht_v(i,j+1)-GP(3)
               elseif (ibm_ht_w(i,j) > GP(3)) then
                  b = (ibm_ht_v(i,j)-ibm_ht_v(i,j+1))/dy
               else
                  b = (ibm_ht_v(i,j)-ibm_ht_w(i,j))/(dy/2)
               endif
            else
               b = (ibm_ht_w(i,j-1)-ibm_ht_w(i,j))/dy
            endif
        ELSEIF ((stag == 'w') .OR. (stag == 't'))THEN
            d = ibm_ht_w(i,j)-GP(3)
            if ((ibm_ht_w(i-1,j) < ibm_ht_w(i,j)) .AND. (ibm_ht_w(i+1,j) < ibm_ht_w(i,j))) then ! if on a ridge, figure out which way to go
                if (ibm_ht_w(i-1,j) == ibm_ht_w(i+1,j)) then ! the two are equal
                   if (ibm_ht_u(i,j) == ibm_ht_u(i+1,j)) then ! a = 0, look closer to see if this is appropriate
                      if ((ABS(top(i,j+1)-top(i,j)) > 1) .OR. (ABS(top(i,j-1)-top(i,j)) > 1)) then ! the the side is north south and a=0 is fine
                         a = (ibm_ht_u(i,j)-ibm_ht_u(i+1,j))/dx
                      else  ! this is a symetric ridge, there is a side to the left and right...go left, this choice is arbitrary
                         if (ibm_ht_u(i,j) >= ht_p(i,side(3,S)+1,j)) then 
                            a = -(ibm_ht_u(i,j)-ibm_ht_w(i-1,j))/(dx/2)
                            d = 2*ibm_ht_u(i,j)-ibm_ht_w(i-1,j)-GP(3)
                         elseif (ibm_ht_u(i,j) > GP(3)) then
                            a = -(ibm_ht_w(i,j)-ibm_ht_w(i-1,j))/dx
                         else
                            a = -(ibm_ht_w(i,j)-ibm_ht_u(i,j))/(dx/2)
                         endif
                      endif
                   else
                      a = (ibm_ht_u(i,j)-ibm_ht_u(i+1,j))/dx
                   endif
                elseif (ibm_ht_w(i-1,j) < ibm_ht_w(i+1,j)) then ! go to the left
                   if (ibm_ht_u(i,j) >= ht_p(i,side(3,S)+1,j)) then 
                      a = -(ibm_ht_u(i,j)-ibm_ht_w(i-1,j))/(dx/2)
                      d = 2*ibm_ht_u(i,j)-ibm_ht_w(i-1,j)-GP(3)
                   elseif (ibm_ht_u(i,j) > GP(3)) then
                      a = -(ibm_ht_w(i,j)-ibm_ht_w(i-1,j))/dx
                   else
                      a = -(ibm_ht_w(i,j)-ibm_ht_u(i,j))/(dx/2)
                   endif
                else  ! if (ibm_ht_w(i+1,j) < ibm_ht_w(i-1,j)) then ! go to the right
                   if (ibm_ht_u(i+1,j) >= ht_p(i,side(3,S)+1,j)) then 
                      a = -(ibm_ht_w(i+1,j)-ibm_ht_u(i+1,j))/(dx/2)
                      d = 2*ibm_ht_u(i+1,j)-ibm_ht_w(i+1,j)-GP(3)
                   elseif (ibm_ht_u(i+1,j) > GP(3)) then
                      a = -(ibm_ht_w(i+1,j)-ibm_ht_w(i,j))/dx
                   else
                      a = -(ibm_ht_u(i+1,j)-ibm_ht_w(i,j))/(dx/2)
                   endif
                endif
            elseif (ibm_ht_w(i-1,j) < ibm_ht_w(i,j)) then !image is to the left
               if (ibm_ht_u(i,j) >= ht_p(i,side(3,S)+1,j)) then 
                  a = -(ibm_ht_u(i,j)-ibm_ht_w(i-1,j))/(dx/2)
                  d = 2*ibm_ht_u(i,j)-ibm_ht_w(i-1,j)-GP(3)
               elseif (ibm_ht_u(i,j) > GP(3)) then
                  a = -(ibm_ht_w(i,j)-ibm_ht_w(i-1,j))/dx
               else
                  a = -(ibm_ht_w(i,j)-ibm_ht_u(i,j))/(dx/2)
               endif
            elseif (ibm_ht_w(i+1,j) < ibm_ht_w(i,j)) then ! image is to the right  
               if (ibm_ht_u(i+1,j) >= ht_p(i,side(3,S)+1,j)) then 
                  a = -(ibm_ht_w(i+1,j)-ibm_ht_u(i+1,j))/(dx/2)
                  d = 2*ibm_ht_u(i+1,j)-ibm_ht_w(i+1,j)-GP(3)
               elseif (ibm_ht_u(i+1,j) > GP(3)) then
                  a = -(ibm_ht_w(i+1,j)-ibm_ht_w(i,j))/dx
               else
                  a = -(ibm_ht_u(i+1,j)-ibm_ht_w(i,j))/(dx/2)
               endif
            else
               a = (ibm_ht_u(i,j)-ibm_ht_u(i+1,j))/dx   
            endif
            if ((ibm_ht_w(i,j-1) < ibm_ht_w(i,j)) .AND. (ibm_ht_w(i,j+1) < ibm_ht_w(i,j))) then ! on a ridge      
               if (ibm_ht_w(i,j-1) == ibm_ht_w(i,j+1)) then ! the two are equal
                  if (ibm_ht_v(i,j+1) == ibm_ht_v(i,j)) then ! b=0, look closer to see if this is appropriate
                     if ((ABS(top(i+1,j)-top(i,j)) > 1) .OR. (ABS(top(i-1,j)-top(i,j)) > 1)) then ! then the side is east west and b=0 is fine
                        b = -(ibm_ht_v(i,j+1)-ibm_ht_v(i,j))/dy
                     else ! this is a symetric ridge, there is a side to the north and south...go south, this choice is arbitrary
                        if (ibm_ht_v(i,j) >= ht_p(i,side(3,S)+1,j)) then 
                           b = (ibm_ht_w(i,j-1)-ibm_ht_v(i,j))/(dy/2)
                           d = 2*ibm_ht_v(i,j)-ibm_ht_w(i,j-1)-GP(3)
                        elseif (ibm_ht_v(i,j) > GP(3)) then
                           b = (ibm_ht_w(i,j-1)-ibm_ht_w(i,j))/dy
                        else
                           b = (ibm_ht_v(i,j)-ibm_ht_w(i,j))/(dy/2)
                        endif
                     endif
                  else
                     b = -(ibm_ht_v(i,j+1)-ibm_ht_v(i,j))/dy
                  endif
               elseif (ibm_ht_w(i,j-1) < ibm_ht_w(i,j+1)) then !image is to the south
                  ! Now, should I be calculating the y slope between w(j-1) and v(j),
                  ! or between v(j) and w(j)
                  if (ibm_ht_v(i,j) >= ht_p(i,side(3,S)+1,j)) then 
                     b = (ibm_ht_w(i,j-1)-ibm_ht_v(i,j))/(dy/2)
                     d = 2*ibm_ht_v(i,j)-ibm_ht_w(i,j-1)-GP(3)
                  elseif (ibm_ht_v(i,j) > GP(3)) then
                     b = (ibm_ht_w(i,j-1)-ibm_ht_w(i,j))/dy
                  else
                     b = (ibm_ht_v(i,j)-ibm_ht_w(i,j))/(dy/2)
                  endif
               else  ! if (ibm_ht_w(i,j+1) < ibm_ht_w(i,j-1)) then  ! image is to the north 
                  if (ibm_ht_v(i,j+1) >= ht_p(i,side(3,S)+1,j)) then 
                     b = (ibm_ht_v(i,j+1)-ibm_ht_w(i,j+1))/(dy/2)
                     d = 2*ibm_ht_v(i,j+1)-ibm_ht_w(i,j+1)-GP(3)
                  elseif (ibm_ht_v(i,j+1) > GP(3)) then
                     b = (ibm_ht_w(i,j)-ibm_ht_w(i,j+1))/dy
                  else
                     b = (ibm_ht_w(i,j)-ibm_ht_v(i,j+1))/(dy/2)
                  endif
               endif
            elseif (ibm_ht_w(i,j-1) < ibm_ht_w(i,j)) then !image is to the south
            !if (top(i,j-1) < top(i,j)) then !image is to the south 
               ! Now, should I be calculating the y slope between w(j-1) and v(j),
               ! or between v(j) and w(j)
               if (ibm_ht_v(i,j) >= ht_p(i,side(3,S)+1,j)) then 
                  b = (ibm_ht_w(i,j-1)-ibm_ht_v(i,j))/(dy/2)
                  d = 2*ibm_ht_v(i,j)-ibm_ht_w(i,j-1)-GP(3)
               elseif (ibm_ht_v(i,j) > GP(3)) then
                  b = (ibm_ht_w(i,j-1)-ibm_ht_w(i,j))/dy
               else
                  b = (ibm_ht_v(i,j)-ibm_ht_w(i,j))/(dy/2)
               endif
            elseif (ibm_ht_w(i,j+1) < ibm_ht_w(i,j)) then ! image is to the north 
            !elseif (top(i,j+1) < top(i,j)) then ! image is to the north
               if (ibm_ht_v(i,j+1) >= ht_p(i,side(3,S)+1,j)) then 
                  b = (ibm_ht_v(i,j+1)-ibm_ht_w(i,j+1))/(dy/2)
                  d = 2*ibm_ht_v(i,j+1)-ibm_ht_w(i,j+1)-GP(3)
               elseif (ibm_ht_v(i,j+1) > GP(3)) then
                  b = (ibm_ht_w(i,j)-ibm_ht_w(i,j+1))/dy
               else
                  b = (ibm_ht_w(i,j)-ibm_ht_v(i,j+1))/(dy/2)
               endif
            else
               b = -(ibm_ht_v(i,j+1)-ibm_ht_v(i,j))/dy
            endif
        ENDIF
        c = 1.0
        ! normal distance from ghost point to plane that represents terrain
        mag = SQRT(a**2+b**2+c**2)
        dist = d/mag
        side_dist(S) = dist
        ! normal vector to plane
        n(1) = a/mag
        n(2) = b/mag
        n(3) = c/mag
        side_norm(1:3,S) = n
        ! (x,y,z) of boundary point
        side_bound(1:3,S) = GP+dist*n
        ! (x,y,z) of image point
        IP = GP+2*dist*n

        ! change for interp_opt 2, bc_type 2 to put the image point on the face of the cut cell
        ! if it is 'too' close to the boundary for the Neumann boundary conditions
        ! right now only stag t uses bc_type , so it is the only stag that is programmed
        IF ((interp_opt == 2) .AND. (bc_type == 2)) THEN
           IF ( (ABS(IP(1)-GP(1)) .LT. dx) .AND. &
                (ABS(IP(2)-GP(2)) .LT. dy) .AND. &
                (IP(3) .LT. ht_p(i,side(3,S)+1,j)) ) THEN
              !DJW changed the conditional to avoid dividing by 0 if n(2)=0
              !IF (ABS(n(1)/n(2)) .GT. (dx/dy)) THEN
              IF (ABS(n(1)/dx) .GT. ABS(n(2)/dy)) THEN
                 IF (ABS(n(1)/n(3)) .GT. (dx/(ht_p(i,side(3,S)+1,j)-ht_p(i,side(3,S),j)))) THEN !intersects with x side
                    dist = ABS(dx/n(1))
                    IP = GP+dist*n  
                 ELSE ! intersects with top
                    dist = ABS((ht_p(i,side(3,S)+1,j)-GP(3))/n(3))
                    IP = GP+dist*n     
                 ENDIF
              ELSE
                 IF (ABS(n(2)/n(3)) .GT. (dy/(ht_p(i,side(3,S)+1,j)-ht_p(i,side(3,S),j)))) THEN !intersects with y side
                     dist = ABS(dy/n(2))
                     IP = GP+dist*n  
                 ELSE ! intersects with top
                    dist = ABS((ht_p(i,side(3,S)+1,j)-GP(3))/n(3))
                    IP = GP+dist*n     
                 ENDIF
              ENDIF
           ENDIF
        ENDIF

        ! change for interp_opt 3, bc_type 2 to put the image point on the face of the cut cell
        ! ALWAYS (NOT if it is 'too' close to the boundary for the Neumann boundary conditions AS ABOVE)
        ! right now only stag t uses bc_type , so it is the only stag that is programmed
        IF ((interp_opt == 3) .AND. (bc_type == 2)) THEN
           !IF (stag == 'u') THEN

           !ELSEIF (stag == 'v') THEN

           !ELSEIF ((stag == 'w').OR.(stag == 't')) THEN
             !IF ((ABS(IP(1)-GP(1))<dx).AND.(ABS(IP(2)-GP(2))<dy).AND.(IP(3)<ht_p(i,side(3,S)+1,j))) THEN
                if (ABS(n(1)/n(2)) > (dx/dy)) then
                  if (ABS(n(1)/n(3)) > (dx/(ht_p(i,side(3,S)+1,j)-ht_p(i,side(3,S),j)))) then !intersects with x side
                     dist = ABS(dx/n(1))
                     IP = GP+dist*n  
                  else ! intersects with top
                     dist = ABS((ht_p(i,side(3,S)+1,j)-GP(3))/n(3))
                     IP = GP+dist*n     
                  endif
                else
                  if (ABS(n(2)/n(3)) > (dy/(ht_p(i,side(3,S)+1,j)-ht_p(i,side(3,S),j)))) then !intersects with y side
                     dist = ABS(dy/n(2))
                     IP = GP+dist*n  
                  else ! intersects with top
                     dist = ABS((ht_p(i,side(3,S)+1,j)-GP(3))/n(3))
                     IP = GP+dist*n     
                  endif
                endif
             !ENDIF
           !ENDIF
        ENDIF

        side_img(1:3,S) = GP
        side_img(4:6,S) = IP
    ENDDO
 endif ! end of finding the image of s side points
     
 END SUBROUTINE image_pts 
 
!------------------------------------------------------------------------------- 

SUBROUTINE interpolation_pts( stag,                         &
                              dx, dy, ht_p,                 &
                              ibm_ht_u, ibm_ht_v,           &
                              ibm_ht_w, ibm_ht_c,           &
                              inside, top, side,            &
                              top_img, top_bound,           &
                              side_img, side_bound,         &
                              ns, top_norm, side_norm,      &
                              top_dist, side_dist,          &
                              ibm_nn_horz, ibm_nn_vert,     &
                              ids, ide, jds, jde, kds, kde, &
                              ims, ime, jms, jme, kms, kme, &
                              its, ite, jts, jte, kts, kte )

 IMPLICIT NONE
 !input data
 CHARACTER, INTENT(IN   )                                  :: stag
 REAL, INTENT(IN   )                                       :: dx, dy
 REAL, DIMENSION(ims:ime,kms:kme,jms:jme), INTENT(IN   )   :: ht_p
 REAL, DIMENSION(ims:ime,jms:jme), INTENT(IN   )           :: ibm_ht_u,   &
                                                              ibm_ht_v,   &
                                                              ibm_ht_w,   &
                                                              ibm_ht_c
 INTEGER, DIMENSION(ims:ime,kms:kme,jms:jme), INTENT(IN   ):: inside
 INTEGER, DIMENSION(ims:ime,jms:jme), INTENT(IN   )        :: top           !'top boundary' forcing (reconstruction) points
 INTEGER, DIMENSION(3,ns), INTENT(IN   )                   :: side          !'side boundary' forcing (reconstruction) points
 REAL, DIMENSION(ims:ime,jms:jme,6), INTENT(  OUT)         :: top_img       !(x,y,z) location of forcing (reconstruction) point and interpolation point of the 'top boundary' forcing (reconstruction) points					                     
 REAL, DIMENSION(ims:ime,jms:jme,3), INTENT(  OUT)         :: top_bound,  & !(x,y,z) location of the boundary for top point
                                                              top_norm      !only used for the neumann condition
 REAL, DIMENSION(ims:ime,jms:jme,2), INTENT(   OUT)        :: top_dist      !distance from surface normal to reconstruction and interpolation point
 REAL, DIMENSION(6,ns), INTENT(  OUT)                      :: side_img      !(x,y,z) location of forcing (reconstruction) point and interpolation point of the 'side boundary' forcing (reconstruction) points
 REAL, DIMENSION(3,ns), INTENT(  OUT)                      :: side_bound, & !(x,y,z) location of the boundary for side points
                                                              side_norm     !only used for the neumann condition
 REAL, DIMENSION(2,ns), INTENT(   OUT)                     :: side_dist     !distance from surface normal to reconstruction and interpolation point
 INTEGER, INTENT(IN   )                                    :: ns,         & !number of 'side boundary' forcing (reconstruction) points
                                    ibm_nn_horz, ibm_nn_vert,             & !dims of searchbox for nearest neighbors
                                    ids, ide, jds, jde, kds, kde,         & !d: domain
                                    ims, ime, jms, jme, kms, kme,         & !m: memory
                                    its, ite, jts, jte, kts, kte            !p: patch, t: tile
 !local data
 INTEGER                                                  :: i, j,        &
                                                             S,           &
                                                             i_end,       &
                                                             j_end,       &
                                                             ii, ji, ki,  &
                                                             nn,          &
                                                             is, ks, js
 REAL                                                     :: a, b,        & !coefficients of plane that represents terrain
                                                             c, d,        &
                                                             mag,         & !norm of gradient of eqn for plane SQRT(a**2+b**2+c**2)
                                                             dist,        & !distance (magnitude) from forcing (reconstruction) point to terrain
                                                             e, f,        &
                                                             g, h,        &
                                                             d1, d2
 REAL, DIMENSION(3)                                       :: n,           & !outward normal vector to terrain
                                                             GP,          & !(x,y,z) location of forcing (reconstruction) point
                                                             IP             !(x,y,z) location of interpolation point
 LOGICAL                                                  :: moveip
 CHARACTER(len=265)                                       :: wrf_err_message

!---------------------------------------------------------------------------------
! this subroutine finds the interpolation point for the immersed boundary method forcing points
! when the forcing is in the fluid domain and velocity reconstruction is being used
 write(wrf_err_message, '(A,A)') 'dyn_em/module_ibm.F/subroutine interpolation_pts stag=',stag
 CALL wrf_debug(100, TRIM(wrf_err_message))
!--------------------------------------------------------------------------------

 !initialize the arrays top be computed
 top_img = 0.0
 top_bound = 0.0
 top_norm = 0.0
 top_dist = 0.0
 if (ns .GT. 0) side_img = 0.0
 if (ns .GT. 0) side_bound = 0.0
 if (ns .GT. 0) side_norm = 0.0
 if (ns .GT. 0) side_dist = 0.0
 
 IF (stag .EQ. 'u') THEN
    i_end = ite
    j_end = MIN(jte,jde-1)
 ELSEIF (stag .EQ. 'v') THEN
    i_end = MIN(ite,ide-1)
    j_end = jte
 ELSEIF ((stag .EQ. 'w') .OR. (stag .EQ. 't')) THEN
    i_end = MIN(ite,ide-1)
    j_end = MIN(jte,jde-1)
 ENDIF

 DO i=its,i_end
 DO j=jts,j_end
    !find the interpolation location for top forcing points (x,y,z) of forcing point
    IF (stag .EQ. 'u') THEN
       GP(1) = (i*dx)-(dx)  
    ELSE 
       GP(1) = (i*dx)-(dx/2.0)
    ENDIF
    IF (stag .EQ. 'v') THEN
       GP(2) = (j*dy)-(dy)
    ELSE
       GP(2) = (j*dy)-(dy/2.0)
    ENDIF
    GP(3) = ht_p(i,top(i,j),j)
    !equation for plane that represents terrain (ax+by+cz+d = 0)
    IF (stag .EQ. 'u') THEN
       a = (ibm_ht_w(i-1,j)-ibm_ht_w(i,j))/dx
       b = (ibm_ht_c(i,j)-ibm_ht_c(i,j+1))/dy
       c = 1.0
       d = ibm_ht_u(i,j)-GP(3)
    ELSEIF (stag .EQ. 'v') THEN
       a = (ibm_ht_c(i,j)-ibm_ht_c(i+1,j))/dx
       b = (ibm_ht_w(i,j-1)-ibm_ht_w(i,j))/dy
       c = 1.0
       d = ibm_ht_v(i,j)-GP(3)    
    ELSEIF ((stag .EQ. 'w') .OR. (stag .EQ. 't')) THEN    
       a = (ibm_ht_u(i,j)-ibm_ht_u(i+1,j))/dx
       b = (ibm_ht_v(i,j)-ibm_ht_v(i,j+1))/dy
       c = 1.0
       d = ibm_ht_w(i,j)-GP(3)
    ENDIF
    mag = SQRT(a**2+b**2+c**2)
    IF (mag .EQ. 0) THEN
       CALL wrf_error_fatal("DJW[module_ibm/interpolation_pts]: mag = 0.0, would divide by zero for top-point.")
    ENDIF
    !normal distance from forcing point to plane that represents terrain
    dist = d/mag
    !normal vector to plane
    n(1) = a/mag
    n(2) = b/mag
    n(3) = c/mag

    !(x,y,z) of boundary point
    top_bound(i,j,1:3) = GP+dist*n

    !distance to reconstruction point
    top_dist(i,j,1) = -dist

    !now find the interpolation point
    !put the interpolation point on the opposite face of the cell w/ the forcing point
    !the algorithm is similar to option interp_opt 2, bc_type 2 which puts the image point
    !on the face of the cut cell if it is 'too' close to the boundary for the Neumann boundary conditions

100 IF ((n(1) .EQ. 0.0) .AND. (n(2) .EQ. 0.0)) THEN
       !intersects with top
       dist = ABS((ht_p(i,top(i,j)+1,j)-GP(3))/n(3))
       IP = GP+dist*n
    ELSEIF (ABS(n(1))/dx .GT. ABS(n(2))/dy) THEN
       IF (ABS(n(1)/n(3)) .GT. (dx/(ht_p(i,top(i,j)+1,j)-ht_p(i,top(i,j),j)))) THEN !intersects with x side
          dist = ABS(dx/n(1))
          IP = GP+dist*n
       ELSE !intersects with top
          dist = ABS((ht_p(i,top(i,j)+1,j)-GP(3))/n(3))
          IP = GP+dist*n
       ENDIF
    ELSE
       IF (ABS(n(2)/n(3)) .GT. (dy/(ht_p(i,top(i,j)+1,j)-ht_p(i,top(i,j),j)))) THEN !intersects with y side
          dist = ABS(dy/n(2))
          IP = GP+dist*n
       ELSE !intersects with top
          dist = ABS((ht_p(i,top(i,j)+1,j)-GP(3))/n(3))
          IP = GP+dist*n
       ENDIF
    ENDIF

    IF (stag .EQ. "u") THEN
       ii = CEILING(IP(1)/dx)+1
    ELSE
       ii = CEILING((IP(1)-dx/2.0)/dx)+1
    ENDIF
    IF (stag .EQ. "v") THEN
       ji = CEILING(IP(2)/dy)+1
    ELSE
       ji = CEILING((IP(2)-dy/2.0)/dy)+1
    ENDIF
    ki = 1
    DO WHILE (IP(3) .GE. ht_p(i,ki,j))
       ki = ki+1
    ENDDO
    ki = ki-1
    ki = MAX(ki, 2)

    !DJW the commented lines below check to ensure there is at least two nearest neighbors
    !    but it slows down execution and shouldn't be uncommented unless you're debugging
    !    some new terrain and trying to locate problematic grid points.
!    nn = 0
!    DO is=ii-ibm_nn_horz/2+1,ii+ibm_nn_horz/2
!    DO ks=ki-ibm_nn_vert/2+1,ki+ibm_nn_vert/2
!    DO js=ji-ibm_nn_horz/2+1,ji+ibm_nn_horz/2
!       IF (inside(is, ks, js) .EQ. 0) THEN
!          nn = nn+1
!       ENDIF
!    ENDDO
!    ENDDO
!    ENDDO
!    IF (nn .LE. 1) THEN
!       write(*,'(3(A,F7.2))') "DJW[module_ibm/interpolation_pts]: GP(1)=",GP(1),"   GP(2)=",GP(2),"   GP(3)=",GP(3)
!       write(*,'(3(A,F7.2))') "DJW[module_ibm/interpolation_pts]: IP(1)=",IP(1),"   IP(2)=",IP(2),"   IP(3)=",IP(3)
!       write(wrf_err_message,'(2(A,I3),2A)') "--- ERROR: top IP at i=",i," j=",j," has too few neighbors. stag=",stag
!       CALL wrf_message(TRIM(wrf_err_message))
!    ENDIF

    !distance to interpolation point
    top_dist(i,j,2) = top_dist(i,j,1)+dist
    top_norm(i,j,1:3)=n
    
    top_img(i,j,1:3)=GP
    top_img(i,j,4:6)=IP

 ENDDO
 ENDDO

 !find the interpolation point for the s side ghost points
 IF (ns .GT. 0) THEN
    DO S=1,ns
       i = side(1,S)
       j = side(2,S)
       !(x,y,z) of interpolation point
       IF (stag .EQ. 'u') THEN
          GP(1) = (i*dx)-(dx)  
       ELSE
          GP(1) = (i*dx)-(dx/2)
       ENDIF
       IF (stag .EQ. 'v') THEN
          GP(2) = (j*dy)-(dy)
       ELSE
          GP(2) = (j*dy)-(dy/2)
       ENDIF
       GP(3) = ht_p(i,side(3,S),j)
       !equation for plane that represents terrain (ax+by+cz+d = 0)
       IF (stag .EQ. 'u') THEN
          d = ibm_ht_u(i,j)-GP(3)
          IF ((ibm_ht_u(i-1,j) .LE. ibm_ht_u(i,j)) .AND. (ibm_ht_u(i+1,j) .LE. ibm_ht_u(i,j))) THEN
             !on a ridge, figure out which way to go
             IF (ibm_ht_u(i-1,j) .EQ. ibm_ht_u(i+1,j)) THEN !it is a symmetric ridge
                IF (ibm_ht_w(i-1,j) .EQ. ibm_ht_w(i,j)) THEN !it is a really symmetric ridge
                   a = 0.0
                ELSE
                   a = (ibm_ht_w(i-1,j)-ibm_ht_w(i,j))/dx
                ENDIF
             ELSEIF (ibm_ht_u(i-1,j) .LT. ibm_ht_u(i+1,j)) THEN !go to the west
                a = (ibm_ht_w(i-1,j)-ibm_ht_u(i,j))/(dx/2)
             ELSE !go to the east
                a = (ibm_ht_u(i,j)-ibm_ht_w(i,j))/(dx/2)
             ENDIF
          ELSEIF ((ibm_ht_u(i,j) .LT. ibm_ht_u(i+1,j)) .AND. (ibm_ht_u(i-1,j) .LE. ibm_ht_u(i+1,j))) THEN
             !the image point is to the west
             IF (ibm_ht_u(i+1,j) .GT. ibm_ht_w(i,j)) THEN
                !the interpolation point could be closest to a wall, check for this
                e = dx/2.0
                f = ibm_ht_u(i+1,j)-ibm_ht_w(i,j)
                g = -(GP(3)-ibm_ht_u(i+1,j)-dx*e/f)/(f/e+e/f)
                d1 = (dx-g)/(SIN(ATAN(f/e)))
                h = ATAN((ibm_ht_w(i,j)-ibm_ht_u(i,j))/(dx/2.0))
                d2 = COS(h)*(GP(3)-ibm_ht_u(i,j))
                IF (d1 .LT. d2) THEN
                   a = (ibm_ht_w(i,j)-ibm_ht_u(i+1,j))/(dx/2)
                ELSE
                   a = (ibm_ht_u(i,j)-ibm_ht_w(i,j))/(dx/2)
                ENDIF
             ELSE
                a = (ibm_ht_u(i,j)-ibm_ht_w(i,j))/(dx/2)
             ENDIF
          ELSEIF (ibm_ht_u(i,j) .LT. ibm_ht_u(i-1,j)) THEN
             !the image point is to the east
             IF (ibm_ht_u(i-1,j) .GT. ibm_ht_w(i-1,j)) THEN
                !the interpolation point could be closest to a wall, check for this
                e = dx/2.0
                f = ibm_ht_u(i-1,j)-ibm_ht_w(i-1,j)
                g = -(GP(3)-ibm_ht_u(i-1,j)-dx*e/f)/(f/e+e/f)
                d1 = (dx-g)/(SIN(ATAN(f/e)))
                h = ATAN((ibm_ht_w(i-1,j)-ibm_ht_u(i,j))/(dx/2.0))
                d2 = COS(h)*(GP(3)-ibm_ht_u(i,j))
                IF (d1 .LT. d2) THEN
                   a = (ibm_ht_u(i-1,j)-ibm_ht_w(i-1,j))/(dx/2)
                ELSE
                   a = (ibm_ht_w(i-1,j)-ibm_ht_u(i,j))/(dx/2)
                ENDIF
             ELSE
                a = (ibm_ht_w(i-1,j)-ibm_ht_u(i,j))/(dx/2)
             ENDIF
          ELSE
             a = (ibm_ht_w(i-1,j)-ibm_ht_w(i,j))/dx
          ENDIF
          IF ((ibm_ht_u(i,j-1) .LE. ibm_ht_u(i,j)) .AND. (ibm_ht_u(i,j+1) .LE. ibm_ht_u(i,j))) THEN
             !on a ridge, figure out which way to go
             IF (ibm_ht_u(i,j-1) .EQ. ibm_ht_u(i,j+1)) THEN !it is a symmetric ridge
                IF (ibm_ht_c(i,j) .EQ. ibm_ht_c(i,j+1)) THEN !it is a really symmetric ridge
                   b = 0.0
                ELSE
                   b = (ibm_ht_c(i,j)-ibm_ht_c(i,j+1))/dy
                ENDIF
             ELSEIF (ibm_ht_u(i,j-1) .LT. ibm_ht_u(i,j+1)) THEN !go to the south
                b = (ibm_ht_c(i,j)-ibm_ht_u(i,j))/(dy/2)
             ELSE !go to the north
                b = (ibm_ht_u(i,j)-ibm_ht_c(i,j+1))/(dy/2)
             ENDIF
          ELSEIF ((ibm_ht_u(i,j) .LT. ibm_ht_u(i,j+1)) .AND. (ibm_ht_u(i,j-1) .LE. ibm_ht_u(i,j+1))) THEN
             !the image point is to the south	    
             IF (ibm_ht_u(i,j+1) .GT. ibm_ht_c(i,j+1)) THEN
                !the interpolation point could be closest to a wall, check for this
                e = dy/2.0
                f = ibm_ht_u(i,j+1)-ibm_ht_c(i,j+1)
                g = -(GP(3)-ibm_ht_u(i,j+1)-dy*e/f)/(f/e+e/f)
                d1 = (dy-g)/(SIN(ATAN(f/e)))
                h = ATAN((ibm_ht_c(i,j+1)-ibm_ht_u(i,j))/(dy/2.0))
                d2 = COS(h)*(GP(3)-ibm_ht_u(i,j))
                IF (d1 .LT. d2) THEN
                   b = (ibm_ht_c(i,j+1)-ibm_ht_u(i,j+1))/(dy/2)
                ELSE
                   b = (ibm_ht_u(i,j)-ibm_ht_c(i,j+1))/(dy/2)
                ENDIF
             ELSE
                b = (ibm_ht_u(i,j)-ibm_ht_c(i,j+1))/(dy/2)
             ENDIF
          ELSEIF (ibm_ht_u(i,j) .LT. ibm_ht_u(i,j-1)) THEN
             !the image point is to the north   
             IF (ibm_ht_u(i,j-1) .GT. ibm_ht_c(i,j)) THEN
                !the interpolation point could be closest to a wall, check for this
                e = dy/2.0
                f = ibm_ht_u(i,j-1)-ibm_ht_c(i,j)
                g = -(GP(3)-ibm_ht_u(i,j-1)-dy*e/f)/(f/e+e/f)
                d1 = (dy-g)/(SIN(ATAN(f/e)))
                h = ATAN((ibm_ht_c(i,j)-ibm_ht_u(i,j))/(dy/2.0))
                d2 = COS(h)*(GP(3)-ibm_ht_u(i,j))
                IF (d1 .LT. d2) THEN
                   b = (ibm_ht_u(i,j-1)-ibm_ht_c(i,j))/(dy/2)
                ELSE
                   b = (ibm_ht_c(i,j)-ibm_ht_u(i,j))/(dy/2)
                ENDIF
             ELSE
                b = (ibm_ht_c(i,j)-ibm_ht_u(i,j))/(dy/2)
             ENDIF
          ELSE
             b = (ibm_ht_c(i,j)-ibm_ht_c(i,j+1))/dy
          ENDIF
       ELSEIF (stag .EQ. 'v') THEN
          d = ibm_ht_v(i,j)-GP(3)
          IF ((ibm_ht_v(i-1,j) .LE. ibm_ht_v(i,j)) .AND. (ibm_ht_v(i+1,j) .LE. ibm_ht_v(i,j))) THEN
             !on a ridge, figure out which way to go
             IF (ibm_ht_v(i-1,j) .EQ. ibm_ht_v(i+1,j)) THEN !it is a symmetric ridge
                IF (ibm_ht_c(i,j) .EQ. ibm_ht_c(i+1,j)) THEN !it is a really symmetric ridge
                   a = 0.0
                ELSE
                   a = (ibm_ht_c(i,j)-ibm_ht_c(i+1,j))/dx
                ENDIF
             ELSEIF (ibm_ht_v(i-1,j) .LT. ibm_ht_v(i+1,j)) THEN !go to the west
                a = (ibm_ht_c(i,j)-ibm_ht_v(i,j))/(dx/2)
             ELSE !go to the east
                a = (ibm_ht_v(i,j)-ibm_ht_c(i+1,j))/(dx/2)
             ENDIF
          ELSEIF ((ibm_ht_v(i,j) .LT. ibm_ht_v(i+1,j)) .AND. (ibm_ht_v(i-1,j) .LE. ibm_ht_v(i+1,j))) THEN
             !the image point is to the west
             IF (ibm_ht_v(i+1,j) .GT. ibm_ht_c(i+1,j)) THEN
                !the interpolation point could be closest to a wall, check for this
                e = dx/2.0
                f = ibm_ht_v(i+1,j)-ibm_ht_c(i+1,j)
                g = -(GP(3)-ibm_ht_v(i+1,j)-dx*e/f)/(f/e+e/f)
                d1 = (dx-g)/(SIN(ATAN(f/e)))
                h = ATAN((ibm_ht_c(i+1,j)-ibm_ht_v(i,j))/(dx/2.0))
                d2 = COS(h)*(GP(3)-ibm_ht_v(i,j))
                IF (d1 .LT. d2) THEN
                   a = (ibm_ht_c(i+1,j)-ibm_ht_v(i+1,j))/(dx/2)
                ELSE
                   a = (ibm_ht_v(i,j)-ibm_ht_c(i+1,j))/(dx/2)
                ENDIF
             ELSE
                a = (ibm_ht_v(i,j)-ibm_ht_c(i+1,j))/(dx/2)
             ENDIF
          ELSEIF (ibm_ht_v(i,j) .LT. ibm_ht_v(i-1,j)) THEN
             !the image point is to the east
             IF (ibm_ht_v(i-1,j) .GT. ibm_ht_c(i,j)) THEN
                !the interpolation point could be closest to a wall, check for this
                e = dx/2.0
                f = ibm_ht_v(i-1,j)-ibm_ht_c(i,j)
                g = -(GP(3)-ibm_ht_v(i-1,j)-dx*e/f)/(f/e+e/f)
                d1 = (dx-g)/SIN(ATAN(f/e))
                h = ATAN((ibm_ht_c(i,j)-ibm_ht_v(i,j))/(dx/2.0))
                d2 = COS(h)*(GP(3)-ibm_ht_v(i,j))
                IF (d1 .LT. d2) THEN
                   a = (ibm_ht_v(i-1,j)-ibm_ht_c(i,j))/(dx/2)
                ELSE
                   a = (ibm_ht_c(i,j)-ibm_ht_v(i,j))/(dx/2)
                ENDIF
             ELSE
                a = (ibm_ht_c(i,j)-ibm_ht_v(i,j))/(dx/2)
             ENDIF
          ELSE
             a = (ibm_ht_c(i,j)-ibm_ht_c(i+1,j))/dx
          ENDIF
          IF ((ibm_ht_v(i,j-1) .LE. ibm_ht_v(i,j)) .AND. (ibm_ht_v(i,j+1) .LE. ibm_ht_v(i,j))) THEN
             !on a ridge, figure out which way to go
             IF (ibm_ht_v(i,j-1) .EQ. ibm_ht_v(i,j+1)) THEN !it is a symmetric ridge
                IF (ibm_ht_w(i,j-1) .EQ. ibm_ht_w(i,j)) THEN !it is a really symmetric ridge
                   b = 0.0
                ELSE
                   b = (ibm_ht_w(i,j-1)-ibm_ht_w(i,j))/dy
                ENDIF
             ELSEIF (ibm_ht_v(i,j-1) .LT. ibm_ht_v(i,j+1)) THEN !go to the south
                b = (ibm_ht_w(i,j-1)-ibm_ht_v(i,j))/(dy/2)
             ELSE !go to the north
                b = (ibm_ht_v(i,j)-ibm_ht_w(i,j))/(dy/2)
             ENDIF
          ELSEIF ((ibm_ht_v(i,j) .LT. ibm_ht_v(i,j+1)) .AND. (ibm_ht_v(i,j-1) .LE. ibm_ht_v(i,j+1))) THEN
             !the image point is to the south
             IF (ibm_ht_v(i,j+1) .GT. ibm_ht_w(i,j)) THEN
                !the interpolation point could be closest to a wall, check for this
                e = dy/2.0
                f = ibm_ht_v(i,j+1)-ibm_ht_w(i,j)
                g = -(GP(3)-ibm_ht_v(i,j+1)-dy*e/f)/(f/e+e/f)
                d1 = (dy-g)/(SIN(ATAN(f/e)))
                h = ATAN((ibm_ht_w(i,j)-ibm_ht_v(i,j))/(dy/2.0))
                d2 = COS(h)*(GP(3)-ibm_ht_v(i,j))
                IF (d1 .LT. d2) THEN
                   b = (ibm_ht_w(i,j)-ibm_ht_v(i,j+1))/(dy/2)
                ELSE
                   b = (ibm_ht_v(i,j)-ibm_ht_w(i,j))/(dy/2)
                ENDIF
             ELSE
                b = (ibm_ht_v(i,j)-ibm_ht_w(i,j))/(dy/2)
             ENDIF
          ELSEIF (ibm_ht_v(i,j) .LT. ibm_ht_v(i,j-1)) THEN
             !the image point is to the north       
             IF (ibm_ht_v(i,j-1) .GT. ibm_ht_w(i,j-1)) THEN
                !the interpolation point could be closest to a wall, check for this
                e = dy/2.0
                f = ibm_ht_v(i,j-1)-ibm_ht_w(i,j-1)
                g = -(GP(3)-ibm_ht_v(i,j-1)-dy*e/f)/(f/e+e/f)
                d1 = (dy-g)/SIN(ATAN(f/e))
                h = ATAN((ibm_ht_w(i,j-1)-ibm_ht_v(i,j))/(dy/2.0))
                d2 = COS(h)*(GP(3)-ibm_ht_v(i,j))
                IF (d1 .LT. d2) THEN
                   b = (ibm_ht_v(i,j-1)-ibm_ht_w(i,j-1))/(dy/2)
                ELSE
                   b = (ibm_ht_w(i,j-1)-ibm_ht_v(i,j))/(dy/2)
                ENDIF
             ELSE
                b = (ibm_ht_w(i,j-1)-ibm_ht_v(i,j))/(dy/2)
             ENDIF
          ELSE
             b = (ibm_ht_w(i,j-1)-ibm_ht_w(i,j))/dy
          ENDIF
       ELSEIF ((stag .EQ. 'w') .OR. (stag .EQ. 't')) THEN
          d = ibm_ht_w(i,j)-GP(3)
          IF ((ibm_ht_w(i-1,j) .LE. ibm_ht_w(i,j)) .AND. (ibm_ht_w(i+1,j) .LE. ibm_ht_w(i,j))) THEN
             !on a ridge, figure out which way to go
             IF (ibm_ht_w(i-1,j) .EQ. ibm_ht_w(i+1,j)) THEN !it is a symmetric ridge
                IF (ibm_ht_u(i,j) .EQ. ibm_ht_u(i+1,j)) THEN !it is a really symmetric ridge
                   a = 0.0
                ELSE
                   a = (ibm_ht_u(i,j)-ibm_ht_u(i+1,j))/dx
                ENDIF
             ELSEIF (ibm_ht_w(i-1,j) .LT. ibm_ht_w(i+1,j)) THEN !go to the west
                a = (ibm_ht_u(i,j)-ibm_ht_w(i,j))/(dx/2)
             ELSE !go to the east
                a = (ibm_ht_w(i,j)-ibm_ht_u(i+1,j))/(dx/2)
             ENDIF
          ELSEIF ((ibm_ht_w(i,j) .LT. ibm_ht_w(i+1,j)) .AND. (ibm_ht_w(i-1,j) .LE. ibm_ht_w(i+1,j))) THEN
             !the image point is to the west
             IF (ibm_ht_w(i+1,j) .GT. ibm_ht_u(i+1,j)) THEN
                !the interpolation point could be closest to a wall, check for this
                e = dx/2.0
                f = ibm_ht_w(i+1,j)-ibm_ht_u(i+1,j)
                g = -(GP(3)-ibm_ht_w(i+1,j)-dx*e/f)/(f/e+e/f)
                d1 = (dx-g)/(SIN(ATAN(f/e)))
                h = ATAN((ibm_ht_u(i+1,j)-ibm_ht_w(i,j))/(dx/2.0))
                d2 = COS(h)*(GP(3)-ibm_ht_w(i,j))
                IF (d1 .LT. d2) THEN
                   a = (ibm_ht_u(i+1,j)-ibm_ht_w(i+1,j))/(dx/2)
                ELSE
                   a = (ibm_ht_w(i,j)-ibm_ht_u(i+1,j))/(dx/2)
                ENDIF
             ELSE
                a = (ibm_ht_w(i,j)-ibm_ht_u(i+1,j))/(dx/2)
             ENDIF
          ELSEIF (ibm_ht_w(i,j) .LT. ibm_ht_w(i-1,j)) THEN
             !the image point is to the east
             IF (ibm_ht_w(i-1,j) .GT. ibm_ht_u(i,j)) THEN
                !the interpolation point could be closest to a wall, check for this
                e = dx/2.0
                f = ibm_ht_w(i-1,j)-ibm_ht_u(i,j)
                g = -(GP(3)-ibm_ht_w(i-1,j)-dx*e/f)/(f/e+e/f)
                d1 = (dx-g)/SIN(ATAN(f/e))
                h = ATAN((ibm_ht_u(i,j)-ibm_ht_w(i,j))/(dx/2.0))
                d2 = COS(h)*(GP(3)-ibm_ht_w(i,j))
                IF (d1 .LT. d2) THEN
                   a = (ibm_ht_w(i-1,j)-ibm_ht_u(i,j))/(dx/2)
                ELSE
                   a = (ibm_ht_u(i,j)-ibm_ht_w(i,j))/(dx/2)
                ENDIF
             ELSE
                a = (ibm_ht_u(i,j)-ibm_ht_w(i,j))/(dx/2)
             ENDIF
          ELSE
             a = (ibm_ht_u(i,j)-ibm_ht_u(i+1,j))/dx
          ENDIF
          IF ((ibm_ht_w(i,j-1) .LE. ibm_ht_w(i,j)) .AND. (ibm_ht_w(i,j+1) .LE. ibm_ht_w(i,j))) THEN
             !on a ridge, figure out which way to go
             IF (ibm_ht_w(i,j-1) .EQ. ibm_ht_w(i,j+1)) THEN !it is a symmetric ridge
                IF (ibm_ht_v(i,j) .EQ. ibm_ht_v(i,j+1)) THEN !it is a really symmetric ridge
                   b = 0.0
                ELSE
                   b = (ibm_ht_v(i,j)-ibm_ht_v(i,j+1))/dy
                ENDIF
             ELSEIF (ibm_ht_w(i,j-1) .LT. ibm_ht_w(i,j+1)) THEN !go to the south
                b = (ibm_ht_v(i,j)-ibm_ht_w(i,j))/(dy/2)
             ELSE !go to the north
                b = (ibm_ht_w(i,j)-ibm_ht_v(i,j+1))/(dy/2)
             ENDIF
          ELSEIF ((ibm_ht_w(i,j) .LT. ibm_ht_w(i,j+1)) .AND. (ibm_ht_w(i,j-1) .LE. ibm_ht_w(i,j+1))) THEN
             !the image point is to the south
             IF (ibm_ht_w(i,j+1) .GT. ibm_ht_v(i,j+1)) THEN
                !the interpolation point could be closest to a wall, check for this
                e = dy/2.0
                f = ibm_ht_w(i,j+1)-ibm_ht_v(i,j+1)
                g = -(GP(3)-ibm_ht_w(i,j+1)-dy*e/f)/(f/e+e/f)
                d1 = (dy-g)/SIN(ATAN(f/e))
                h = ATAN((ibm_ht_v(i,j+1)-ibm_ht_w(i,j))/(dy/2.0))
                d2 = COS(h)*(GP(3)-ibm_ht_w(i,j))
                IF (d1 .LT. d2) THEN
                   b = (ibm_ht_v(i,j+1)-ibm_ht_w(i,j+1))/(dy/2)
                ELSE
                   b = (ibm_ht_w(i,j)-ibm_ht_v(i,j+1))/(dy/2)
                ENDIF
             ELSE
                b = (ibm_ht_w(i,j)-ibm_ht_v(i,j+1))/(dy/2)
             ENDIF
          ELSEIF (ibm_ht_w(i,j) .LT. ibm_ht_w(i,j-1)) THEN
             !the image point is to the north 
             IF (ibm_ht_w(i,j-1) .GT. ibm_ht_v(i,j)) THEN
                !the interpolation point could be closest to a wall, check for this
                e = dy/2.0
                f = ibm_ht_w(i,j-1)-ibm_ht_v(i,j)
                g = -(GP(3)-ibm_ht_w(i,j-1)-dy*e/f)/(f/e+e/f)
                d1 = (dy-g)/SIN(ATAN(f/e))
                h = ATAN((ibm_ht_v(i,j)-ibm_ht_w(i,j))/(dy/2.0))
                d2 = COS(h)*(GP(3)-ibm_ht_w(i,j))
                IF (d1 .LT. d2) THEN
                   b = (ibm_ht_w(i,j-1)-ibm_ht_v(i,j))/(dy/2)
                ELSE
                   b = (ibm_ht_v(i,j)-ibm_ht_w(i,j))/(dy/2)
                ENDIF
             ELSE
                b = (ibm_ht_v(i,j)-ibm_ht_w(i,j))/(dy/2)
             ENDIF
          ELSE
             b = (ibm_ht_v(i,j)-ibm_ht_v(i,j+1))/dy
          ENDIF
       ENDIF

       c = 1.0
       !normal distance from ghost point to plane that represents terrain
       mag = SQRT(a**2+b**2+c**2)
       IF (mag .EQ. 0) THEN
          CALL wrf_error_fatal("DJW[module_ibm/interpolation_pts]: mag = 0.0, would divide by zero for side-point.")
       ENDIF
       dist = d/mag
       !normal vector to plane
       n(1) = a/mag
       n(2) = b/mag
       n(3) = c/mag

       !(x,y,z) of boundary point
       side_bound(1:3,S) = GP+dist*n

       !normal distance to reconstruction point from the boundary
       side_dist(1,S) = -dist

       IF ((n(1) .EQ. 0.0) .AND. (n(2) .EQ. 0.0)) THEN
          !intersects with top
          dist = ABS((ht_p(i,side(3,S)+1,j)-GP(3))/n(3))
          IP = GP+dist*n
       ELSEIF (ABS(n(1))/dx .GT. ABS(n(2))/dy) THEN
          IF (ABS(n(1)/n(3)) .GT. (dx/(ht_p(i,side(3,S)+1,j)-ht_p(i,side(3,S),j)))) THEN !intersects with x side
             dist = ABS(dx/n(1))
             IP = GP+dist*n  
          ELSE !intersects with top
             dist = ABS((ht_p(i,side(3,S)+1,j)-GP(3))/n(3))
             IP = GP+dist*n     
          ENDIF
       ELSE
          IF (ABS(n(2)/n(3)) .GT. (dy/(ht_p(i,side(3,S)+1,j)-ht_p(i,side(3,S),j)))) THEN !intersects with y side
             dist = ABS(dy/n(2))
             IP = GP+dist*n  
          ELSE !intersects with top
             dist = ABS((ht_p(i,side(3,S)+1,j)-GP(3))/n(3))
             IP = GP+dist*n     
          ENDIF
       ENDIF

       !normal distance to interpolation point from the boundary
       side_dist(2,S) = side_dist(1,S)+dist

       side_norm(1:3,S) = n

       side_img(1:3,S) = GP
       side_img(4:6,S) = IP

    ENDDO
 ENDIF !end of finding the image of s side points

 END SUBROUTINE interpolation_pts 

!------------------------------------------------------------------------------- 

SUBROUTINE shear_stress_recon_interp_pts( stag,                         &
                                          dx, dy, ht_p,                 &
                                          ibm_ht_u, ibm_ht_v,           &
                                          ibm_ht_w, ibm_ht_c,           &
                                          inside, top, side,            &
                                          top_img, top_bound,           &
                                          side_img, side_bound,         &
                                          ns, top_norm, side_norm,      &
                                          top_dist, side_dist,          &
                                          delta_recon,                  &
                                          ids, ide, jds, jde, kds, kde, &
                                          ims, ime, jms, jme, kms, kme, &
                                          its, ite, jts, jte, kts, kte )

 IMPLICIT NONE
 !input data
 CHARACTER, INTENT(IN   )                                  :: stag
 REAL, INTENT(IN   )                                       :: dx, dy
 REAL, DIMENSION(ims:ime,kms:kme,jms:jme), INTENT(IN   )   :: ht_p
 REAL, DIMENSION(ims:ime,jms:jme), INTENT(IN   )           :: ibm_ht_u,   &
                                                              ibm_ht_v,   &
                                                              ibm_ht_w,   &
                                                              ibm_ht_c
 REAL, INTENT(IN   )                                       :: delta_recon   ! shear stress reconstruction region from namelist
 INTEGER, DIMENSION(ims:ime,kms:kme,jms:jme), INTENT(IN   ):: inside
 INTEGER, DIMENSION(ims:ime,jms:jme), INTENT(IN   )        :: top           !'top boundary' forcing (reconstruction) points
 INTEGER, DIMENSION(3,ns), INTENT(IN   )                   :: side          !'side boundary' forcing (reconstruction) points
 REAL, DIMENSION(ims:ime,jms:jme,6), INTENT(  OUT)         :: top_img       !(x,y,z) location of forcing (reconstruction) point and interpolation point of the 'top boundary' forcing (reconstruction) points					                     
 REAL, DIMENSION(ims:ime,jms:jme,3), INTENT(  OUT)         :: top_bound,  & !(x,y,z) location of the boundary for top point
                                                              top_norm      !only used for the neumann condition
 REAL, DIMENSION(ims:ime,jms:jme,2), INTENT(   OUT)        :: top_dist      !distance from surface normal to reconstruction and interpolation point
 REAL, DIMENSION(6,ns), INTENT(  OUT)                      :: side_img      !(x,y,z) location of forcing (reconstruction) point and interpolation point of the 'side boundary' forcing (reconstruction) points
 REAL, DIMENSION(3,ns), INTENT(  OUT)                      :: side_bound, & !(x,y,z) location of the boundary for side points
                                                              side_norm     !only used for the neumann condition
 REAL, DIMENSION(2,ns), INTENT(   OUT)                     :: side_dist     !distance from surface normal to reconstruction and interpolation point
 INTEGER, INTENT(IN   )                                    :: ns            !number of 'side boundary' forcing (reconstruction) points
 INTEGER,        INTENT(IN   )   :: ids, ide, jds, jde, kds, kde,         & !d: domain
                                    ims, ime, jms, jme, kms, kme,         & !m: memory
                                    its, ite, jts, jte, kts, kte            !p: patch, t: tile
 !local data
 INTEGER                                                  :: i, j,        &
                                                             S,           &
                                                             i_end,       &
                                                             j_end,       &
                                                             ii, ji, ki,  &
                                                             nn,          &
                                                             is, ks, js
 REAL                                                     :: a, b,        & !coefficients of plane that represents terrain
                                                             c, d,        &
                                                             mag,         & !norm of gradient of eqn for plane SQRT(a**2+b**2+c**2)
                                                             dist,        & !distance (magnitude) from forcing (reconstruction) point to terrain
                                                             e, f,        &
                                                             g, h,        &
                                                             d1, d2
 REAL, DIMENSION(3)                                       :: n,           & !outward normal vector to terrain
                                                             GP,          & !(x,y,z) location of forcing (reconstruction) point
                                                             IP             !(x,y,z) location of interpolation point
 LOGICAL                                                  :: moveip
 CHARACTER(len=265)                                       :: wrf_err_message

!---------------------------------------------------------------------------------
! this subroutine finds the interpolation point for the velocity used to
! estimate the surface shear stress for IBM shear stress reconstruction
! RSA modified version of interpolation_pts subroutine.
 write(wrf_err_message, '(A,A)') 'dyn_em/module_ibm.F/subroutine shear_stress_recon_interp_pts stag=',stag
 CALL wrf_debug(100, TRIM(wrf_err_message))
!--------------------------------------------------------------------------------

 !initialize the arrays top be computed
 top_img = 0.0
 top_bound = 0.0
 top_norm = 0.0
 top_dist = 0.0
 if (ns .GT. 0) side_img = 0.0
 if (ns .GT. 0) side_bound = 0.0
 if (ns .GT. 0) side_norm = 0.0
 if (ns .GT. 0) side_dist = 0.0
 
 IF ((stag .EQ. 'u') .OR. (stag .EQ. 'e')) THEN
    i_end = ite
    j_end = MIN(jte,jde-1)
 ELSEIF ((stag .EQ. 'v') .OR. (stag .EQ. 'f')) THEN
    i_end = MIN(ite,ide-1)
    j_end = jte
 ELSEIF ((stag .EQ. 'w') .OR. (stag .EQ. 't')) THEN
    i_end = MIN(ite,ide-1)
    j_end = MIN(jte,jde-1)
 ELSEIF (stag .EQ. 'd') THEN
    i_end = ite
    j_end = jte
 ENDIF

 DO i=its,i_end
 DO j=jts,j_end
    !find the interpolation location for top forcing points (x,y,z) of forcing point
    IF ((stag .EQ. 'u') .OR. (stag .EQ. 'd') .OR. (stag .EQ. 'e')) THEN
       GP(1) = (i*dx)-(dx)  
    ELSE 
       GP(1) = (i*dx)-(dx/2.0)
    ENDIF
    IF ((stag .EQ. 'v') .OR. (stag .EQ. 'd') .OR. (stag .EQ. 'f')) THEN
       GP(2) = (j*dy)-(dy)
    ELSE
       GP(2) = (j*dy)-(dy/2.0)
    ENDIF
    GP(3) = ht_p(i,top(i,j),j)
    !equation for plane that represents terrain (ax+by+cz+d = 0)
    IF ((stag .EQ. 'u') .OR. (stag .EQ. 'e')) THEN
       a = (ibm_ht_w(i-1,j)-ibm_ht_w(i,j))/dx
       b = (ibm_ht_c(i,j)-ibm_ht_c(i,j+1))/dy
       c = 1.0
       d = ibm_ht_u(i,j)-GP(3)
    ELSEIF ((stag .EQ. 'v') .OR. (stag .EQ. 'f')) THEN
       a = (ibm_ht_c(i,j)-ibm_ht_c(i+1,j))/dx
       b = (ibm_ht_w(i,j-1)-ibm_ht_w(i,j))/dy
       c = 1.0
       d = ibm_ht_v(i,j)-GP(3)    
    ELSEIF ((stag .EQ. 'w') .OR. (stag .EQ. 't')) THEN    
       a = (ibm_ht_u(i,j)-ibm_ht_u(i+1,j))/dx
       b = (ibm_ht_v(i,j)-ibm_ht_v(i,j+1))/dy
       c = 1.0
       d = ibm_ht_w(i,j)-GP(3)
    ELSEIF (stag .EQ. 'd') THEN
       a = (ibm_ht_v(i-1,j)-ibm_ht_v(i,j))/dx
       b = (ibm_ht_u(i,j-1)-ibm_ht_u(i,j))/dy
       c = 1.0
       d = ibm_ht_c(i,j)-GP(3)
    ENDIF
    mag = SQRT(a**2+b**2+c**2)
    IF (mag .EQ. 0) THEN
       CALL wrf_error_fatal("RSA[module_ibm/shear_stress_recon_interp_pts]: mag = 0.0, would divide by zero for top-point.")
    ENDIF
    !normal distance from forcing point to plane that represents terrain
    dist = d/mag
    !normal vector to plane
    n(1) = a/mag
    n(2) = b/mag
    n(3) = c/mag

    !(x,y,z) of boundary point
    top_bound(i,j,1:3) = GP+dist*n

    !distance to reconstruction point
    top_dist(i,j,1) = -dist
    top_norm(i,j,1:3) = n

    !put the interpolation point distance delta_recon away from the surface
    top_img(i,j,1:3) = GP !location of reconstruction pt
    top_img(i,j,4:6) = top_bound(i,j,1:3)+delta_recon*n !location of interpolation pt

    !normal distance to interpolation point from the boundary
    top_dist(i,j,2) = delta_recon

 ENDDO
 ENDDO

 !find the interpolation point for the s side ghost points
 IF (ns .GT. 0) THEN
    DO S=1,ns
       i = side(1,S)
       j = side(2,S)
       !(x,y,z) of interpolation point
       IF ((stag .EQ. 'u') .OR. (stag .EQ. 'd') .OR. (stag .EQ. 'e')) THEN
          GP(1) = (i*dx)-(dx)  
       ELSE
          GP(1) = (i*dx)-(dx/2)
       ENDIF
       IF ((stag .EQ. 'v') .OR. (stag .EQ. 'd') .OR. (stag .EQ. 'f')) THEN
          GP(2) = (j*dy)-(dy)
       ELSE
          GP(2) = (j*dy)-(dy/2)
       ENDIF
       GP(3) = ht_p(i,side(3,S),j)
       !equation for plane that represents terrain (ax+by+cz+d = 0)
       IF ((stag .EQ. 'u') .OR. (stag .EQ. 'e')) THEN
          d = ibm_ht_u(i,j)-GP(3)
          IF ((ibm_ht_u(i-1,j) .LE. ibm_ht_u(i,j)) .AND. (ibm_ht_u(i+1,j) .LE. ibm_ht_u(i,j))) THEN
             !on a ridge, figure out which way to go
             IF (ibm_ht_u(i-1,j) .EQ. ibm_ht_u(i+1,j)) THEN !it is a symmetric ridge
                IF (ibm_ht_w(i-1,j) .EQ. ibm_ht_w(i,j)) THEN !it is a really symmetric ridge !RSA POTENTIAL BUG FIX
                   a = 0.0
                ELSE
                   a = (ibm_ht_w(i-1,j)-ibm_ht_w(i,j))/dx
                ENDIF
             ELSEIF (ibm_ht_u(i-1,j) .LT. ibm_ht_u(i+1,j)) THEN !go to the west
                a = (ibm_ht_w(i-1,j)-ibm_ht_u(i,j))/(dx/2)
             ELSE !go to the east
                a = (ibm_ht_u(i,j)-ibm_ht_w(i,j))/(dx/2)
             ENDIF
          ELSEIF ((ibm_ht_u(i,j) .LT. ibm_ht_u(i+1,j)) .AND. (ibm_ht_u(i-1,j) .LE. ibm_ht_u(i+1,j))) THEN
             !the image point is to the west
             IF (ibm_ht_u(i+1,j) .GT. ibm_ht_w(i,j)) THEN
                !the interpolation point could be closest to a wall, check for this
                e = dx/2.0
                f = ibm_ht_u(i+1,j)-ibm_ht_w(i,j)
                g = -(GP(3)-ibm_ht_u(i+1,j)-dx*e/f)/(f/e+e/f)
                d1 = (dx-g)/(SIN(ATAN(f/e)))
                h = ATAN((ibm_ht_w(i,j)-ibm_ht_u(i,j))/(dx/2.0))
                d2 = COS(h)*(GP(3)-ibm_ht_u(i,j))
                IF (d1 .LT. d2) THEN
                   a = (ibm_ht_w(i,j)-ibm_ht_u(i+1,j))/(dx/2)
                ELSE
                   a = (ibm_ht_u(i,j)-ibm_ht_w(i,j))/(dx/2)
                ENDIF
             ELSE
                a = (ibm_ht_u(i,j)-ibm_ht_w(i,j))/(dx/2)
             ENDIF
          ELSEIF (ibm_ht_u(i,j) .LT. ibm_ht_u(i-1,j)) THEN
             !the image point is to the east
             IF (ibm_ht_u(i-1,j) .GT. ibm_ht_w(i-1,j)) THEN
                !the interpolation point could be closest to a wall, check for this
                e = dx/2.0
                f = ibm_ht_u(i-1,j)-ibm_ht_w(i-1,j)
                g = -(GP(3)-ibm_ht_u(i-1,j)-dx*e/f)/(f/e+e/f)
                d1 = (dx-g)/(SIN(ATAN(f/e)))
                h = ATAN((ibm_ht_w(i-1,j)-ibm_ht_u(i,j))/(dx/2.0))
                d2 = COS(h)*(GP(3)-ibm_ht_u(i,j))
                IF (d1 .LT. d2) THEN
                   a = (ibm_ht_u(i-1,j)-ibm_ht_w(i-1,j))/(dx/2)
                ELSE
                   a = (ibm_ht_w(i-1,j)-ibm_ht_u(i,j))/(dx/2)
                ENDIF
             ELSE
                a = (ibm_ht_w(i-1,j)-ibm_ht_u(i,j))/(dx/2)
             ENDIF
          ELSE
             a = (ibm_ht_w(i-1,j)-ibm_ht_w(i,j))/dx
          ENDIF
          IF ((ibm_ht_u(i,j-1) .LE. ibm_ht_u(i,j)) .AND. (ibm_ht_u(i,j+1) .LE. ibm_ht_u(i,j))) THEN
             !on a ridge, figure out which way to go
             IF (ibm_ht_u(i,j-1) .EQ. ibm_ht_u(i,j+1)) THEN !it is a symmetric ridge
                IF (ibm_ht_c(i,j) .EQ. ibm_ht_c(i,j+1)) THEN !it is a really symmetric ridge
                   b = 0.0
                ELSE
                   b = (ibm_ht_c(i,j)-ibm_ht_c(i,j+1))/dy
                ENDIF
             ELSEIF (ibm_ht_u(i,j-1) .LT. ibm_ht_u(i,j+1)) THEN !go to the south
                b = (ibm_ht_c(i,j)-ibm_ht_u(i,j))/(dy/2)
             ELSE !go to the north
                b = (ibm_ht_u(i,j)-ibm_ht_c(i,j+1))/(dy/2)
             ENDIF
          ELSEIF ((ibm_ht_u(i,j) .LT. ibm_ht_u(i,j+1)) .AND. (ibm_ht_u(i,j-1) .LE. ibm_ht_u(i,j+1))) THEN
             !the image point is to the south	    
             IF (ibm_ht_u(i,j+1) .GT. ibm_ht_c(i,j+1)) THEN
                !the interpolation point could be closest to a wall, check for this
                e = dy/2.0
                f = ibm_ht_u(i,j+1)-ibm_ht_c(i,j+1)
                g = -(GP(3)-ibm_ht_u(i,j+1)-dy*e/f)/(f/e+e/f) !RSA POTENTIAL BUG FIX
                d1 = (dy-g)/(SIN(ATAN(f/e)))
                h = ATAN((ibm_ht_c(i,j+1)-ibm_ht_u(i,j))/(dy/2.0))
                d2 = COS(h)*(GP(3)-ibm_ht_u(i,j))
                IF (d1 .LT. d2) THEN
                   b = (ibm_ht_c(i,j+1)-ibm_ht_u(i,j+1))/(dy/2)
                ELSE
                   b = (ibm_ht_u(i,j)-ibm_ht_c(i,j+1))/(dy/2)
                ENDIF
             ELSE
                b = (ibm_ht_u(i,j)-ibm_ht_c(i,j+1))/(dy/2)
             ENDIF
          ELSEIF (ibm_ht_u(i,j) .LT. ibm_ht_u(i,j-1)) THEN
             !the image point is to the north   
             IF (ibm_ht_u(i,j-1) .GT. ibm_ht_c(i,j)) THEN
                !the interpolation point could be closest to a wall, check for this
                e = dy/2.0
                f = ibm_ht_u(i,j-1)-ibm_ht_c(i,j)
                g = -(GP(3)-ibm_ht_u(i,j-1)-dy*e/f)/(f/e+e/f) !RSA POTENTIAL BUG FIX
                d1 = (dy-g)/SIN(ATAN(f/e))
                h = ATAN((ibm_ht_c(i,j)-ibm_ht_u(i,j))/(dy/2.0))
                d2 = COS(h)*(GP(3)-ibm_ht_u(i,j))
                IF (d1 .LT. d2) THEN
                   b = (ibm_ht_u(i,j-1)-ibm_ht_c(i,j))/(dy/2)
                ELSE
                   b = (ibm_ht_c(i,j)-ibm_ht_u(i,j))/(dy/2)
                ENDIF
             ELSE
                b = (ibm_ht_c(i,j)-ibm_ht_u(i,j))/(dy/2)
             ENDIF
          ELSE
             b = (ibm_ht_c(i,j)-ibm_ht_c(i,j+1))/dy
          ENDIF
       ELSEIF ((stag .EQ. 'v') .OR. (stag .EQ. 'f')) THEN
          d = ibm_ht_v(i,j)-GP(3)
          IF ((ibm_ht_v(i-1,j) .LE. ibm_ht_v(i,j)) .AND. (ibm_ht_v(i+1,j) .LE. ibm_ht_v(i,j))) THEN
             !on a ridge, figure out which way to go
             IF (ibm_ht_v(i-1,j) .EQ. ibm_ht_v(i+1,j)) THEN !it is a symmetric ridge
                IF (ibm_ht_c(i,j) .EQ. ibm_ht_c(i+1,j)) THEN !it is a really symmetric ridge
                   a = 0.0
                ELSE
                   a = (ibm_ht_c(i,j)-ibm_ht_c(i+1,j))/dx
                ENDIF
             ELSEIF (ibm_ht_v(i-1,j) .LT. ibm_ht_v(i+1,j)) THEN !go to the west
                a = (ibm_ht_c(i,j)-ibm_ht_v(i,j))/(dx/2)
             ELSE !go to the east
                a = (ibm_ht_v(i,j)-ibm_ht_c(i+1,j))/(dx/2)
             ENDIF
          ELSEIF ((ibm_ht_v(i,j) .LT. ibm_ht_v(i+1,j)) .AND. (ibm_ht_v(i-1,j) .LE. ibm_ht_v(i+1,j))) THEN
             !the image point is to the west
             IF (ibm_ht_v(i+1,j) .GT. ibm_ht_c(i+1,j)) THEN
                !the interpolation point could be closest to a wall, check for this
                e = dx/2.0
                f = ibm_ht_v(i+1,j)-ibm_ht_c(i+1,j)
                g = -(GP(3)-ibm_ht_v(i+1,j)-dx*e/f)/(f/e+e/f)
                d1 = (dx-g)/(SIN(ATAN(f/e)))
                h = ATAN((ibm_ht_c(i+1,j)-ibm_ht_v(i,j))/(dx/2.0))
                d2 = COS(h)*(GP(3)-ibm_ht_v(i,j))
                IF (d1 .LT. d2) THEN
                   a = (ibm_ht_c(i+1,j)-ibm_ht_v(i+1,j))/(dx/2)
                ELSE
                   a = (ibm_ht_v(i,j)-ibm_ht_c(i+1,j))/(dx/2)
                ENDIF
             ELSE
                a = (ibm_ht_v(i,j)-ibm_ht_c(i+1,j))/(dx/2)
             ENDIF
          ELSEIF (ibm_ht_v(i,j) .LT. ibm_ht_v(i-1,j)) THEN
             !the image point is to the east
             IF (ibm_ht_v(i-1,j) .GT. ibm_ht_c(i,j)) THEN
                !the interpolation point could be closest to a wall, check for this
                e = dx/2.0
                f = ibm_ht_v(i-1,j)-ibm_ht_c(i,j)
                g = -(GP(3)-ibm_ht_v(i-1,j)-dx*e/f)/(f/e+e/f)
                d1 = (dx-g)/SIN(ATAN(f/e))
                h = ATAN((ibm_ht_c(i,j)-ibm_ht_v(i,j))/(dx/2.0))
                d2 = COS(h)*(GP(3)-ibm_ht_v(i,j))
                IF (d1 .LT. d2) THEN
                   a = (ibm_ht_v(i-1,j)-ibm_ht_c(i,j))/(dx/2)
                ELSE
                   a = (ibm_ht_c(i,j)-ibm_ht_v(i,j))/(dx/2)
                ENDIF
             ELSE
                a = (ibm_ht_c(i,j)-ibm_ht_v(i,j))/(dx/2)
             ENDIF
          ELSE
             a = (ibm_ht_c(i,j)-ibm_ht_c(i+1,j))/dx
          ENDIF
          IF ((ibm_ht_v(i,j-1) .LE. ibm_ht_v(i,j)) .AND. (ibm_ht_v(i,j+1) .LE. ibm_ht_v(i,j))) THEN
             !on a ridge, figure out which way to go
             IF (ibm_ht_v(i,j-1) .EQ. ibm_ht_v(i,j+1)) THEN !it is a symmetric ridge
                IF (ibm_ht_w(i,j-1) .EQ. ibm_ht_w(i,j)) THEN !it is a really symmetric ridge
                   b = 0.0
                ELSE
                   b = (ibm_ht_w(i,j-1)-ibm_ht_w(i,j))/dy
                ENDIF
             ELSEIF (ibm_ht_v(i,j-1) .LT. ibm_ht_v(i,j+1)) THEN !go to the south
                b = (ibm_ht_w(i,j-1)-ibm_ht_v(i,j))/(dy/2)
             ELSE !go to the north
                b = (ibm_ht_v(i,j)-ibm_ht_w(i,j))/(dy/2)
             ENDIF
          ELSEIF ((ibm_ht_v(i,j) .LT. ibm_ht_v(i,j+1)) .AND. (ibm_ht_v(i,j-1) .LE. ibm_ht_v(i,j+1))) THEN
             !the image point is to the south
             IF (ibm_ht_v(i,j+1) .GT. ibm_ht_w(i,j)) THEN
                !the interpolation point could be closest to a wall, check for this
                e = dy/2.0
                f = ibm_ht_v(i,j+1)-ibm_ht_w(i,j)
                g = -(GP(3)-ibm_ht_v(i,j+1)-dy*e/f)/(f/e+e/f)
                d1 = (dy-g)/(SIN(ATAN(f/e)))
                h = ATAN((ibm_ht_w(i,j)-ibm_ht_v(i,j))/(dy/2.0))
                d2 = COS(h)*(GP(3)-ibm_ht_v(i,j))
                IF (d1 .LT. d2) THEN
                   b = (ibm_ht_w(i,j)-ibm_ht_v(i,j+1))/(dy/2)
                ELSE
                   b = (ibm_ht_v(i,j)-ibm_ht_w(i,j))/(dy/2)
                ENDIF
             ELSE
                b = (ibm_ht_v(i,j)-ibm_ht_w(i,j))/(dy/2)
             ENDIF
          ELSEIF (ibm_ht_v(i,j) .LT. ibm_ht_v(i,j-1)) THEN
             !the image point is to the north       
             IF (ibm_ht_v(i-1,j) .GT. ibm_ht_w(i,j-1)) THEN
                !the interpolation point could be closest to a wall, check for this
                e = dy/2.0
                f = ibm_ht_v(i,j-1)-ibm_ht_w(i,j-1)
                g = -(GP(3)-ibm_ht_v(i,j-1)-dy*e/f)/(f/e+e/f)
                d1 = (dy-g)/SIN(ATAN(f/e))
                h = ATAN((ibm_ht_w(i,j-1)-ibm_ht_v(i,j))/(dy/2.0))
                d2 = COS(h)*(GP(3)-ibm_ht_v(i,j))
                IF (d1 .LT. d2) THEN
                   b = (ibm_ht_v(i,j-1)-ibm_ht_w(i,j-1))/(dy/2)
                ELSE
                   b = (ibm_ht_w(i,j-1)-ibm_ht_v(i,j))/(dy/2)
                ENDIF
             ELSE
                b = (ibm_ht_w(i,j-1)-ibm_ht_v(i,j))/(dy/2)
             ENDIF
          ELSE
             b = (ibm_ht_w(i,j-1)-ibm_ht_w(i,j))/dy
          ENDIF
       ELSEIF ((stag .EQ. 'w') .OR. (stag .EQ. 't')) THEN
          d = ibm_ht_w(i,j)-GP(3)
          IF ((ibm_ht_w(i-1,j) .LE. ibm_ht_w(i,j)) .AND. (ibm_ht_w(i+1,j) .LE. ibm_ht_w(i,j))) THEN
             !on a ridge, figure out which way to go
             IF (ibm_ht_w(i-1,j) .EQ. ibm_ht_w(i+1,j)) THEN !it is a symmetric ridge
                IF (ibm_ht_u(i,j) .EQ. ibm_ht_u(i+1,j)) THEN !it is a really symmetric ridge
                   a = 0.0
                ELSE
                   a = (ibm_ht_u(i,j)-ibm_ht_u(i+1,j))/dx
                ENDIF
             ELSEIF (ibm_ht_w(i-1,j) .LT. ibm_ht_w(i+1,j)) THEN !go to the west
                a = (ibm_ht_u(i,j)-ibm_ht_w(i,j))/(dx/2)
             ELSE !go to the east
                a = (ibm_ht_w(i,j)-ibm_ht_u(i+1,j))/(dx/2)
             ENDIF
          ELSEIF ((ibm_ht_w(i,j) .LT. ibm_ht_w(i+1,j)) .AND. (ibm_ht_w(i-1,j) .LE. ibm_ht_w(i+1,j))) THEN
             !the image point is to the west
             IF (ibm_ht_w(i+1,j) .GT. ibm_ht_u(i+1,j)) THEN
                !the interpolation point could be closest to a wall, check for this
                e = dx/2.0
                f = ibm_ht_w(i+1,j)-ibm_ht_u(i+1,j)
                g = -(GP(3)-ibm_ht_w(i+1,j)-dx*e/f)/(f/e+e/f)
                d1 = (dx-g)/(SIN(ATAN(f/e)))
                h = ATAN((ibm_ht_u(i+1,j)-ibm_ht_w(i,j))/(dx/2.0))
                d2 = COS(h)*(GP(3)-ibm_ht_w(i,j))
                IF (d1 .LT. d2) THEN
                   a = (ibm_ht_u(i+1,j)-ibm_ht_w(i+1,j))/(dx/2)
                ELSE
                   a = (ibm_ht_w(i,j)-ibm_ht_u(i+1,j))/(dx/2)
                ENDIF
             ELSE
                a = (ibm_ht_w(i,j)-ibm_ht_u(i+1,j))/(dx/2)
             ENDIF
          ELSEIF (ibm_ht_w(i,j) .LT. ibm_ht_w(i-1,j)) THEN
             !the image point is to the east
             IF (ibm_ht_w(i-1,j) .GT. ibm_ht_u(i,j)) THEN
                !the interpolation point could be closest to a wall, check for this
                e = dx/2.0
                f = ibm_ht_w(i-1,j)-ibm_ht_u(i,j)
                g = -(GP(3)-ibm_ht_w(i-1,j)-dx*e/f)/(f/e+e/f)
                d1 = (dx-g)/SIN(ATAN(f/e))
                h = ATAN((ibm_ht_u(i,j)-ibm_ht_w(i,j))/(dx/2.0))
                d2 = COS(h)*(GP(3)-ibm_ht_w(i,j))
                IF (d1 .LT. d2) THEN
                   a = (ibm_ht_w(i-1,j)-ibm_ht_u(i,j))/(dx/2)
                ELSE
                   a = (ibm_ht_u(i,j)-ibm_ht_w(i,j))/(dx/2)
                ENDIF
             ELSE
                a = (ibm_ht_u(i,j)-ibm_ht_w(i,j))/(dx/2)
             ENDIF
          ELSE
             a = (ibm_ht_u(i,j)-ibm_ht_u(i+1,j))/dx
          ENDIF
          IF ((ibm_ht_w(i,j-1) .LE. ibm_ht_w(i,j)) .AND. (ibm_ht_w(i,j+1) .LE. ibm_ht_w(i,j))) THEN
             !on a ridge, figure out which way to go
             IF (ibm_ht_w(i,j-1) .EQ. ibm_ht_w(i,j+1)) THEN !it is a symmetric ridge
                IF (ibm_ht_v(i,j) .EQ. ibm_ht_v(i,j+1)) THEN !it is a really symmetric ridge
                   b = 0.0
                ELSE
                   b = (ibm_ht_v(i,j)-ibm_ht_v(i,j+1))/dy
                ENDIF
             ELSEIF (ibm_ht_w(i,j-1) .LT. ibm_ht_w(i,j+1)) THEN !go to the south
                b = (ibm_ht_v(i,j)-ibm_ht_w(i,j))/(dy/2)
             ELSE !go to the north
                b = (ibm_ht_w(i,j)-ibm_ht_v(i,j+1))/(dy/2)
             ENDIF
          ELSEIF ((ibm_ht_w(i,j) .LT. ibm_ht_w(i,j+1)) .AND. (ibm_ht_w(i,j-1) .LE. ibm_ht_w(i,j+1))) THEN
             !the image point is to the south
             IF (ibm_ht_w(i,j+1) .GT. ibm_ht_v(i,j+1)) THEN
                !the interpolation point could be closest to a wall, check for this
                e = dy/2.0
                f = ibm_ht_w(i,j+1)-ibm_ht_v(i,j+1)
                g = -(GP(3)-ibm_ht_w(i,j+1)-dy*e/f)/(f/e+e/f)
                d1 = (dy-g)/SIN(ATAN(f/e))
                h = ATAN((ibm_ht_v(i,j+1)-ibm_ht_w(i,j))/(dy/2.0))
                d2 = COS(h)*(GP(3)-ibm_ht_w(i,j))
                IF (d1 .LT. d2) THEN
                   b = (ibm_ht_v(i,j+1)-ibm_ht_w(i,j+1))/(dy/2)
                ELSE
                   b = (ibm_ht_w(i,j)-ibm_ht_v(i,j+1))/(dy/2)
                ENDIF
             ELSE
                b = (ibm_ht_w(i,j)-ibm_ht_v(i,j+1))/(dy/2)
             ENDIF
          ELSEIF (ibm_ht_w(i,j) .LT. ibm_ht_w(i,j-1)) THEN
             !the image point is to the north 
             IF (ibm_ht_w(i,j-1) .GT. ibm_ht_v(i,j)) THEN
                !the interpolation point could be closest to a wall, check for this
                e = dy/2.0
                f = ibm_ht_w(i,j-1)-ibm_ht_v(i,j)
                g = -(GP(3)-ibm_ht_w(i,j-1)-dy*e/f)/(f/e+e/f)
                d1 = (dy-g)/SIN(ATAN(f/e))
                h = ATAN((ibm_ht_v(i,j)-ibm_ht_w(i,j))/(dy/2.0))
                d2 = COS(h)*(GP(3)-ibm_ht_w(i,j))
                IF (d1 .LT. d2) THEN
                   b = (ibm_ht_w(i,j-1)-ibm_ht_v(i,j))/(dy/2)
                ELSE
                   b = (ibm_ht_v(i,j)-ibm_ht_w(i,j))/(dy/2)
                ENDIF
             ELSE
                b = (ibm_ht_v(i,j)-ibm_ht_w(i,j))/(dy/2)
             ENDIF
          ELSE
             b = (ibm_ht_v(i,j)-ibm_ht_v(i,j+1))/dy
          ENDIF
       ELSEIF (stag .EQ. 'd') THEN
          d = ibm_ht_c(i,j)-GP(3)
          IF ((ibm_ht_c(i-1,j) .LE. ibm_ht_c(i,j)) .AND. (ibm_ht_c(i+1,j) .LE. ibm_ht_c(i,j))) THEN
             !on a ridge, figure out which way to go
             IF (ibm_ht_c(i-1,j) .EQ. ibm_ht_c(i+1,j)) THEN !it is a symmetric ridge
                IF (ibm_ht_v(i-1,j) .EQ. ibm_ht_v(i,j)) THEN !it is a really symmetric ridge
                   a = 0.0
                ELSE
                   a = (ibm_ht_v(i-1,j)-ibm_ht_v(i,j))/dx
                ENDIF
             ELSEIF (ibm_ht_c(i-1,j) .LT. ibm_ht_c(i+1,j)) THEN !go to the west
                a = (ibm_ht_v(i-1,j)-ibm_ht_c(i,j))/(dx/2)
             ELSE !go to the east
                a = (ibm_ht_c(i,j)-ibm_ht_v(i,j))/(dx/2)
             ENDIF
          ELSEIF ((ibm_ht_c(i,j) .LT. ibm_ht_c(i+1,j)) .AND. (ibm_ht_c(i-1,j) .LE. ibm_ht_c(i+1,j))) THEN
             !the image point is to the west
             IF (ibm_ht_c(i+1,j) .GT. ibm_ht_v(i,j)) THEN
                !the interpolation point could be closest to a wall, check for this
                e = dx/2.0
                f = ibm_ht_c(i+1,j)-ibm_ht_v(i,j)
                g = -(GP(3)-ibm_ht_c(i+1,j)-dx*e/f)/(f/e+e/f)
                d1 = (dx-g)/(SIN(ATAN(f/e)))
                h = ATAN((ibm_ht_v(i,j)-ibm_ht_c(i,j))/(dx/2.0))
                d2 = COS(h)*(GP(3)-ibm_ht_c(i,j))
                IF (d1 .LT. d2) THEN
                   a = (ibm_ht_v(i,j)-ibm_ht_c(i+1,j))/(dx/2)
                ELSE
                   a = (ibm_ht_c(i,j)-ibm_ht_v(i,j))/(dx/2)
                ENDIF
             ELSE
                a = (ibm_ht_c(i,j)-ibm_ht_v(i,j))/(dx/2)
             ENDIF
          ELSEIF (ibm_ht_c(i,j) .LT. ibm_ht_c(i-1,j)) THEN
             !the image point is to the east
             IF (ibm_ht_c(i-1,j) .GT. ibm_ht_v(i-1,j)) THEN
                !the interpolation point could be closest to a wall, check for this
                e = dx/2.0
                f = ibm_ht_c(i-1,j)-ibm_ht_v(i-1,j)
                g = -(GP(3)-ibm_ht_c(i-1,j)-dx*e/f)/(f/e+e/f)
                d1 = (dx-g)/(SIN(ATAN(f/e)))
                h = ATAN((ibm_ht_v(i-1,j)-ibm_ht_c(i,j))/(dx/2.0))
                d2 = COS(h)*(GP(3)-ibm_ht_c(i,j))
                IF (d1 .LT. d2) THEN
                   a = (ibm_ht_c(i-1,j)-ibm_ht_v(i-1,j))/(dx/2)
                ELSE
                   a = (ibm_ht_v(i-1,j)-ibm_ht_c(i,j))/(dx/2)
                ENDIF
             ELSE
                a = (ibm_ht_v(i-1,j)-ibm_ht_c(i,j))/(dx/2)
             ENDIF
          ELSE
             a = (ibm_ht_v(i-1,j)-ibm_ht_c(i,j))/dx
          ENDIF
          IF ((ibm_ht_c(i,j-1) .LE. ibm_ht_c(i,j)) .AND. (ibm_ht_c(i,j+1) .LE. ibm_ht_c(i,j))) THEN
             !on a ridge, figure out which way to go
             IF (ibm_ht_c(i,j-1) .EQ. ibm_ht_c(i,j+1)) THEN !it is a symmetric ridge
                IF (ibm_ht_u(i,j-1) .EQ. ibm_ht_u(i,j)) THEN !it is a really symmetric ridge
                   b = 0.0
                ELSE
                   b = (ibm_ht_u(i,j-1)-ibm_ht_u(i,j))/dy
                ENDIF
             ELSEIF (ibm_ht_c(i,j-1) .LT. ibm_ht_c(i,j+1)) THEN !go to the south
                b = (ibm_ht_u(i,j-1)-ibm_ht_c(i,j))/(dy/2)
             ELSE !go to the north
                b = (ibm_ht_c(i,j)-ibm_ht_u(i,j))/(dy/2)
             ENDIF
          ELSEIF ((ibm_ht_c(i,j) .LT. ibm_ht_c(i,j+1)) .AND. (ibm_ht_c(i,j-1) .LE. ibm_ht_c(i,j+1))) THEN
             !the image point is to the south
             IF (ibm_ht_c(i,j+1) .GT. ibm_ht_u(i,j)) THEN
                !the interpolation point could be closest to a wall, check for this
                e = dy/2.0
                f = ibm_ht_c(i,j+1)-ibm_ht_u(i,j)
                g = -(GP(3)-ibm_ht_c(i,j+1)-dy*e/f)/(f/e+e/f)
                d1 = (dy-g)/(SIN(ATAN(f/e)))
                h = ATAN((ibm_ht_u(i,j)-ibm_ht_c(i,j))/(dy/2.0))
                d2 = COS(h)*(GP(3)-ibm_ht_c(i,j))
                IF (d1 .LT. d2) THEN
                   b = (ibm_ht_u(i,j)-ibm_ht_c(i,j+1))/(dy/2)
                ELSE
                   b = (ibm_ht_c(i,j)-ibm_ht_u(i,j))/(dy/2)
                ENDIF
             ELSE
                b = (ibm_ht_c(i,j)-ibm_ht_u(i,j))/(dy/2)
             ENDIF
          ELSEIF (ibm_ht_c(i,j) .LT. ibm_ht_c(i,j-1)) THEN
             !the image point is to the north       
             IF (ibm_ht_c(i-1,j) .GT. ibm_ht_u(i,j-1)) THEN
                !the interpolation point could be closest to a wall, check for this
                e = dy/2.0
                f = ibm_ht_c(i,j-1)-ibm_ht_u(i,j-1)
                g = -(GP(3)-ibm_ht_c(i,j-1)-dy*e/f)/(f/e+e/f)
                d1 = (dy-g)/SIN(ATAN(f/e))
                h = ATAN((ibm_ht_u(i,j-1)-ibm_ht_c(i,j))/(dy/2.0))
                d2 = COS(h)*(GP(3)-ibm_ht_c(i,j))
                IF (d1 .LT. d2) THEN
                   b = (ibm_ht_c(i,j-1)-ibm_ht_u(i,j-1))/(dy/2)
                ELSE
                   b = (ibm_ht_u(i,j-1)-ibm_ht_c(i,j))/(dy/2)
                ENDIF
             ELSE
                b = (ibm_ht_u(i,j-1)-ibm_ht_c(i,j))/(dy/2)
             ENDIF
          ELSE
             b = (ibm_ht_u(i,j-1)-ibm_ht_u(i,j))/dy
          ENDIF
       ENDIF

       c = 1.0
       !normal distance from ghost point to plane that represents terrain
       mag = SQRT(a**2+b**2+c**2)
       IF (mag .EQ. 0) THEN
          CALL wrf_error_fatal("RSA[module_ibm/shear_stress_recon_interp_pts]: mag = 0.0, would divide by zero for side-point.")
       ENDIF
       dist = d/mag
       !normal vector to plane
       n(1) = a/mag
       n(2) = b/mag
       n(3) = c/mag

       !(x,y,z) of boundary point
       side_bound(1:3,S) = GP+dist*n

       !normal distance to reconstruction point from the boundary
       side_dist(1,S) = -dist
       side_norm(1:3,S) = n

       !put the interpolation point distance delta_recon away from the surface
       side_img(1:3,S) = GP !location of reconstruction pt
       side_img(4:6,S) = side_bound(1:3,S)+delta_recon*n !location of interpolation pt

       !normal distance to interpolation point from the boundary
       side_dist(2,S) = delta_recon

    ENDDO
 ENDIF !end of finding the image of s side points

 END SUBROUTINE shear_stress_recon_interp_pts

!------------------------------------------------------------------------------- 

SUBROUTINE shear_stress_extrap_pts( stag,                                              &
                                    dx, dy, ht_p,                                      &
                                    ibm_ht_u, ibm_ht_v,                                &
                                    ibm_ht_w, ibm_ht_c,                                &
                                    top, side,                                         &
                                    top_img_1, top_img_2, top_img_3, top_bound,        &
                                    side_img_1, side_img_2, side_img_3, side_bound,    &
                                    ns, top_norm, side_norm,                           &
                                    top_dist, side_dist,                               &
                                    delta_extrap_in,                                   &
                                    ids, ide, jds, jde, kds, kde,                      &
                                    ims, ime, jms, jme, kms, kme,                      &
                                    its, ite, jts, jte, kts, kte )

 IMPLICIT NONE
 !input data
 CHARACTER, INTENT(IN   )                                 :: stag
 REAL, INTENT(IN   )                                      :: dx, dy
 REAL, DIMENSION(ims:ime,kms:kme,jms:jme), INTENT(IN   )  :: ht_p
 REAL, DIMENSION(ims:ime,jms:jme), INTENT(IN   )          :: ibm_ht_u,  &
                                                             ibm_ht_v,  &
                                                             ibm_ht_w,  &
                                                             ibm_ht_c
 REAL, INTENT(IN   )                                      :: delta_extrap_in ! shear stress extrapolation distance
 INTEGER, DIMENSION(ims:ime,jms:jme), INTENT(IN   )       :: top             !'top boundary' ghost points
 INTEGER, DIMENSION(3,ns), INTENT(IN   )                  :: side            !'side boundary' ghost points
 REAL, DIMENSION(ims:ime,jms:jme,6), INTENT(  OUT)        :: top_img_1, &    !(x,y,z) location of ghost point and image point of the 'top boundary' ghost points					                     
                                                             top_img_2, &
                                                             top_img_3
 REAL, DIMENSION(ims:ime,jms:jme,3), INTENT(  OUT)        :: top_bound, &    !(x,y,z) location of the boundary for top point
                                                             top_norm        !only used for the neumann condition
 REAL, DIMENSION(ims:ime,jms:jme), INTENT(   OUT)         :: top_dist
 REAL, DIMENSION(6,ns), INTENT(  OUT)                     :: side_img_1,&    !(x,y,z) location of ghost point and image point of the 'side boundary' ghost points
                                                             side_img_2,&
                                                             side_img_3
 REAL, DIMENSION(3,ns), INTENT(  OUT)                     :: side_bound,&    !(x,y,z) location of the boundary for side points
                                                             side_norm       !only used for the neumann condition
 REAL, DIMENSION(ns), INTENT(   OUT)                      :: side_dist
 INTEGER, INTENT(IN   )                                   :: ns              !number of 'side boundary' ghost points
 INTEGER ,       INTENT(IN   )   :: ids, ide, jds, jde, kds, kde, &          !d: domain
                                    ims, ime, jms, jme, kms, kme, &          !m: memory
                                    its, ite, jts, jte, kts, kte             !p: patch, t: tile
 !local data
 INTEGER                                                  :: i, j, &
                                                             S,    &
                                                             i_end,&
                                                             j_end
 REAL                                                     :: a, b, &          !coefficients of plane that represents terrain
                                                             c, d, &
                                                             mag,  &          !norm of gradient of eqn for plane SQRT(a**2+b**2+c**2)
                                                             dist, &          !distance (magnitude) from ghost point to terrain
                                                             delta_extrap, &
                                                             delta_fact, &
                                                             delta_z
 REAL, DIMENSION(3)                                       :: n,    &          !outward normal vector to terrain
                                                             GP,   &          !(x,y,z) location of ghost point
                                                             IP               !(x,y,z) location of image point						     

!---------------------------------------------------------------------------------
 !this subroutine finds the extrapolation points for the shear stress underneath
 !the terrain
 !RSA modified version of image_pts subroutine
 CALL wrf_debug(100,'dyn_em/module_ibm.F/subroutine shear_stress_extrap_pts')
!--------------------------------------------------------------------------------
 !Values for extrapolation distance
 delta_z = delta_extrap_in / 1.1
 delta_fact = 0.3

 !initialize the arrays top be computed
 top_img_1 = 0.0
 top_img_2 = 0.0
 top_img_3 = 0.0
 top_bound = 0.0
 top_norm = 0.0
 top_dist = 0.0
 if (ns > 0) side_img_1 = 0.0
 if (ns > 0) side_img_2 = 0.0
 if (ns > 0) side_img_3 = 0.0
 if (ns > 0) side_bound = 0.0
 if (ns > 0) side_norm = 0.0
 if (ns > 0) side_dist = 0.0
 
 IF ((stag .EQ. 'u') .OR. (stag .EQ. 'e')) THEN
    i_end = ite
    j_end = MIN(jte,jde-1)
 ELSEIF ((stag .EQ. 'v') .OR. (stag .EQ. 'f')) THEN
    i_end = MIN(ite,ide-1)
    j_end = jte
 ELSEIF ((stag .EQ. 'w') .OR. (stag .EQ. 't')) THEN
    i_end = MIN(ite,ide-1)
    j_end = MIN(jte,jde-1)
 ELSEIF (stag .EQ. 'd') THEN
    i_end = ite
    j_end = jte
 ENDIF
 
 DO i = its,i_end
 DO j = jts,j_end 
    ! find the image location for top ghost points
    ! (x,y,z) of ghost point
    IF ((stag .EQ. 'u') .OR. (stag .EQ. 'd') .OR. (stag .EQ. 'e')) THEN
        GP(1) = (i*dx)-(dx)  
    ELSE
        GP(1) = (i*dx)-(dx/2)
    ENDIF
    IF ((stag .EQ. 'v') .OR. (stag .EQ. 'd') .OR. (stag .EQ. 'f')) THEN
        GP(2) = (j*dy)-(dy)
    ELSE
        GP(2) = (j*dy)-(dy/2)
    ENDIF
    GP(3) = ht_p(i,top(i,j),j)
    ! equation for plane that represents terrain (ax+by+cz+d = 0)
    IF ((stag .EQ. 'u') .OR. (stag .EQ. 'e')) THEN
        a = (ibm_ht_w(i-1,j)-ibm_ht_w(i,j))/dx
        b = (ibm_ht_c(i,j)-ibm_ht_c(i,j+1))/dy
        c = 1.0
        d = ibm_ht_u(i,j)-GP(3)
    ELSEIF ((stag .EQ. 'v') .OR. (stag .EQ. 'f')) THEN
        a = (ibm_ht_c(i,j)-ibm_ht_c(i+1,j))/dx
        b = (ibm_ht_w(i,j-1)-ibm_ht_w(i,j))/dy
        c = 1.0
        d = ibm_ht_v(i,j)-GP(3)    
    ELSEIF ((stag == 'w') .OR. (stag == 't')) THEN    
        a = (ibm_ht_u(i,j)-ibm_ht_u(i+1,j))/dx
        b = (ibm_ht_v(i,j)-ibm_ht_v(i,j+1))/dy
        c = 1.0
        d = ibm_ht_w(i,j)-GP(3)
    ELSEIF (stag .EQ. 'd') THEN
       a = (ibm_ht_v(i-1,j)-ibm_ht_v(i,j))/dx
       b = (ibm_ht_u(i,j-1)-ibm_ht_u(i,j))/dy
       c = 1.0
       d = ibm_ht_c(i,j)-GP(3)
    ENDIF
    mag = SQRT(a**2+b**2+c**2)
    IF (mag .EQ. 0) THEN
       CALL wrf_error_fatal("RSA[module_ibm/shear_stress_extrap_pts]: mag = 0.0, would divide by zero for top-point.")
    ENDIF
    ! normal distance from ghost point to plane that represents terrain
    dist = d/mag
    ! normal vector to plane
    n(1) = a/mag
    n(2) = b/mag
    n(3) = c/mag

    ! (x,y,z) of boundary point
    top_bound(i,j,1:3) = GP+dist*n

    !distance to ghost point
    top_dist(i,j) = -dist
    top_norm(i,j,1:3) = n

    !set extrapolation distance (check if first point is underneath terrain)
    IF (delta_extrap_in .LT. dist) THEN
       delta_extrap = dist + delta_fact*delta_z
       ! write(*,*) "Changing delta_extrap at i=",i,",j=",j
    ELSE
       delta_extrap = delta_extrap_in
    ENDIF

    !put the extrapolation points 1, 2, and 3 times delta_extrap from ghost point
    !in surface normal direction
    top_img_1(i,j,1:3) = GP !location of ghost pt
    top_img_1(i,j,4:6) = GP + delta_extrap*n 
    top_img_2(i,j,1:3) = GP !location of ghost pt
    top_img_2(i,j,4:6) = GP + 2.0*delta_extrap*n
    top_img_3(i,j,1:3) = GP !location of ghost pt
    top_img_3(i,j,4:6) = GP + 3.0*delta_extrap*n

 ENDDO
 ENDDO

 ! find the image of the s side ghost points
 if (ns > 0) then
    DO S=1,ns
        i = side(1,S)
        j = side(2,S) 
        ! (x,y,z) of ghost point
        IF ((stag .EQ. 'u') .OR. (stag .EQ. 'd') .OR. (stag .EQ. 'e')) THEN
            GP(1) = (i*dx)-(dx)  
        ELSE
            GP(1) = (i*dx)-(dx/2)
        ENDIF
        IF ((stag .EQ. 'v') .OR. (stag .EQ. 'd') .OR. (stag .EQ. 'f')) THEN
            GP(2) = (j*dy)-(dy)
        ELSE
            GP(2) = (j*dy)-(dy/2)
        ENDIF
        GP(3) = ht_p(i,side(3,S),j)
        ! equation for plane that represents terrain (ax+by+cz+d = 0)
        IF ((stag .EQ. 'u') .OR. (stag .EQ. 'e')) THEN
            d = ibm_ht_u(i,j)-GP(3)
            if ((ibm_ht_u(i-1,j) < ibm_ht_u(i,j)) .AND. (ibm_ht_u(i+1,j) < ibm_ht_u(i,j))) then ! on a ridge, figure out which way to go	    
               if (ibm_ht_u(i-1,j) == ibm_ht_u(i+1,j)) then ! the two are equal
                  if (ibm_ht_w(i-1,j) == ibm_ht_w(i,j)) then ! a=0, look closer to see if this is appropriate
                     if ((ABS(top(i,j+1)-top(i,j)) > 1) .OR. (ABS(top(i,j-1)-top(i,j)) > 1)) then ! the the side is north south and a=0 is fine
                        a = (ibm_ht_w(i-1,j)-ibm_ht_w(i,j))/dx
                     else ! this is a symetric ridge, there is a side to the left and right...fo left, this is an arbitrary choice
                        if (ibm_ht_w(i-1,j) >= ht_p(i,side(3,S)+1,j)) then 
                           a = (ibm_ht_u(i-1,j)-ibm_ht_w(i-1,j))/(dx/2)
                           d = 2*ibm_ht_w(i-1,j)-ibm_ht_u(i-1,j)-GP(3)
                        elseif (ibm_ht_w(i-1,j) > GP(3)) then
                           a = (ibm_ht_u(i-1,j)-ibm_ht_u(i,j))/dx
                        else
                           a = (ibm_ht_w(i-1,j)-ibm_ht_u(i,j))/(dx/2)
                        endif
                     endif
                  else
                     a = (ibm_ht_w(i-1,j)-ibm_ht_w(i,j))/dx
                  endif
               elseif (ibm_ht_u(i-1,j) < ibm_ht_u(i+1,j)) then ! go to the left
                  if (ibm_ht_w(i-1,j) >= ht_p(i,side(3,S)+1,j)) then 
                     a = (ibm_ht_u(i-1,j)-ibm_ht_w(i-1,j))/(dx/2)
                     d = 2*ibm_ht_w(i-1,j)-ibm_ht_u(i-1,j)-GP(3)
                  elseif (ibm_ht_w(i-1,j) > GP(3)) then
                     a = (ibm_ht_u(i-1,j)-ibm_ht_u(i,j))/dx
                  else
                     a = (ibm_ht_w(i-1,j)-ibm_ht_u(i,j))/(dx/2)
                  endif
               else ! (ibm_ht_u(i+1,j) < ibm_ht_u(i-1,j)) ! go to the right
                  if (ibm_ht_w(i,j) >= ht_p(i,side(3,S)+1,j)) then 
                     a = (ibm_ht_w(i,j)-ibm_ht_u(i+1,j))/(dx/2)
                     d = 2*ibm_ht_w(i,j)-ibm_ht_u(i+1,j)-GP(3)
                  elseif (ibm_ht_w(i,j) > GP(3)) then
                     a = (ibm_ht_u(i,j)-ibm_ht_u(i+1,j))/dx
                  else
                     a = (ibm_ht_u(i,j)-ibm_ht_w(i,j))/(dx/2)
                  endif
               endif  
            elseif (ibm_ht_u(i-1,j) < ibm_ht_u(i,j)) then !image is to the left
            !if (top(i-1,j) < top(i,j)) then !image is to the left
               ! Now, should I be calculating the x slope between u(i-1) and w(i-1),
               ! or between w(i-1) and u(i)
               if (ibm_ht_w(i-1,j) >= ht_p(i,side(3,S)+1,j)) then 
                  a = (ibm_ht_u(i-1,j)-ibm_ht_w(i-1,j))/(dx/2)
                  d = 2*ibm_ht_w(i-1,j)-ibm_ht_u(i-1,j)-GP(3)
               elseif (ibm_ht_w(i-1,j) > GP(3)) then
                  a = (ibm_ht_u(i-1,j)-ibm_ht_u(i,j))/dx
               else
                  a = (ibm_ht_w(i-1,j)-ibm_ht_u(i,j))/(dx/2)
               endif
            elseif (ibm_ht_u(i+1,j) < ibm_ht_u(i,j)) then ! image is to the right   
            !elseif (top(i+1,j) < top(i,j)) then ! image is to the right
               if (ibm_ht_w(i,j) >= ht_p(i,side(3,S)+1,j)) then 
                  a = (ibm_ht_w(i,j)-ibm_ht_u(i+1,j))/(dx/2)
                  d = 2*ibm_ht_w(i,j)-ibm_ht_u(i+1,j)-GP(3)
               elseif (ibm_ht_w(i,j) > GP(3)) then
                  a = (ibm_ht_u(i,j)-ibm_ht_u(i+1,j))/dx
               else
                  a = (ibm_ht_u(i,j)-ibm_ht_w(i,j))/(dx/2)
               endif
            else
               a = (ibm_ht_w(i-1,j)-ibm_ht_w(i,j))/dx
            endif
            if ((ibm_ht_u(i,j-1) < ibm_ht_u(i,j)) .AND. (ibm_ht_u(i,j+1) < ibm_ht_u(i,j))) then ! on a ridge
              if (ibm_ht_u(i,j-1) == ibm_ht_u(i,j+1)) then ! the two are equal
                 if (ibm_ht_c(i,j) == ibm_ht_c(i,j+1)) then ! b=0, look closer to see if this is appropriate
                    if ((ABS(top(i+1,j)-top(i,j)) > 1) .OR. (ABS(top(i-1,j)-top(i,j)) > 1)) then ! then the side is east west and b=0 is fine
                       b = (ibm_ht_c(i,j)-ibm_ht_c(i,j+1))/dy
                    else ! this is a symetric ridge, there is a side to the north and south...go south, this choice is arbitrary
                       if (ibm_ht_c(i,j) >= ht_p(i,side(3,S)+1,j)) then 
                          b = (ibm_ht_u(i,j-1)-ibm_ht_c(i,j))/(dy/2)
                          d = 2*ibm_ht_c(i,j)-ibm_ht_u(i,j-1)-GP(3)
                       elseif (ibm_ht_c(i,j) > GP(3)) then
                          b = (ibm_ht_u(i,j-1)-ibm_ht_u(i,j))/dy
                       else
                          b = (ibm_ht_c(i,j)-ibm_ht_u(i,j))/(dy/2)
                       endif
                    endif
                 else
                    b = (ibm_ht_c(i,j)-ibm_ht_c(i,j+1))/dy
                 endif
              elseif (ibm_ht_u(i,j-1) < ibm_ht_u(i,j+1)) then ! image is to the south
                 if (ibm_ht_c(i,j) >= ht_p(i,side(3,S)+1,j)) then 
                    b = (ibm_ht_u(i,j-1)-ibm_ht_c(i,j))/(dy/2)
                    d = 2*ibm_ht_c(i,j)-ibm_ht_u(i,j-1)-GP(3)
                 elseif (ibm_ht_c(i,j) > GP(3)) then
                    b = (ibm_ht_u(i,j-1)-ibm_ht_u(i,j))/dy
                 else
                    b = (ibm_ht_c(i,j)-ibm_ht_u(i,j))/(dy/2)
                 endif
              else ! image is to the north
                 if (ibm_ht_c(i,j+1) >= ht_p(i,side(3,S)+1,j)) then 
                    b = (ibm_ht_c(i,j+1)-ibm_ht_u(i,j+1))/(dy/2)
                    d = 2*ibm_ht_c(i,j+1)-ibm_ht_u(i,j+1)-GP(3)
                 elseif (ibm_ht_c(i,j+1) > GP(3)) then
                    b = (ibm_ht_u(i,j)-ibm_ht_u(i,j+1))/dy
                 else
                    b = (ibm_ht_u(i,j)-ibm_ht_c(i,j+1))/(dy/2)
                 endif
              endif
            elseif (ibm_ht_u(i,j-1) < ibm_ht_u(i,j)) then !image is to the south	    
            !if (top(i,j-1) < top(i,j)) then !image is to the south
               ! Now, should I be calculating the y slope between u(j-1) and c(j),
               ! or between c(j) and u(j)
               if (ibm_ht_c(i,j) >= ht_p(i,side(3,S)+1,j)) then 
                  b = (ibm_ht_u(i,j-1)-ibm_ht_c(i,j))/(dy/2)
                  d = 2*ibm_ht_c(i,j)-ibm_ht_u(i,j-1)-GP(3)
               elseif (ibm_ht_c(i,j) > GP(3)) then
                  b = (ibm_ht_u(i,j-1)-ibm_ht_u(i,j))/dy
               else
                  b = (ibm_ht_c(i,j)-ibm_ht_u(i,j))/(dy/2)
               endif
            elseif (ibm_ht_u(i,j+1) < ibm_ht_u(i,j)) then ! image is to the north   
            !elseif (top(i,j+1) < top(i,j)) then ! image is to the north
               if (ibm_ht_c(i,j+1) >= ht_p(i,side(3,S)+1,j)) then 
                  b = (ibm_ht_c(i,j+1)-ibm_ht_u(i,j+1))/(dy/2)
                  d = 2*ibm_ht_c(i,j+1)-ibm_ht_u(i,j+1)-GP(3)
               elseif (ibm_ht_c(i,j+1) > GP(3)) then
                  b = (ibm_ht_u(i,j)-ibm_ht_u(i,j+1))/dy
               else
                  b = (ibm_ht_u(i,j)-ibm_ht_c(i,j+1))/(dy/2)
               endif
            else
               b = (ibm_ht_c(i,j)-ibm_ht_c(i,j+1))/dy
            endif
        ELSEIF ((stag .EQ. 'v') .OR. (stag .EQ. 'f')) THEN
            d = ibm_ht_v(i,j)-GP(3)
            if ((ibm_ht_v(i-1,j) < ibm_ht_v(i,j)) .AND. (ibm_ht_v(i+1,j) < ibm_ht_v(i,j))) then ! if on a ridge, figure out which way to go
               if (ibm_ht_v(i-1,j) == ibm_ht_v(i+1,j)) then ! the two are equal
                  if (ibm_ht_c(i,j) == ibm_ht_c(i+1,j)) then ! a=0, look closer to see if this is appropriate
                     if ((ABS(top(i,j+1)-top(i,j)) > 1) .OR. (ABS(top(i,j-1)-top(i,j)) > 1)) then ! the the side is north south and a=0 is fine
                        a = (ibm_ht_c(i,j)-ibm_ht_c(i+1,j))/dx
                     else  ! this is a symetric ridge, there is a side to the left and right...go left, this choice is arbitrary
                        if (ibm_ht_c(i,j) >= ht_p(i,side(3,S)+1,j)) then 
                           a = (ibm_ht_v(i-1,j)-ibm_ht_c(i,j))/(dx/2)
                           d = 2*ibm_ht_c(i,j)-ibm_ht_v(i-1,j)-GP(3)
                        elseif (ibm_ht_c(i,j) > GP(3)) then
                           a = (ibm_ht_v(i-1,j)-ibm_ht_v(i,j))/dx
                        else
                           a = (ibm_ht_c(i,j)-ibm_ht_v(i,j))/(dx/2)
                        endif
                     endif
                  else
                     a = (ibm_ht_c(i,j)-ibm_ht_c(i+1,j))/dx
                  endif
               elseif (ibm_ht_v(i-1,j) < ibm_ht_v(i+1,j)) then ! go to the left
                  if (ibm_ht_c(i,j) >= ht_p(i,side(3,S)+1,j)) then 
                     a = (ibm_ht_v(i-1,j)-ibm_ht_c(i,j))/(dx/2)
                     d = 2*ibm_ht_c(i,j)-ibm_ht_v(i-1,j)-GP(3)
                  elseif (ibm_ht_c(i,j) > GP(3)) then
                     a = (ibm_ht_v(i-1,j)-ibm_ht_v(i,j))/dx
                  else
                     a = (ibm_ht_c(i,j)-ibm_ht_v(i,j))/(dx/2)
                  endif
               else   ! go to the right
                  if (ibm_ht_c(i+1,j) >= ht_p(i,side(3,S)+1,j)) then 
                     a = (ibm_ht_c(i+1,j)-ibm_ht_v(i+1,j))/(dx/2)
                     d = 2*ibm_ht_c(i+1,j)-ibm_ht_v(i+1,j)-GP(3)
                  elseif (ibm_ht_c(i+1,j) > GP(3)) then
                     a = (ibm_ht_v(i,j)-ibm_ht_v(i+1,j))/dx
                  else
                     a = (ibm_ht_v(i,j)-ibm_ht_c(i+1,j))/(dx/2)
                  endif
               endif
            elseif (ibm_ht_v(i-1,j) < ibm_ht_v(i,j)) then !image is to the left
            !if (top(i-1,j) < top(i,j)) then !image is to the left
               if (ibm_ht_c(i,j) >= ht_p(i,side(3,S)+1,j)) then 
                  a = (ibm_ht_v(i-1,j)-ibm_ht_c(i,j))/(dx/2)
                  d = 2*ibm_ht_c(i,j)-ibm_ht_v(i-1,j)-GP(3)
               elseif (ibm_ht_c(i,j) > GP(3)) then
                  a = (ibm_ht_v(i-1,j)-ibm_ht_v(i,j))/dx
               else
                  a = (ibm_ht_c(i,j)-ibm_ht_v(i,j))/(dx/2)
               endif
            elseif (ibm_ht_v(i+1,j) < ibm_ht_v(i,j)) then ! image is to the right  
            !elseif (top(i+1,j) < top(i,j)) then ! image is to the right
               if (ibm_ht_c(i+1,j) >= ht_p(i,side(3,S)+1,j)) then 
                  a = (ibm_ht_c(i+1,j)-ibm_ht_v(i+1,j))/(dx/2)
                  d = 2*ibm_ht_c(i+1,j)-ibm_ht_v(i+1,j)-GP(3)
               elseif (ibm_ht_c(i+1,j) > GP(3)) then
                  a = (ibm_ht_v(i,j)-ibm_ht_v(i+1,j))/dx
               else
                  a = (ibm_ht_v(i,j)-ibm_ht_c(i+1,j))/(dx/2)
               endif
            else
               a = (ibm_ht_c(i,j)-ibm_ht_c(i+1,j))/dx
            endif
            if ((ibm_ht_v(i,j-1) < ibm_ht_v(i,j)) .AND. (ibm_ht_v(i,j+1) < ibm_ht_v(i,j))) then ! on a ridge
               if (ibm_ht_v(i,j-1) == ibm_ht_v(i,j+1)) then ! the two are equal
                  if (ibm_ht_w(i,j-1) == ibm_ht_w(i,j)) then ! b=0, look closer to see if this is appropriate
                     if ((ABS(top(i+1,j)-top(i,j)) > 1) .OR. (ABS(top(i-1,j)-top(i,j)) > 1)) then ! then the side is east west and b=0 is fine
                        b = (ibm_ht_w(i,j-1)-ibm_ht_w(i,j))/dy
                     else ! this is a symetric ridge, there is a side to the north and south...go south, this choice is arbitrary		  
                        if (ibm_ht_w(i,j-1) >= ht_p(i,side(3,S)+1,j)) then 
                           b = (ibm_ht_v(i,j-1)-ibm_ht_w(i,j-1))/(dy/2)
                           d = 2*ibm_ht_w(i,j-1)-ibm_ht_v(i,j-1)-GP(3)
                        elseif (ibm_ht_w(i,j-1) > GP(3)) then
                           b = (ibm_ht_v(i,j-1)-ibm_ht_v(i,j))/dy
                        else
                           b = (ibm_ht_w(i,j-1)-ibm_ht_v(i,j))/(dy/2)
                        endif
                     endif
                  else
                     b = (ibm_ht_w(i,j-1)-ibm_ht_w(i,j))/dy
                  endif       
               elseif (ibm_ht_v(i,j-1) < ibm_ht_v(i,j+1)) then !image is to the south	       
                  if (ibm_ht_w(i,j-1) >= ht_p(i,side(3,S)+1,j)) then 
                     b = (ibm_ht_v(i,j-1)-ibm_ht_w(i,j-1))/(dy/2)
                     d = 2*ibm_ht_w(i,j-1)-ibm_ht_v(i,j-1)-GP(3)
                  elseif (ibm_ht_w(i,j-1) > GP(3)) then
                     b = (ibm_ht_v(i,j-1)-ibm_ht_v(i,j))/dy
                  else
                     b = (ibm_ht_w(i,j-1)-ibm_ht_v(i,j))/(dy/2)
                  endif
               else   ! image is to the north
                  if (ibm_ht_w(i,j) >= ht_p(i,side(3,S)+1,j)) then 
                     b = (ibm_ht_w(i,j)-ibm_ht_v(i,j+1))/(dy/2)
                     d = 2*ibm_ht_w(i,j)-ibm_ht_v(i,j+1)-GP(3)
                  elseif (ibm_ht_w(i,j) > GP(3)) then
                     b = (ibm_ht_v(i,j)-ibm_ht_v(i,j+1))/dy
                  else
                     b = (ibm_ht_v(i,j)-ibm_ht_w(i,j))/(dy/2)
                  endif   
               endif
            elseif (ibm_ht_v(i,j-1) < ibm_ht_v(i,j)) then !image is to the south
            !if (top(i,j-1) < top(i,j)) then !image is to the south
               ! Now, should I be calculating the y slope between v(j-1) and w(j-1),
               ! or between w(j-1) and v(j)
               if (ibm_ht_w(i,j-1) >= ht_p(i,side(3,S)+1,j)) then 
                  b = (ibm_ht_v(i,j-1)-ibm_ht_w(i,j-1))/(dy/2)
                  d = 2*ibm_ht_w(i,j-1)-ibm_ht_v(i,j-1)-GP(3)
               elseif (ibm_ht_w(i,j-1) > GP(3)) then
                  b = (ibm_ht_v(i,j-1)-ibm_ht_v(i,j))/dy
               else
                  b = (ibm_ht_w(i,j-1)-ibm_ht_v(i,j))/(dy/2)
               endif
            elseif (ibm_ht_v(i,j+1) < ibm_ht_v(i,j)) then !image is to the north       
            !elseif (top(i,j+1) < top(i,j)) then !image is to the north
               if (ibm_ht_w(i,j) >= ht_p(i,side(3,S)+1,j)) then 
                  b = (ibm_ht_w(i,j)-ibm_ht_v(i,j+1))/(dy/2)
                  d = 2*ibm_ht_w(i,j)-ibm_ht_v(i,j+1)-GP(3)
               elseif (ibm_ht_w(i,j) > GP(3)) then
                  b = (ibm_ht_v(i,j)-ibm_ht_v(i,j+1))/dy
               else
                  b = (ibm_ht_v(i,j)-ibm_ht_w(i,j))/(dy/2)
               endif
            else
               b = (ibm_ht_w(i,j-1)-ibm_ht_w(i,j))/dy
            endif
        ELSEIF ((stag == 'w') .OR. (stag == 't'))THEN
            d = ibm_ht_w(i,j)-GP(3)
            if ((ibm_ht_w(i-1,j) < ibm_ht_w(i,j)) .AND. (ibm_ht_w(i+1,j) < ibm_ht_w(i,j))) then ! if on a ridge, figure out which way to go
                if (ibm_ht_w(i-1,j) == ibm_ht_w(i+1,j)) then ! the two are equal
                   if (ibm_ht_u(i,j) == ibm_ht_u(i+1,j)) then ! a = 0, look closer to see if this is appropriate
                      if ((ABS(top(i,j+1)-top(i,j)) > 1) .OR. (ABS(top(i,j-1)-top(i,j)) > 1)) then ! the the side is north south and a=0 is fine
                         a = (ibm_ht_u(i,j)-ibm_ht_u(i+1,j))/dx
                      else  ! this is a symetric ridge, there is a side to the left and right...go left, this choice is arbitrary
                         if (ibm_ht_u(i,j) >= ht_p(i,side(3,S)+1,j)) then 
                            a = -(ibm_ht_u(i,j)-ibm_ht_w(i-1,j))/(dx/2)
                            d = 2*ibm_ht_u(i,j)-ibm_ht_w(i-1,j)-GP(3)
                         elseif (ibm_ht_u(i,j) > GP(3)) then
                            a = -(ibm_ht_w(i,j)-ibm_ht_w(i-1,j))/dx
                         else
                            a = -(ibm_ht_w(i,j)-ibm_ht_u(i,j))/(dx/2)
                         endif
                      endif
                   else
                      a = (ibm_ht_u(i,j)-ibm_ht_u(i+1,j))/dx
                   endif
                elseif (ibm_ht_w(i-1,j) < ibm_ht_w(i+1,j)) then ! go to the left
                   if (ibm_ht_u(i,j) >= ht_p(i,side(3,S)+1,j)) then 
                      a = -(ibm_ht_u(i,j)-ibm_ht_w(i-1,j))/(dx/2)
                      d = 2*ibm_ht_u(i,j)-ibm_ht_w(i-1,j)-GP(3)
                   elseif (ibm_ht_u(i,j) > GP(3)) then
                      a = -(ibm_ht_w(i,j)-ibm_ht_w(i-1,j))/dx
                   else
                      a = -(ibm_ht_w(i,j)-ibm_ht_u(i,j))/(dx/2)
                   endif
                else  ! if (ibm_ht_w(i+1,j) < ibm_ht_w(i-1,j)) then ! go to the right
                   if (ibm_ht_u(i+1,j) >= ht_p(i,side(3,S)+1,j)) then 
                      a = -(ibm_ht_w(i+1,j)-ibm_ht_u(i+1,j))/(dx/2)
                      d = 2*ibm_ht_u(i+1,j)-ibm_ht_w(i+1,j)-GP(3)
                   elseif (ibm_ht_u(i+1,j) > GP(3)) then
                      a = -(ibm_ht_w(i+1,j)-ibm_ht_w(i,j))/dx
                   else
                      a = -(ibm_ht_u(i+1,j)-ibm_ht_w(i,j))/(dx/2)
                   endif
                endif
            elseif (ibm_ht_w(i-1,j) < ibm_ht_w(i,j)) then !image is to the left
               if (ibm_ht_u(i,j) >= ht_p(i,side(3,S)+1,j)) then 
                  a = -(ibm_ht_u(i,j)-ibm_ht_w(i-1,j))/(dx/2)
                  d = 2*ibm_ht_u(i,j)-ibm_ht_w(i-1,j)-GP(3)
               elseif (ibm_ht_u(i,j) > GP(3)) then
                  a = -(ibm_ht_w(i,j)-ibm_ht_w(i-1,j))/dx
               else
                  a = -(ibm_ht_w(i,j)-ibm_ht_u(i,j))/(dx/2)
               endif
            elseif (ibm_ht_w(i+1,j) < ibm_ht_w(i,j)) then ! image is to the right  
               if (ibm_ht_u(i+1,j) >= ht_p(i,side(3,S)+1,j)) then 
                  a = -(ibm_ht_w(i+1,j)-ibm_ht_u(i+1,j))/(dx/2)
                  d = 2*ibm_ht_u(i+1,j)-ibm_ht_w(i+1,j)-GP(3)
               elseif (ibm_ht_u(i+1,j) > GP(3)) then
                  a = -(ibm_ht_w(i+1,j)-ibm_ht_w(i,j))/dx
               else
                  a = -(ibm_ht_u(i+1,j)-ibm_ht_w(i,j))/(dx/2)
               endif
            else
               a = (ibm_ht_u(i,j)-ibm_ht_u(i+1,j))/dx   
            endif
            if ((ibm_ht_w(i,j-1) < ibm_ht_w(i,j)) .AND. (ibm_ht_w(i,j+1) < ibm_ht_w(i,j))) then ! on a ridge      
               if (ibm_ht_w(i,j-1) == ibm_ht_w(i,j+1)) then ! the two are equal
                  if (ibm_ht_v(i,j+1) == ibm_ht_v(i,j)) then ! b=0, look closer to see if this is appropriate
                     if ((ABS(top(i+1,j)-top(i,j)) > 1) .OR. (ABS(top(i-1,j)-top(i,j)) > 1)) then ! then the side is east west and b=0 is fine
                        b = -(ibm_ht_v(i,j+1)-ibm_ht_v(i,j))/dy
                     else ! this is a symetric ridge, there is a side to the north and south...go south, this choice is arbitrary
                        if (ibm_ht_v(i,j) >= ht_p(i,side(3,S)+1,j)) then 
                           b = (ibm_ht_w(i,j-1)-ibm_ht_v(i,j))/(dy/2)
                           d = 2*ibm_ht_v(i,j)-ibm_ht_w(i,j-1)-GP(3)
                        elseif (ibm_ht_v(i,j) > GP(3)) then
                           b = (ibm_ht_w(i,j-1)-ibm_ht_w(i,j))/dy
                        else
                           b = (ibm_ht_v(i,j)-ibm_ht_w(i,j))/(dy/2)
                        endif
                     endif
                  else
                     b = -(ibm_ht_v(i,j+1)-ibm_ht_v(i,j))/dy
                  endif
               elseif (ibm_ht_w(i,j-1) < ibm_ht_w(i,j+1)) then !image is to the south
                  ! Now, should I be calculating the y slope between w(j-1) and v(j),
                  ! or between v(j) and w(j)
                  if (ibm_ht_v(i,j) >= ht_p(i,side(3,S)+1,j)) then 
                     b = (ibm_ht_w(i,j-1)-ibm_ht_v(i,j))/(dy/2)
                     d = 2*ibm_ht_v(i,j)-ibm_ht_w(i,j-1)-GP(3)
                  elseif (ibm_ht_v(i,j) > GP(3)) then
                     b = (ibm_ht_w(i,j-1)-ibm_ht_w(i,j))/dy
                  else
                     b = (ibm_ht_v(i,j)-ibm_ht_w(i,j))/(dy/2)
                  endif
               else  ! if (ibm_ht_w(i,j+1) < ibm_ht_w(i,j-1)) then  ! image is to the north 
                  if (ibm_ht_v(i,j+1) >= ht_p(i,side(3,S)+1,j)) then 
                     b = (ibm_ht_v(i,j+1)-ibm_ht_w(i,j+1))/(dy/2)
                     d = 2*ibm_ht_v(i,j+1)-ibm_ht_w(i,j+1)-GP(3)
                  elseif (ibm_ht_v(i,j+1) > GP(3)) then
                     b = (ibm_ht_w(i,j)-ibm_ht_w(i,j+1))/dy
                  else
                     b = (ibm_ht_w(i,j)-ibm_ht_v(i,j+1))/(dy/2)
                  endif
               endif
            elseif (ibm_ht_w(i,j-1) < ibm_ht_w(i,j)) then !image is to the south
            !if (top(i,j-1) < top(i,j)) then !image is to the south 
               ! Now, should I be calculating the y slope between w(j-1) and v(j),
               ! or between v(j) and w(j)
               if (ibm_ht_v(i,j) >= ht_p(i,side(3,S)+1,j)) then 
                  b = (ibm_ht_w(i,j-1)-ibm_ht_v(i,j))/(dy/2)
                  d = 2*ibm_ht_v(i,j)-ibm_ht_w(i,j-1)-GP(3)
               elseif (ibm_ht_v(i,j) > GP(3)) then
                  b = (ibm_ht_w(i,j-1)-ibm_ht_w(i,j))/dy
               else
                  b = (ibm_ht_v(i,j)-ibm_ht_w(i,j))/(dy/2)
               endif
            elseif (ibm_ht_w(i,j+1) < ibm_ht_w(i,j)) then ! image is to the north 
            !elseif (top(i,j+1) < top(i,j)) then ! image is to the north
               if (ibm_ht_v(i,j+1) >= ht_p(i,side(3,S)+1,j)) then 
                  b = (ibm_ht_v(i,j+1)-ibm_ht_w(i,j+1))/(dy/2)
                  d = 2*ibm_ht_v(i,j+1)-ibm_ht_w(i,j+1)-GP(3)
               elseif (ibm_ht_v(i,j+1) > GP(3)) then
                  b = (ibm_ht_w(i,j)-ibm_ht_w(i,j+1))/dy
               else
                  b = (ibm_ht_w(i,j)-ibm_ht_v(i,j+1))/(dy/2)
               endif
            else
               b = -(ibm_ht_v(i,j+1)-ibm_ht_v(i,j))/dy
            endif
        ELSEIF (stag == 'd') THEN
            d = ibm_ht_c(i,j)-GP(3)
            if ((ibm_ht_c(i-1,j) < ibm_ht_c(i,j)) .AND. (ibm_ht_c(i+1,j) < ibm_ht_c(i,j))) then ! on a ridge, figure out which way to go	    
               if (ibm_ht_c(i-1,j) == ibm_ht_c(i+1,j)) then ! the two are equal
                  if (ibm_ht_v(i-1,j) == ibm_ht_v(i,j)) then ! a=0, look closer to see if this is appropriate
                     if ((ABS(top(i,j+1)-top(i,j)) > 1) .OR. (ABS(top(i,j-1)-top(i,j)) > 1)) then ! the the side is north south and a=0 is fine
                        a = (ibm_ht_v(i-1,j)-ibm_ht_v(i,j))/dx
                     else ! this is a symetric ridge, there is a side to the left and right...fo left, this is an arbitrary choice
                        if (ibm_ht_v(i-1,j) >= ht_p(i,side(3,S)+1,j)) then 
                           a = (ibm_ht_c(i-1,j)-ibm_ht_v(i-1,j))/(dx/2)
                           d = 2*ibm_ht_v(i-1,j)-ibm_ht_c(i-1,j)-GP(3)
                        elseif (ibm_ht_v(i-1,j) > GP(3)) then
                           a = (ibm_ht_c(i-1,j)-ibm_ht_c(i,j))/dx
                        else
                           a = (ibm_ht_v(i-1,j)-ibm_ht_c(i,j))/(dx/2)
                        endif
                     endif
                  else
                     a = (ibm_ht_v(i-1,j)-ibm_ht_v(i,j))/dx
                  endif
               elseif (ibm_ht_c(i-1,j) < ibm_ht_c(i+1,j)) then ! go to the left
                  if (ibm_ht_v(i-1,j) >= ht_p(i,side(3,S)+1,j)) then 
                     a = (ibm_ht_c(i-1,j)-ibm_ht_v(i-1,j))/(dx/2)
                     d = 2*ibm_ht_v(i-1,j)-ibm_ht_c(i-1,j)-GP(3)
                  elseif (ibm_ht_v(i-1,j) > GP(3)) then
                     a = (ibm_ht_c(i-1,j)-ibm_ht_c(i,j))/dx
                  else
                     a = (ibm_ht_v(i-1,j)-ibm_ht_c(i,j))/(dx/2)
                  endif
               else ! (ibm_ht_c(i+1,j) < ibm_ht_c(i-1,j)) ! go to the right
                  if (ibm_ht_v(i,j) >= ht_p(i,side(3,S)+1,j)) then 
                     a = (ibm_ht_v(i,j)-ibm_ht_c(i+1,j))/(dx/2)
                     d = 2*ibm_ht_v(i,j)-ibm_ht_c(i+1,j)-GP(3)
                  elseif (ibm_ht_v(i,j) > GP(3)) then
                     a = (ibm_ht_c(i,j)-ibm_ht_c(i+1,j))/dx
                  else
                     a = (ibm_ht_c(i,j)-ibm_ht_v(i,j))/(dx/2)
                  endif
               endif  
            elseif (ibm_ht_c(i-1,j) < ibm_ht_c(i,j)) then !image is to the left
            !if (top(i-1,j) < top(i,j)) then !image is to the left
               ! Now, should I be calculating the x slope between c(i-1) and v(i-1),
               ! or between v(i-1) and c(i)
               if (ibm_ht_v(i-1,j) >= ht_p(i,side(3,S)+1,j)) then 
                  a = (ibm_ht_c(i-1,j)-ibm_ht_v(i-1,j))/(dx/2)
                  d = 2*ibm_ht_v(i-1,j)-ibm_ht_c(i-1,j)-GP(3)
               elseif (ibm_ht_v(i-1,j) > GP(3)) then
                  a = (ibm_ht_c(i-1,j)-ibm_ht_c(i,j))/dx
               else
                  a = (ibm_ht_v(i-1,j)-ibm_ht_c(i,j))/(dx/2)
               endif
            elseif (ibm_ht_c(i+1,j) < ibm_ht_c(i,j)) then ! image is to the right   
            !elseif (top(i+1,j) < top(i,j)) then ! image is to the right
               if (ibm_ht_v(i,j) >= ht_p(i,side(3,S)+1,j)) then 
                  a = (ibm_ht_v(i,j)-ibm_ht_c(i+1,j))/(dx/2)
                  d = 2*ibm_ht_v(i,j)-ibm_ht_c(i+1,j)-GP(3)
               elseif (ibm_ht_v(i,j) > GP(3)) then
                  a = (ibm_ht_c(i,j)-ibm_ht_c(i+1,j))/dx
               else
                  a = (ibm_ht_c(i,j)-ibm_ht_v(i,j))/(dx/2)
               endif
            else
               a = (ibm_ht_v(i-1,j)-ibm_ht_v(i,j))/dx
            endif
            if ((ibm_ht_c(i,j-1) < ibm_ht_c(i,j)) .AND. (ibm_ht_c(i,j+1) < ibm_ht_c(i,j))) then ! on a ridge
               if (ibm_ht_c(i,j-1) == ibm_ht_c(i,j+1)) then ! the two are equal
                  if (ibm_ht_u(i,j-1) == ibm_ht_u(i,j)) then ! b=0, look closer to see if this is appropriate
                     if ((ABS(top(i+1,j)-top(i,j)) > 1) .OR. (ABS(top(i-1,j)-top(i,j)) > 1)) then ! then the side is east west and b=0 is fine
                        b = (ibm_ht_u(i,j-1)-ibm_ht_u(i,j))/dy
                     else ! this is a symetric ridge, there is a side to the north and south...go south, this choice is arbitrary		  
                        if (ibm_ht_u(i,j-1) >= ht_p(i,side(3,S)+1,j)) then 
                           b = (ibm_ht_c(i,j-1)-ibm_ht_u(i,j-1))/(dy/2)
                           d = 2*ibm_ht_u(i,j-1)-ibm_ht_c(i,j-1)-GP(3)
                        elseif (ibm_ht_u(i,j-1) > GP(3)) then
                           b = (ibm_ht_c(i,j-1)-ibm_ht_c(i,j))/dy
                        else
                           b = (ibm_ht_u(i,j-1)-ibm_ht_c(i,j))/(dy/2)
                        endif
                     endif
                  else
                     b = (ibm_ht_u(i,j-1)-ibm_ht_u(i,j))/dy
                  endif       
               elseif (ibm_ht_c(i,j-1) < ibm_ht_c(i,j+1)) then !image is to the south	       
                  if (ibm_ht_u(i,j-1) >= ht_p(i,side(3,S)+1,j)) then 
                     b = (ibm_ht_c(i,j-1)-ibm_ht_u(i,j-1))/(dy/2)
                     d = 2*ibm_ht_u(i,j-1)-ibm_ht_c(i,j-1)-GP(3)
                  elseif (ibm_ht_u(i,j-1) > GP(3)) then
                     b = (ibm_ht_c(i,j-1)-ibm_ht_c(i,j))/dy
                  else
                     b = (ibm_ht_u(i,j-1)-ibm_ht_c(i,j))/(dy/2)
                  endif
               else   ! image is to the north
                  if (ibm_ht_u(i,j) >= ht_p(i,side(3,S)+1,j)) then 
                     b = (ibm_ht_u(i,j)-ibm_ht_c(i,j+1))/(dy/2)
                     d = 2*ibm_ht_u(i,j)-ibm_ht_c(i,j+1)-GP(3)
                  elseif (ibm_ht_u(i,j) > GP(3)) then
                     b = (ibm_ht_c(i,j)-ibm_ht_c(i,j+1))/dy
                  else
                     b = (ibm_ht_c(i,j)-ibm_ht_u(i,j))/(dy/2)
                  endif   
               endif
            elseif (ibm_ht_c(i,j-1) < ibm_ht_c(i,j)) then !image is to the south
            !if (top(i,j-1) < top(i,j)) then !image is to the south
               ! Now, should I be calculating the y slope between c(j-1) and u(j-1),
               ! or between u(j-1) and c(j)
               if (ibm_ht_u(i,j-1) >= ht_p(i,side(3,S)+1,j)) then 
                  b = (ibm_ht_c(i,j-1)-ibm_ht_u(i,j-1))/(dy/2)
                  d = 2*ibm_ht_u(i,j-1)-ibm_ht_c(i,j-1)-GP(3)
               elseif (ibm_ht_u(i,j-1) > GP(3)) then
                  b = (ibm_ht_c(i,j-1)-ibm_ht_c(i,j))/dy
               else
                  b = (ibm_ht_u(i,j-1)-ibm_ht_c(i,j))/(dy/2)
               endif
            elseif (ibm_ht_c(i,j+1) < ibm_ht_c(i,j)) then !image is to the north       
            !elseif (top(i,j+1) < top(i,j)) then !image is to the north
               if (ibm_ht_u(i,j) >= ht_p(i,side(3,S)+1,j)) then 
                  b = (ibm_ht_u(i,j)-ibm_ht_c(i,j+1))/(dy/2)
                  d = 2*ibm_ht_u(i,j)-ibm_ht_c(i,j+1)-GP(3)
               elseif (ibm_ht_u(i,j) > GP(3)) then
                  b = (ibm_ht_c(i,j)-ibm_ht_c(i,j+1))/dy
               else
                  b = (ibm_ht_c(i,j)-ibm_ht_u(i,j))/(dy/2)
               endif
            else
               b = (ibm_ht_u(i,j-1)-ibm_ht_u(i,j))/dy
            endif
        ENDIF

        c = 1.0
        ! normal distance from ghost point to plane that represents terrain
        mag = SQRT(a**2+b**2+c**2)
        IF (mag .EQ. 0) THEN
           CALL wrf_error_fatal("RSA[module_ibm/shear_stress_extrap_pts]: mag = 0.0, would divide by zero for side-point.")
        ENDIF
        dist = d/mag
        ! normal vector to plane
        n(1) = a/mag
        n(2) = b/mag
        n(3) = c/mag

        !(x,y,z) of boundary point
        side_bound(1:3,S) = GP+dist*n

        !normal distance to ghost point from the boundary
        side_dist(S) = -dist
        side_norm(1:3,S) = n

       !set extrapolation distance (check if first point is underneath terrain)
       IF (delta_extrap_in .LT. dist) THEN
          delta_extrap = dist + delta_fact*delta_z
          ! write(*,*) "Changing delta_extrap at S=",S
       ELSE
          delta_extrap = delta_extrap_in
       ENDIF

        !put the extrapolation points 1, 2, and 3 times delta_extrap from ghost point
        !in surface normal direction 
        side_img_1(1:3,S) = GP !location of ghost pt
        side_img_1(4:6,S) = GP + delta_extrap*n
        side_img_2(1:3,S) = GP !location of ghost pt
        side_img_2(4:6,S) = GP + 2.0*delta_extrap*n
        side_img_3(1:3,S) = GP !location of ghost pt
        side_img_3(4:6,S) = GP + 3.0*delta_extrap*n

    ENDDO
 endif ! end of finding the image of s side points

 END SUBROUTINE shear_stress_extrap_pts

!-------------------------------------------------------------------------------- 

 SUBROUTINE neighbors_fs_temp( ibm_opt,                         &
                               ibm_temp,                        &
                               ibm_nn_horz,                     &
                               ibm_nn_vert,                     &
                               dx, dy,                          &
                               ibm_ht_u, ibm_ht_v,              &
                               ibm_ht_w, ibm_ht_c,              &
                               ht, inside,                      &
                               inside_all,                      & !RSA
                               recon_pts_as_neigh,              & !RSA
                               in_vel_recon,                    & !RSA
                               side,                            &
                               top_img, side_img,               &
                               top_bound, side_bound,           &
                               top_neigh, top_neigh_i,          &
                               side_neigh, side_neigh_i,        &
                               n, np,                           &
                               antt_at_s, anst_at_s,            &
                               ids, ide, jds, jde, kds, kde,    &
                               ims, ime, jms, jme, kms, kme,    &
                               its, ite, jts, jte, kts, kte )

 IMPLICIT NONE
 !input data
 INTEGER, INTENT(IN   )                                    :: ibm_opt,     &
                                                              ibm_temp,    &
                                                              ibm_nn_horz, &
                                                              ibm_nn_vert
 REAL, INTENT(IN   )                                       :: dx, dy
 REAL, DIMENSION(ims:ime,jms:jme), INTENT(IN   )           :: ibm_ht_u,    &
                                                              ibm_ht_v,    &
                                                              ibm_ht_w,    &
                                                              ibm_ht_c
 REAL, DIMENSION(ims:ime,kms:kme,jms:jme), INTENT(IN   )   :: ht
 INTEGER, DIMENSION(ims:ime,kms:kme,jms:jme), INTENT(IN  ) :: inside         !1 if the pt is inside boundary, 0 if it is outside
 INTEGER, DIMENSION(ims:ime,kms:kme,jms:jme), INTENT(IN  ) :: inside_all     ! RSA inside includes recon pts, inside_all does not
 LOGICAL, INTENT(IN   )                                    :: recon_pts_as_neigh, in_vel_recon !RSA
 INTEGER, DIMENSION(3,np), INTENT(IN   )                   :: side           !'side boundary' ghost points							      
 REAL, DIMENSION(ims:ime,jms:jme,6), INTENT(IN   )         :: top_img        !(x,y,z) location of ghost point and image point of the 'top boundary' ghost points
 REAL, DIMENSION(6,np), INTENT(IN   )                      :: side_img       !(x,y,z) location of ghost point and image point of the 'side boundary' ghost points
 REAL, DIMENSION(ims:ime,jms:jme,3), INTENT(IN   )         :: top_bound      !(x,y,z) location of the boundary for top point
 REAL, DIMENSION(3,np), INTENT(IN   )                      :: side_bound     !(x,y,z) location of the boundary for side points
 REAL, DIMENSION(ims:ime,jms:jme,0:9*n-1), INTENT(  OUT)   :: top_neigh      !(x,y,z) location of  neighbors
 INTEGER, DIMENSION(ims:ime,jms:jme,0:9*n-1), INTENT(  OUT):: top_neigh_i    !(i,j,k) index of top neighbors
 REAL, DIMENSION(0:3*n-1,np), INTENT(  OUT)                :: side_neigh     !(x,y,z) location of neighbors
 INTEGER, DIMENSION(0:3*n-1,np), INTENT(  OUT)             :: side_neigh_i   !(i,j,k) location of neighbors
 INTEGER, INTENT(IN   )                                    :: n,           & !desired number of nearest neighbors
                                                              np             !number of side ghost points
 INTEGER, DIMENSION(ims:ime,jms:jme), INTENT(  OUT)        :: antt_at_s      !actual number of nearest neighbors for top points
 INTEGER, DIMENSION(np), INTENT(   OUT)                    :: anst_at_s      !actual number of nearest neighbors for side points
 INTEGER, INTENT(IN   )                   :: ids, ide, jds, jde, kds, kde, & !d: domain
                                             ims, ime, jms, jme, kms, kme, & !m: memory
                                             its, ite, jts, jte, kts, kte    !p: patch, t: tile

!--------------------------------------------------------------------------------
 !the executable begins here
 CALL wrf_debug(100,'dyn_em/module_ibm.F/subroutine neighbors_fs_temp')
!--------------------------------------------------------------------------------

 IF (ibm_temp .EQ. 2) THEN
    !get side points for a neumann BC (omits the boundary point)
    CALL get_top_pts_idw_3d( ibm_opt,                                &
                             3, 3, 2,                                &
                             ibm_nn_horz,                            &
                             ibm_nn_vert,                            &
                             dx, dy,                                 &
                             ht, inside,                             &
                             inside_all,                             & !RSA
                             recon_pts_as_neigh,                     & !RSA
                             in_vel_recon,                           & !RSA
                             top_img, top_bound,                     &
                             top_neigh(ims:ime,jms:jme,6*n:9*n-1),   &
                             top_neigh_i(ims:ime,jms:jme,6*n:9*n-1), &
                             n, antt_at_s,                           &
                             ids, ide, jds, jde, kds, kde,           &
                             ims, ime, jms, jme, kms, kme,           &
                             its, ite, jts, jte, kts, kte )
 ELSEIF (ibm_temp .EQ. 3) THEN
    !get side points for a dirichlet BC (includes the boundary point)
    !RSA also used for ibm_eddy = 1 because ibm_temp is set to 3 in the
    !function call
    CALL get_top_pts_idw_3d( ibm_opt,                                &
                             3, 3, 1,                                &
                             ibm_nn_horz,                            &
                             ibm_nn_vert,                            &
                             dx, dy,                                 &
                             ht, inside,                             &
                             inside_all,                             & !RSA
                             recon_pts_as_neigh,                     & !RSA
                             in_vel_recon,                           & !RSA
                             top_img, top_bound,                     &
                             top_neigh(ims:ime,jms:jme,6*n:9*n-1),   &
                             top_neigh_i(ims:ime,jms:jme,6*n:9*n-1), &
                             n, antt_at_s,                           &
                             ids, ide, jds, jde, kds, kde,           &
                             ims, ime, jms, jme, kms, kme,           &
                             its, ite, jts, jte, kts, kte )
 ENDIF

 IF (np > 0) THEN
    IF (ibm_temp .EQ. 2) THEN
       !get side points for a neumann BC (omits the boundary point)
       CALL get_side_pts_idw_3d( 3, 2,                                &
                                 ibm_nn_horz,                         &
                                 ibm_nn_vert,                         &
                                 dx, dy,                              &
                                 ht, inside,                          &
                                 inside_all,                          & !RSA
                                 recon_pts_as_neigh,                  & !RSA
                                 in_vel_recon,                        & !RSA
                                 side, side_img, side_bound,          &
                                 side_neigh,                          &
                                 side_neigh_i,                        &
                                 n, np, anst_at_s,                    &
                                 ids, ide, jds, jde, kds, kde,        &
                                 ims, ime, jms, jme, kms, kme,        &
                                 its, ite, jts, jte, kts, kte )
    ELSEIF (ibm_temp .EQ. 3) THEN
       !get side points for a dirichlet BC (includes the boundary point)
       !RSA also used for ibm_eddy = 1 because ibm_temp is set to 3 in the
       !function call
       CALL get_side_pts_idw_3d( 3, 1,                                &
                                 ibm_nn_horz,                         &
                                 ibm_nn_vert,                         &
                                 dx, dy,                              &
                                 ht, inside,                          &
                                 inside_all,                          & !RSA
                                 recon_pts_as_neigh,                  & !RSA
                                 in_vel_recon,                        & !RSA
                                 side, side_img, side_bound,          &
                                 side_neigh,                          &
                                 side_neigh_i,                        &
                                 n, np, anst_at_s,                    &
                                 ids, ide, jds, jde, kds, kde,        &
                                 ims, ime, jms, jme, kms, kme,        &
                                 its, ite, jts, jte, kts, kte )
    ENDIF
 ENDIF

 END SUBROUTINE neighbors_fs_temp

!-------------------------------------------------------------------------------- 

 SUBROUTINE neighbors_fs( ibm_opt,                                  &
                          interp_opt,                               &
                          dim_terrain, c_stag, bc_type,             &
                          ibm_nn_horz,                              &
                          ibm_nn_vert,                              &
                          dx, dy,                                   &
                          ibm_ht_u, ibm_ht_v,                       &
                          ibm_ht_w, ibm_ht_c,                       &
                          ht_u, ht_v, ht_w,                         &
                          inside_u, inside_v, inside_w,             &
                          inside_all_u, inside_all_v, inside_all_w, & !RSA
                          recon_pts_as_neigh,                       & !RSA
                          in_vel_recon,                             & !RSA
                          side,                                     &
                          top_img, side_img,                        &
                          top_bound, side_bound,                    &
                          top_neigh, top_neigh_i,                   &
                          side_neigh, side_neigh_i,                 &
                          n, np,                                    &
                          antu_at_p, antv_at_p, antw_at_p,          &
                          ansu_at_p, ansv_at_p, answ_at_p,          &
                          ids, ide, jds, jde, kds, kde,             &
                          ims, ime, jms, jme, kms, kme,             &
                          its, ite, jts, jte, kts, kte )

 IMPLICIT NONE
 !input data  
 CHARACTER, INTENT(IN   )                                  :: c_stag
 REAL, INTENT(IN   )                                       :: dx,dy
 REAL, DIMENSION(ims:ime,jms:jme), INTENT(IN   )           :: ibm_ht_u,    &
                                                              ibm_ht_v,    &
                                                              ibm_ht_w,    &
                                                              ibm_ht_c
 REAL, DIMENSION(ims:ime,kms:kme,jms:jme), INTENT(IN   )   :: ht_u,        &
                                                              ht_v,        &
                                                              ht_w
 INTEGER, DIMENSION(ims:ime,kms:kme,jms:jme), INTENT(IN  ) :: inside_u,    & !one if the pt is inside boundary, zero if it is outside
                                                              inside_v,    &
                                                              inside_w
 INTEGER, DIMENSION(ims:ime,kms:kme,jms:jme), INTENT(IN  ) :: inside_all_u,  & !RSA inside includes recon pts, inside_all does not
                                                              inside_all_v,  &
                                                              inside_all_w
 LOGICAL, INTENT(IN   )                                    :: recon_pts_as_neigh, in_vel_recon !RSA
 INTEGER, DIMENSION(3,np), INTENT(IN   )                   :: side           !'side boundary' ghost points							      
 REAL, DIMENSION(ims:ime,jms:jme,6), INTENT(IN   )         :: top_img        !(x,y,z) location of ghost point and image point of the 'top boundary' ghost points
 REAL, DIMENSION(6,np), INTENT(IN   )                      :: side_img       !(x,y,z) location of ghost point and image point of the 'side boundary' ghost points
 REAL, DIMENSION(ims:ime,jms:jme,3), INTENT(IN   )         :: top_bound      !(x,y,z) location of the boundary for top point
 REAL, DIMENSION(3,np), INTENT(IN   )                      :: side_bound     !(x,y,z) location of the boundary for side points
 REAL, DIMENSION(ims:ime,jms:jme,0:9*n-1), INTENT(  OUT)   :: top_neigh      !(x,y,z) location of  neighbors
 INTEGER, DIMENSION(ims:ime,jms:jme,0:9*n-1), INTENT(  OUT):: top_neigh_i    !(i,j,k) index of top neighbors
 REAL, DIMENSION(0:9*n-1,np), INTENT(  OUT)                :: side_neigh     !(x,y,z) location of neighbors
 INTEGER, DIMENSION(0:9*n-1,np), INTENT(  OUT)             :: side_neigh_i   !(i,j,k) location of neighbors
 INTEGER, INTENT(IN   )                                    :: ibm_opt,     &
                                                              interp_opt,  &
                                                              dim_terrain, &
                                                              bc_type,     &
                                                              ibm_nn_horz, & !controls searched extents for nearest neighbors
                                                              ibm_nn_vert, & !controls searched extents for nearest neighbors
                                                              n,           & !desired number of nearest neighbors
                                                              np             !number of side ghost points
 INTEGER, DIMENSION(ims:ime,jms:jme), INTENT(  OUT)        :: antu_at_p,   & !actual number of nearest neighbors for top points
                                                              antv_at_p,   &
                                                              antw_at_p
 INTEGER, DIMENSION(np), INTENT(   OUT)                    :: ansu_at_p,   & !actual number of nearest neighbors for side points
                                                              ansv_at_p,   &
                                                              answ_at_p
 INTEGER, INTENT(IN   )                   :: ids, ide, jds, jde, kds, kde, & !d: domain
                                             ims, ime, jms, jme, kms, kme, & !m: memory
                                             its, ite, jts, jte, kts, kte    !p: patch, t: tile

 !local data
 INTEGER                                                   :: p_stag,      & !stagger of ghost/reconstruction point
                                                              n_stag         !stagger of neighbors to be found
 
!--------------------------------------------------------------------------------
! the executable begins here
! This subroutine is used for the free slip and velocity reconstruction boundary conditions.  
! It finds the nearest neighbors to the image of the ghost point or the interpolation point for each velocity variable.
 CALL wrf_debug(100,'dyn_em/module_ibm.F/subroutine neighbors_fs')
!--------------------------------------------------------------------------------

 IF ((c_stag == 'u') .OR. (c_stag == 'e')) THEN
    p_stag = 1
 ELSEIF ((c_stag == 'v') .OR. (c_stag == 'f')) THEN
    p_stag = 2
 ELSEIF ((c_stag == 'w').OR.(c_stag == 't')) THEN
    p_stag = 3
 ELSEIF (c_stag == 'd') THEN
    p_stag = 4
 ENDIF  !stag

 IF (interp_opt == 1) THEN 
    write(0,*) 'This IBM option and interpolation option are not completed'   
    !  !!for utop_neigh store (x,y,z) of the four nearset u neighbors to the u image pt
    !  !!also store (x,y,z) of the four nearst w neighbors to the u image pt
    !  !!store the indicies of these eight points in utop_neigh_i
    !   istag = 1
    !   stag = 1
    !   CALL get_top_pts_fs( istag,stag, dx, dy, ibm_ht_u,&
    !			 ibm_ht_w,		   &
    !			 ph_u,  		   &
    !			 uinside,			   &
    !			 utop, utop_img, utop_bound,   &
    !			 utop_neigh(ims:ime,jms:jme,0:11),&
    !			 utop_neigh_i(ims:ime,jms:jme,0:11),&
    !			 n,			   &
    !			 ids, ide, jds, jde, kds, kde, &
    !			 ims, ime, jms, jme, kms, kme, &
    !			 its, ite, jts, jte, kts, kte)
    !   stag = 3
    !   CALL get_top_pts_fs( istag,stag, dx, dy, ibm_ht_w,&
    !			 ibm_ht_u,		   &
    !			 ph_w,  		   &
    !			 winside,			   &
    !			 utop, utop_img, utop_bound,   &
    !			 utop_neigh(ims:ime,jms:jme,12:23),&
    !			 utop_neigh_i(ims:ime,jms:jme,12:23),&
    !			 n,			   &
    !			 ids, ide, jds, jde, kds, kde, &
    !			 ims, ime, jms, jme, kms, kme, &
    !			 its, ite, jts, jte, kts, kte)
    !
    !    istag = 3
    !    stag = 1
    !    CALL get_top_pts_fs( istag,stag, dx, dy, ibm_ht_u, &
    !			  ibm_ht_w,			&
    !			  ph_u, 		     &
    !			  uinside,		     &
    !			  wtop, wtop_img, wtop_bound,	&
    !			  wtop_neigh(ims:ime,jms:jme,0:11),&
    !			  wtop_neigh_i(ims:ime,jms:jme,0:11),&
    !			  n,			     &
    !			  ids, ide, jds, jde, kds, kde, &
    !			  ims, ime, jms, jme, kms, kme, &
    !			  its, ite, jts, jte, kts, kte) 	     
    !    stag = 3
    !    CALL get_top_pts_fs( istag,stag, dx, dy, ibm_ht_w, &
    !			  ibm_ht_u,			&
    !			  ph_w, 		     &
    !			  winside,		     &
    !			  wtop, wtop_img, wtop_bound,	&
    !			  wtop_neigh(ims:ime,jms:jme,12:23),&
    !			  wtop_neigh_i(ims:ime,jms:jme,12:23),&
    !			  n,			     &
    !			  ids, ide, jds, jde, kds, kde, &
    !			  ims, ime, jms, jme, kms, kme, &
    !			  its, ite, jts, jte, kts, kte)
 ELSEIF ((interp_opt == 2).OR.(interp_opt == 3)) THEN
   ! the 3d routine is called to find neighbors regardless of the terrain being 2d or 3d when free slip/velocity reconstruction
   ! log-law boundary conditions are used.  This is because neighbors for all three velocity variables are needed for each individual velocity 
   ! variable.  For instance u,v,w, neighbors are needed for just u to calculate the surface tangent and surface normal velocity vectors.
   ! If just one j value is searched (as in 2d) all of the v neighbors would be to one side of the u point.  In order to have the v neighbors
   ! surrounding the u point, they have to be found in 3d.
   IF ((dim_terrain == 2).OR.(dim_terrain == 3)) THEN
      n_stag = 1
      CALL get_top_pts_idw_3d( ibm_opt,                                &
                               p_stag, n_stag, bc_type,                &
                               ibm_nn_horz,                            &
                               ibm_nn_vert,                            &
                               dx, dy,                                 &
                               ht_u,                                   &
                               inside_u,                               &
                               inside_all_u,                           & !RSA
                               recon_pts_as_neigh,                     & !RSA
                               in_vel_recon,                           & !RSA
                               top_img, top_bound,                     &
                               top_neigh(ims:ime,jms:jme,0:3*n-1),     &
                               top_neigh_i(ims:ime,jms:jme,0:3*n-1),   &
                               n, antu_at_p,                           &
                               ids, ide, jds, jde, kds, kde,           &
                               ims, ime, jms, jme, kms, kme,           &
                               its, ite, jts, jte, kts, kte )
      n_stag = 2
      CALL get_top_pts_idw_3d( ibm_opt,                                &
                               p_stag, n_stag, bc_type,                &
                               ibm_nn_horz,                            &
                               ibm_nn_vert,                            &
                               dx, dy,                                 &
                               ht_v,                                   &
                               inside_v,                               &
                               inside_all_v,                           & !RSA
                               recon_pts_as_neigh,                     & !RSA
                               in_vel_recon,                           & !RSA
                               top_img, top_bound,                     &
                               top_neigh(ims:ime,jms:jme,3*n:6*n-1),   &
                               top_neigh_i(ims:ime,jms:jme,3*n:6*n-1), &
                               n, antv_at_p,                           &
                               ids, ide, jds, jde, kds, kde,           &
                               ims, ime, jms, jme, kms, kme,           &
                               its, ite, jts, jte, kts, kte )
      n_stag = 3
      CALL get_top_pts_idw_3d( ibm_opt,                                &
                               p_stag, n_stag, bc_type,                &
                               ibm_nn_horz,                            &
                               ibm_nn_vert,                            &
                               dx, dy,                                 &
                               ht_w,                                   &
                               inside_w,                               &
                               inside_all_w,                           & !RSA
                               recon_pts_as_neigh,                     & !RSA
                               in_vel_recon,                           & !RSA
                               top_img, top_bound,                     &
                               top_neigh(ims:ime,jms:jme,6*n:9*n-1),   &
                               top_neigh_i(ims:ime,jms:jme,6*n:9*n-1), &
                               n, antw_at_p,                           &
                               ids, ide, jds, jde, kds, kde,           &
                               ims, ime, jms, jme, kms, kme,           &
                               its, ite, jts, jte, kts, kte )
      IF (np > 0) THEN
        n_stag = 1
        CALL get_side_pts_idw_3d( n_stag, bc_type,              &
                                  ibm_nn_horz,                  &
                                  ibm_nn_vert,                  &
                                  dx, dy,                       &
                                  ht_u,                         &
                                  inside_u,                     &
                                  inside_all_u,                 & !RSA
                                  recon_pts_as_neigh,           & !RSA
                                  in_vel_recon,                 & !RSA
                                  side, side_img, side_bound,   &
                                  side_neigh(0:3*n-1,1:np),     &
                                  side_neigh_i(0:3*n-1,1:np),   &
                                  n, np, ansu_at_p,             &
                                  ids, ide, jds, jde, kds, kde, &
                                  ims, ime, jms, jme, kms, kme, &
                                  its, ite, jts, jte, kts, kte )
        n_stag = 2
        CALL get_side_pts_idw_3d( n_stag, bc_type,              &
                                  ibm_nn_horz,                  &
                                  ibm_nn_vert,                  &
                                  dx, dy,                       &
                                  ht_v,                         &
                                  inside_v,                     &
                                  inside_all_v,                 & !RSA
                                  recon_pts_as_neigh,           & !RSA
                                  in_vel_recon,                 & !RSA
                                  side, side_img, side_bound,   &
                                  side_neigh(3*n:6*n-1,1:np),   &
                                  side_neigh_i(3*n:6*n-1,1:np), &
                                  n, np, ansv_at_p,             &
                                  ids, ide, jds, jde, kds, kde, &
                                  ims, ime, jms, jme, kms, kme, &
                                  its, ite, jts, jte, kts, kte )
        n_stag = 3
        CALL get_side_pts_idw_3d( n_stag, bc_type,              &
                                  ibm_nn_horz,                  &
                                  ibm_nn_vert,                  &
                                  dx, dy,                       &
                                  ht_w,                         &
                                  inside_w,                     &
                                  inside_all_w,                 & !RSA
                                  recon_pts_as_neigh,           & !RSA
                                  in_vel_recon,                 & !RSA
                                  side, side_img, side_bound,   &
                                  side_neigh(6*n:9*n-1,1:np),   &
                                  side_neigh_i(6*n:9*n-1,1:np), &
                                  n, np, answ_at_p,             &
                                  ids, ide, jds, jde, kds, kde, &
                                  ims, ime, jms, jme, kms, kme, &
                                  its, ite, jts, jte, kts, kte )
      ENDIF
   ENDIF
 ENDIF

 END SUBROUTINE neighbors_fs

!-------------------------------------------------------------------------------- 

 SUBROUTINE neighbors_ss_extrap( ibm_opt,                            &
                                 interp_opt,                         &
                                 dim_terrain, c_stag, bc_type,       &
                                 ibm_nn_horz,                        &
                                 ibm_nn_vert,                        &
                                 dx, dy,                             &
                                 ibm_ht_u, ibm_ht_v,                 &
                                 ibm_ht_w, ibm_ht_c,                 &
                                 ht_tau, inside_tau,                 &
                                 inside_all_tau,                     & !RSA
                                 recon_pts_as_neigh,                 & !RSA
                                 in_vel_recon,                       & !RSA
                                 side,                               &
                                 top_img_1, top_img_2, top_img_3,    &
                                 side_img_1, side_img_2, side_img_3, &
                                 top_bound, side_bound,              &
                                 top_neigh, top_neigh_i,             &
                                 side_neigh, side_neigh_i,           &
                                 n, np,                              &
                                 ant_1, ant_2, ant_3,                &
                                 ans_1, ans_2, ans_3,                &
                                 ids, ide, jds, jde, kds, kde,       &
                                 ims, ime, jms, jme, kms, kme,       &
                                 its, ite, jts, jte, kts, kte )

 IMPLICIT NONE
 !input data  
 CHARACTER, INTENT(IN   )                                  :: c_stag
 REAL, INTENT(IN   )                                       :: dx,dy
 REAL, DIMENSION(ims:ime,jms:jme), INTENT(IN   )           :: ibm_ht_u,    &
                                                              ibm_ht_v,    &
                                                              ibm_ht_w,    &
                                                              ibm_ht_c
 REAL, DIMENSION(ims:ime,kms:kme,jms:jme), INTENT(IN   )   :: ht_tau
 INTEGER, DIMENSION(ims:ime,kms:kme,jms:jme), INTENT(IN  ) :: inside_tau,  & !one if the pt is inside boundary, zero if it is outside
                                                              inside_all_tau !RSA inside includes recon pts, inside_all does not
 LOGICAL, INTENT(IN   )                                    :: recon_pts_as_neigh, in_vel_recon !RSA
 INTEGER, DIMENSION(3,np), INTENT(IN   )                   :: side           !'side boundary' ghost points							      
 REAL, DIMENSION(ims:ime,jms:jme,6), INTENT(IN   )         :: top_img_1,   & !(x,y,z) location of ghost point and image point of the 'top boundary' ghost points
                                                              top_img_2,   &
                                                              top_img_3
 REAL, DIMENSION(6,np), INTENT(IN   )                      :: side_img_1,  & !(x,y,z) location of ghost point and image point of the 'side boundary' ghost points
                                                              side_img_2,  &
                                                              side_img_3
 REAL, DIMENSION(ims:ime,jms:jme,3), INTENT(IN   )         :: top_bound      !(x,y,z) location of the boundary for top point
 REAL, DIMENSION(3,np), INTENT(IN   )                      :: side_bound     !(x,y,z) location of the boundary for side points
 REAL, DIMENSION(ims:ime,jms:jme,0:9*n-1), INTENT(  OUT)   :: top_neigh      !(x,y,z) location of  neighbors
 INTEGER, DIMENSION(ims:ime,jms:jme,0:9*n-1), INTENT(  OUT):: top_neigh_i    !(i,j,k) index of top neighbors
 REAL, DIMENSION(0:9*n-1,np), INTENT(  OUT)                :: side_neigh     !(x,y,z) location of neighbors
 INTEGER, DIMENSION(0:9*n-1,np), INTENT(  OUT)             :: side_neigh_i   !(i,j,k) location of neighbors
 INTEGER, INTENT(IN   )                                    :: ibm_opt,     &
                                                              interp_opt,  &
                                                              dim_terrain, &
                                                              bc_type,     &
                                                              ibm_nn_horz, & !controls searched extents for nearest neighbors
                                                              ibm_nn_vert, & !controls searched extents for nearest neighbors
                                                              n,           & !desired number of nearest neighbors
                                                              np             !number of side ghost points
 INTEGER, DIMENSION(ims:ime,jms:jme), INTENT(  OUT)        :: ant_1,       & !actual number of nearest neighbors for top points
                                                              ant_2,       &
                                                              ant_3
 INTEGER, DIMENSION(np), INTENT(   OUT)                    :: ans_1,       & !actual number of nearest neighbors for side points
                                                              ans_2,       &
                                                              ans_3
 INTEGER, INTENT(IN   )                   :: ids, ide, jds, jde, kds, kde, & !d: domain
                                             ims, ime, jms, jme, kms, kme, & !m: memory
                                             its, ite, jts, jte, kts, kte    !p: patch, t: tile

 !local data
 INTEGER                                                   :: p_stag,      & !stagger of ghost/reconstruction point
                                                              n_stag         !stagger of neighbors to be found
 
!--------------------------------------------------------------------------------
! the executable begins here
! This subroutine is used for the shear stress reconstruction boundary condition.  
! It finds the nearest neighbors to the three extrapolation points for each stress term.
! RSA modified version of neighbors_fs
 CALL wrf_debug(100,'dyn_em/module_ibm.F/subroutine neighbors_ss_extrap')
!--------------------------------------------------------------------------------

 IF ((c_stag == 'u') .OR. (c_stag == 'e')) THEN
    p_stag = 1
    n_stag = 1
 ELSEIF ((c_stag == 'v') .OR. (c_stag == 'f')) THEN
    p_stag = 2
    n_stag = 2
 ELSEIF ((c_stag == 'w').OR.(c_stag == 't')) THEN
    p_stag = 3
    n_stag = 3
 ELSEIF (c_stag == 'd') THEN
    p_stag = 4
    n_stag = 4
 ENDIF  !stag

 IF (interp_opt == 1) THEN 
    write(0,*) 'This IBM option and interpolation option are not completed'   
 ELSEIF ((interp_opt == 2).OR.(interp_opt == 3)) THEN
   IF ((dim_terrain == 2).OR.(dim_terrain == 3)) THEN
      !first extrapolation point
      CALL get_top_pts_idw_3d( ibm_opt,                                & !RSA not 100% sure on this but preliminary tests match whether ibm_opt or 51 is used
                               p_stag, n_stag, bc_type,                &
                               ibm_nn_horz,                            &
                               ibm_nn_vert,                            &
                               dx, dy,                                 &
                               ht_tau,                                 &
                               inside_tau,                             &
                               inside_all_tau,                         & !RSA
                               recon_pts_as_neigh,                     & !RSA
                               in_vel_recon,                           & !RSA
                               top_img_1, top_bound,                   &
                               top_neigh(ims:ime,jms:jme,0:3*n-1),     &
                               top_neigh_i(ims:ime,jms:jme,0:3*n-1),   &
                               n, ant_1,                               &
                               ids, ide, jds, jde, kds, kde,           &
                               ims, ime, jms, jme, kms, kme,           &
                               its, ite, jts, jte, kts, kte )
      !second extrapolation point
      CALL get_top_pts_idw_3d( ibm_opt,                                & !RSA not 100% sure on this but preliminary tests match whether ibm_opt or 51 is used
                               p_stag, n_stag, bc_type,                &
                               ibm_nn_horz,                            &
                               ibm_nn_vert,                            &
                               dx, dy,                                 &
                               ht_tau,                                 &
                               inside_tau,                             &
                               inside_all_tau,                         & !RSA
                               recon_pts_as_neigh,                     & !RSA
                               in_vel_recon,                           & !RSA
                               top_img_2, top_bound,                   &
                               top_neigh(ims:ime,jms:jme,3*n:6*n-1),   &
                               top_neigh_i(ims:ime,jms:jme,3*n:6*n-1), &
                               n, ant_2,                               &
                               ids, ide, jds, jde, kds, kde,           &
                               ims, ime, jms, jme, kms, kme,           &
                               its, ite, jts, jte, kts, kte )
      !third extrapolation point
      CALL get_top_pts_idw_3d( ibm_opt,                                & !RSA not 100% sure on this but preliminary tests match whether ibm_opt or 51 is used
                               p_stag, n_stag, bc_type,                &
                               ibm_nn_horz,                            &
                               ibm_nn_vert,                            &
                               dx, dy,                                 &
                               ht_tau,                                 &
                               inside_tau,                             &
                               inside_all_tau,                         & !RSA
                               recon_pts_as_neigh,                     & !RSA
                               in_vel_recon,                           & !RSA
                               top_img_3, top_bound,                   &
                               top_neigh(ims:ime,jms:jme,6*n:9*n-1),   &
                               top_neigh_i(ims:ime,jms:jme,6*n:9*n-1), &
                               n, ant_3,                               &
                               ids, ide, jds, jde, kds, kde,           &
                               ims, ime, jms, jme, kms, kme,           &
                               its, ite, jts, jte, kts, kte )
      IF (np > 0) THEN
        !first extrapolation point
        CALL get_side_pts_idw_3d( n_stag, bc_type,              &
                                  ibm_nn_horz,                  &
                                  ibm_nn_vert,                  &
                                  dx, dy,                       &
                                  ht_tau,                       &
                                  inside_tau,                   &
                                  inside_all_tau,               & !RSA
                                  recon_pts_as_neigh,           & !RSA
                                  in_vel_recon,                 & !RSA
                                  side, side_img_1, side_bound, &
                                  side_neigh(0:3*n-1,1:np),     &
                                  side_neigh_i(0:3*n-1,1:np),   &
                                  n, np, ans_1,                 &
                                  ids, ide, jds, jde, kds, kde, &
                                  ims, ime, jms, jme, kms, kme, &
                                  its, ite, jts, jte, kts, kte )
        !second extrapolation point
        CALL get_side_pts_idw_3d( n_stag, bc_type,              &
                                  ibm_nn_horz,                  &
                                  ibm_nn_vert,                  &
                                  dx, dy,                       &
                                  ht_tau,                       &
                                  inside_tau,                   &
                                  inside_all_tau,               & !RSA
                                  recon_pts_as_neigh,           & !RSA
                                  in_vel_recon,                 & !RSA
                                  side, side_img_2, side_bound, &
                                  side_neigh(3*n:6*n-1,1:np),   &
                                  side_neigh_i(3*n:6*n-1,1:np), &
                                  n, np, ans_2,                 &
                                  ids, ide, jds, jde, kds, kde, &
                                  ims, ime, jms, jme, kms, kme, &
                                  its, ite, jts, jte, kts, kte )
        !third extrapolation point
        CALL get_side_pts_idw_3d( n_stag, bc_type,              &
                                  ibm_nn_horz,                  &
                                  ibm_nn_vert,                  &
                                  dx, dy,                       &
                                  ht_tau,                       &
                                  inside_tau,                   &
                                  inside_all_tau,               & !RSA
                                  recon_pts_as_neigh,           & !RSA
                                  in_vel_recon,                 & !RSA
                                  side, side_img_3, side_bound, &
                                  side_neigh(6*n:9*n-1,1:np),   &
                                  side_neigh_i(6*n:9*n-1,1:np), &
                                  n, np, ans_3,                 &
                                  ids, ide, jds, jde, kds, kde, &
                                  ims, ime, jms, jme, kms, kme, &
                                  its, ite, jts, jte, kts, kte )
      ENDIF
   ENDIF
 ENDIF

 END SUBROUTINE neighbors_ss_extrap

!--------------------------------------------------------------------------------

 SUBROUTINE neighbors_ns( ibm_opt,                      &
                          ibm_scalar,                   &
                          in_scalar,                    &
                          interp_opt,                   &
                          dim_terrain, c_stag, bc_type, &
                          ibm_nn_horz,                  &
                          ibm_nn_vert,                  &
                          dx, dy, prox,                 &
                          ibm_ht_u, ibm_ht_v,           &
                          ibm_ht_w, ibm_ht_c,           &
                          ht_p, inside,                 &
                          inside_all,                   &
                          recon_pts_as_neigh,           &
                          in_vel_recon,                 &
                          top,side,top_img, side_img,   &
                          top_bound, side_bound,        &
                          top_neigh, top_neigh_i,       &
                          side_neigh, side_neigh_i,     & 
                          n, np, ant, ans,              &
                          ids, ide, jds, jde, kds, kde, &
                          ims, ime, jms, jme, kms, kme, &
                          its, ite, jts, jte, kts, kte )

 IMPLICIT NONE
 !input data  
 CHARACTER, INTENT(IN   )                                  :: c_stag
 REAL, INTENT(IN   )                                       :: dx,dy
 INTEGER, DIMENSION(ims:ime,jms:jme), INTENT(IN   )        :: prox
 REAL, DIMENSION(ims:ime,jms:jme), INTENT(IN   )           :: ibm_ht_u,    &
                                                              ibm_ht_v,    &
                                                              ibm_ht_w,    &
                                                              ibm_ht_c
 REAL, DIMENSION(ims:ime,kms:kme,jms:jme), INTENT(IN   )   :: ht_p
 INTEGER, DIMENSION(ims:ime,kms:kme,jms:jme), INTENT(IN  ) :: inside         !one if the pt is inside boundary, zero if it is outside
 INTEGER, DIMENSION(ims:ime,kms:kme,jms:jme), INTENT(IN  ) :: inside_all     ! RSA inside includes recon pts, inside_all does not
 LOGICAL, INTENT(IN   )                                    :: recon_pts_as_neigh, & !RSA for using recon pts as neighbors
                                                              in_vel_recon,       & !RSA for using recon pts as neighbors, are we in a velocity reconstruction routine?
                                                              in_scalar             !RSA for using VRM with ghost pt temp/scalar BC, are we in a temp or scalar routine?
 INTEGER, DIMENSION(ims:ime,jms:jme), INTENT(IN   )        :: top            !'top boundary' ghost points
 INTEGER, DIMENSION(3,np), INTENT(IN   )                   :: side           !'side boundary' ghost points							      
 REAL, DIMENSION(ims:ime,jms:jme,6), INTENT(IN   )         :: top_img        !(x,y,z) location of ghost point and image point of the 'top boundary' ghost points
 REAL, DIMENSION(6,np), INTENT(IN   )                      :: side_img       !(x,y,z) location of ghost point and image point of the 'side boundary' ghost points
 REAL, DIMENSION(ims:ime,jms:jme,3), INTENT(IN   )         :: top_bound      !(x,y,z) location of the boundary for top point
 REAL, DIMENSION(3,np), INTENT(IN   )                      :: side_bound     !(x,y,z) location of the boundary for side points
 REAL, DIMENSION(ims:ime,jms:jme,0:3*n-1), INTENT(  OUT)   :: top_neigh      !(x,y,z) location of  neighbors
 INTEGER, DIMENSION(ims:ime,jms:jme,0:3*n-1), INTENT(  OUT):: top_neigh_i    !(i,j,k) index of top neighbors
 REAL, DIMENSION(0:3*n-1,np), INTENT(  OUT)                :: side_neigh     !(x,y,z) location of neighbors
 INTEGER, DIMENSION(0:3*n-1,np), INTENT(  OUT)             :: side_neigh_i   !(i,j,k) location of neighbors
 INTEGER, INTENT(IN   )                                    :: ibm_opt,     &
                                                              ibm_scalar,  & !RSA for using VRM with ghost pt temp/scalar BC
                                                              interp_opt,  &
                                                              dim_terrain, &
                                                              bc_type,     &
                                                              ibm_nn_horz, &
                                                              ibm_nn_vert, &
                                                              n,           & !desired number of nearest neighbors
                                                              np             !number of side ghost points
 INTEGER, DIMENSION(ims:ime,jms:jme), INTENT(  OUT)        :: ant            !actual number of nearest neighbors for top points							      
 INTEGER, DIMENSION(np), INTENT(   OUT)                    :: ans            !actual number of nearest neighbors for side points
 INTEGER, INTENT(IN   )                   :: ids, ide, jds, jde, kds, kde, & !d: domain
                                             ims, ime, jms, jme, kms, kme, & !m: memory
                                             its, ite, jts, jte, kts, kte    !p: patch, t: tile

!local data
 INTEGER                                                   :: p_stag,      & !stagger of the ghost/reconstruction point
                                                              n_stag,      & !stagger of the neighbors to be found
                                                              ibm_opt_mod    !RSA for using VRM with ghost pt temperature BC 

!--------------------------------------------------------------------------------
! the executable begins here
! This subroutine is used for the no slip boundary condition.  It finds the 
! four nearest neighbors to the image of the ghost point.  The location of the 
! image point was determined in the subroutine image_ghost_pts_ibm.
 CALL wrf_debug(100,'dyn_em/module_ibm.F/subroutine neighbors_ns')
!--------------------------------------------------------------------------------
 top_neigh = 0.0
 
 IF (c_stag == 'u') THEN
    p_stag = 1
    n_stag = 1
 ELSEIF (c_stag == 'v') THEN
    p_stag = 2
    n_stag = 2
 ELSEIF ((c_stag == 'w').OR.(c_stag == 't')) THEN
    p_stag = 3
    n_stag = 3
 ENDIF !stag 

 IF (interp_opt == 1) THEN 
    IF (dim_terrain == 2) THEN
       IF (c_stag == 'u') THEN
          CALL get_top_pts_2d( p_stag, bc_type,              &
                               dx, dy, prox,                 &
                               ibm_ht_u, ibm_ht_w,           &
                               ht_p,                         &
                               inside,                       &
                               top, top_img, top_bound,      &
                               top_neigh, top_neigh_i,       &
                               n,                            &
                               ids, ide, jds, jde, kds, kde, &
                               ims, ime, jms, jme, kms, kme, &
                               its, ite, jts, jte, kts, kte )
          IF (np > 0) THEN
             CALL get_side_pts_2d( p_stag, bc_type,              &
                                   dx, dy,                       &
                                   ibm_ht_u, ibm_ht_w,           &
                                   ht_p,                         &
                                   inside,                       &
                                   side, side_img, side_bound,   &
                                   side_neigh, side_neigh_i,     &
                                   n, np,                        &
                                   ids, ide, jds, jde, kds, kde, &
                                   ims, ime, jms, jme, kms, kme, &
                                   its, ite, jts, jte, kts, kte )
          ENDIF 
       ELSEIF (c_stag == 'v') THEN
          CALL get_top_pts_2d( p_stag, bc_type,              &
                               dx, dy, prox,                 &
                               ibm_ht_v, ibm_ht_c,           &
                               ht_p,                         &
                               inside,                       &
                               top, top_img, top_bound,      &
                               top_neigh, top_neigh_i,       &
                               n,                            &
                               ids, ide, jds, jde, kds, kde, &
                               ims, ime, jms, jme, kms, kme, &
                               its, ite, jts, jte, kts, kte )
          IF (np > 0) THEN
             CALL get_side_pts_2d( p_stag, bc_type,              &
                                   dx, dy,                       &
                                   ibm_ht_v, ibm_ht_c,           &
                                   ht_p,                         &
                                   inside,                       &
                                   side, side_img, side_bound,   &
                                   side_neigh, side_neigh_i,     &
                                   n, np,                        &
                                   ids, ide, jds, jde, kds, kde, &
                                   ims, ime, jms, jme, kms, kme, &
                                   its, ite, jts, jte, kts, kte )
          ENDIF
       ELSEIF ((c_stag == 'w') .OR. (c_stag == 't')) THEN
          CALL get_top_pts_2d( p_stag, bc_type,                 &
                               dx, dy, prox,                    &
                               ibm_ht_w, ibm_ht_u,              &
                               ht_p,                            &
                               inside,                          &
                               top, top_img, top_bound,         &
                               top_neigh, top_neigh_i,          &
                               n,                               &
                               ids, ide, jds, jde, kds, kde,    &
                               ims, ime, jms, jme, kms, kme,    &
                               its, ite, jts, jte, kts, kte )
          IF (np > 0) THEN
             CALL get_side_pts_2d ( p_stag, bc_type,              &
                                    dx, dy,                       &
                                    ibm_ht_w, ibm_ht_u,           &
                                    ht_p,                         &
                                    inside,                       &
                                    side, side_img, side_bound,   &
                                    side_neigh, side_neigh_i,     &
                                    n, np,                        &
                                    ids, ide, jds, jde, kds, kde, &
                                    ims, ime, jms, jme, kms, kme, &
                                    its, ite, jts, jte, kts, kte )
          ENDIF
       ENDIF   
    ELSEIF (dim_terrain == 3) THEN 
       IF (c_stag == 'u') THEN
          CALL get_top_pts_3d( p_stag, bc_type,              &
                               dx, dy, prox,                 &
                               ibm_ht_u, ibm_ht_w, ibm_ht_c, &
                               ht_p,                         &
                               inside,                       &
                               top, top_img, top_bound,      &
                               top_neigh, top_neigh_i,       &
                               n,                            &
                               ids, ide, jds, jde, kds, kde, &
                               ims, ime, jms, jme, kms, kme, &
                               its, ite, jts, jte, kts, kte )
          IF (np > 0) THEN
             CALL get_side_pts_3d( p_stag, bc_type,              &
                                   dx, dy,                       &
                                   ibm_ht_u, ibm_ht_w, ibm_ht_c, &
                                   ht_p,                         &
                                   inside,                       &
                                   side, side_img, side_bound,   &
                                   side_neigh, side_neigh_i,     &
                                   n, np,                        &
                                   ids, ide, jds, jde, kds, kde, &
                                   ims, ime, jms, jme, kms, kme, &
                                   its, ite, jts, jte, kts, kte )
          ENDIF
       ELSEIF (c_stag == 'v') THEN
          CALL get_top_pts_3d( p_stag, bc_type,              &
                               dx, dy, prox,                 &
                               ibm_ht_v, ibm_ht_c, ibm_ht_w, &
                               ht_p,                         &
                               inside,                       &
                               top, top_img, top_bound,      &
                               top_neigh, top_neigh_i,       &
                               n,                            &
                               ids, ide, jds, jde, kds, kde, &
                               ims, ime, jms, jme, kms, kme, &
                               its, ite, jts, jte, kts, kte )
          IF (np > 0) THEN
             CALL get_side_pts_3d( p_stag, bc_type,              &
                                   dx, dy,                       &
                                   ibm_ht_v, ibm_ht_c,ibm_ht_w,  &
                                   ht_p,                         &
                                   inside,                       &
                                   side, side_img, side_bound,   &
                                   side_neigh, side_neigh_i,     &
                                   n, np,                        &
                                   ids, ide, jds, jde, kds, kde, &
                                   ims, ime, jms, jme, kms, kme, &
                                   its, ite, jts, jte, kts, kte )
          ENDIF
       ELSEIF ((c_stag == 'w') .OR. (c_stag == 't')) THEN
          CALL get_top_pts_3d( p_stag, bc_type,              &
                               dx, dy, prox,                 &
                               ibm_ht_w, ibm_ht_u, ibm_ht_v, &
                               ht_p,                         &
                               inside,                       &
                               top, top_img, top_bound,      &
                               top_neigh, top_neigh_i,       &
                               n,                            &
                               ids, ide, jds, jde, kds, kde, &
                               ims, ime, jms, jme, kms, kme, &
                               its, ite, jts, jte, kts, kte )
          IF (np > 0) THEN
             CALL get_side_pts_3d( p_stag, bc_type,              &
                                   dx, dy,                       &
                                   ibm_ht_w, ibm_ht_u, ibm_ht_v, &
                                   ht_p,                         &
                                   inside,                       &
                                   side, side_img, side_bound,   &
                                   side_neigh, side_neigh_i,     &
                                   n, np,                        &
                                   ids, ide, jds, jde, kds, kde, &
                                   ims, ime, jms, jme, kms, kme, &
                                   its, ite, jts, jte, kts, kte )
          ENDIF !side points
       ENDIF !stag       
    ENDIF !dim terrain
 ELSEIF ((interp_opt == 2) .OR. (interp_opt == 3)) THEN
    IF (dim_terrain == 2) THEN 
       CALL get_top_pts_idw_2d( p_stag, bc_type,              &
                                dx, dy,                       &
                                ht_p,                         &
                                inside,                       &
                                top_img, top_bound,           &
                                top_neigh, top_neigh_i,       &
                                n, ant,                       &
                                ids, ide, jds, jde, kds, kde, &
                                ims, ime, jms, jme, kms, kme, &
                                its, ite, jts, jte, kts, kte )
       IF (np > 0) THEN
          CALL get_side_pts_idw_2d( p_stag, bc_type,              &
                                    dx, dy,                       &
                                    ht_p,                         &
                                    inside,                       &
                                    side, side_img, side_bound,   &
                                    side_neigh, side_neigh_i,     &
                                    n, np, ans,                   &
                                    ids, ide, jds, jde, kds, kde, &
                                    ims, ime, jms, jme, kms, kme, &
                                    its, ite, jts, jte, kts, kte )
       ENDIF
    ELSEIF (dim_terrain == 3) THEN
       !RSA for using VRM with ghost pt temp/scalar BC
       IF ( in_scalar .AND. ibm_opt .EQ. 3 .AND. ibm_scalar .EQ. 1) THEN
          ibm_opt_mod = 2
       ELSE
          ibm_opt_mod = ibm_opt
       ENDIF
       !RSA end
       CALL get_top_pts_idw_3d( ibm_opt_mod,                  & !RSA changed from ibm_opt to ibm_opt_mod
                                p_stag, n_stag, bc_type,      &
                                ibm_nn_horz,                  &
                                ibm_nn_vert,                  &
                                dx, dy,                       &
                                ht_p,                         &
                                inside,                       &
                                inside_all,                   & !RSA for using recon pts as neighbors
                                recon_pts_as_neigh,           & !RSA for using recon pts as neighbors
                                in_vel_recon,                 & !RSA for using recon pts as neighbors
                                top_img, top_bound,           &
                                top_neigh, top_neigh_i,       &
                                n, ant,                       &
                                ids, ide, jds, jde, kds, kde, &
                                ims, ime, jms, jme, kms, kme, &
                                its, ite, jts, jte, kts, kte )
       IF (np > 0) THEN
          CALL get_side_pts_idw_3d( p_stag, bc_type,              &
                                    ibm_nn_horz,                  &
                                    ibm_nn_vert,                  &
                                    dx, dy,                       &
                                    ht_p,                         &
                                    inside,                       &
                                    inside_all,                   & !RSA for using recon pts as neighbors
                                    recon_pts_as_neigh,           & !RSA for using recon pts as neighbors
                                    in_vel_recon,                 & !RSA for using recon pts as neighbors
                                    side, side_img, side_bound,   &
                                    side_neigh, side_neigh_i,     &
                                    n, np, ans,                   &
                                    ids, ide, jds, jde, kds, kde, &
                                    ims, ime, jms, jme, kms, kme, &
                                    its, ite, jts, jte, kts, kte )
       ENDIF
    ENDIF
 ENDIF 
    
 END SUBROUTINE neighbors_ns

!--------------------------------------------------------------------------------

 SUBROUTINE write_ibm_data( var, side,                       &
                            top_img, side_img,               &
                            top_bound, side_bound,           &
                            top_neigh, side_neigh,           &
                            n, ns,                           &
                            ids, ide, jds, jde, kds, kde,    &
                            ims, ime, jms, jme, kms, kme,    &
                            its, ite, jts, jte, kts, kte,    &
                            antu_at_p, antv_at_p, antw_at_p, &
                            ansu_at_p, ansv_at_p, answ_at_p )

 IMPLICIT NONE
 !input data
 CHARACTER, INTENT(IN   )                                  :: var
 INTEGER, DIMENSION(3,ns), INTENT(IN   )                   :: side           !index of side ghost point
 REAL, DIMENSION(ims:ime,jms:jme,6), INTENT(IN   )         :: top_img        !(x,y,z) location of ghost point and image point of the 'top boundary' ghost points
 REAL, DIMENSION(6,ns), INTENT(IN   )                      :: side_img       !(x,y,z) location of ghost point and image point of the 'side boundary' ghost points
 REAL, DIMENSION(ims:ime,jms:jme,3), INTENT(IN   )         :: top_bound      !(x,y,z) location of the boundary for top point
 REAL, DIMENSION(3,ns), INTENT(IN   )                      :: side_bound     !(x,y,z) location of the boundary for side pointsd
 !REAL, DIMENSION(ims:ime,jms:jme,0:3*n-1), INTENT(IN   )   :: top_neigh      !(x,y,z) location of  neighbors
 REAL, DIMENSION(0:3*n-1,ns), INTENT(IN   )                :: side_neigh     !(x,y,z) location of neighbors
 !use assumed shape arrays (no slip options require neighbors for just that
 !velocity component (3*n), but free slip or wall models require neighbors for all the the velocity values (9*n))
 REAL, DIMENSION(ims:,jms:,0:), INTENT(IN   )              :: top_neigh      !(x,y,z) location of  neighbors
! REAL, DIMENSION(0:,1:), INTENT(IN   )                     :: side_neigh     !(x,y,z) location of neighbors
 INTEGER, INTENT(IN   )                                    :: n,           & !number of nearest neighbors
                                                              ns             !number of 'side boundary' ghost points
 INTEGER, INTENT(IN   )               :: ids, ide, jds, jde, kds, kde,     & !d: domain
                                         ims, ime, jms, jme, kms, kme,     & !m: memory
                                         its, ite, jts, jte, kts, kte        !p: patch, t: tile
 INTEGER, DIMENSION(ims:ime,jms:jme), OPTIONAL, INTENT(IN   ) :: antu_at_p,   & !actual number of nearest neighbors for top points
                                                              antv_at_p,   &
                                                              antw_at_p
 INTEGER, DIMENSION(ns), OPTIONAL, INTENT(IN   )           :: ansu_at_p,   & !actual number of nearest neighbors for side points
                                                              ansv_at_p,   &
                                                              answ_at_p
 !local data
 INTEGER                                                   :: i,j,myproc,  &
                                                              i_end,       &
                                                              j_end
 CHARACTER(len=4)                                          :: c_myproc
 CHARACTER(len=132)                                        :: fname

!--------------------------------------------------------------------------------
   !the executable begins here
   CALL wrf_debug(100,'dyn_em/module_ibm.F/subroutine write_ibm_data ')
!--------------------------------------------------------------------------------

   IF (var == 'u') THEN
      i_end = ite
      j_end = MIN(jte,jde-1)
   ELSEIF (var == 'v') THEN
      i_end = MIN(ite,ide-1)
      j_end = jte
   ELSEIF (var == 'w') THEN
      i_end = MIN(ite,ide-1)
      j_end = MIN(jte,jde-1)
   ELSEIF (var == 't') THEN
      i_end = MIN(ite,ide-1)
      j_end = MIN(jte,jde-1)
   ENDIF
   
   !get the processor for the file name
   CALL wrf_get_myproc(myproc)
   write(c_myproc,'(i4.4)') myproc
   !writing the ghost point and image point locations to a file for matlab plotting
   write(fname,'(A)') 'image'//c_myproc//'.dat'
   !s variable (pot temp) is called twice from start_em.  The variable only appears once
   !in the files because it is not set to append 
   IF (var .EQ. 't') THEN
      open(12,file=fname)
   ELSEIF (var .EQ. 'u')  THEN
      open(12,file=fname)
   ELSE
      open(12,file=fname,status='old',position='append')
   ENDIF
   write(12,'(A,A)') "var=",var
   write(12,'(A,I4,A,I4,A,I4,A,I4)') "its=",its," ite=",i_end," jts=",jts," jte=",j_end
   write(12,'(A,A)') "TOP_IMG ",var
   DO i=its,i_end
   DO j=jts,j_end
      write(12,'(6f20.8)') top_img(i,j,1:6)
   ENDDO
   ENDDO
   write(12,'(A,A)') "TOP_BOUND ",var
   DO i=its,i_end
   DO j=jts,j_end
      write(12,'(3f20.8)') top_bound(i,j,1:3)
   ENDDO
   ENDDO
   IF (var .EQ. 's') THEN
      write(12,'(A,I6)') "nss=",ns
   ELSEIF (var .EQ. 'u') THEN
      write(12,'(A,I6)') "nsu=",ns
   ELSEIF (var .EQ. 'v') THEN
      write(12,'(A,I6)') "nsv=",ns
   ELSEIF (var .EQ. 'w') THEN
      write(12,'(A,I6)') "nsw=",ns
   ENDIF
   IF (ns .GT. 0) THEN
      !this is needed for image point plotting for 3d cases
      !printing out the index allows matlab script to pick out a portion of the terrain/grid to plot
      write(12,'(A,A)') "SIDE ",var
      write(12,'(3i20)') side
      write(12,'(A,A)') "SIDE_IMG ",var
      write(12,'(6f20.8)') side_img
      write(12,'(A,A)') "SIDE_BOUND ",var
      write(12,'(3f20.8)') side_bound
   ENDIF
   close(12)

   !writing the indicies of the neighbors of the ghost point to a file for matlab plotting
   write(fname,'(A)') 'neighbors'//c_myproc//'.dat'
   IF (var .EQ. 't') THEN
      open(12,file=fname)
   ELSEIF (var .EQ. 'u')  THEN
      open(12,file=fname)
   ELSE
      open(12,file=fname,status='old',position='append')
   ENDIF
   write(12,'(A,A)') "var=",var
   write(12,'(A,I4,A,I4,A,I4,A,I4)') "its=",its," ite=",i_end," jts=",jts," jte=",j_end
   write(12,'(A,I6)') "n=",n
   write(12,'(A,A)') "TOP_NEIGH ",var
   DO i=its,i_end
   DO j=jts,j_end
      write(12,'(96f25.8)') top_neigh(i,j,:)
   ENDDO
   ENDDO
   IF (PRESENT(antu_at_p)) THEN
      IF (var .EQ. "u") THEN
         write(12,'(A)') "ANTU_AT_U"
      ELSEIF (var .EQ. "v") THEN
         write(12,'(A)') "ANTU_AT_V"
      ELSEIF (var .EQ. "w") THEN
         write(12,'(A)') "ANTU_AT_W"
      ENDIF
      DO j=jts,j_end
         DO i=its,i_end-1
            write(12,'(I3)',ADVANCE='NO') antu_at_p(i,j)
         ENDDO
         write(12,'(I3)') antu_at_p(i_end,j)
      ENDDO
   ENDIF
   IF (PRESENT(antv_at_p)) THEN
      IF (var .EQ. "u") THEN
         write(12,'(A)') "ANTV_AT_U"
      ELSEIF (var .EQ. "v") THEN
         write(12,'(A)') "ANTV_AT_V"
      ELSEIF (var .EQ. "w") THEN
         write(12,'(A)') "ANTV_AT_W"
      ENDIF
      DO j=jts,j_end
         DO i=its,i_end-1
            write(12,'(I3)',ADVANCE='NO') antv_at_p(i,j)
         ENDDO
         write(12,'(I3)') antv_at_p(i_end,j)
      ENDDO
   ENDIF
   IF (PRESENT(antw_at_p)) THEN
      IF (var .EQ. "u") THEN
         write(12,'(A)') "ANTW_AT_U"
      ELSEIF (var .EQ. "v") THEN
         write(12,'(A)') "ANTW_AT_V"
      ELSEIF (var .EQ. "w") THEN
         write(12,'(A)') "ANTW_AT_W"
      ENDIF
      DO j=jts,j_end
         DO i=its,i_end-1
            write(12,'(I3)',ADVANCE='NO') antw_at_p(i_end,j)
         ENDDO
         write(12,'(I3)') antw_at_p(i_end,j)
      ENDDO
   ENDIF
   write(12,'(A,I6)') "ns=",ns
   IF (ns .GT. 0) THEN
!      write(*,'(A,A)') "SIDE_NEIGH ",var
      write(12,'(A,A)') "SIDE_NEIGH ",var
      DO i=1,ns
         DO j=0,n-1
!            write(*,'(3f25.8)') side_neigh(3*j:3*j+2,i)
            write(12,'(3f25.8)') side_neigh(3*j:3*j+2,i)
         ENDDO
      ENDDO
      IF (PRESENT(ansu_at_p)) THEN
         IF (var .EQ. "u") THEN
            write(12,'(A)') "ANSU_AT_U"
         ELSEIF (var .EQ. "v") THEN
            write(12,'(A)') "ANSU_AT_V"
         ELSEIF (var .EQ. "w") THEN
            write(12,'(A)') "ANSU_AT_W"
         ENDIF
         write(12,'(i20)') ansu_at_p
      ENDIF
      IF (PRESENT(ansv_at_p)) THEN
         IF (var .EQ. "u") THEN
            write(12,'(A)') "ANSV_AT_U"
         ELSEIF (var .EQ. "v") THEN
            write(12,'(A)') "ANSV_AT_V"
         ELSEIF (var .EQ. "w") THEN
            write(12,'(A)') "ANSV_AT_W"
         ENDIF
         write(12,'(i20)') ansv_at_p
      ENDIF
      IF (PRESENT(answ_at_p)) THEN
         IF (var .EQ. "u") THEN
            write(12,'(A)') "ANSW_AT_U"
         ELSEIF (var .EQ. "v") THEN
            write(12,'(A)') "ANSW_AT_V"
         ELSEIF (var .EQ. "w") THEN
            write(12,'(A)') "ANSW_AT_W"
         ENDIF
         write(12,'(i20)') answ_at_p
      ENDIF
   ENDIF
   close(12)
    
 END SUBROUTINE write_ibm_data 

!--------------------------------------------------------------------------------

 SUBROUTINE write_ht_data( var, ht_p,                    &
                           ids, ide, jds, jde, kds, kde, &
                           ims, ime, jms, jme, kms, kme, &
                           its, ite, jts, jte, kts, kte )

 IMPLICIT NONE
 !input data
 CHARACTER, INTENT(IN   )                                        :: var
 REAL, DIMENSION(ims:ime,kms:kme,jms:jme), INTENT(IN   )         :: ht_p
 INTEGER, INTENT(IN   )                                          :: ids, ide, jds, jde, kds, kde, & !d: domain
                                                                    ims, ime, jms, jme, kms, kme, & !m: memory
                                                                    its, ite, jts, jte, kts, kte    !p: patch, t: tile
 !local data
 INTEGER                                                         :: i, j, k, myproc
 CHARACTER(len=4)                                                :: c_myproc
 CHARACTER(len=132)                                              :: fname

!--------------------------------------------------------------------------------
 !the executable begins here
 CALL wrf_debug(100,'dyn_em/module_ibm.F/subroutine write_ht_data ')
 write(*,*) 'dyn_em/module_ibm.F/subroutine write_ht_data'
!--------------------------------------------------------------------------------
 
! IF (var == 'u') THEN
!    i_end = ite
!    j_end = MIN(jte,jde-1)
! ELSEIF (var == 'v') THEN
!    i_end = MIN(ite,ide-1)
!    j_end = jte
! ELSEIF (var == 'w') THEN
!    i_end = MIN(ite,ide-1)
!    j_end = MIN(jte,jde-1)
! ELSEIF (var == 't') THEN
!    i_end = MIN(ite,ide-1)
!    j_end = MIN(jte,jde-1)
! ENDIF

! get the processor for the file name
   CALL wrf_get_myproc(myproc)
   write(c_myproc,'(i4.4)') myproc
! writing the ghost point and image point locations to a file for matlab plotting
   write(fname,'(A)') 'grid_height'//c_myproc//'.dat'
   ! s variable (pot temp) is called twice from start_em.  The variable only appears once
   ! in the files because it is not set to append 
   if (var == 't') then
      open(12,file=fname)
   else
      open(12,file=fname,status='old',position='append')
   endif
   write(12,*) var
   write(12,*) its,ite,kts,kte,jts,jte
   DO i=its,ite
   DO j=jts,jte
   DO k=kts,kte
      write(12,'(f20.8)') ht_p(i,k,j)
   ENDDO
   ENDDO
   ENDDO
   close(12)

 END SUBROUTINE write_ht_data 

!--------------------------------------------------------------------------------

 SUBROUTINE neighbors_check( stag_in, allgood, np,            &
                             antu_at_p, antv_at_p, antw_at_p, &
                             ansu_at_p, ansv_at_p, answ_at_p, &
                             top_img, side_img,               &
                             top_bound, side_bound,           &
                             ibm_ht_u, ibm_ht_v,              &
                             ibm_ht_w, ibm_ht_c,              &
                             ids, ide, jds, jde, kds, kde,    &
                             ims, ime, jms, jme, kms, kme,    &
                             its, ite, jts, jte, kts, kte )
 IMPLICIT NONE
 !input data
 CHARACTER, INTENT(IN   )                           :: stag_in
 LOGICAL, INTENT(INOUT)                             :: allgood
 INTEGER, INTENT(IN   )                             :: np
 INTEGER, DIMENSION(ims:ime,jms:jme), INTENT(IN   ) :: antu_at_p, &
                                                       antv_at_p, &
                                                       antw_at_p
 INTEGER, DIMENSION(np), INTENT(IN   )              :: ansu_at_p, &
                                                       ansv_at_p, &
                                                       answ_at_p
 REAL, DIMENSION(ims:ime,jms:jme,6), INTENT(IN   )  :: top_img      !(x,y,z) location of ghost point
 REAL, DIMENSION(ims:ime,jms:jme,3), INTENT(IN   )  :: top_bound
 REAL, DIMENSION(6,np), INTENT(IN   )               :: side_img
 REAL, DIMENSION(3,np), INTENT(IN   )               :: side_bound
 REAL, DIMENSION(ims:ime,jms:jme), INTENT(IN   )    :: ibm_ht_u,  &
                                                       ibm_ht_v,  &
                                                       ibm_ht_w,  &
                                                       ibm_ht_c
 INTEGER, INTENT(IN   )          :: ids, ide, jds, jde, kds, kde, & !d: domain
                                    ims, ime, jms, jme, kms, kme, & !m: memory
                                    its, ite, jts, jte, kts, kte    !p: patch, t: tile
 !local data
 INTEGER                                            :: i, j, S,   &
                                                       ii, jj,    &
                                                       i_end,     &
                                                       j_end
 CHARACTER                                          :: stag
 CHARACTER(len=265)                                 :: debug_message

!--------------------------------------------------------------------------------
    !the executable begins here
    CALL wrf_debug(100, 'dyn_em/module_ibm.F/subroutine neighbors_check')
!--------------------------------------------------------------------------------

    !for asthetic purposes, capitalize the staggering if it already isn't.
    IF ((ICHAR(stag_in) .GE. ICHAR("a")) .AND. (ICHAR(stag_in) .LE. ICHAR("z"))) THEN
       stag = CHAR(ICHAR(stag_in)+ICHAR("A")-ICHAR("a"))
    ENDIF

    IF (stag .EQ. 'U') THEN
       i_end = ite
       j_end = MIN(jte,jde-1)
    ELSEIF (stag .EQ. 'V') THEN
       i_end = MIN(ite,ide-1)
       j_end = jte
    ELSEIF ((stag .EQ. 'W') .OR. (stag .EQ. 'T')) THEN
       i_end = MIN(ite,ide-1)
       j_end = MIN(jte,jde-1)
    ELSE
       write(debug_message,'(3A)') "--- ERROR: unrecognized staggering (",stag,") in subroutine neighbors_check"
       CALL wrf_error_fatal(TRIM(debug_message))
    ENDIF

    DO i=its,i_end
    DO j=jts,j_end
       IF (antu_at_p(i,j) .LE. 1) THEN
          write(debug_message,'(3A,2(I4,A),I1,A)') "--- ERROR: ",stag,"-top-point at (i, j) = ",i,", ",j," has ",antu_at_p(i,j)," neighboring U-points"
          CALL wrf_message(TRIM(debug_message))
          write(*,'(3(A,F8.2),A)') "reconstruction point at (",top_img(i,j,1),", ",top_img(i,j,2),", ",top_img(i,j,3),")"
          write(*,'(3(A,F8.2),A)') "interpolation point at  (",top_img(i,j,4),", ",top_img(i,j,5),", ",top_img(i,j,6),")"
          write(*,'(3(A,F8.2),A)') "boundary point at       (",top_bound(i,j,1),", ",top_bound(i,j,2),", ",top_bound(i,j,3),")"
          IF (allgood .EQ. .TRUE.) allgood = .FALSE.

          write(*,'(A)',ADVANCE='NO') "      "
          DO ii=MAX(its,i-2),MIN(i_end,i+2)-1
             write(*,'(2(I4,A))',ADVANCE='NO') ii," ",ii," "
          ENDDO
          write(*,'(I4,A,I4)') ii+1," ",ii+1
          write(*,'(A)',ADVANCE='NO') "      "
          DO ii=MAX(its,i-2),MIN(i_end,i+2)-1
             write(*,'(4A)',ADVANCE='NO') "   U"," ","   W"," "
          ENDDO
          write(*,'(3A)') "   U"," ","   W"
          DO jj=MAX(jts,j-2),MIN(j_end,j+2)
             write(*,'(I3,A)',ADVANCE='NO') jj," V "
             DO ii=MAX(its,i-2),MIN(i_end,i+2)-1
                write(*,'(2(F4.0,A))',ADVANCE='NO') ibm_ht_c(ii,jj)," ",ibm_ht_v(ii,jj)," "
             ENDDO
             write(*,'(F4.0,A,F4.0)') ibm_ht_c(ii+1,jj)," ",ibm_ht_v(ii+1,jj)
             write(*,'(I3,A)',ADVANCE='NO') jj," W "
             DO ii=MAX(its,i-2),MIN(i_end,i+2)-1
                write(*,'(2(F4.0,A))',ADVANCE='NO') ibm_ht_u(ii,jj)," ",ibm_ht_w(ii,jj)," "
             ENDDO
             write(*,'(F4.0,A,F4.0)') ibm_ht_u(ii+1,jj)," ",ibm_ht_w(ii+1,jj)
          ENDDO

       ENDIF
       IF (antv_at_p(i,j) .LE. 1) THEN
          write(debug_message,'(3A,2(I4,A),I1,A)') "--- ERROR: ",stag,"-top-point at (i, j) = ",i,", ",j," has ",antv_at_p(i,j)," neighboring V-points"
          CALL wrf_message(TRIM(debug_message))
          write(*,'(3(A,F8.2),A)') "reconstruction point at (",top_img(i,j,1),", ",top_img(i,j,2),", ",top_img(i,j,3),")"
          write(*,'(3(A,F8.2),A)') "interpolation point at  (",top_img(i,j,4),", ",top_img(i,j,5),", ",top_img(i,j,6),")"
          write(*,'(3(A,F8.2),A)') "boundary point at       (",top_bound(i,j,1),", ",top_bound(i,j,2),", ",top_bound(i,j,3),")"
          IF (allgood .EQ. .TRUE.) allgood = .FALSE.

          write(*,'(A)',ADVANCE='NO') "      "
          DO ii=MAX(its,i-2),MIN(i_end,i+2)-1
             write(*,'(2(I4,A))',ADVANCE='NO') ii," ",ii," "
          ENDDO
          write(*,'(I4,A,I4)') ii+1," ",ii+1
          write(*,'(A)',ADVANCE='NO') "      "
          DO ii=MAX(its,i-2),MIN(i_end,i+2)-1
             write(*,'(4A)',ADVANCE='NO') "   U"," ","   W"," "
          ENDDO
          write(*,'(3A)') "   U"," ","   W"
          DO jj=MAX(jts,j-2),MIN(j_end,j+2)
             write(*,'(I3,A)',ADVANCE='NO') jj," V "
             DO ii=MAX(its,i-2),MIN(i_end,i+2)-1
                write(*,'(2(F4.0,A))',ADVANCE='NO') ibm_ht_c(ii,jj)," ",ibm_ht_v(ii,jj)," "
             ENDDO
             write(*,'(F4.0,A,F4.0)') ibm_ht_c(ii+1,jj)," ",ibm_ht_v(ii+1,jj)
             write(*,'(I3,A)',ADVANCE='NO') jj," W "
             DO ii=MAX(its,i-2),MIN(i_end,i+2)-1
                write(*,'(2(F4.0,A))',ADVANCE='NO') ibm_ht_u(ii,jj)," ",ibm_ht_w(ii,jj)," "
             ENDDO
             write(*,'(F4.0,A,F4.0)') ibm_ht_u(ii+1,jj)," ",ibm_ht_w(ii+1,jj)
          ENDDO

       ENDIF
       IF (antw_at_p(i,j) .LE. 1) THEN
          write(debug_message,'(3A,2(I4,A),I1,A)') "--- ERROR: ",stag,"-top-point at (i, j) = ",i,", ",j," has ",antw_at_p(i,j)," neighboring W-points"
          CALL wrf_message(TRIM(debug_message))
          write(*,'(3(A,F8.2),A)') "reconstruction point at (",top_img(i,j,1),", ",top_img(i,j,2),", ",top_img(i,j,3),")"
          write(*,'(3(A,F8.2),A)') "interpolation point at  (",top_img(i,j,4),", ",top_img(i,j,5),", ",top_img(i,j,6),")"
          write(*,'(3(A,F8.2),A)') "boundary point at       (",top_bound(i,j,1),", ",top_bound(i,j,2),", ",top_bound(i,j,3),")"
          IF (allgood .EQ. .TRUE.) allgood = .FALSE.

          write(*,'(A)',ADVANCE='NO') "      "
          DO ii=MAX(its,i-2),MIN(i_end,i+2)-1
             write(*,'(2(I4,A))',ADVANCE='NO') ii," ",ii," "
          ENDDO
          write(*,'(I4,A,I4)') ii+1," ",ii+1
          write(*,'(A)',ADVANCE='NO') "      "
          DO ii=MAX(its,i-2),MIN(i_end,i+2)-1
             write(*,'(4A)',ADVANCE='NO') "   U"," ","   W"," "
          ENDDO
          write(*,'(3A)') "   U"," ","   W"
          DO jj=MAX(jts,j-2),MIN(j_end,j+2)
             write(*,'(I3,A)',ADVANCE='NO') jj," V "
             DO ii=MAX(its,i-2),MIN(i_end,i+2)-1
                write(*,'(2(F4.0,A))',ADVANCE='NO') ibm_ht_c(ii,jj)," ",ibm_ht_v(ii,jj)," "
             ENDDO
             write(*,'(F4.0,A,F4.0)') ibm_ht_c(ii+1,jj)," ",ibm_ht_v(ii+1,jj)
             write(*,'(I3,A)',ADVANCE='NO') jj," W "
             DO ii=MAX(its,i-2),MIN(i_end,i+2)-1
                write(*,'(2(F4.0,A))',ADVANCE='NO') ibm_ht_u(ii,jj)," ",ibm_ht_w(ii,jj)," "
             ENDDO
             write(*,'(F4.0,A,F4.0)') ibm_ht_u(ii+1,jj)," ",ibm_ht_w(ii+1,jj)
          ENDDO

       ENDIF
    ENDDO
    ENDDO

    DO S=1,np
       IF (ansu_at_p(S) .LE. 1) THEN
          write(debug_message,'(3A,I7,A,I1,A)') "--- ERROR: ",stag,"-side-point S=",S," has ",ansu_at_p(S)," neighboring U-points"
          CALL wrf_message(TRIM(debug_message))
          write(*,'(3(A,F8.2),A)') "reconstruction point at (",side_img(S,1),", ",side_img(S,2),", ",side_img(S,3),")"
          write(*,'(3(A,F8.2),A)') "interpolation point at  (",side_img(S,4),", ",side_img(S,5),", ",side_img(S,6),")"
          write(*,'(3(A,F8.2),A)') "boundary point at       (",side_bound(S,1),", ",side_bound(S,2),", ",side_bound(S,3),")"
          IF (allgood .EQ. .TRUE.) allgood = .FALSE.
       ENDIF
       IF (ansv_at_p(S) .LE. 1) THEN
          write(debug_message,'(3A,I7,A,I1,A)') "--- ERROR: ",stag,"-side-point S=",S," has ",ansv_at_p(S)," neighboring V-points"
          CALL wrf_message(TRIM(debug_message))
          write(*,'(3(A,F8.2),A)') "reconstruction point at (",side_img(S,1),", ",side_img(S,2),", ",side_img(S,3),")"
          write(*,'(3(A,F8.2),A)') "interpolation point at  (",side_img(S,4),", ",side_img(S,5),", ",side_img(S,6),")"
          write(*,'(3(A,F8.2),A)') "boundary point at       (",side_bound(S,1),", ",side_bound(S,2),", ",side_bound(S,3),")"
          IF (allgood .EQ. .TRUE.) allgood = .FALSE.
       ENDIF
       IF (answ_at_p(S) .LE. 1) THEN
          write(debug_message,'(3A,I7,A,I1,A)') "--- ERROR: ",stag,"-side-point S=",S," has ",answ_at_p(S)," neighboring W-points"
          CALL wrf_message(TRIM(debug_message))
          write(*,'(3(A,F8.2),A)') "reconstruction point at (",side_img(S,1),", ",side_img(S,2),", ",side_img(S,3),")"
          write(*,'(3(A,F8.2),A)') "interpolation point at  (",side_img(S,4),", ",side_img(S,5),", ",side_img(S,6),")"
          write(*,'(3(A,F8.2),A)') "boundary point at       (",side_bound(S,1),", ",side_bound(S,2),", ",side_bound(S,3),")"
          IF (allgood .EQ. .TRUE.) allgood = .FALSE.
       ENDIF
    ENDDO

 END SUBROUTINE neighbors_check

!--------------------------------------------------------------------------------

 SUBROUTINE terrain_check( utop, vtop, wtop,             &
                           ids, ide, jds, jde, kds, kde, &
                           ims, ime, jms, jme, kms, kme, &
                           its, ite, jts, jte, kts, kte )
 IMPLICIT NONE
 !input data
 INTEGER, DIMENSION(ims:ime,jms:jme), INTENT(IN   )      :: utop, &  
                                                            vtop, &  
                                                            wtop
 INTEGER, INTENT(IN   )       :: ids, ide, jds, jde, kds, kde,    & !d: domain
                                 ims, ime, jms, jme, kms, kme,    & !m: memory
                                 its, ite, jts, jte, kts, kte       !p: patch, t: tile
 !local data
 INTEGER                                                 :: i, j    

!--------------------------------------------------------------------------------
 !the executable begins here
 CALL wrf_debug(100, 'dyn_em/module_ibm.F/subroutine terrain_check')
!--------------------------------------------------------------------------------
 DO i=its,ite
 DO j=jts,jte
    !check to make sure that there are a few points below the terrain
    IF ((j .NE. jde) .AND. (utop(i,j) .LT. 2)) THEN
       print *, 'at i,j',i,j,' utop = ',utop(i,j)
       CALL wrf_error_fatal ('There are not two points below the ibm terrain for utop')
    ENDIF
    IF ((i .NE. ide) .AND. (vtop(i,j) .LT. 2)) THEN
       print *, 'at i,j',i,j,' vtop = ',vtop(i,j)
       CALL wrf_error_fatal ('There are not two points below the ibm terrain for vtop')
    ENDIF
    IF ((i .NE. ide) .AND. (j .NE. jde) .AND. (wtop(i,j) .LT. 2)) THEN
       print *, 'at i,j',i,j,' wtop = ',wtop(i,j)
       CALL wrf_error_fatal ('There are not two points below the ibm terrain for wtop')
    ENDIF
 ENDDO
 ENDDO

 END SUBROUTINE terrain_check

!--------------------------------------------------------------------------------

 SUBROUTINE zero_interior( ibm_opt,                                  &
                           u, v, w,                                  &
                           utop, vtop, wtop,                         &
                           ids, ide, jds, jde, kds, kde,             &
                           ims, ime, jms, jme, kms, kme,             &
                           its, ite, jts, jte, kts, kte )

 IMPLICIT NONE
 !input data
 REAL, DIMENSION(ims:ime,kms:kme,jms:jme), INTENT(INOUT)   :: u,     &
                                                              v,     &
                                                              w
 INTEGER, DIMENSION(ims:ime,jms:jme), INTENT(IN   )        :: utop,  & !store the 'top boundary' ghost points here
                                                              vtop,  &
                                                              wtop
 INTEGER,        INTENT(IN   )   :: ibm_opt,                         &
                                    ids, ide, jds, jde, kds, kde,    & !d: domain
                                    ims, ime, jms, jme, kms, kme,    & !m: memory
                                    its, ite, jts, jte, kts, kte       !p: patch, t: tile
 !local data
 INTEGER                                                   :: i, j, k, offset
!---------------------------------------------------------------------------------
! the executable begins here
! this is only called once from start_em
   CALL wrf_debug(100, 'dyn_em/module_ibm.F/subroutine zero_interior')
!---------------------------------------------------------------------------------

   IF ((ibm_opt .EQ. 3) .OR. (ibm_opt .EQ. 5)) THEN
      offset = 0
   ELSE
      offset = 1
   ENDIF

   !set the velocities within the topography to zero  
   DO i=its,ite
   DO j=jts,jte
      DO k=kts,utop(i,j)-offset
         u(i,k,j) = 0.0
      ENDDO
      DO k=kts,vtop(i,j)-offset
         v(i,k,j) = 0.0
      ENDDO
      DO k=kts,wtop(i,j)
         w(i,k,j) = 0.0
      ENDDO
   ENDDO
   ENDDO 

 END SUBROUTINE zero_interior

!--------------------------------------------------------------------------------

 SUBROUTINE zero_interior_t( t, top,                                 &
                             ids, ide, jds, jde, kds, kde,           &
                             ims, ime, jms, jme, kms, kme,           &
                             its, ite, jts, jte, kts, kte )

 IMPLICIT NONE
 !input data     			     
 REAL, DIMENSION(ims:ime,kms:kme,jms:jme), INTENT(INOUT)   :: t
 INTEGER, DIMENSION(ims:ime,jms:jme), INTENT(IN   )        :: top      !store the 'top boundary' ghost points here
 INTEGER,        INTENT(IN   )   :: ids, ide, jds, jde, kds, kde,    & !d: domain
                                    ims, ime, jms, jme, kms, kme,    & !m: memory
                                    its, ite, jts, jte, kts, kte       !p: patch, t: tile
 !local data
 INTEGER                                                   :: i, j, k
!---------------------------------------------------------------------------------
! the executable begins here
! this is only called once from start_em
   CALL wrf_debug(100, 'dyn_em/module_ibm.F/subroutine zero_interior_t')
!---------------------------------------------------------------------------------
 
   !set the temperature within the topography to zero  
   DO i=its,ite
   DO j=jts,jte
      DO k=kts,top(i,j)
         t(i,k,j) = 0.0
      ENDDO
   ENDDO
   ENDDO 

 END SUBROUTINE zero_interior_t

!--------------------------------------------------------------------------------

 SUBROUTINE free_slip_bilin ( top_slope,                                  &
                              u, v, w,                                    &
                              ph_u, ph_v, ph_w,                           &
                              utop, vtop, wtop,                           &
                              uprox, vprox, wprox,                        &
                              utop_img, vtop_img, wtop_img,               &
                              uside, vside, wside,                        &
                              uside_img, vside_img, wside_img,            &
                              utop_neigh, vtop_neigh, wtop_neigh,         &
                              uside_neigh, vside_neigh, wside_neigh,      &
                              utop_neigh_i, vtop_neigh_i, wtop_neigh_i,   &
                              uside_neigh_i, vside_neigh_i, wside_neigh_i,&
                              n, nu, nv, nw,                              &
                              ids, ide, jds, jde, kds, kde,               &
                              ims, ime, jms, jme, kms, kme,               &
                              its, ite, jts, jte, kts, kte)
 IMPLICIT NONE
 ! input data 
 REAL, DIMENSION(ims:ime,jms:jme,3), INTENT(IN   )         :: top_slope
 REAL, DIMENSION(ims:ime,kms:kme,jms:jme), INTENT(INOUT)   :: u,           &
                                                              v,           &
                                                              w
 REAL, DIMENSION(ims:ime,kms:kme,jms:jme), INTENT(IN   )   :: ph_u,        &  ! this is the total geopotential at u v, and w points
                                                              ph_v,        &
                                                              ph_w 
 INTEGER, DIMENSION(ims:ime,jms:jme), INTENT(IN   )        :: utop,        &
                                                              vtop,        &
                                                              wtop,        &
                                                              uprox,       &
                                                              vprox,       &
                                                              wprox
 INTEGER, DIMENSION(3,nu), INTENT(IN   )                   :: uside           !'side boundary' ghost points
 INTEGER, DIMENSION(3,nv), INTENT(IN   )                   :: vside
 INTEGER, DIMENSION(3,nw), INTENT(IN   )                   :: wside
 REAL, DIMENSION(ims:ime,jms:jme,6), INTENT(IN   )         :: utop_img,    &  ! (x,y,z) location of ghost point
                                                              vtop_img,    &  ! and image point of the 'top boundary' ghost points
                                                              wtop_img
 REAL, DIMENSION(6,nu), INTENT(IN   )                      :: uside_img       ! (x,y,z) location of ghost point
 REAL, DIMENSION(6,nv), INTENT(IN   )                      :: vside_img       ! and image point of the 'side boundary' ghost points
 REAL, DIMENSION(6,nw), INTENT(IN   )                      :: wside_img
 REAL, DIMENSION(ims:ime,jms:jme,0:3*n-1), INTENT(IN   )   :: utop_neigh,  &  ! (x,y,z) location of  neighbors
                                                              vtop_neigh,  &
                                                              wtop_neigh 
 REAL, DIMENSION(0:3*n-1,nu), INTENT(IN   )                :: uside_neigh     ! (x,y,z) location of neighbors
 REAL, DIMENSION(0:3*n-1,nv), INTENT(IN   )                :: vside_neigh
 REAL, DIMENSION(0:3*n-1,nw), INTENT(IN   )                :: wside_neigh
 INTEGER, DIMENSION(ims:ime,jms:jme,0:3*n-1), INTENT(IN   ):: utop_neigh_i,&  ! (i,j,k) index of top neighbors
                                                              vtop_neigh_i,&
                                                              wtop_neigh_i
 INTEGER, DIMENSION(0:3*n-1,nu), INTENT(IN   )             :: uside_neigh_i   ! (i,j,k) location of neighbors
 INTEGER, DIMENSION(0:3*n-1,nv), INTENT(IN   )             :: vside_neigh_i
 INTEGER, DIMENSION(0:3*n-1,nw), INTENT(IN   )             :: wside_neigh_i
 INTEGER, INTENT(IN   )                                    :: n,           & ! desired number of nearest neighbors
                                                              nu,nv,nw       ! number of side ghost points
 INTEGER, INTENT(IN   )                   :: ids, ide, jds, jde, kds, kde, & ! d: domain m:memory p:patch t:tile
                                             ims, ime, jms, jme, kms, kme, &
                                             its, ite, jts, jte, kts, kte

 !local data
 INTEGER                                                   :: i, j, nC,    &
                                                              info
 REAL                                                      :: u_image, w_image
 REAL, DIMENSION(16)                                       :: matrix
 REAL, DIMENSION(4)                                        :: RHS, ipiv
 REAL, DIMENSION(2)                                        :: reflect

 !---------------------------------------------------------------------------------
 ! the executable begins here
 !  print *, 'dyn_em/module_ibm.F/subroutine free_slip_bilin'
 ! this is for 2-d problems!
 !	    |1 x_1 z_1 x_1*z_1|  	  |a_1|         |u_1|
 ! matrix = |1 x_2 z_2 x_2*z_2|  a_coef = |a_2|   RHS = |u_2| 
 !	    |1 x_3 z_3 x_3*z_3|  	  |a_3|         |u_3|
 !          |1 x_4 z_4 x_4*z_4|           |a_4|         |u_4|
 ! matrix*a_coef = RHS or a_coef=(matrix^-1)*RHS
 !
 !                    1     | 1-slope^2 2*slope   |
 !reflect(2d) =   _________ |                     |
 !               slope^2+1  | 2*slope   slope^2-1 |
 !---------------------------------------------------------------------------------


 DO i=its,ite
 DO j=jts,jte
    if (j /= jde) then 
        ! calculate u velocity at the image point
        matrix = [1., utop_neigh(i,j,0), utop_neigh(i,j,2), utop_neigh(i,j,0)*utop_neigh(i,j,2),&
                  1., utop_neigh(i,j,3), utop_neigh(i,j,5), utop_neigh(i,j,3)*utop_neigh(i,j,5),&
                  1., utop_neigh(i,j,6), utop_neigh(i,j,8), utop_neigh(i,j,6)*utop_neigh(i,j,8),&
                  1., utop_neigh(i,j,9), utop_neigh(i,j,11),utop_neigh(i,j,9)*utop_neigh(i,j,11)]
        DO nC=0,3
           if (utop_neigh_i(i,j,3*nC+2) == 0) then
               ! utop_neigh_i(k)=0 only occurs at bottom two points
               if (nC == 2) then
                  CALL lagrange_extrap(utop_img(i,j,6),utop_neigh(i,j,8),utop_neigh_i(i,j,3:5),ph_u,u,RHS(nC+1), &
                                       ims,ime,jms,jme,kms,kme)
               elseif (nC == 3) then
                  CALL lagrange_extrap(utop_img(i,j,6),utop_neigh(i,j,11),utop_neigh_i(i,j,0:2),ph_u,u,RHS(nC+1), &
                                       ims,ime,jms,jme,kms,kme)
               endif
           else
               RHS(nC+1) = u(utop_neigh_i(i,j,3*nC),utop_neigh_i(i,j,3*nC+2),utop_neigh_i(i,j,3*nC+1))
           endif
        ENDDO
        if (KIND(matrix) == 4) then
            CALL SGETRF(4,4,matrix,4,ipiv,info)
            if (info/=0) CALL wrf_error_fatal('LU Factorization')
            CALL SGETRS('T',4,1,matrix,4,ipiv,RHS,4,info)
            if (info/=0) CALL wrf_error_fatal('Matrix Solve')
        elseif (KIND(matrix) == 8) then    
            CALL DGETRF(4,4,matrix,4,ipiv,info)
            if (info/=0) CALL wrf_error_fatal('LU Factorization')
            CALL DGETRS('T',4,1,matrix,4,ipiv,RHS,4,info)
            if (info/=0) CALL wrf_error_fatal('Matrix Solve')
        endif 
!	u_image= RHS(1)+RHS(2)*utop_img(i,j,4)+RHS(3)*utop_img(i,j,6) &
!	        +RHS(4)*utop_img(i,j,4)*utop_img(i,j,6)	
        u_image = RHS(1)
        ! calculate w velocity at the image point
        matrix = [1., utop_neigh(i,j,12), utop_neigh(i,j,14), utop_neigh(i,j,12)*utop_neigh(i,j,14),&
                  1., utop_neigh(i,j,15), utop_neigh(i,j,17), utop_neigh(i,j,14)*utop_neigh(i,j,17),&
                  1., utop_neigh(i,j,18), utop_neigh(i,j,20), utop_neigh(i,j,18)*utop_neigh(i,j,20),&
                  1., utop_neigh(i,j,21), utop_neigh(i,j,23), utop_neigh(i,j,21)*utop_neigh(i,j,23)]
        DO nC=0,3
           if (utop_neigh_i(i,j,3*nC+14) == 0) then 
               ! utop_neigh_i(k)=0 only occurs at bottom two points
               if (nC == 2) then
                  CALL lagrange_extrap(utop_img(i,j,6),utop_neigh(i,j,20),utop_neigh_i(i,j,15:17),ph_w,w,RHS(nC+1), &
                                       ims,ime,jms,jme,kms,kme)
               elseif (nC == 3) then
                  CALL lagrange_extrap(utop_img(i,j,6),utop_neigh(i,j,23),utop_neigh_i(i,j,12:14),ph_w,w,RHS(nC+1), &
                                       ims,ime,jms,jme,kms,kme)
               endif
           else 
               RHS(nC+1) = w(utop_neigh_i(i,j,3*nC+12),utop_neigh_i(i,j,3*nC+14),utop_neigh_i(i,j,3*nC+13))
           endif
        ENDDO
        if (KIND(matrix) == 4) then
            CALL SGETRF(4,4,matrix,4,ipiv,info)
            if (info/=0) CALL wrf_error_fatal('LU Factorization')
            CALL SGETRS('T',4,1,matrix,4,ipiv,RHS,4,info)
            if (info/=0) CALL wrf_error_fatal('Matrix Solve')
        elseif (KIND(matrix) == 8) then    
            CALL DGETRF(4,4,matrix,4,ipiv,info)
            if (info/=0) CALL wrf_error_fatal('LU Factorization')
            CALL DGETRS('T',4,1,matrix,4,ipiv,RHS,4,info)
            if (info/=0) CALL wrf_error_fatal('Matrix Solve')
        endif 
!	w_image= RHS(1)+RHS(2)*utop_img(i,j,4)+RHS(3)*utop_img(i,j,6) &
!		+RHS(4)*utop_img(i,j,4)*utop_img(i,j,6)	
        w_image = RHS(1)
        ! now figure out tangential and normal components and assign velocity
        ! calculate reflection matrix using slope
        reflect = [1-top_slope(i,j,1)**2, 2*top_slope(i,j,1)] &
                  /(top_slope(i,j,1)**2+1)
        u(i,utop(i,j),j) = reflect(1)*u_image + reflect(2)*w_image
    endif ! end of setting u velocity at ghost point
   
   if ((i /= ide).AND.(j /= jde)) then 
       ! calculate u velocity at the image point
       matrix = [1., wtop_neigh(i,j,0), wtop_neigh(i,j,2), wtop_neigh(i,j,0)*wtop_neigh(i,j,2),&
                 1., wtop_neigh(i,j,3), wtop_neigh(i,j,5), wtop_neigh(i,j,3)*wtop_neigh(i,j,5),&
                 1., wtop_neigh(i,j,6), wtop_neigh(i,j,8), wtop_neigh(i,j,6)*wtop_neigh(i,j,8),&
                 1., wtop_neigh(i,j,9), wtop_neigh(i,j,11),wtop_neigh(i,j,9)*wtop_neigh(i,j,11)]
       DO nC=0,3
          if (wtop_neigh_i(i,j,3*nC+2) == 0) then 
               ! wtop_neigh_i(k)=0 only occurs at bottom two points
               if (nC == 2) then
                  CALL lagrange_extrap(wtop_img(i,j,6),wtop_neigh(i,j,8),wtop_neigh_i(i,j,3:5),ph_u,u,RHS(nC+1), &
                                       ims,ime,jms,jme,kms,kme)
               elseif (nC == 3) then
                  CALL lagrange_extrap(wtop_img(i,j,6),wtop_neigh(i,j,11),wtop_neigh_i(i,j,0:2),ph_u,u,RHS(nC+1), &
                                       ims,ime,jms,jme,kms,kme)
               endif
          else 
               RHS(nC+1) = u(wtop_neigh_i(i,j,3*nC),wtop_neigh_i(i,j,3*nC+2),wtop_neigh_i(i,j,3*nC+1))
          endif
       ENDDO
       if (KIND(matrix) == 4) then
            CALL SGETRF(4,4,matrix,4,ipiv,info)
            if (info/=0) CALL wrf_error_fatal('LU Factorization')
            CALL SGETRS('T',4,1,matrix,4,ipiv,RHS,4,info)
            if (info/=0) CALL wrf_error_fatal('Matrix Solve')
        elseif (KIND(matrix) == 8) then    
            CALL DGETRF(4,4,matrix,4,ipiv,info)
            if (info/=0) CALL wrf_error_fatal('LU Factorization')
            CALL DGETRS('T',4,1,matrix,4,ipiv,RHS,4,info)
            if (info/=0) CALL wrf_error_fatal('Matrix Solve')
        endif 
 !       u_image= RHS(1)+RHS(2)*wtop_img(i,j,4)+RHS(3)*wtop_img(i,j,6) &
 !      	        +RHS(4)*wtop_img(i,j,4)*wtop_img(i,j,6)
        u_image = RHS(1)
        ! calculate w velocity at the image point
        matrix = [1., wtop_neigh(i,j,12), wtop_neigh(i,j,14), wtop_neigh(i,j,12)*wtop_neigh(i,j,14),&
                  1., wtop_neigh(i,j,15), wtop_neigh(i,j,17), wtop_neigh(i,j,14)*wtop_neigh(i,j,17),&
                  1., wtop_neigh(i,j,18), wtop_neigh(i,j,20), wtop_neigh(i,j,18)*wtop_neigh(i,j,20),&
                  1., wtop_neigh(i,j,21), wtop_neigh(i,j,23), wtop_neigh(i,j,21)*wtop_neigh(i,j,23)]
        DO nC=0,3
           if (wtop_neigh_i(i,j,3*nC+14) == 0) then 
               ! wtop_neigh_i(k)=0 only occurs at bottom two points
               if (nC == 2) then
                  CALL lagrange_extrap(wtop_img(i,j,6),wtop_neigh(i,j,20),wtop_neigh_i(i,j,15:17),ph_w,w,RHS(nC+1), &
                                       ims,ime,jms,jme,kms,kme)
               elseif (nC == 3) then
                  CALL lagrange_extrap(wtop_img(i,j,6),wtop_neigh(i,j,23),wtop_neigh_i(i,j,12:14),ph_w,w,RHS(nC+1), &
                                       ims,ime,jms,jme,kms,kme)
               endif       
           else 
               RHS(nC+1) = w(wtop_neigh_i(i,j,3*nC+12),wtop_neigh_i(i,j,3*nC+14),wtop_neigh_i(i,j,3*nC+13))
           endif
        ENDDO
        if (KIND(matrix) == 4) then
            CALL SGETRF(4,4,matrix,4,ipiv,info)
            if (info/=0) CALL wrf_error_fatal('LU Factorization')
            CALL SGETRS('T',4,1,matrix,4,ipiv,RHS,4,info)
            if (info/=0) CALL wrf_error_fatal('Matrix Solve')
        elseif (KIND(matrix) == 8) then    
            CALL DGETRF(4,4,matrix,4,ipiv,info)
            if (info/=0) CALL wrf_error_fatal('LU Factorization')
            CALL DGETRS('T',4,1,matrix,4,ipiv,RHS,4,info)
            if (info/=0) CALL wrf_error_fatal('Matrix Solve')
        endif 
!	w_image= RHS(1)+RHS(2)*wtop_img(i,j,4)+RHS(3)*wtop_img(i,j,6) &
!		+RHS(4)*wtop_img(i,j,4)*wtop_img(i,j,6)	
        w_image=RHS(1)
        ! now figure out tangential and normal components and assign velocity
        ! calculate reflection matrix using slope			
        reflect = [2*top_slope(i,j,3), top_slope(i,j,3)**2-1] &
                  /(top_slope(i,j,3)**2+1)
        w(i,wtop(i,j),j) = reflect(1)*u_image + reflect(2)*w_image
   endif ! end of setting w velocity at ghost point	
 ENDDO
 ENDDO
 
! print *,'IBM Velocities'
! DO i=ims,ime
! print '(3f16.12)', u(i,utop(i,1),1), v(i,vtop(i,1),1), w(i,wtop(i,1),1)
! ENDDO
 

 END SUBROUTINE free_slip_bilin

!--------------------------------------------------------------------------------

 SUBROUTINE no_slip_lin_ss ( stag, prox, dim_terrain,                     &
                             var, varfull, varsave,                       &
                             mu, mus,                                     &
                             top, top_img,                                &
                             side, side_img,                              &
                             top_neigh, side_neigh,                       &
                             top_neigh_i, side_neigh_i,                   &
                             n, np,                                       &
                             ids, ide, jds, jde, kds, kde,                &
                             ims, ime, jms, jme, kms, kme,                &
                             its, ite, jts, jte, kts, kte)
 IMPLICIT NONE
 ! input data	
 CHARACTER, INTENT(IN   )                                  :: stag
 REAL, DIMENSION(ims:ime,kms:kme,jms:jme), INTENT(INOUT)   :: var,        &
                                                              varfull
 REAL, DIMENSION(ims:ime,kms:kme,jms:jme), INTENT(IN   )   :: varsave
 REAL, DIMENSION(ims:ime,jms:jme), INTENT(IN   )           :: mu,         &
                                                              mus
 INTEGER, DIMENSION(ims:ime,jms:jme), INTENT(IN   )        :: prox,       &
                                                              top
 INTEGER, DIMENSION(3,np), INTENT(IN   )                   :: side            !'side boundary' ghost points		       
 REAL, DIMENSION(ims:ime,jms:jme,6), INTENT(IN   )         :: top_img         ! (x,y,z) location of ghost point and image point of the 'top boundary' ghost points
 REAL, DIMENSION(6,np), INTENT(IN   )                      :: side_img        ! (x,y,z) location of ghost point and image point of the 'side boundary' ghost points						     
 REAL, DIMENSION(ims:ime,jms:jme,0:3*n-1), INTENT(IN   )   :: top_neigh       ! (x,y,z) location of  neighbors 
 REAL, DIMENSION(0:3*n-1,np), INTENT(IN   )                :: side_neigh      ! (x,y,z) location of neighbors							     
 INTEGER, DIMENSION(ims:ime,jms:jme,0:3*n-1), INTENT(IN   ):: top_neigh_i     ! (i,j,k) index of top neighbors
 INTEGER, DIMENSION(0:3*n-1,np), INTENT(IN   )             :: side_neigh_i    ! (i,j,k) location of neighbors							     
 INTEGER, INTENT(IN   )                                    :: dim_terrain, &
                                                              n,           &  ! desired number of nearest neighbors
                                                              np              ! number of side ghost points
 INTEGER, INTENT(IN   )                   :: ids, ide, jds, jde, kds, kde, & ! d: domain m:memory p:patch t:tile
                                             ims, ime, jms, jme, kms, kme, &
                                             its, ite, jts, jte, kts, kte

 !local data
 INTEGER                                                  :: i, j,         &
                                                             nC,S,         &
                                                             info,         &
                                                             i_end,        &
                                                             j_end
 REAL, DIMENSION(n*n)                                     :: matrix
 REAL, DIMENSION(n)                                       :: RHS
 INTEGER, DIMENSION(n)                                    :: ipiv
! REAL,DIMENSION(its:ite) :: test

 !---------------------------------------------------------------------------------
 ! the executable begins here
  CALL wrf_debug(100,'dyn_em/module_ibm.F/subroutine no_slip_lin_ss')
 ! bilinear or trilinear interpolation 
 ! this is the matrix for 2-d problems
 !	    |1 x_1 z_1 x_1*z_1|  	  |a_1|         |u_1|
 ! matrix = |1 x_2 z_2 x_2*z_2|  a_coef = |a_2|   RHS = |u_2| 
 !	    |1 x_3 z_3 x_3*z_3|  	  |a_3|         |u_3|
 !	    |1 x_4 z_4 x_4*z_4|  	  |a_4|         |u_4|
 ! this is the matrix for 3-d problems
 !	    |1 x_1 y_1 z_1 x_1*y_1 x_1*z_1 y_1*z_1 x_1*y_1*z_1|  	  |a_1|         |u_1|
 !          |1 x_2 y_2 z_2 x_2*y_2 x_2*z_2 y_2*z_2 x_2*y_2*z_2|           |a_2|         |u_2| 
 !	    |1 x_3 y_3 z_3 x_3*y_3 x_3*z_3 y_3*z_3 x_3*y_3*z_3|  	  |a_3|         |u_3|
 ! matrix = |1 x_4 y_4 z_4 x_4*y_4 x_4*z_4 y_4*z_4 x_4*y_4*z_4|  a_coef = |a_4|  RHS =  |u_4|
 !          |1 x_5 y_5 z_5 x_5*y_5 x_5*z_5 y_5*z_5 x_5*y_5*z_5|           |a_5|         |u_5|
 !	    |1 x_6 y_6 z_6 x_6*y_6 x_6*z_6 y_6*z_6 x_6*y_6*z_6|  	  |a_6|         |u_6|
 !          |1 x_7 y_7 z_7 x_7*y_7 x_7*z_7 y_7*z_7 x_7*y_7*z_7|           |a_7|         |u_7| 
 !	    |1 x_8 y_8 z_8 x_8*y_8 x_8*z_8 y_8*z_8 x_8*y_8*z_8|  	  |a_8|         |u_8|
 ! matrix*a_coef = RHS or a_coef=(matrix^-1)*RHS
 !---------------------------------------------------------------------------------

 IF (stag == 'u') THEN
    i_end = ite
    j_end = MIN(jte,jde-1)
 ELSEIF (stag == 'v') THEN
    i_end = MIN(ite,ide-1)
    j_end = jte
 ELSEIF ((stag == 'w').OR.(stag == 't')) THEN
    i_end = MIN(ite,ide-1)
    j_end = MIN(jte,jde-1)
 ENDIF

 DO i=its,i_end
 DO j=jts,j_end 
    if (dim_terrain == 2) then
        matrix = [1., top_neigh(i,j,0), top_neigh(i,j,2), top_neigh(i,j,0)*top_neigh(i,j,2),&
                  1., top_neigh(i,j,3), top_neigh(i,j,5), top_neigh(i,j,3)*top_neigh(i,j,5),&
                  1., top_neigh(i,j,6), top_neigh(i,j,8), top_neigh(i,j,6)*top_neigh(i,j,8),&
                  1., top_neigh(i,j,9), top_neigh(i,j,11),top_neigh(i,j,9)*top_neigh(i,j,11)]
    elseif (dim_terrain == 3) then
        matrix = [1., top_neigh(i,j,0),  top_neigh(i,j,1),  top_neigh(i,j,2),  top_neigh(i,j,0)*top_neigh(i,j,1),   top_neigh(i,j,0)*top_neigh(i,j,2),   top_neigh(i,j,1)*top_neigh(i,j,2),   top_neigh(i,j,0)*top_neigh(i,j,1)*top_neigh(i,j,2),   &
                  1., top_neigh(i,j,3),  top_neigh(i,j,4),  top_neigh(i,j,5),  top_neigh(i,j,3)*top_neigh(i,j,4),   top_neigh(i,j,3)*top_neigh(i,j,5),   top_neigh(i,j,4)*top_neigh(i,j,5),   top_neigh(i,j,3)*top_neigh(i,j,4)*top_neigh(i,j,5),   &
                  1., top_neigh(i,j,6),  top_neigh(i,j,7),  top_neigh(i,j,8),  top_neigh(i,j,6)*top_neigh(i,j,7),   top_neigh(i,j,6)*top_neigh(i,j,8),   top_neigh(i,j,7)*top_neigh(i,j,8),   top_neigh(i,j,6)*top_neigh(i,j,7)*top_neigh(i,j,8),   & 
                  1., top_neigh(i,j,9),  top_neigh(i,j,10), top_neigh(i,j,11), top_neigh(i,j,9)*top_neigh(i,j,10),  top_neigh(i,j,9)*top_neigh(i,j,11),  top_neigh(i,j,10)*top_neigh(i,j,11), top_neigh(i,j,9)*top_neigh(i,j,10)*top_neigh(i,j,11), & 
                  1., top_neigh(i,j,12), top_neigh(i,j,13), top_neigh(i,j,14), top_neigh(i,j,12)*top_neigh(i,j,13), top_neigh(i,j,12)*top_neigh(i,j,14), top_neigh(i,j,13)*top_neigh(i,j,14), top_neigh(i,j,12)*top_neigh(i,j,13)*top_neigh(i,j,14),&
                  1., top_neigh(i,j,15), top_neigh(i,j,16), top_neigh(i,j,17), top_neigh(i,j,15)*top_neigh(i,j,16), top_neigh(i,j,15)*top_neigh(i,j,17), top_neigh(i,j,16)*top_neigh(i,j,17), top_neigh(i,j,15)*top_neigh(i,j,16)*top_neigh(i,j,17),&
                  1., top_neigh(i,j,18), top_neigh(i,j,19), top_neigh(i,j,20), top_neigh(i,j,18)*top_neigh(i,j,19), top_neigh(i,j,18)*top_neigh(i,j,20), top_neigh(i,j,19)*top_neigh(i,j,20), top_neigh(i,j,18)*top_neigh(i,j,19)*top_neigh(i,j,20),&
                  1., top_neigh(i,j,21), top_neigh(i,j,22), top_neigh(i,j,23), top_neigh(i,j,21)*top_neigh(i,j,22), top_neigh(i,j,21)*top_neigh(i,j,23), top_neigh(i,j,22)*top_neigh(i,j,23), top_neigh(i,j,21)*top_neigh(i,j,22)*top_neigh(i,j,23)]
    endif
    DO nC=0,n-1
       if (top_neigh_i(i,j,3*nC+2) == 0) then 
           RHS(nC+1) = 0.
       else     
           RHS(nC+1) = varfull(top_neigh_i(i,j,3*nC),top_neigh_i(i,j,3*nC+2),top_neigh_i(i,j,3*nC+1))
       endif
    ENDDO   
    if (KIND(matrix) == 4) then
        CALL SGETRF(n,n,matrix,n,ipiv,info)
        if (info/=0) write(*,'(2A20,2i5,64f20.8)') stag, ' top LU i,j=',i,j,matrix
        CALL SGETRS('T',n,1,matrix,n,ipiv,RHS,n,info)
        !if (info/=0) CALL wrf_error_fatal('Matrix Solve')
        if (info/=0) write(*,'(2A20,2i5,8f20.8)')stag,' top S i,j=',i,j,RHS
    elseif (KIND(matrix) == 8) then    
        CALL DGETRF(n,n,matrix,n,ipiv,info)
        !if (info/=0) CALL wrf_error_fatal('LU Factorization')
        if (info/=0) write(*,'(2A20,2i5,64f20.8)') stag,' top LU i,j=',i,j,matrix
        CALL DGETRS('T',n,1,matrix,n,ipiv,RHS,n,info)
        !if (info/=0) CALL wrf_error_fatal('Matrix Solve')
        if (info/=0) write(*,'(2A20,2i5,8f20.8)')stag,' top S i,j=',i,j,RHS
    endif     
    if (prox(i,j) == 0) then
        varfull(i,top(i,j),j)=-RHS(1)
    elseif (prox(i,j) == 1) then
        varfull(i,top(i,j),j)=RHS(1)
    endif  ! end of setting scalar at ghost point
    if (stag=='u') then
        var(i,top(i,j),j) = varfull(i,top(i,j),j)*0.5*(mus(i,j)+mus(i-1,j)) - varsave(i,top(i,j),j)*mu(i,j)
    elseif (stag=='v') then
        var(i,top(i,j),j) = varfull(i,top(i,j),j)*0.5*(mus(i,j)+mus(i,j-1)) - varsave(i,top(i,j),j)*mu(i,j)
    elseif (stag=='w') then
        var(i,top(i,j),j) = varfull(i,top(i,j),j)*mus(i,j) - varsave(i,top(i,j),j)*mu(i,j)
    endif     
 ENDDO
 ENDDO

 if (np > 0) then
    DO S=1,np   
       if (dim_terrain == 2) then 
           matrix = [1., side_neigh(0,S), side_neigh(2,S),  side_neigh(0,S)*side_neigh(2,S),&
                     1., side_neigh(3,S), side_neigh(5,S),  side_neigh(3,S)*side_neigh(5,S),&
                     1., side_neigh(6,S), side_neigh(8,S),  side_neigh(6,S)*side_neigh(8,S),&
                     1., side_neigh(9,S), side_neigh(11,S), side_neigh(9,S)*side_neigh(11,S)]
       elseif (dim_terrain == 3) then
           matrix = [1., side_neigh(0,S),  side_neigh(1,S),  side_neigh(2,S),  side_neigh(0,S)*side_neigh(1,S),   side_neigh(0,S)*side_neigh(2,S),   side_neigh(1,S)*side_neigh(2,S),   side_neigh(0,S)*side_neigh(1,S)*side_neigh(2,S),   &
                     1., side_neigh(3,S),  side_neigh(4,S),  side_neigh(5,S),  side_neigh(3,S)*side_neigh(4,S),   side_neigh(3,S)*side_neigh(5,S),   side_neigh(4,S)*side_neigh(5,S),   side_neigh(3,S)*side_neigh(4,S)*side_neigh(5,S),   &
                     1., side_neigh(6,S),  side_neigh(7,S),  side_neigh(8,S),  side_neigh(6,S)*side_neigh(7,S),   side_neigh(6,S)*side_neigh(8,S),   side_neigh(7,S)*side_neigh(8,S),   side_neigh(6,S)*side_neigh(7,S)*side_neigh(8,S),   &
                     1., side_neigh(9,S),  side_neigh(10,S), side_neigh(11,S), side_neigh(9,S)*side_neigh(10,S),  side_neigh(9,S)*side_neigh(11,S),  side_neigh(10,S)*side_neigh(11,S), side_neigh(9,S)*side_neigh(10,S)*side_neigh(11,S), &
                     1., side_neigh(12,S), side_neigh(13,S), side_neigh(14,S), side_neigh(12,S)*side_neigh(13,S), side_neigh(12,S)*side_neigh(14,S), side_neigh(13,S)*side_neigh(14,S), side_neigh(12,S)*side_neigh(13,S)*side_neigh(14,S),&
                     1., side_neigh(15,S), side_neigh(16,S), side_neigh(17,S), side_neigh(15,S)*side_neigh(16,S), side_neigh(15,S)*side_neigh(17,S), side_neigh(16,S)*side_neigh(17,S), side_neigh(15,S)*side_neigh(16,S)*side_neigh(17,S),&
                     1., side_neigh(18,S), side_neigh(19,S), side_neigh(20,S), side_neigh(18,S)*side_neigh(19,S), side_neigh(18,S)*side_neigh(20,S), side_neigh(19,S)*side_neigh(20,S), side_neigh(18,S)*side_neigh(19,S)*side_neigh(20,S),&
                     1., side_neigh(21,S), side_neigh(22,S), side_neigh(23,S), side_neigh(21,S)*side_neigh(22,S), side_neigh(21,S)*side_neigh(23,S), side_neigh(22,S)*side_neigh(23,S), side_neigh(21,S)*side_neigh(22,S)*side_neigh(23,S)]
       endif
       DO nC=0,n-1
          if (side_neigh_i(3*nC+2,S) == 0) then 
              RHS(nC+1) = 0.
          else 
              RHS(nC+1) = varfull(side_neigh_i(3*nC,S),side_neigh_i(3*nC+2,S),side_neigh_i(3*nC+1,S))
          endif
       ENDDO
       if (KIND(matrix) == 4) then
           CALL SGETRF(n,n,matrix,n,ipiv,info)
           !if (info/=0) CALL wrf_error_fatal('LU Factorization')
           if (info/=0) write(*,'(2A20,1i5,64f20.8)') stag,' side LU np=',np,matrix
           CALL SGETRS('T',n,1,matrix,n,ipiv,RHS,n,info)
           !if (info/=0) CALL wrf_error_fatal('Matrix Solve')
           if (info/=0) write(*,'(2A20,1i5,8f20.8)') stag,' side S np=',np,RHS
       elseif (KIND(matrix) == 8) then    
           CALL DGETRF(n,n,matrix,n,ipiv,info)
           !if (info/=0) CALL wrf_error_fatal('LU Factorization')
           if (info/=0) write(*,'(2A20,1i5,64f20.8)') stag,' side LU np=',np,matrix
           CALL DGETRS('T',n,1,matrix,n,ipiv,RHS,n,info)
           !if (info/=0) CALL wrf_error_fatal('Matrix Solve')
           if (info/=0) write(*,'(2A20,1i5,8f20.8)') stag,' side S np=',np,RHS
       endif
       varfull(side(1,S),side(3,S),side(2,S))=-RHS(1)
       if (stag=='u') then
           var(side(1,S),side(3,S),side(2,S)) = varfull(side(1,S),side(3,S),side(2,S))*0.5*(mus(side(1,S),side(2,S))+mus(side(1,S)-1,side(2,S))) &
                                              - varsave(side(1,S),side(3,S),side(2,S))*mu(side(1,S),side(2,S))
       elseif (stag=='v') then
           var(side(1,S),side(3,S),side(2,S)) = varfull(side(1,S),side(3,S),side(2,S))*0.5*(mus(side(1,S),side(2,S))+mus(side(1,S),side(2,S)-1)) &
                                              - varsave(side(1,S),side(3,S),side(2,S))*mu(side(1,S),side(2,S))
       elseif (stag=='w') then
           var(side(1,S),side(3,S),side(2,S)) = varfull(side(1,S),side(3,S),side(2,S))*mus(side(1,S),side(2,S)) &
                                              - varsave(side(1,S),side(3,S),side(2,S))*mu(side(1,S),side(2,S))
       endif  
    ENDDO 
 endif

 END SUBROUTINE no_slip_lin_ss

!------------------------------------------------------------------------------------------------------

 SUBROUTINE no_slip_lin ( stag, prox, dim_terrain,                &
                          var,                                    &
                          top, top_img,                           &
                          side, side_img,                         &
                          top_neigh, side_neigh,                  &
                          top_neigh_i, side_neigh_i,              &
                          n, np,                                  &
                          ids, ide, jds, jde, kds, kde,           &
                          ims, ime, jms, jme, kms, kme,           &
                          its, ite, jts, jte, kts, kte)
 IMPLICIT NONE
 ! input data	
 CHARACTER, INTENT(IN   )                                  :: stag
 REAL, DIMENSION(ims:ime,kms:kme,jms:jme), INTENT(INOUT)   :: var
 INTEGER, DIMENSION(ims:ime,jms:jme), INTENT(IN   )        :: prox,         &
                                                              top
 INTEGER, DIMENSION(3,np), INTENT(IN   )                   :: side            !'side boundary' ghost points		       
 REAL, DIMENSION(ims:ime,jms:jme,6), INTENT(IN   )         :: top_img         ! (x,y,z) location of ghost point and image point of the 'top boundary' ghost points
 REAL, DIMENSION(6,np), INTENT(IN   )                      :: side_img        ! (x,y,z) location of ghost point and image point of the 'side boundary' ghost points						     
 REAL, DIMENSION(ims:ime,jms:jme,0:3*n-1), INTENT(IN   )   :: top_neigh       ! (x,y,z) location of  neighbors 
 REAL, DIMENSION(0:3*n-1,np), INTENT(IN   )                :: side_neigh      ! (x,y,z) location of neighbors							     
 INTEGER, DIMENSION(ims:ime,jms:jme,0:3*n-1), INTENT(IN   ):: top_neigh_i     ! (i,j,k) index of top neighbors
 INTEGER, DIMENSION(0:3*n-1,np), INTENT(IN   )             :: side_neigh_i    ! (i,j,k) location of neighbors							     
 INTEGER, INTENT(IN   )                                    :: dim_terrain, &
                                                              n,           &  ! desired number of nearest neighbors
                                                              np              ! number of side ghost points
 INTEGER, INTENT(IN   )                   :: ids, ide, jds, jde, kds, kde, & ! d: domain m:memory p:patch t:tile
                                             ims, ime, jms, jme, kms, kme, &
                                             its, ite, jts, jte, kts, kte

 !local data
 INTEGER                                                  :: i,j,          &
                                                             nC,S,         &
                                                             info,         &
                                                             i_end,        &
                                                             j_end
 REAL, DIMENSION(n*n)                                     :: matrix
 REAL, DIMENSION(n)                                       :: RHS
 INTEGER, DIMENSION(n)                                    :: ipiv

 !---------------------------------------------------------------------------------
 ! the executable begins here
 CALL wrf_debug(100, 'dyn_em/module_ibm.F/subroutine no_slip_lin')
 ! bilinear or trilinear interpolation 
 ! this is the matrix for 2-d problems
 !	    |1 x_1 z_1 x_1*z_1|  	  |a_1|         |u_1|
 ! matrix = |1 x_2 z_2 x_2*z_2|  a_coef = |a_2|   RHS = |u_2| 
 !	    |1 x_3 z_3 x_3*z_3|  	  |a_3|         |u_3|
 !	    |1 x_4 z_4 x_4*z_4|  	  |a_4|         |u_4|
 ! this is the matrix for 3-d problems
 !	    |1 x_1 y_1 z_1 x_1*y_1 x_1*z_1 y_1*z_1 x_1*y_1*z_1|  	  |a_1|         |u_1|
 !          |1 x_2 y_2 z_2 x_2*y_2 x_2*z_2 y_2*z_2 x_2*y_2*z_2|           |a_2|         |u_2| 
 !	    |1 x_3 y_3 z_3 x_3*y_3 x_3*z_3 y_3*z_3 x_3*y_3*z_3|  	  |a_3|         |u_3|
 ! matrix = |1 x_4 y_4 z_4 x_4*y_4 x_4*z_4 y_4*z_4 x_4*y_4*z_4|  a_coef = |a_4|  RHS =  |u_4|
 !          |1 x_5 y_5 z_5 x_5*y_5 x_5*z_5 y_5*z_5 x_5*y_5*z_5|           |a_5|         |u_5|
 !	    |1 x_6 y_6 z_6 x_6*y_6 x_6*z_6 y_6*z_6 x_6*y_6*z_6|  	  |a_6|         |u_6|
 !          |1 x_7 y_7 z_7 x_7*y_7 x_7*z_7 y_7*z_7 x_7*y_7*z_7|           |a_7|         |u_7| 
 !	    |1 x_8 y_8 z_8 x_8*y_8 x_8*z_8 y_8*z_8 x_8*y_8*z_8|  	  |a_8|         |u_8|
 ! matrix*a_coef = RHS or a_coef=(matrix^-1)*RHS
 !---------------------------------------------------------------------------------

 IF (stag == 'u') THEN
    i_end = ite
    j_end = MIN(jte,jde-1)
 ELSEIF (stag == 'v') THEN
    i_end = MIN(ite,ide-1)
    j_end = jte
 ELSEIF ((stag == 'w').OR.(stag == 't')) THEN
    i_end = MIN(ite,ide-1)
    j_end = MIN(jte,jde-1)
 ENDIF

 DO i=its,i_end
 DO j=jts,j_end 
    if (dim_terrain == 2) then
        matrix = [1., top_neigh(i,j,0), top_neigh(i,j,2), top_neigh(i,j,0)*top_neigh(i,j,2),&
                  1., top_neigh(i,j,3), top_neigh(i,j,5), top_neigh(i,j,3)*top_neigh(i,j,5),&
                  1., top_neigh(i,j,6), top_neigh(i,j,8), top_neigh(i,j,6)*top_neigh(i,j,8),&
                  1., top_neigh(i,j,9), top_neigh(i,j,11),top_neigh(i,j,9)*top_neigh(i,j,11)]
    elseif (dim_terrain == 3) then
        matrix = [1., top_neigh(i,j,0),  top_neigh(i,j,1),  top_neigh(i,j,2),  top_neigh(i,j,0)*top_neigh(i,j,1),   top_neigh(i,j,0)*top_neigh(i,j,2),   top_neigh(i,j,1)*top_neigh(i,j,2),   top_neigh(i,j,0)*top_neigh(i,j,1)*top_neigh(i,j,2),   &
                  1., top_neigh(i,j,3),  top_neigh(i,j,4),  top_neigh(i,j,5),  top_neigh(i,j,3)*top_neigh(i,j,4),   top_neigh(i,j,3)*top_neigh(i,j,5),   top_neigh(i,j,4)*top_neigh(i,j,5),   top_neigh(i,j,3)*top_neigh(i,j,4)*top_neigh(i,j,5),   &
                  1., top_neigh(i,j,6),  top_neigh(i,j,7),  top_neigh(i,j,8),  top_neigh(i,j,6)*top_neigh(i,j,7),   top_neigh(i,j,6)*top_neigh(i,j,8),   top_neigh(i,j,7)*top_neigh(i,j,8),   top_neigh(i,j,6)*top_neigh(i,j,7)*top_neigh(i,j,8),   & 
                  1., top_neigh(i,j,9),  top_neigh(i,j,10), top_neigh(i,j,11), top_neigh(i,j,9)*top_neigh(i,j,10),  top_neigh(i,j,9)*top_neigh(i,j,11),  top_neigh(i,j,10)*top_neigh(i,j,11), top_neigh(i,j,9)*top_neigh(i,j,10)*top_neigh(i,j,11), & 
                  1., top_neigh(i,j,12), top_neigh(i,j,13), top_neigh(i,j,14), top_neigh(i,j,12)*top_neigh(i,j,13), top_neigh(i,j,12)*top_neigh(i,j,14), top_neigh(i,j,13)*top_neigh(i,j,14), top_neigh(i,j,12)*top_neigh(i,j,13)*top_neigh(i,j,14),&
                  1., top_neigh(i,j,15), top_neigh(i,j,16), top_neigh(i,j,17), top_neigh(i,j,15)*top_neigh(i,j,16), top_neigh(i,j,15)*top_neigh(i,j,17), top_neigh(i,j,16)*top_neigh(i,j,17), top_neigh(i,j,15)*top_neigh(i,j,16)*top_neigh(i,j,17),&
                  1., top_neigh(i,j,18), top_neigh(i,j,19), top_neigh(i,j,20), top_neigh(i,j,18)*top_neigh(i,j,19), top_neigh(i,j,18)*top_neigh(i,j,20), top_neigh(i,j,19)*top_neigh(i,j,20), top_neigh(i,j,18)*top_neigh(i,j,19)*top_neigh(i,j,20),&
                  1., top_neigh(i,j,21), top_neigh(i,j,22), top_neigh(i,j,23), top_neigh(i,j,21)*top_neigh(i,j,22), top_neigh(i,j,21)*top_neigh(i,j,23), top_neigh(i,j,22)*top_neigh(i,j,23), top_neigh(i,j,21)*top_neigh(i,j,22)*top_neigh(i,j,23)]
    endif
    DO nC=0,n-1
       if (top_neigh_i(i,j,3*nC+2) == 0) then 
           RHS(nC+1) = 0.
       else     
           RHS(nC+1) = var(top_neigh_i(i,j,3*nC),top_neigh_i(i,j,3*nC+2),top_neigh_i(i,j,3*nC+1))
       endif
    ENDDO       
    if (KIND(matrix) == 4) then
       CALL SGETRF(n,n,matrix,n,ipiv,info)
       !if (info/=0) CALL wrf_error_fatal('LU Factorization')
       if (info/=0) write(*,'(2A20,2i5,64f20.8)') stag,' top LU i,j=',i,j,matrix
       CALL SGETRS('T',n,1,matrix,n,ipiv,RHS,n,info)
       !if (info/=0) CALL wrf_error_fatal('Matrix Solve')
       if (info/=0) write(*,'(2A20,2i5,8f20.8)') stag,' top S i,j=',i,j,RHS
   elseif (KIND(matrix) == 8) then    
       CALL DGETRF(n,n,matrix,n,ipiv,info)
       !if (info/=0) CALL wrf_error_fatal('LU Factorization')
       if (info/=0) write(*,'(2A20,2i5,64f20.8)') stag,' top LU i,j=',i,j,matrix
       CALL DGETRS('T',n,1,matrix,n,ipiv,RHS,n,info)
       !if (info/=0) CALL wrf_error_fatal('Matrix Solve')
       if (info/=0) write(*,'(2A20,2i5,8f20.8)') stag,' top S i,j=',i,j,RHS
   endif 
   if (prox(i,j) == 0) then
       var(i,top(i,j),j)=-RHS(1)
   elseif (prox(i,j) == 1) then
       var(i,top(i,j),j)=RHS(1)
   endif  ! end of setting scalar at ghost point 
 ENDDO
 ENDDO

 if (np > 0) then
    DO S=1,np   
       if (dim_terrain == 2) then 
           matrix = [1., side_neigh(0,S), side_neigh(2,S),  side_neigh(0,S)*side_neigh(2,S),&
                     1., side_neigh(3,S), side_neigh(5,S),  side_neigh(3,S)*side_neigh(5,S),&
                     1., side_neigh(6,S), side_neigh(8,S),  side_neigh(6,S)*side_neigh(8,S),&
                     1., side_neigh(9,S), side_neigh(11,S), side_neigh(9,S)*side_neigh(11,S)]
       elseif (dim_terrain == 3) then
           matrix = [1., side_neigh(0,S),  side_neigh(1,S),  side_neigh(2,S),  side_neigh(0,S)*side_neigh(1,S),   side_neigh(0,S)*side_neigh(2,S),   side_neigh(1,S)*side_neigh(2,S),   side_neigh(0,S)*side_neigh(1,S)*side_neigh(2,S),   &
                     1., side_neigh(3,S),  side_neigh(4,S),  side_neigh(5,S),  side_neigh(3,S)*side_neigh(4,S),   side_neigh(3,S)*side_neigh(5,S),   side_neigh(4,S)*side_neigh(5,S),   side_neigh(3,S)*side_neigh(4,S)*side_neigh(5,S),   &
                     1., side_neigh(6,S),  side_neigh(7,S),  side_neigh(8,S),  side_neigh(6,S)*side_neigh(7,S),   side_neigh(6,S)*side_neigh(8,S),   side_neigh(7,S)*side_neigh(8,S),   side_neigh(6,S)*side_neigh(7,S)*side_neigh(8,S),   &
                     1., side_neigh(9,S),  side_neigh(10,S), side_neigh(11,S), side_neigh(9,S)*side_neigh(10,S),  side_neigh(9,S)*side_neigh(11,S),  side_neigh(10,S)*side_neigh(11,S), side_neigh(9,S)*side_neigh(10,S)*side_neigh(11,S), &
                     1., side_neigh(12,S), side_neigh(13,S), side_neigh(14,S), side_neigh(12,S)*side_neigh(13,S), side_neigh(12,S)*side_neigh(14,S), side_neigh(13,S)*side_neigh(14,S), side_neigh(12,S)*side_neigh(13,S)*side_neigh(14,S),&
                     1., side_neigh(15,S), side_neigh(16,S), side_neigh(17,S), side_neigh(15,S)*side_neigh(16,S), side_neigh(15,S)*side_neigh(17,S), side_neigh(16,S)*side_neigh(17,S), side_neigh(15,S)*side_neigh(16,S)*side_neigh(17,S),&
                     1., side_neigh(18,S), side_neigh(19,S), side_neigh(20,S), side_neigh(18,S)*side_neigh(19,S), side_neigh(18,S)*side_neigh(20,S), side_neigh(19,S)*side_neigh(20,S), side_neigh(18,S)*side_neigh(19,S)*side_neigh(20,S),&
                     1., side_neigh(21,S), side_neigh(22,S), side_neigh(23,S), side_neigh(21,S)*side_neigh(22,S), side_neigh(21,S)*side_neigh(23,S), side_neigh(22,S)*side_neigh(23,S), side_neigh(21,S)*side_neigh(22,S)*side_neigh(23,S)]
       endif
       DO nC=0,n-1
          if (side_neigh_i(3*nC+2,S) == 0) then 
              RHS(nC+1) = 0.
          else 
              RHS(nC+1) = var(side_neigh_i(3*nC,S),side_neigh_i(3*nC+2,S),side_neigh_i(3*nC+1,S))
          endif
       ENDDO
       if (KIND(matrix) == 4) then
           CALL SGETRF(n,n,matrix,n,ipiv,info)
           !if (info/=0) CALL wrf_error_fatal('LU Factorization')
           if (info/=0) write(*,'(2A20,1i5,64f20.8)') stag,' side LU np=',np,matrix
           CALL SGETRS('T',n,1,matrix,n,ipiv,RHS,n,info)
           !if (info/=0) CALL wrf_error_fatal('Matrix Solve')
           if (info/=0) write(*,'(2A20,1i5,8f20.8)') stag,' side S np=',np,RHS
       elseif (KIND(matrix) == 8) then
           CALL DGETRF(n,n,matrix,n,ipiv,info)
           !if (info/=0) CALL wrf_error_fatal('LU Factorization')
           if (info/=0) write(*,'(2A20,1i5,64f20.8)') stag,' side LU np=',np,matrix
           CALL DGETRS('T',n,1,matrix,n,ipiv,RHS,n,info)
           !if (info/=0) CALL wrf_error_fatal('Matrix Solve')
           if (info/=0) write(*,'(2A20,1i5,8f20.8)') stag,' side S np=',np,RHS
       endif 
       var(side(1,S),side(3,S),side(2,S))=-RHS(1) 
    ENDDO 
 endif

 END SUBROUTINE no_slip_lin

!--------------------------------------------------------------------------------

 SUBROUTINE no_slip_inverse_dist_ss ( stag, prox, dim_terrain,                    &
                                      var, varfull, varsave,                      &
                                      mu, mus,                                    &
                                      top,                                        &
                                      side,                                       &
                                      top_neigh, side_neigh,                      &
                                      top_neigh_i, side_neigh_i,                  &
                                      n, np, ant, ans,                            &
                                      ids, ide, jds, jde, kds, kde,               &
                                      ims, ime, jms, jme, kms, kme,               &
                                      its, ite, jts, jte, kts, kte)
 IMPLICIT NONE
 ! input data	
 CHARACTER, INTENT(IN   )                                  :: stag
 REAL, DIMENSION(ims:ime,kms:kme,jms:jme), INTENT(INOUT)   :: var,        &
                                                              varfull
 REAL, DIMENSION(ims:ime,kms:kme,jms:jme), INTENT(IN   )   :: varsave
 REAL, DIMENSION(ims:ime,jms:jme), INTENT(IN   )           :: mu,         &
                                                              mus
 INTEGER, DIMENSION(ims:ime,jms:jme), INTENT(IN   )        :: prox,       &
                                                              top,        &
                                                              ant             ! actual number of nearest neighbors for top points
 INTEGER, DIMENSION(3,np), INTENT(IN   )                   :: side            !'side boundary' ghost points						     
 REAL, DIMENSION(ims:ime,jms:jme,0:3*n-1), INTENT(IN   )   :: top_neigh       ! (x,y,z) location of  neighbors 
 REAL, DIMENSION(0:3*n-1,np), INTENT(IN   )                :: side_neigh      ! (x,y,z) location of neighbors							     
 INTEGER, DIMENSION(ims:ime,jms:jme,0:3*n-1), INTENT(IN   ):: top_neigh_i     ! (i,j,k) index of top neighbors
 INTEGER, DIMENSION(0:3*n-1,np), INTENT(IN   )             :: side_neigh_i    ! (i,j,k) location of neighbors							     
 INTEGER, INTENT(IN   )                                    :: dim_terrain, &
                                                              n,           &  ! desired number of nearest neighbors
                                                              np              ! number of side ghost points
 INTEGER, DIMENSION(np), INTENT(IN   )                     :: ans             ! actual number of nearest neighbor for side points
 INTEGER, INTENT(IN   )                   :: ids, ide, jds, jde, kds, kde, &  ! d: domain m:memory p:patch t:tile
                                             ims, ime, jms, jme, kms, kme, &
                                             its, ite, jts, jte, kts, kte

 !local data
 INTEGER                                                  :: i,j,          &
                                                             nC,S,         &
                                                             i_end,        &
                                                             j_end
 DOUBLE PRECISION                                         :: max_rad, val_img
 DOUBLE PRECISION, DIMENSION(0:n-1)                       :: weight, radius

 !---------------------------------------------------------------------------------
 ! the executable begins here
  CALL wrf_debug(100,'dyn_em/module_ibm.F/subroutine no_slip_inverse_dist_ss')
 !---------------------------------------------------------------------------------

 IF (stag == 'u') THEN
    i_end = ite
    j_end = MIN(jte,jde-1)
 ELSEIF (stag == 'v') THEN
    i_end = MIN(ite,ide-1)
    j_end = jte
 ELSEIF ((stag == 'w').OR.(stag == 't')) THEN
    i_end = MIN(ite,ide-1)
    j_end = MIN(jte,jde-1)
 ENDIF
 DO i=its,i_end
 DO j=jts,j_end 
 
    radius = 0.
    !DO nC=0,n-1
    DO nC = 0,ant(i,j)-1
       ! calculate the radius to image point, and determine the largest radius  
       radius(nC) = SQRT(top_neigh(i,j,3*nC)**2+top_neigh(i,j,3*nC+1)**2+top_neigh(i,j,3*nC+2)**2)
       if (radius(nC)== 0.) radius(nC) = epsilon
    ENDDO
    max_rad = MAXVAL(radius)
    weight = 0.
    val_img = 0.
    !DO nC=0,n-1
    DO nC=0,ant(i,j)-1
       !weight(nC) = ((max_rad-radius(nC))/(max_rad*radius(nC)))**2
       !weight(nC) = ((max_rad-radius(nC))/(max_rad*radius(nC)))
       weight(nC) = ((max_rad-radius(nC))/(max_rad*radius(nC)))**(0.5)
       if (nC == 0) then
          ! zero here for the no-slip value
          val_img = val_img + weight(nC)*0.  
       else
          val_img = val_img + weight(nC)*varfull(top_neigh_i(i,j,3*nC),top_neigh_i(i,j,3*nC+2),top_neigh_i(i,j,3*nC+1))
       endif
       
    ENDDO
    val_img = val_img/SUM(weight)     
    ! calculate the value at the ghost point
    if (prox(i,j) == 0) then
        varfull(i,top(i,j),j)=-val_img
    elseif (prox(i,j) == 1) then
        varfull(i,top(i,j),j)=val_img
    endif  ! end of setting scalar at ghost point 

    if (stag=='u') then
        var(i,top(i,j),j) = varfull(i,top(i,j),j)*0.5*(mus(i,j)+mus(i-1,j)) - varsave(i,top(i,j),j)*mu(i,j)
    elseif (stag=='v') then
        var(i,top(i,j),j) = varfull(i,top(i,j),j)*0.5*(mus(i,j)+mus(i,j-1)) - varsave(i,top(i,j),j)*mu(i,j)
    elseif (stag=='w') then
        var(i,top(i,j),j) = varfull(i,top(i,j),j)*mus(i,j) - varsave(i,top(i,j),j)*mu(i,j)
    endif  
 ENDDO
 ENDDO

 if (np > 0) then 
    DO S=1,np 
       radius = 0.  
       !DO nC=0,n-1
       DO nC=0,ans(S)-1
          ! calculate the radius to image point, and determine the largest radius  
          radius(nC) = SQRT(side_neigh(3*nC,S)**2+side_neigh(3*nC+1,S)**2+side_neigh(3*nC+2,S)**2)
          if (radius(nC)== 0.) radius(nC) = epsilon
       ENDDO
       max_rad = MAXVAL(radius)
       weight = 0.
       val_img = 0.
       !DO nC=0,n-1
       DO nc=0,ans(S)-1
          !weight(nC) = ((max_rad-radius(nC))/(max_rad*radius(nC)))**2
          !weight(nC) = ((max_rad-radius(nC))/(max_rad*radius(nC)))
          weight(nC) = ((max_rad-radius(nC))/(max_rad*radius(nC)))**(0.5)
          if (nC == 0) then
             val_img = val_img + weight(nC)*0.
          else
             val_img = val_img + weight(nC)*varfull(side_neigh_i(3*nC,S),side_neigh_i(3*nC+2,S),side_neigh_i(3*nC+1,S))
          endif
       ENDDO
       val_img = val_img/SUM(weight)     
       ! calculate the value at the ghost point
       varfull(side(1,S),side(3,S),side(2,S))=-val_img
       if (stag=='u') then
           var(side(1,S),side(3,S),side(2,S)) = varfull(side(1,S),side(3,S),side(2,S))*0.5*(mus(side(1,S),side(2,S))+mus(side(1,S)-1,side(2,S))) &
                                              - varsave(side(1,S),side(3,S),side(2,S))*mu(side(1,S),side(2,S))
       elseif (stag=='v') then
           var(side(1,S),side(3,S),side(2,S)) = varfull(side(1,S),side(3,S),side(2,S))*0.5*(mus(side(1,S),side(2,S))+mus(side(1,S),side(2,S)-1)) &
                                              - varsave(side(1,S),side(3,S),side(2,S))*mu(side(1,S),side(2,S))
       elseif (stag=='w') then
           var(side(1,S),side(3,S),side(2,S)) = varfull(side(1,S),side(3,S),side(2,S))*mus(side(1,S),side(2,S)) &
                                              - varsave(side(1,S),side(3,S),side(2,S))*mu(side(1,S),side(2,S))
       endif  
    ENDDO 
 endif

 END SUBROUTINE no_slip_inverse_dist_ss

!-------------------------------------------------------------------------------------------------------------------------------------

 SUBROUTINE no_slip_inverse_dist ( stag, prox,                            &
                                   var,                                   &
                                   top,                                   &
                                   side,                                  &
                                   top_neigh, side_neigh,                 &
                                   top_neigh_i, side_neigh_i,             &
                                   n, np, ant, ans,                       &
                                   ids, ide, jds, jde, kds, kde,          &
                                   ims, ime, jms, jme, kms, kme,          &
                                   its, ite, jts, jte, kts, kte )
 IMPLICIT NONE
 ! input data	
 CHARACTER, INTENT(IN   )                                  :: stag
 REAL, DIMENSION(ims:ime,kms:kme,jms:jme), INTENT(INOUT)   :: var
 INTEGER, DIMENSION(ims:ime,jms:jme), INTENT(IN   )        :: prox,       &
                                                              top,        &
                                                              ant             ! actual number of nearest neighbors for top points
 INTEGER, DIMENSION(3,np), INTENT(IN   )                   :: side            !'side boundary' ghost points					     
 REAL, DIMENSION(ims:ime,jms:jme,0:3*n-1), INTENT(IN   )   :: top_neigh       ! (x,y,z) location of  neighbors 
 REAL, DIMENSION(0:3*n-1,np), INTENT(IN   )                :: side_neigh      ! (x,y,z) location of neighbors							     
 INTEGER, DIMENSION(ims:ime,jms:jme,0:3*n-1), INTENT(IN   ):: top_neigh_i     ! (i,j,k) index of top neighbors
 INTEGER, DIMENSION(0:3*n-1,np), INTENT(IN   )             :: side_neigh_i    ! (i,j,k) location of neighbors							     
 INTEGER, INTENT(IN   )                                    :: n,           &  ! desired number of nearest neighbors
                                                              np              ! number of side ghost points
 INTEGER, DIMENSION(np), INTENT(IN   )                     :: ans             ! actual number of nearest neighbors for side points 						      
 INTEGER, INTENT(IN   )                   :: ids, ide, jds, jde, kds, kde, &  ! d: domain m:memory p:patch t:tile
                                             ims, ime, jms, jme, kms, kme, &
                                             its, ite, jts, jte, kts, kte

 !local data
 INTEGER                                                  :: i,j,          &
                                                             nC,S,         &
                                                             i_end,        &
                                                             j_end
 DOUBLE PRECISION                                         :: max_rad, val_img
 DOUBLE PRECISION, DIMENSION(0:n-1)                       :: weight, radius
 !---------------------------------------------------------------------------------
 ! the executable begins here
 CALL wrf_debug(100, 'dyn_em/module_ibm.F/subroutine no_slip_inverse_dist')
 !---------------------------------------------------------------------------------

 IF (stag == 'u') THEN
    i_end = ite
    j_end = MIN(jte,jde-1)
 ELSEIF (stag == 'v') THEN
    i_end = MIN(ite,ide-1)
    j_end = jte
 ELSEIF ((stag == 'w').OR.(stag == 't')) THEN
    i_end = MIN(ite,ide-1)
    j_end = MIN(jte,jde-1)
 ENDIF

 DO i=its,i_end
 DO j=jts,j_end 
    radius = 0.
    !DO nC=0,n-1
    DO nC=0,ant(i,j)-1
       ! calculate the radius to image point, and determine the largest radius  
       radius(nC) = SQRT(top_neigh(i,j,3*nC)**2+top_neigh(i,j,3*nC+1)**2+top_neigh(i,j,3*nC+2)**2)
       if (radius(nC)== 0.) radius(nC) = epsilon
    ENDDO
    max_rad = MAXVAL(radius)
    weight = 0.
    val_img = 0.
    !DO nC=0,n-1
    DO nC=0,ant(i,j)-1
       !weight(nC) = ((max_rad-radius(nC))/(max_rad*radius(nC)))**2
       !weight(nC) = ((max_rad-radius(nC))/(max_rad*radius(nC)))
       weight(nC) = ((max_rad-radius(nC))/(max_rad*radius(nC)))**(0.5)
       if (nC == 0) then
          val_img = val_img + weight(nC)*0.
       else
          val_img = val_img + weight(nC)*var(top_neigh_i(i,j,3*nC),top_neigh_i(i,j,3*nC+2),top_neigh_i(i,j,3*nC+1))
       endif
    ENDDO
    val_img = val_img/SUM(weight) 
    ! calculate the value at the ghost point
    if (prox(i,j) == 0) then
        var(i,top(i,j),j)=-val_img
    elseif (prox(i,j) == 1) then
        var(i,top(i,j),j)=val_img
    endif  ! end of setting scalar at ghost point 
 ENDDO
 ENDDO

 if (np > 0) then
    DO S=1,np 
       radius = 0.  
       !DO nC=0,n-1
       DO nC=0,ans(S)-1
          ! calculate the radius to image point, and determine the largest radius  
          radius(nC) = SQRT(side_neigh(3*nC,S)**2+side_neigh(3*nC+1,S)**2+side_neigh(3*nC+2,S)**2)
          if (radius(nC)== 0.) radius(nC) = epsilon
       ENDDO
       max_rad = MAXVAL(radius)
       weight = 0.
       val_img = 0.
       !DO nC=0,n-1
       DO nC=0,ans(S)-1
          !weight(nC) = ((max_rad-radius(nC))/(max_rad*radius(nC)))**2
          !weight(nC) = ((max_rad-radius(nC))/(max_rad*radius(nC)))
          weight(nC) = ((max_rad-radius(nC))/(max_rad*radius(nC)))**(0.5)
          if (nC == 0) then
             val_img = val_img + weight(nC)*0.
          else
             val_img = val_img + weight(nC)*var(side_neigh_i(3*nC,S),side_neigh_i(3*nC+2,S),side_neigh_i(3*nC+1,S))
          endif
       ENDDO
       val_img = val_img/SUM(weight)     
       var(side(1,S),side(3,S),side(2,S))=-val_img
    ENDDO 
 endif

 END SUBROUTINE no_slip_inverse_dist

!-------------------------------------------------------------------------------------------------------------------------------------

 SUBROUTINE vel_recon_inverse_dist ( z_rough,                               &
                                     stag, u, v, w,                         &
                                     u_in, v_in, w_in,                      &
                                     top, side,                             &
                                     top_neigh, side_neigh,                 &
                                     top_neigh_i, side_neigh_i,             &
                                     n, np,                                 &
                                     vrm_bound_pt_as_neigh,                 &
                                     top_norm, top_dist,                    &
                                     side_norm, side_dist,                  &
                                     antu_at_p, antv_at_p, antw_at_p,       &
                                     ansu_at_p, ansv_at_p, answ_at_p,       &
                                     ids, ide, jds, jde, kds, kde,          &
                                     ims, ime, jms, jme, kms, kme,          &
                                     its, ite, jts, jte, kts, kte )

 IMPLICIT NONE
 !input data
 REAL, INTENT(IN   )                                       :: z_rough
 CHARACTER, INTENT(IN   )                                  :: stag
 REAL, DIMENSION(ims:ime,kms:kme,jms:jme), INTENT(INOUT)   :: u, v, w
 REAL, DIMENSION(ims:ime,kms:kme,jms:jme), INTENT(IN   )   :: u_in,        &
                                                              v_in,        &
                                                              w_in           !RSA copies of u, v, w before update begins. 
                                                                             !Enables reconstruction pts to be used as nearest neighbors
 INTEGER, DIMENSION(ims:ime,jms:jme), INTENT(IN   )        :: top,         &
                                                              antu_at_p,   & !actual number of nearest neighbors for top points
                                                              antv_at_p,   &
                                                              antw_at_p
 INTEGER, DIMENSION(3,np), INTENT(IN   )                   :: side           !'side boundary' ghost points					     
 REAL, DIMENSION(ims:ime,jms:jme,0:9*n-1), INTENT(IN   )   :: top_neigh      !(x,y,z) location of  neighbors 
 REAL, DIMENSION(0:9*n-1,np), INTENT(IN   )                :: side_neigh     !(x,y,z) location of neighbors
 INTEGER, DIMENSION(ims:ime,jms:jme,0:9*n-1), INTENT(IN   ):: top_neigh_i    !(i,j,k) index of top neighbors
 INTEGER, DIMENSION(0:9*n-1,np), INTENT(IN   )             :: side_neigh_i   !(i,j,k) location of neighbors
 INTEGER, INTENT(IN   )                                    :: n,           & !desired number of nearest neighbors
                                                              np             !number of side ghost points
 LOGICAL, INTENT(IN   )                                    :: vrm_bound_pt_as_neigh !whether to use u,v=0 at boundary as a neighbor
 REAL, DIMENSION(ims:ime,jms:jme,3), INTENT(IN   )         :: top_norm       !surface normal vector
 REAL, DIMENSION(ims:ime,jms:jme,2), INTENT(IN   )         :: top_dist       !distance of reconstruction and interpolation points from boundary
 REAL, DIMENSION(3,np), INTENT(IN   )                      :: side_norm      !surface normal vector
 REAL, DIMENSION(2,np), INTENT(IN   )                     :: side_dist       !distance from surface normal to reconstruction and interpolation point
 INTEGER, DIMENSION(np), INTENT(IN   )                     :: ansu_at_p,   & !actual number of nearest neighbors for side points 
                                                              ansv_at_p,   &
                                                              answ_at_p
 INTEGER, INTENT(IN   )                   :: ids, ide, jds, jde, kds, kde, & !d: domain
                                             ims, ime, jms, jme, kms, kme, & !m: memory
                                             its, ite, jts, jte, kts, kte    !p: patch, t: tile

 !local data                                
 INTEGER                                                  :: i, j,         &
                                                             nC, S,        &
                                                             i_end,        &
                                                             j_end
 DOUBLE PRECISION                                         :: max_rad
 DOUBLE PRECISION, DIMENSION(3)                           :: vel_img
 DOUBLE PRECISION, DIMENSION(3,3)                         :: matrix
 DOUBLE PRECISION, DIMENSION(0:n-1)                       :: weight, radius
 !for lapack routines
! INTEGER                                                  :: info
! INTEGER, DIMENSION(3)					   :: ipiv
! REAL, DIMENSION(336)                                     :: work
 !---------------------------------------------------------------------------------
 !the executable begins here
 CALL wrf_debug(100, 'dyn_em/module_ibm.F/subroutine vel_recon_inverse_dist')
 !---------------------------------------------------------------------------------

 IF (stag == 'u') THEN
    i_end = ite
    j_end = MIN(jte,jde-1)
 ELSEIF (stag == 'v') THEN
    i_end = MIN(ite,ide-1)
    j_end = jte
 ELSEIF ((stag == 'w').OR.(stag == 't')) THEN
    i_end = MIN(ite,ide-1)
    j_end = MIN(jte,jde-1)
 ENDIF
 IF (z_rough .LE. 0.0) THEN
    write(*,'(A,F8.6)') "DJW[module_ibm/vel_recon_inverse_dist]: z_rough=",z_rough
    CALL wrf_error_fatal( "stopped by DJW in module_ibm/vel_recon_inverse_dist" )
 ENDIF

 DO i=its,i_end
 DO j=jts,j_end 

    vel_img = 0.0
    
    !get u velocity at interpolation point 
    radius = 0.0
    DO nC=0,antu_at_p(i,j)-1
       !calculate the radius to image point, and determine the largest radius  
       radius(nC) = SQRT(top_neigh(i,j,3*nC)**2+top_neigh(i,j,3*nC+1)**2+top_neigh(i,j,3*nC+2)**2)
       IF (radius(nC) .EQ. 0.0) radius(nC) = epsilon
    ENDDO
    max_rad = MAXVAL(radius)
    weight = 0.0
    DO nC=0,antu_at_p(i,j)-1
!       weight(nC) = ((max_rad-radius(nC))/(max_rad*radius(nC)))**2
!       weight(nC) = ((max_rad-radius(nC))/(max_rad*radius(nC)))
       weight(nC) = ((max_rad-radius(nC))/(max_rad*radius(nC)))**(0.5)
       IF (nC .EQ. 0) THEN
          IF (vrm_bound_pt_as_neigh .EQ. .false.) weight(nC) = 0.0
          vel_img(1) = vel_img(1) + weight(nC)*0.0
       ELSE
          !RSA changed from u to u_in so that reconstruction pts can be used as
          !nearest neighbors if needed. Since u is updated continuously, we want
          !the interpolation to be based on a copy of u before the update began,
          !(i.e, u_in). If reconstruction pts are not used as neighbors, the
          !code should be unaffected because only reconstruction pts would have
          !been updated in u.
          vel_img(1) = vel_img(1) + weight(nC)*u_in(top_neigh_i(i,j,3*nC),top_neigh_i(i,j,3*nC+2),top_neigh_i(i,j,3*nC+1))
       ENDIF
    ENDDO
    IF (SUM(weight) .EQ. 0.0) THEN
      DO nC=0,antu_at_p(i,j)-1
        write(*,'(A,I1,2(A,I3),A,F11.5)') "DJW[module_ibm/vel_recon_inverse_dist]: 1   nC=",nC,"   i=",i,"   j=",j,"   weight=",weight(nC)
      ENDDO
      CALL wrf_error_fatal("stopped by DJW in module_ibm/vel_recon_inverse_dist")
    ENDIF
    vel_img(1) = vel_img(1)/SUM(weight)

    !get v velocity at interpolation point 
    radius = 0.0
    DO nC=0,antv_at_p(i,j)-1
       !calculate the radius to image point, and determine the largest radius  
       radius(nC) = SQRT(top_neigh(i,j,3*n+3*nC)**2+top_neigh(i,j,3*n+3*nC+1)**2+top_neigh(i,j,3*n+3*nC+2)**2)
       IF (radius(nC) .EQ. 0.0) radius(nC) = epsilon
    ENDDO
    max_rad = MAXVAL(radius)
    weight = 0.0
    DO nC=0,antv_at_p(i,j)-1
!       weight(nC) = ((max_rad-radius(nC))/(max_rad*radius(nC)))**2
!       weight(nC) = ((max_rad-radius(nC))/(max_rad*radius(nC)))
       weight(nC) = ((max_rad-radius(nC))/(max_rad*radius(nC)))**(0.5)
       IF (nC .EQ. 0) THEN
          IF (vrm_bound_pt_as_neigh .EQ. .false.) weight(nC) = 0.0
          vel_img(2) = vel_img(2) + weight(nC)*0.0
       ELSE
          !RSA changed from v to v_in so that reconstruction pts can be used as
          !nearest neighbors if needed. Since v is updated continuously, we want
          !the interpolation to be based on a copy of v before the update began,
          !(i.e, v_in). If reconstruction pts are not used as neighbors, the
          !code should be unaffected because only reconstruction pts would have
          !been updated in v.
          vel_img(2) = vel_img(2) + weight(nC)*v_in(top_neigh_i(i,j,3*n+3*nC),top_neigh_i(i,j,3*n+3*nC+2),top_neigh_i(i,j,3*n+3*nC+1))
       ENDIF
    ENDDO
    IF (SUM(weight) .EQ. 0.0) THEN
      DO nC=0,antv_at_p(i,j)-1
        write(*,'(A,I1,2(A,I3),A,F11.5)') "DJW[module_ibm/vel_recon_inverse_dist]: 2   nC=",nC,"   i=",i,"   j=",j,"   weight=",weight(nC)
      ENDDO
      CALL wrf_error_fatal("stopped by DJW in module_ibm/vel_recon_inverse_dist")
    ENDIF
    vel_img(2) = vel_img(2)/SUM(weight)

    !get w velocity at interpolation point 
    radius = 0.0
    DO nC=0,antw_at_p(i,j)-1
       !calculate the radius to image point, and determine the largest radius  
       radius(nC) = SQRT(top_neigh(i,j,6*n+3*nC)**2+top_neigh(i,j,6*n+3*nC+1)**2+top_neigh(i,j,6*n+3*nC+2)**2)
       IF (radius(nC) .EQ. 0.0) radius(nC) = epsilon
    ENDDO
    max_rad = MAXVAL(radius)
    weight = 0.0
    DO nC=0,antw_at_p(i,j)-1
!       weight(nC) = ((max_rad-radius(nC))/(max_rad*radius(nC)))**2
!       weight(nC) = ((max_rad-radius(nC))/(max_rad*radius(nC)))zx
       weight(nC) = ((max_rad-radius(nC))/(max_rad*radius(nC)))**(0.5)
       IF (nC .EQ. 0) THEN
          IF (vrm_bound_pt_as_neigh .EQ. .false.) weight(nC) = 0.0
          vel_img(3) = vel_img(3) + weight(nC)*0.0
       ELSE
          !RSA changed from w to w_in so that reconstruction pts can be used as
          !nearest neighbors if needed. Since w is updated continuously, we want
          !the interpolation to be based on a copy of w before the update began,
          !(i.e, w_in). If reconstruction pts are not used as neighbors, the
          !code should be unaffected because only reconstruction pts would have
          !been updated in w.
          vel_img(3) = vel_img(3) + weight(nC)*w_in(top_neigh_i(i,j,6*n+3*nC),top_neigh_i(i,j,6*n+3*nC+2),top_neigh_i(i,j,6*n+3*nC+1))
       ENDIF
    ENDDO
    IF (SUM(weight) .EQ. 0.0) THEN
      DO nC=0,antw_at_p(i,j)-1
        write(*,'(A,I1,2(A,I3),A,F11.5)') "DJW[module_ibm/vel_recon_inverse_dist]: 3   nC=",nC,"   i=",i,"   j=",j,"   weight=",weight(nC)
      ENDDO
      CALL wrf_error_fatal("stopped by DJW in module_ibm/vel_recon_inverse_dist")
    ENDIF
    vel_img(3) = vel_img(3)/SUM(weight)

    !calculate the surface normal and tangential components at the interpolation point
    !find the orthonormal basis for the plane representing the immersed boundary
    !the plane is defined as ax+by+cz=0 or n(1)x+n(2)y+n(3)z = 0
    !We know that one vector is the normal vector already calculated
    !to find the second vector set x=1 and y=0 so that [1 0 -a/c] results, then normalize for a unit vector
    !cross these two vectors to find the third
    matrix(1,:) = [1/SQRT(1 + (top_norm(i,j,1)/top_norm(i,j,3))**2), 0., (-top_norm(i,j,1)/top_norm(i,j,3))/SQRT(1 + (top_norm(i,j,1)/top_norm(i,j,3))**2)]
    matrix(2,:) = [top_norm(i,j,2)*matrix(1,3), top_norm(i,j,3)*matrix(1,1) - top_norm(i,j,1)*matrix(1,3), -top_norm(i,j,2)*matrix(1,1)]
    matrix(3,:) = top_norm(i,j,1:3)

    !now vel_img(1) and (2) are along the tangent vectors and vel_img(3) is the surface normal velocity at the interpolation point
    vel_img = MATMUL(matrix,vel_img) 
   
    !calculate the normal and tangential components at the reconstruction point
    !try using linear interpolation for the normal component
    vel_img(3) = vel_img(3)*top_dist(i,j,1)/top_dist(i,j,2)
    
    !try using log law for the tangential components
    IF (top_dist(i,j,1) .LT. z_rough) THEN
       vel_img(1) = 0.0
       vel_img(2) = 0.0
    ELSE
       !RSA note that realistic z0 "z0_phys" as in vel_recon_inverse_dist_ss
       !is not used here because it has not yet been calculated by the
       !physics scheme.
       vel_img(1) = vel_img(1)*LOG(top_dist(i,j,1)/z_rough)/LOG(top_dist(i,j,2)/z_rough)
       vel_img(2) = vel_img(2)*LOG(top_dist(i,j,1)/z_rough)/LOG(top_dist(i,j,2)/z_rough)
    ENDIF

    !now transform back into cartesian coordinates by inverting the transformation matrix 
    !then multiplying the velocities by the inverted tranformation matrix      
!    if (KIND(matrix) == 4) then
!    	CALL SGETRF(3,3,matrix,3,ipiv,info)
!    	CALL SGETRI(3,matrix,3,ipiv,work,336,info)
!    elseif (KIND(matrix) == 8) then    
!    	CALL DGETRF(3,3,matrix,3,ipiv,info)
!    	CALL DGETRI(3,matrix,3,ipiv,work,336,info)
!    endif
    matrix = TRANSPOSE(matrix)
    vel_img = MATMUL(matrix,vel_img)     

    IF (stag == 'u') THEN
       u(i,top(i,j),j) = vel_img(1)
    ELSEIF (stag == 'v') THEN
       v(i,top(i,j),j) = vel_img(2)
    ELSEIF (stag == 'w') THEN
       w(i,top(i,j),j) = vel_img(3)
    ENDIF

 ENDDO
 ENDDO

 IF (np .GT. 0) THEN
    DO S=1,np 

       vel_img = 0.0
       
       radius = 0.0
       DO nC=0,ansu_at_p(S)-1
          !calculate the radius to image point, and determine the largest radius  
          radius(nC) = SQRT(side_neigh(3*nC,S)**2+side_neigh(3*nC+1,S)**2+side_neigh(3*nC+2,S)**2)
          IF (radius(nC) .EQ. 0.0) radius(nC) = epsilon
       ENDDO
       max_rad = MAXVAL(radius)
       weight = 0.0
       DO nC=0,ansu_at_p(S)-1
!          weight(nC) = ((max_rad-radius(nC))/(max_rad*radius(nC)))**2
!          weight(nC) = ((max_rad-radius(nC))/(max_rad*radius(nC)))
          weight(nC) = ((max_rad-radius(nC))/(max_rad*radius(nC)))**(0.5)
          IF (nC .EQ. 0) THEN
             IF (vrm_bound_pt_as_neigh .EQ. .false.) weight(nC) = 0.0
             vel_img(1) = vel_img(1) + weight(nC)*0.0
          ELSE
             !RSA changed from u to u_in so that reconstruction pts can be used as
             !nearest neighbors if needed. Since u is updated continuously, we want
             !the interpolation to be based on a copy of u before the update began,
             !(i.e, u_in). If reconstruction pts are not used as neighbors, the
             !code should be unaffected because only reconstruction pts would have
             !been updated in u.
             vel_img(1) = vel_img(1) + weight(nC)*u_in(side_neigh_i(3*nC,S),side_neigh_i(3*nC+2,S),side_neigh_i(3*nC+1,S))
          ENDIF
       ENDDO
       vel_img(1) = vel_img(1)/SUM(weight)

       radius = 0.0
       DO nC=0,ansv_at_p(S)-1
          !calculate the radius to image point, and determine the largest radius  
          radius(nC) = SQRT(side_neigh(3*n+3*nC,S)**2+side_neigh(3*n+3*nC+1,S)**2+side_neigh(3*n+3*nC+2,S)**2)
          IF (radius(nC) .EQ. 0.0) radius(nC) = epsilon
       ENDDO
       max_rad = MAXVAL(radius)
       weight = 0.0
       DO nC=0,ansv_at_p(S)-1
!          weight(nC) = ((max_rad-radius(nC))/(max_rad*radius(nC)))**2
!          weight(nC) = ((max_rad-radius(nC))/(max_rad*radius(nC)))
          weight(nC) = ((max_rad-radius(nC))/(max_rad*radius(nC)))**(0.5)
          IF (nC .EQ. 0) THEN
             IF (vrm_bound_pt_as_neigh .EQ. .false.) weight(nC) = 0.0
             vel_img(2) = vel_img(2) + weight(nC)*0.0
          ELSE
             !RSA changed from v to v_in so that reconstruction pts can be used as
             !nearest neighbors if needed. Since v is updated continuously, we want
             !the interpolation to be based on a copy of v before the update began,
             !(i.e, v_in). If reconstruction pts are not used as neighbors, the
             !code should be unaffected because only reconstruction pts would have
             !been updated in v.
             vel_img(2) = vel_img(2) + weight(nC)*v_in(side_neigh_i(3*n+3*nC,S),side_neigh_i(3*n+3*nC+2,S),side_neigh_i(3*n+3*nC+1,S))
          ENDIF
       ENDDO
       vel_img(2) = vel_img(2)/SUM(weight)

       radius = 0.0
       DO nC=0,answ_at_p(S)-1
          !calculate the radius to image point, and determine the largest radius  
          radius(nC) = SQRT(side_neigh(6*n+3*nC,S)**2+side_neigh(6*n+3*nC+1,S)**2+side_neigh(6*n+3*nC+2,S)**2)
          IF (radius(nC) .EQ. 0.0) radius(nC) = epsilon
       ENDDO
       max_rad = MAXVAL(radius)
       weight = 0.0
       DO nC=0,answ_at_p(S)-1
!          weight(nC) = ((max_rad-radius(nC))/(max_rad*radius(nC)))**2
!          weight(nC) = ((max_rad-radius(nC))/(max_rad*radius(nC)))
          weight(nC) = ((max_rad-radius(nC))/(max_rad*radius(nC)))**(0.5)
          IF (nC .EQ. 0) THEN
             IF (vrm_bound_pt_as_neigh .EQ. .false.) weight(nC) = 0.0
             vel_img(3) = vel_img(3) + weight(nC)*0.0
          ELSE
             !RSA changed from w to w_in so that reconstruction pts can be used as
             !nearest neighbors if needed. Since w is updated continuously, we want
             !the interpolation to be based on a copy of w before the update began,
             !(i.e, w_in). If reconstruction pts are not used as neighbors, the
             !code should be unaffected because only reconstruction pts would have
             !been updated in w.
             vel_img(3) = vel_img(3) + weight(nC)*w_in(side_neigh_i(6*n+3*nC,S),side_neigh_i(6*n+3*nC+2,S),side_neigh_i(6*n+3*nC+1,S))
          ENDIF
       ENDDO
       vel_img(3) = vel_img(3)/SUM(weight)

       !calculate the surface normal and tangential components at the interpolation point
       !find the orthonormal basis for the plane representing the immersed boundary
       !the plane is defined as ax+by+cz=0 or n(1)x+n(2)y+n(3)z = 0
       !We know that one vector is the normal vector already calculated
       !to find the second vector set x=1 and y=0 so that [1 0 -a/c] results, then normalize for a unit vector
       !cross these two vectors to find the third
       matrix(1,:) = [1/SQRT(1 + (side_norm(1,S)/side_norm(3,S))**2), 0.0, (-side_norm(1,S)/side_norm(3,S))/SQRT(1 + (side_norm(1,S)/side_norm(3,S))**2)]
       matrix(2,:) = [side_norm(2,S)*matrix(1,3), side_norm(3,S)*matrix(1,1) - side_norm(1,S)*matrix(1,3), -side_norm(2,S)*matrix(1,1)]
       matrix(3,:) = side_norm(1:3,S)

       !now vel_img(1) and (2) are along the tangent vectors and vel_img(3) is the surface normal velocity at the interpolation point
       vel_img = MATMUL(matrix,vel_img) 

       !calculate the normal and tangential components at the reconstruction point
       !try using linear interpolation for the normal component
       vel_img(3) = vel_img(3)*side_dist(1,S)/side_dist(2,S)
       !try using log law for the tangential components
       IF (side_dist(1,S) .LT. z_rough) THEN
          vel_img(1) = 0.0
          vel_img(2) = 0.0
       ELSE
          !RSA note that realistic z0 "z0_phys" as in vel_recon_inverse_dist_ss
          !is not used here because it has not yet been calculated by the
          !physics scheme.
          vel_img(1) = vel_img(1)*LOG(side_dist(1,S)/z_rough)/LOG(side_dist(2,S)/z_rough)
          vel_img(2) = vel_img(2)*LOG(side_dist(1,S)/z_rough)/LOG(side_dist(2,S)/z_rough)
       ENDIF

       !now transform back into cartesian coordinates by inverting the transformation matrix 
       !then multiplying the velocities by the inverted tranformation matrix      
       !if (KIND(matrix) == 4) then
       !	CALL SGETRF(3,3,matrix,3,ipiv,info)
       !	CALL SGETRI(3,matrix,3,ipiv,work,336,info)
       !elseif (KIND(matrix) == 8) then    
       !	CALL DGETRF(3,3,matrix,3,ipiv,info)
       !	CALL DGETRI(3,matrix,3,ipiv,work,336,info)
       !endif
       matrix = TRANSPOSE(matrix)
       vel_img = MATMUL(matrix,vel_img)     

       IF (stag .EQ. 'u') THEN
          u(side(1,S),side(3,S),side(2,S)) = vel_img(1)
       ELSEIF (stag .EQ. 'v') THEN
          v(side(1,S),side(3,S),side(2,S)) = vel_img(2)
       ELSEIF (stag .EQ. 'w') THEN
          w(side(1,S),side(3,S),side(2,S)) = vel_img(3)
       ENDIF

    ENDDO 
 endif

 END SUBROUTINE vel_recon_inverse_dist

!-------------------------------------------------------------------------------------------------------------------------------------

 SUBROUTINE vel_recon_inverse_dist_ss ( z_rough,                         &
                                        z0_phys,                         &
                                        ideal_terrain,                   &
                                        stag, u, v, w,                   &
                                        u_in, v_in, w_in,                &
                                        var, varsave,                    &
                                        mu, mus,                         &
                                        top, side,                       &
                                        top_neigh, side_neigh,           &
                                        top_neigh_i, side_neigh_i,       &
                                        n, np,                           &
                                        vrm_bound_pt_as_neigh,           &
                                        zero_within_z_rough,             &
                                        top_norm, top_dist,              &
                                        side_norm, side_dist,            &
                                        antu_at_p, antv_at_p, antw_at_p, &
                                        ansu_at_p, ansv_at_p, answ_at_p, &
                                        ids, ide, jds, jde, kds, kde,    &
                                        ims, ime, jms, jme, kms, kme,    &
                                        its, ite, jts, jte, kts, kte )

 IMPLICIT NONE
 !input data
 REAL, INTENT(IN   )                                       :: z_rough
 REAL, DIMENSION(ims:ime,jms:jme), INTENT(IN   )           :: z0_phys !RSA z0 from land surface data
 INTEGER, INTENT(IN   )                                    :: ideal_terrain !RSA to use z0_phys for certain ideal_terrain cases
 CHARACTER, INTENT(IN   )                                  :: stag
 REAL, DIMENSION(ims:ime,kms:kme,jms:jme), INTENT(INOUT)   :: u, v, w,    &
                                                              var
 REAL, DIMENSION(ims:ime,kms:kme,jms:jme), INTENT(IN   )   :: varsave
 REAL, DIMENSION(ims:ime,kms:kme,jms:jme), INTENT(IN   )   :: u_in,        &
                                                              v_in,        &
                                                              w_in           !RSA copies of u, v, w before update begins. 
                                                                             !Enables reconstruction pts to be used as nearest neighbors
 REAL, DIMENSION(ims:ime,jms:jme), INTENT(IN   )           :: mu,         &
                                                              mus
 INTEGER, DIMENSION(ims:ime,jms:jme), INTENT(IN   )        :: top,        &
                                                              antu_at_p,  & !actual number of nearest neighbors for top points
                                                              antv_at_p,  &
                                                              antw_at_p
 INTEGER, DIMENSION(3,np), INTENT(IN   )                   :: side          !'side boundary' ghost points					     
 REAL, DIMENSION(ims:ime,jms:jme,0:9*n-1), INTENT(IN   )   :: top_neigh     !(x,y,z) location of  neighbors 
 REAL, DIMENSION(0:9*n-1,np), INTENT(IN   )                :: side_neigh    !(x,y,z) location of neighbors							     
 INTEGER, DIMENSION(ims:ime,jms:jme,0:9*n-1), INTENT(IN   ):: top_neigh_i   !(i,j,k) index of top neighbors
 INTEGER, DIMENSION(0:9*n-1,np), INTENT(IN   )             :: side_neigh_i  !(i,j,k) location of neighbors							     
 INTEGER, INTENT(IN   )                                    :: n,          & !desired number of nearest neighbors
                                                              np            !number of side ghost points
 LOGICAL, INTENT(IN   )                                    :: vrm_bound_pt_as_neigh, & !whether to use u,v=0 at boundary as a neighbor
                                                              zero_within_z_rough      !whether to set u,v=0 if top_dist of recon pt is less than z_rough
 REAL, DIMENSION(ims:ime,jms:jme,3), INTENT(IN   )         :: top_norm      !surface normal vector
 REAL, DIMENSION(ims:ime,jms:jme,2), INTENT(IN   )         :: top_dist      !distance of reconstruction and interpolation points from boundary
 REAL, DIMENSION(3,np), INTENT(IN   )                      :: side_norm     !surface normal vector
 REAL, DIMENSION(2,np), INTENT(IN   )                      :: side_dist     !distance from surface normal to reconstruction and interpolation point
 INTEGER, DIMENSION(np), INTENT(IN   )                     :: ansu_at_p,  & !actual number of nearest neighbors for side points 
                                                              ansv_at_p,  &
                                                              answ_at_p
 INTEGER, INTENT(IN   )                  :: ids, ide, jds, jde, kds, kde, & !d: domain
                                            ims, ime, jms, jme, kms, kme, & !m: memory
                                            its, ite, jts, jte, kts, kte    !p: patch, t: tile

 !local data
 INTEGER                                                  :: i, j,        &
                                                             nC, S,       &
                                                             i_end,       &
                                                             j_end
 DOUBLE PRECISION                                         :: max_rad
 DOUBLE PRECISION, DIMENSION(3)                           :: vel_img, vel_img_temp
 DOUBLE PRECISION, DIMENSION(3,3)                         :: matrix
 DOUBLE PRECISION, DIMENSION(0:n-1)                       :: weight, radius
 REAL                                                     :: z0_tmp !RSA
 !for lapack routines
! INTEGER                                                  :: info
! INTEGER, DIMENSION(3)                                    :: ipiv
! REAL, DIMENSION(336)                                     :: work

 !---------------------------------------------------------------------------------
 !the executable begins here
 CALL wrf_debug(100, 'dyn_em/module_ibm.F/subroutine vel_recon_inverse_dist_ss')
 !---------------------------------------------------------------------------------

 IF (stag .EQ. 'u') THEN
    i_end = ite
    j_end = MIN(jte,jde-1)
 ELSEIF (stag .EQ. 'v') THEN
    i_end = MIN(ite,ide-1)
    j_end = jte
 ELSEIF ((stag .EQ. 'w') .OR. (stag .EQ. 't')) THEN
    i_end = MIN(ite,ide-1)
    j_end = MIN(jte,jde-1)
 ENDIF

 DO i=its,i_end
 DO j=jts,j_end 

    !RSA for Granite Mountain case (ideal_terrain = 14), use spatially varying z0 from land
    !surface data (determined using VEGPARM.TBL). Otherwise use z_rough from the
    !namelist. 
    IF (ideal_terrain .EQ. 14) THEN
       z0_tmp = z0_phys(i,j)
    ELSE
       z0_tmp = z_rough
    ENDIF
    IF (z0_tmp .LE. 0.0) THEN
       write(*,'(A,F8.6)') "DJW[module_ibm/vel_recon_inverse_dist_ss]: z0_tmp=",z0_tmp
       CALL wrf_error_fatal( "stopped by DJW in module_ibm/vel_recon_inverse_dist_ss" )
    ENDIF
 
    vel_img = 0.0
    
    !get u velocity at interpolation point 
    radius = 0.0
    DO nC=0,antu_at_p(i,j)-1
       !calculate the radius to image point, and determine the largest radius  
       radius(nC) = SQRT(top_neigh(i,j,3*nC)**2+top_neigh(i,j,3*nC+1)**2+top_neigh(i,j,3*nC+2)**2)
       IF (radius(nC) .EQ. 0.0) radius(nC) = epsilon
    ENDDO
    max_rad = MAXVAL(radius)
    weight = 0.0
    DO nC=0,antu_at_p(i,j)-1
!       weight(nC) = ((max_rad-radius(nC))/(max_rad*radius(nC)))**2
!       weight(nC) = ((max_rad-radius(nC))/(max_rad*radius(nC)))
       IF (radius(nC) .LE. 0.001) THEN
          !DJW if the IP is aligned with a grid-point then radius is 0 and we
          !    end up dividing by 0 when calculating the weight...
          weight = 0.0
          weight(nC) = 1.0
          vel_img(1) = u_in(top_neigh_i(i,j,3*nC),top_neigh_i(i,j,3*nC+2),top_neigh_i(i,j,3*nC+1))
          GOTO 100
       ELSE
          weight(nC) = ((max_rad-radius(nC))/(max_rad*radius(nC)))**(0.5)
          IF (nC .EQ. 0) THEN
             IF (vrm_bound_pt_as_neigh .EQ. .false.) weight(nC) = 0.0
             vel_img(1) = vel_img(1) + weight(nC)*0.0
          ELSE
             !RSA changed from u to u_in so that reconstruction pts can be used as
             !nearest neighbors if needed. Since u is updated continuously, we want
             !the interpolation to be based on a copy of u before the update began,
             !(i.e, u_in). If reconstruction pts are not used as neighbors, the
             !code should be unaffected because only reconstruction pts would have
             !been updated in u.
             vel_img(1) = vel_img(1) + weight(nC)*u_in(top_neigh_i(i,j,3*nC),top_neigh_i(i,j,3*nC+2),top_neigh_i(i,j,3*nC+1))
          ENDIF
       ENDIF
    ENDDO
100 vel_img(1) = vel_img(1)/SUM(weight)
    
    !get v velocity at interpolation point 
    radius = 0.0
    DO nC=0,antv_at_p(i,j)-1
       !calculate the radius to image point, and determine the largest radius  
       radius(nC) = SQRT(top_neigh(i,j,3*n+3*nC)**2+top_neigh(i,j,3*n+3*nC+1)**2+top_neigh(i,j,3*n+3*nC+2)**2)
       IF (radius(nC) .EQ. 0.0) radius(nC) = epsilon
    ENDDO
    max_rad = MAXVAL(radius)
    weight = 0.0
    DO nC=0,antv_at_p(i,j)-1
!       weight(nC) = ((max_rad-radius(nC))/(max_rad*radius(nC)))**2
!       weight(nC) = ((max_rad-radius(nC))/(max_rad*radius(nC)))
       IF (radius(nC) .LE. 0.001) THEN
          !DJW if the IP is aligned with a grid-point then radius is 0 and we
          !    end up dividing by 0 when calculating the weight...
          weight = 0.0
          weight(nC) = 1.0
          vel_img(2) = v_in(top_neigh_i(i,j,3*n+3*nC),top_neigh_i(i,j,3*n+3*nC+2),top_neigh_i(i,j,3*n+3*nC+1))
          GOTO 200
       ELSE
          weight(nC) = ((max_rad-radius(nC))/(max_rad*radius(nC)))**(0.5)
          IF (nC .EQ. 0) THEN
             IF (vrm_bound_pt_as_neigh .EQ. .false.) weight(nC) = 0.0
             vel_img(2) = vel_img(2) + weight(nC)*0.0
          ELSE
             !RSA changed from v to v_in so that reconstruction pts can be used as
             !nearest neighbors if needed. Since v is updated continuously, we want
             !the interpolation to be based on a copy of v before the update began,
             !(i.e, v_in). If reconstruction pts are not used as neighbors, the
             !code should be unaffected because only reconstruction pts would have
             !been updated in v.
             vel_img(2) = vel_img(2) + weight(nC)*v_in(top_neigh_i(i,j,3*n+3*nC),top_neigh_i(i,j,3*n+3*nC+2),top_neigh_i(i,j,3*n+3*nC+1))
          ENDIF
       ENDIF
    ENDDO
200 vel_img(2) = vel_img(2)/SUM(weight)

    !get w velocity at interpolation point 
    radius = 0.0
    DO nC=0,antw_at_p(i,j)-1
       !calculate the radius to image point, and determine the largest radius  
       radius(nC) = SQRT(top_neigh(i,j,6*n+3*nC)**2+top_neigh(i,j,6*n+3*nC+1)**2+top_neigh(i,j,6*n+3*nC+2)**2)
       IF (radius(nC) .EQ. 0.0) radius(nC) = epsilon
    ENDDO
    max_rad = MAXVAL(radius)
    weight = 0.0
    DO nC=0,antw_at_p(i,j)-1
!       weight(nC) = ((max_rad-radius(nC))/(max_rad*radius(nC)))**2
!       weight(nC) = ((max_rad-radius(nC))/(max_rad*radius(nC)))
       IF (radius(nC) .LE. 0.001) THEN
          !DJW if the IP is aligned with a grid-point then radius is 0 and we
          !    end up dividing by 0 when calculating the weight...
          weight = 0.0
          weight(nC) = 1.0
          vel_img(3) = w_in(top_neigh_i(i,j,6*n+3*nC),top_neigh_i(i,j,6*n+3*nC+2),top_neigh_i(i,j,6*n+3*nC+1))
          GOTO 300
       ELSE
          weight(nC) = ((max_rad-radius(nC))/(max_rad*radius(nC)))**(0.5)
          IF (nC .EQ. 0) THEN
             IF (vrm_bound_pt_as_neigh .EQ. .false.) weight(nC) = 0.0
             vel_img(3) = vel_img(3) + weight(nC)*0.0
          ELSE
             !RSA changed from w to w_in so that reconstruction pts can be used as
             !nearest neighbors if needed. Since w is updated continuously, we want
             !the interpolation to be based on a copy of w before the update began,
             !(i.e, w_in). If reconstruction pts are not used as neighbors, the
             !code should be unaffected because only reconstruction pts would have
             !been updated in w.
             vel_img(3) = vel_img(3) + weight(nC)*w_in(top_neigh_i(i,j,6*n+3*nC),top_neigh_i(i,j,6*n+3*nC+2),top_neigh_i(i,j,6*n+3*nC+1))
          ENDIF
       ENDIF
    ENDDO
300 vel_img(3) = vel_img(3)/SUM(weight)

    !calculate the surface normal and tangential components at the interpolation point
    !find the orthonormal basis for the plane representing the immersed boundary
    !the plane is defined as ax+by+cz=0 or n(1)x+n(2)y+n(3)z = 0
    !We know that one vector is the normal vector already calculated
    !to find the second vector set x=1 and y=0 so that [1 0 -a/c] results, then normalize for a unit vector
    !cross these two vectors to find the third
    matrix(1,:) = [1/SQRT(1 + (top_norm(i,j,1)/top_norm(i,j,3))**2), 0.0, (-top_norm(i,j,1)/top_norm(i,j,3))/SQRT(1 + (top_norm(i,j,1)/top_norm(i,j,3))**2)]
    matrix(2,:) = [top_norm(i,j,2)*matrix(1,3), top_norm(i,j,3)*matrix(1,1) - top_norm(i,j,1)*matrix(1,3), -top_norm(i,j,2)*matrix(1,1)]
    matrix(3,:) = top_norm(i,j,1:3)

    !now vel_img(1) and (2) are along the tangent vectors and vel_img(3) is the
    !surface normal velocity at the interpolation point
    vel_img = MATMUL(matrix,vel_img)

    !calculate the normal and tangential components at the reconstruction point
    !try using linear interpolation for the normal component
    vel_img(3) = vel_img(3)*top_dist(i,j,1)/top_dist(i,j,2)
    !try using log law for the tangential components
    !RSA changed from z_rough to z0_tmp to enable use of realistic z0 values
    !for Granite Mountain case
    !IF (top_dist(i,j,1) .LT. z0_tmp) THEN
    IF ((zero_within_z_rough) .and. (top_dist(i,j,1) .LT. z0_tmp)) THEN
       vel_img(1) = 0.0
       vel_img(2) = 0.0
    ELSE
       vel_img(1) = vel_img(1)*LOG(top_dist(i,j,1)/z0_tmp)/LOG(top_dist(i,j,2)/z0_tmp)
       vel_img(2) = vel_img(2)*LOG(top_dist(i,j,1)/z0_tmp)/LOG(top_dist(i,j,2)/z0_tmp)    
    ENDIF

    !now transform back into cartesian coordinates by inverting the transformation matrix 
    !then multiplying the velocities by the inverted tranformation matrix      
!    IF (KIND(matrix) .EQ. 4) THEN
!       CALL SGETRF(3,3,matrix,3,ipiv,info)
!       CALL SGETRI(3,matrix,3,ipiv,work,336,info)
!    ELSEIF (KIND(matrix) .EQ. 8) THEN
!       CALL DGETRF(3,3,matrix,3,ipiv,info)
!       CALL DGETRI(3,matrix,3,ipiv,work,336,info)
!    ENDIF
    matrix = TRANSPOSE(matrix)
    vel_img = MATMUL(matrix,vel_img)
        
    IF (stag .EQ. 'u') THEN
       u(i,top(i,j),j) = vel_img(1)       
       var(i,top(i,j),j) = u(i,top(i,j),j)*0.5*(mus(i,j)+mus(i-1,j)) - varsave(i,top(i,j),j)*mu(i,j)
    ELSEIF (stag .EQ. 'v') THEN    
       v(i,top(i,j),j) = vel_img(2)
       var(i,top(i,j),j) = v(i,top(i,j),j)*0.5*(mus(i,j)+mus(i,j-1)) - varsave(i,top(i,j),j)*mu(i,j)
    ELSEIF (stag .EQ. 'w') THEN
       w(i,top(i,j),j) = vel_img(3)
       var(i,top(i,j),j) = w(i,top(i,j),j)*mus(i,j) - varsave(i,top(i,j),j)*mu(i,j)      
    ENDIF

 ENDDO
 ENDDO

 IF (np .GT. 0) THEN
    DO S=1,np 

       !RSA for Granite Mountain case (ideal_terrain = 14), use spatially varying z0 from land
       !surface data (determined using VEGPARM.TBL). Otherwise use z_rough from the
       !namelist.
       IF (ideal_terrain .EQ. 14) THEN
          z0_tmp = z0_phys(side(1,S),side(2,S))
       ELSE
          z0_tmp = z_rough
       ENDIF
       IF (z0_tmp .LE. 0.0) THEN
          write(*,'(A,F8.6)') "DJW[module_ibm/vel_recon_inverse_dist_ss]: z0_tmp=",z0_tmp
          CALL wrf_error_fatal( "stopped by DJW in module_ibm/vel_recon_inverse_dist_ss" )
       ENDIF

       vel_img = 0.0
       
       radius = 0.0
       DO nC=0,ansu_at_p(S)-1
          !calculate the radius to image point, and determine the largest radius  
          radius(nC) = SQRT(side_neigh(3*nC,S)**2+side_neigh(3*nC+1,S)**2+side_neigh(3*nC+2,S)**2)
          IF (radius(nC) .EQ. 0.0) radius(nC) = epsilon
       ENDDO
       max_rad = MAXVAL(radius)
       weight = 0.0
       DO nC=0,ansu_at_p(S)-1
!          weight(nC) = ((max_rad-radius(nC))/(max_rad*radius(nC)))**2
!          weight(nC) = ((max_rad-radius(nC))/(max_rad*radius(nC)))
          weight(nC) = ((max_rad-radius(nC))/(max_rad*radius(nC)))**(0.5)
          IF (nC .EQ. 0) THEN
             IF (vrm_bound_pt_as_neigh .EQ. .false.) weight(nC) = 0.0
             vel_img(1) = vel_img(1) + weight(nC)*0.0
          ELSE
             !RSA changed from u to u_in so that reconstruction pts can be used as
             !nearest neighbors if needed. Since u is updated continuously, we want
             !the interpolation to be based on a copy of u before the update began,
             !(i.e, u_in). If reconstruction pts are not used as neighbors, the
             !code should be unaffected because only reconstruction pts would have
             !been updated in u.
             vel_img(1) = vel_img(1) + weight(nC)*u_in(side_neigh_i(3*nC,S),side_neigh_i(3*nC+2,S),side_neigh_i(3*nC+1,S))
          ENDIF
       ENDDO
       vel_img(1) = vel_img(1)/SUM(weight)

       radius = 0.0
       DO nC=0,ansv_at_p(S)-1
          !calculate the radius to image point, and determine the largest radius  
          radius(nC) = SQRT(side_neigh(3*n+3*nC,S)**2+side_neigh(3*n+3*nC+1,S)**2+side_neigh(3*n+3*nC+2,S)**2)
          IF (radius(nC) .EQ. 0.0) radius(nC) = epsilon
       ENDDO
       max_rad = MAXVAL(radius)
       weight = 0.0
       DO nC=0,ansv_at_p(S)-1
!          weight(nC) = ((max_rad-radius(nC))/(max_rad*radius(nC)))**2
!          weight(nC) = ((max_rad-radius(nC))/(max_rad*radius(nC)))
          weight(nC) = ((max_rad-radius(nC))/(max_rad*radius(nC)))**(0.5)
          IF (nC .EQ. 0) THEN
             IF (vrm_bound_pt_as_neigh .EQ. .false.) weight(nC) = 0.0
             vel_img(2) = vel_img(2) + weight(nC)*0.0
          ELSE
             !RSA changed from v to v_in so that reconstruction pts can be used as
             !nearest neighbors if needed. Since v is updated continuously, we want
             !the interpolation to be based on a copy of v before the update began,
             !(i.e, v_in). If reconstruction pts are not used as neighbors, the
             !code should be unaffected because only reconstruction pts would have
             !been updated in v.
             vel_img(2) = vel_img(2) + weight(nC)*v_in(side_neigh_i(3*n+3*nC,S),side_neigh_i(3*n+3*nC+2,S),side_neigh_i(3*n+3*nC+1,S))
          ENDIF
       ENDDO
       vel_img(2) = vel_img(2)/SUM(weight)      

       radius = 0.0
       DO nC=0,answ_at_p(S)-1
          !calculate the radius to image point, and determine the largest radius  
          radius(nC) = SQRT(side_neigh(6*n+3*nC,S)**2+side_neigh(6*n+3*nC+1,S)**2+side_neigh(6*n+3*nC+2,S)**2)
          IF (radius(nC) .EQ. 0.0) radius(nC) = epsilon
       ENDDO
       max_rad = MAXVAL(radius)
       weight = 0.0
       DO nC=0,answ_at_p(S)-1
!          weight(nC) = ((max_rad-radius(nC))/(max_rad*radius(nC)))**2
!          weight(nC) = ((max_rad-radius(nC))/(max_rad*radius(nC)))
          weight(nC) = ((max_rad-radius(nC))/(max_rad*radius(nC)))**(0.5)
          IF (nC .EQ. 0) THEN
             IF (vrm_bound_pt_as_neigh .EQ. .false.) weight(nC) = 0.0
             vel_img(3) = vel_img(3) + weight(nC)*0.0
          ELSE
             !RSA changed from w to w_in so that reconstruction pts can be used as
             !nearest neighbors if needed. Since w is updated continuously, we want
             !the interpolation to be based on a copy of w before the update began,
             !(i.e, w_in). If reconstruction pts are not used as neighbors, the
             !code should be unaffected because only reconstruction pts would have
             !been updated in w.
             vel_img(3) = vel_img(3) + weight(nC)*w_in(side_neigh_i(6*n+3*nC,S),side_neigh_i(6*n+3*nC+2,S),side_neigh_i(6*n+3*nC+1,S))
          ENDIF
       ENDDO
       vel_img(3) = vel_img(3)/SUM(weight)

       !calculate the surface normal and tangential components at the interpolation point
       !find the orthonormal basis for the plane representing the immersed boundary
       !the plane is defined as ax+by+cz=0 or n(1)x+n(2)y+n(3)z = 0
       !We know that one vector is the normal vector already calculated
       !to find the second vector set x=1 and y=0 so that [1 0 -a/c] results, then normalize for a unit vector
       !cross these two vectors to find the third
       matrix(1,:) = [1/SQRT(1 + (side_norm(1,S)/side_norm(3,S))**2), 0.0, (-side_norm(1,S)/side_norm(3,S))/SQRT(1 + (side_norm(1,S)/side_norm(3,S))**2)]
       matrix(2,:) = [side_norm(2,S)*matrix(1,3), side_norm(3,S)*matrix(1,1) - side_norm(1,S)*matrix(1,3), -side_norm(2,S)*matrix(1,1)]
       matrix(3,:) = side_norm(1:3,S)

       !now vel_img(1) and (2) are along the tangent vectors and vel_img(3) is the
       !surface normal velocity at the interpolation point
       vel_img = MATMUL(matrix,vel_img) 

       !calculate the normal and tangential components at the reconstruction point
       !try using linear interpolation for the normal component
       vel_img(3) = vel_img(3)*side_dist(1,S)/side_dist(2,S)
       !try using log law for the tangential components
       !RSA changed from z_rough to z0_tmp to enable use of realistic z0 values
       !for Granite Mountain case
       !IF (side_dist(1,S) .LT. z0_tmp) THEN
       IF ((zero_within_z_rough) .and. (side_dist(1,S) .LT. z0_tmp)) THEN
          vel_img(1) = 0.0
          vel_img(2) = 0.0
       ELSE
          vel_img(1) = vel_img(1)*LOG(side_dist(1,S)/z0_tmp)/LOG(side_dist(2,S)/z0_tmp)
          vel_img(2) = vel_img(2)*LOG(side_dist(1,S)/z0_tmp)/LOG(side_dist(2,S)/z0_tmp)
       ENDIF

       !now transform back into cartesian coordinates by inverting the transformation matrix 
       !then multiplying the velocities by the inverted tranformation matrix      
!       IF (KIND(matrix) .EQ. 4) THEN
!          CALL SGETRF(3,3,matrix,3,ipiv,info)
!          CALL SGETRI(3,matrix,3,ipiv,work,336,info)
!       ELSEIF (KIND(matrix) .EQ. 8) THEN
!          CALL DGETRF(3,3,matrix,3,ipiv,info)
!          CALL DGETRI(3,matrix,3,ipiv,work,336,info)
!       ENDIF
       matrix = TRANSPOSE(matrix)
       vel_img = MATMUL(matrix,vel_img)     

       IF (stag .EQ. 'u') THEN
          u(side(1,S),side(3,S),side(2,S)) = vel_img(1)
          var(side(1,S),side(3,S),side(2,S)) = u(side(1,S),side(3,S),side(2,S))*0.5*(mus(side(1,S),side(2,S))+mus(side(1,S)-1,side(2,S))) &
                                             - varsave(side(1,S),side(3,S),side(2,S))*mu(side(1,S),side(2,S))
       ELSEIF (stag .EQ. 'v') THEN
          v(side(1,S),side(3,S),side(2,S)) = vel_img(2)
          var(side(1,S),side(3,S),side(2,S)) = v(side(1,S),side(3,S),side(2,S))*0.5*(mus(side(1,S),side(2,S))+mus(side(1,S),side(2,S)-1)) &
                                             - varsave(side(1,S),side(3,S),side(2,S))*mu(side(1,S),side(2,S))
       ELSEIF (stag .EQ. 'w') THEN
          w(side(1,S),side(3,S),side(2,S)) = vel_img(3)
          var(side(1,S),side(3,S),side(2,S)) = w(side(1,S),side(3,S),side(2,S))*mus(side(1,S),side(2,S)) &
                                             - varsave(side(1,S),side(3,S),side(2,S))*mu(side(1,S),side(2,S))
       ENDIF

    ENDDO 
 ENDIF

 END SUBROUTINE vel_recon_inverse_dist_ss
 
!----------------------------------------------------------------------------------------------------------------- 

 SUBROUTINE vel_recon_inverse_dist_temp ( ibm_temp, ibm_temp_3,        &
                                          varsave, var, varfull,        &
                                          mut, muts, grad,              &
                                          h_diabatic,                   &
                                          number_of_small_timesteps,    &
                                          dts, rk_step, rk_order,       &
                                          top, side,                    &
                                          top_neigh, side_neigh,        &
                                          top_neigh_i, side_neigh_i,    &
                                          n, np,                        &
                                          top_norm, top_dist,           &
                                          side_norm, side_dist,         &
                                          antt_at_s, anst_at_s,         &
                                          ids, ide, jds, jde, kds, kde, &
                                          ims, ime, jms, jme, kms, kme, &
                                          its, ite, jts, jte, kts, kte )

 IMPLICIT NONE
 !input data
 INTEGER, INTENT(IN   )                                      :: ibm_temp
 REAL, INTENT(IN   )                                         :: ibm_temp_3
 REAL, DIMENSION(ims:ime,kms:kme,jms:jme), INTENT(IN   )     :: varsave,    &
                                                                h_diabatic
 REAL, DIMENSION(ims:ime,kms:kme,jms:jme), INTENT(INOUT)     :: var,        &
                                                                varfull
 REAL, DIMENSION(ims:ime,jms:jme), INTENT(IN   )             :: mut,        &
                                                                muts,       &
                                                                grad
 INTEGER, DIMENSION(ims:ime,jms:jme), INTENT(IN   )          :: top,        &
                                                                antt_at_s     !actual number of nearest neighbors for top points
 INTEGER, DIMENSION(3,np), INTENT(IN   )                     :: side          !'side boundary' ghost points
 REAL, DIMENSION(ims:ime,jms:jme,6*n:9*n-1), INTENT(IN   )   :: top_neigh     !(x,y,z) location of  neighbors
 REAL, DIMENSION(0:3*n-1,np), INTENT(IN   )                  :: side_neigh    !(x,y,z) location of neighbors
 INTEGER, DIMENSION(ims:ime,jms:jme,6*n:9*n-1), INTENT(IN   ):: top_neigh_i   !(i,j,k) index of top neighbors
 INTEGER, DIMENSION(0:3*n-1,np), INTENT(IN   )               :: side_neigh_i  !(i,j,k) location of neighbors
 REAL, INTENT(IN   )                                         :: dts
 INTEGER, INTENT(IN   )                                      :: n,          & !desired number of nearest neighbors
                                                                np,         & !number of side ghost points
                                                                number_of_small_timesteps, &
                                                                rk_step,    &
                                                                rk_order
 REAL, DIMENSION(ims:ime,jms:jme,3), INTENT(IN   )           :: top_norm      !surface normal vector
 REAL, DIMENSION(ims:ime,jms:jme,2), INTENT(IN   )           :: top_dist      !distance of reconstruction and interpolation points from boundary
 REAL, DIMENSION(3,np), INTENT(IN   )                        :: side_norm     !surface normal vector
 REAL, DIMENSION(2,np), INTENT(IN   )                        :: side_dist     !distance from surface normal to reconstruction and interpolation point
 INTEGER, DIMENSION(np), INTENT(IN   )                       :: anst_at_s     !actual number of nearest neighbors for side points
 INTEGER, INTENT(IN   )                    :: ids, ide, jds, jde, kds, kde, & !d: domain
                                              ims, ime, jms, jme, kms, kme, & !m: memory
                                              its, ite, jts, jte, kts, kte    !p: patch, t: tile
 !local data
 INTEGER                                                     :: i, j,        &
                                                                nC, S,       &
                                                                i_end,       &
                                                                j_end
 DOUBLE PRECISION                                            :: max_rad,     &
                                                                var_ip
 DOUBLE PRECISION, DIMENSION(0:n-1)                          :: weight, radius

!---------------------------------------------------------------------------------
 !the executable begins here
 CALL wrf_debug(100, 'dyn_em/module_ibm.F/subroutine vel_recon_inverse_dist_temp')
!---------------------------------------------------------------------------------

 !loop over each top point and set the temperature
 i_end = MIN(ite,ide-1)
 j_end = MIN(jte,jde-1)
 DO i=its,i_end
 DO j=jts,j_end 
    !first find the radius from the neighbor to the interpolation point and then
    !determine the largest radius. Next determine the weight to apply to each
    !neighbor. Finally, weight each neighbor and sum the results to find the
    !temperature at the interpolation point.
    radius = 0.0
    DO nC=0,antt_at_s(i,j)-1
       radius(nC) = SQRT(top_neigh(i,j,6*n+3*nC)**2+top_neigh(i,j,6*n+3*nC+1)**2+top_neigh(i,j,6*n+3*nC+2)**2)
       IF (radius(nC) .EQ. 0.0) radius(nC) = epsilon
    ENDDO
    max_rad = MAXVAL(radius)
    weight = 0.0
    var_ip = 0.0
    DO nC=0,antt_at_s(i,j)-1
       weight(nC) = ((max_rad-radius(nC))/(max_rad*radius(nC)))**(0.5)
       IF ((ibm_temp .EQ. 3) .AND. (nC .EQ. 0)) THEN
          !dirichlet BC and this is the boundary point with temperature = ibm_temp_3
          var_ip = var_ip+weight(nC)*ibm_temp_3
       ELSE
          !neumann BC
          var_ip = var_ip+weight(nC)*varfull(top_neigh_i(i,j,6*n+3*nC),top_neigh_i(i,j,6*n+3*nC+2),top_neigh_i(i,j,6*n+3*nC+1))
       ENDIF
    ENDDO
    var_ip = var_ip/SUM(weight)
    IF (ibm_temp .EQ. 3) THEN
       !dirichlet BC w/ boundary temperature = ibm_temp_3
       varfull(i,top(i,j),j) = (ibm_temp_3-var_ip)/top_dist(i,j,2)*top_dist(i,j,1)+ibm_temp_3
    ELSEIF (ibm_temp .EQ. 2) THEN
       !neumann BC
!       write(*,'(2(3(A,I3),A,F5.2))') "DJW[module_ibm/vel_recon_inverse_dist_temp]: top_dist(",i,",",j,",",1,")=",top_dist(i,j,1),"   top_dist(",i,",",j,",",2,")=",top_dist(i,j,2)
       varfull(i,top(i,j),j) = var_ip-(top_dist(i,j,2)-top_dist(i,j,1))*grad(i,j)
    ENDIF
    IF (rk_step .LT. rk_order) THEN
       var(i,top(i,j),j) = varfull(i,top(i,j),j)*muts(i,j)-varsave(i,top(i,j),j)*mut(i,j)
    ELSE
       var(i,top(i,j),j) = varfull(i,top(i,j),j)*muts(i,j)-varsave(i,top(i,j),j)*mut(i,j) &
                         + dts*number_of_small_timesteps*mut(i,j)*h_diabatic(i,top(i,j),j)
    ENDIF
 ENDDO
 ENDDO

 !loop over each side point and set the temperature
 IF (np .GT. 0) THEN
    DO S=1,np 
       radius = 0.0
       DO nC=0,anst_at_s(S)-1
          radius(nC) = SQRT(side_neigh(3*nC,S)**2+side_neigh(3*nC+1,S)**2+side_neigh(3*nC+2,S)**2)
          IF (radius(nC) .EQ. 0.0) radius(nC) = epsilon
       ENDDO
       max_rad = MAXVAL(radius)
       weight = 0.0
       var_ip = 0.0
       DO nC=0,anst_at_s(S)-1
          weight(nC) = ((max_rad-radius(nC))/(max_rad*radius(nC)))**(0.5)
          IF ((ibm_temp .EQ. 3) .AND. (nC .EQ. 0)) THEN
             !dirichlet BC and this is the boundary point with temperature = ibm_temp_3
             var_ip = var_ip+weight(nC)*ibm_temp_3
          ELSE
             !neumann BC
             var_ip = var_ip+weight(nC)*varfull(side_neigh_i(3*nC,S),side_neigh_i(3*nC+2,S),side_neigh_i(3*nC+1,S))
          ENDIF
       ENDDO
       var_ip = var_ip/SUM(weight)
       IF (ibm_temp .EQ. 3) THEN
          !dirichlet BC
          varfull(side(1,S),side(3,S),side(2,S)) = (ibm_temp_3-var_ip)/side_dist(2,S)*side_dist(1,S)+ibm_temp_3
       ELSEIF (ibm_temp .EQ. 2) THEN
          !neumann BC
          varfull(side(1,S),side(3,S),side(2,S)) = var_ip-(side_dist(2,S)-side_dist(1,S))*grad(side(1,S),side(2,S))
       ENDIF
       IF (rk_step .LT. rk_order) THEN
          var(side(1,S),side(3,S),side(2,S)) = varfull(side(1,S),side(3,S),side(2,S))*muts(side(1,S),side(2,S)) &
                                             - varsave(side(1,S),side(3,S),side(2,S))*mut(side(1,S),side(2,S))
       ELSE
          var(side(1,S),side(3,S),side(2,S)) = varfull(side(1,S),side(3,S),side(2,S))*muts(side(1,S),side(2,S)) &
                                             - varsave(side(1,S),side(3,S),side(2,S))*mut(side(1,S),side(2,S))  &
                                             + dts*number_of_small_timesteps*mut(side(1,S),side(2,S))           &
                                             * h_diabatic(side(1,S),side(3,S),side(2,S))
       ENDIF
    ENDDO
 ENDIF

 END SUBROUTINE vel_recon_inverse_dist_temp

!----------------------------------------------------------------------------------------------------------------- 

 SUBROUTINE vel_recon_inverse_dist_eddy ( xkmh, xkmv, xkhh, xkhv,       &
                                          top, side,                    &
                                          top_neigh, side_neigh,        &
                                          top_neigh_i, side_neigh_i,    &
                                          n, np,                        &
                                          top_norm, top_dist,           &
                                          side_norm, side_dist,         &
                                          antt_at_s, anst_at_s,         &
                                          msftx, msfty, rdzw,           &
                                          dx, dy, dt,                   &
                                          mix_upper_bound,              &
                                          ids, ide, jds, jde, kds, kde, &
                                          ims, ime, jms, jme, kms, kme, &
                                          its, ite, jts, jte, kts, kte )

 IMPLICIT NONE
 !input data
 REAL, DIMENSION(ims:ime,kms:kme,jms:jme), INTENT(INOUT)     :: xkmh,        &
                                                                xkmv,        &
                                                                xkhh,        &
                                                                xkhv
 INTEGER, DIMENSION(ims:ime,jms:jme), INTENT(IN   )          :: top,         &
                                                                antt_at_s      !actual number of nearest neighbors for top points
 INTEGER, DIMENSION(3,np), INTENT(IN   )                     :: side           !'side boundary' ghost points
 REAL, DIMENSION(ims:ime,jms:jme,6*n:9*n-1), INTENT(IN   )   :: top_neigh      !(x,y,z) location of  neighbors
 REAL, DIMENSION(0:3*n-1,np), INTENT(IN   )                  :: side_neigh     !(x,y,z) location of neighbors
 INTEGER, DIMENSION(ims:ime,jms:jme,6*n:9*n-1), INTENT(IN   ):: top_neigh_i    !(i,j,k) index of top neighbors
 INTEGER, DIMENSION(0:3*n-1,np), INTENT(IN   )               :: side_neigh_i   !(i,j,k) location of neighbors
 INTEGER, INTENT(IN   )                                      :: n,           & !desired number of nearest neighbors
                                                                np             !number of side ghost points
 REAL, DIMENSION(ims:ime,jms:jme,3), INTENT(IN   )           :: top_norm       !surface normal vector
 REAL, DIMENSION(ims:ime,jms:jme,2), INTENT(IN   )           :: top_dist       !distance of reconstruction and interpolation points from boundary
 REAL, DIMENSION(3,np), INTENT(IN   )                        :: side_norm      !surface normal vector
 REAL, DIMENSION(2,np), INTENT(IN   )                        :: side_dist      !distance from surface normal to reconstruction and interpolation point
 INTEGER, DIMENSION(np), INTENT(IN   )                       :: anst_at_s      !actual number of nearest neighbors for side points
 REAL, DIMENSION(ims:ime, jms:jme), INTENT(IN   )            :: msftx,       & !DJW map scale factor on mass grid in x-direction
                                                                msfty          !DJW map scale factor on mass grid in y-direction
 REAL, DIMENSION(ims:ime, kms:kme, jms:jme), INTENT(IN   )   :: rdzw           !DJW dz**-1 at W-levels
 REAL, INTENT(IN   )                                         :: dx,          & !DJW grid spacing in x-direction
                                                                dy,          & !DJW grid spacing in y-direction
                                                                dt,          & !DJW timestep
                                                                mix_upper_bound !non-dimensional limit for mixing
 INTEGER, INTENT(IN   )                    :: ids, ide, jds, jde, kds, kde,  & !d: domain
                                              ims, ime, jms, jme, kms, kme,  & !m: memory
                                              its, ite, jts, jte, kts, kte     !p: patch, t: tile
 !local data
 INTEGER                                                     :: i, j,        &
                                                                nC, S,       &
                                                                i_end,       &
                                                                j_end
 REAL                                                        :: pr,          &
                                                                deltas,      &
                                                                xkmh_rp,     &
                                                                xkmv_rp
 DOUBLE PRECISION                                            :: max_rad,     &
                                                                xkmh_ip,     &
                                                                xkmv_ip,     &
                                                                xkhh_ip,     &
                                                                xkhv_ip
 DOUBLE PRECISION, DIMENSION(0:n-1)                          :: weight, radius

!---------------------------------------------------------------------------------
 !the executable begins here
 CALL wrf_debug(100, 'dyn_em/module_ibm.F/subroutine vel_recon_inverse_dist_eddy')
!---------------------------------------------------------------------------------

 pr = prandtl

 !loop over each top point and set the eddy viscosity/diffusivity
 i_end = MIN(ite,ide-1)
 j_end = MIN(jte,jde-1)
 DO i=its,i_end
 DO j=jts,j_end 
    xkmh_ip = 0.0
    xkmv_ip = 0.0
    !first find the radius from the neighbor to the interpolation point and then
    !determine the largest radius. Next determine the weight to apply to each
    !neighbor. Finally, weight each neighbor and sum the results to find the
    !eddy viscosity/diffusivity at the interpolation point.
    radius = 0.0
    DO nC=0,antt_at_s(i,j)-1
       radius(nC) = SQRT(top_neigh(i,j,6*n+3*nC)**2+top_neigh(i,j,6*n+3*nC+1)**2+top_neigh(i,j,6*n+3*nC+2)**2)
       IF (radius(nC) .EQ. 0.0) radius(nC) = epsilon
    ENDDO
    max_rad = MAXVAL(radius)
    weight = 0.0
    DO nC=0,antt_at_s(i,j)-1
       IF (radius(nC) .LE. 0.001) THEN
          weight = 0.0
          weight(nC) = 1.0
          xkmh_ip = xkmh(top_neigh_i(i,j,6*n+3*nC),top_neigh_i(i,j,6*n+3*nC+2),top_neigh_i(i,j,6*n+3*nC+1))
          xkmv_ip = xkmv(top_neigh_i(i,j,6*n+3*nC),top_neigh_i(i,j,6*n+3*nC+2),top_neigh_i(i,j,6*n+3*nC+1))
          GOTO 100
       ELSE
          weight(nC) = ((max_rad-radius(nC))/(max_rad*radius(nC)))**(0.5)
          xkmh_ip = xkmh_ip+weight(nC)*xkmh(top_neigh_i(i,j,6*n+3*nC),top_neigh_i(i,j,6*n+3*nC+2),top_neigh_i(i,j,6*n+3*nC+1))
          xkmv_ip = xkmv_ip+weight(nC)*xkmv(top_neigh_i(i,j,6*n+3*nC),top_neigh_i(i,j,6*n+3*nC+2),top_neigh_i(i,j,6*n+3*nC+1))
       ENDIF
    ENDDO
100 xkmh_ip = xkmh_ip/SUM(weight)
    xkmv_ip = xkmv_ip/SUM(weight)   
    !Deltas is used for a lower limit, which is grid dependent, which is
    !why I'm using rdzw instead of distance to the IB.
    deltas = (dx/msftx(i,j)*dy/msfty(i,j)/rdzw(i,top(i,j),j))**0.33333333
    !Calculate value at the reconstruction point using linear interpolation
    !Apply lower and upper limits to the viscosities
    xkmh_rp = MIN( xkmh_ip*top_dist(i,j,1)/top_dist(i,j,2), mix_upper_bound*dx/msftx(i,j)*dy/msfty(i,j)/dt )
    xkmv_rp = MIN( xkmv_ip*top_dist(i,j,1)/top_dist(i,j,2), mix_upper_bound/rdzw(i,top(i,j),j)/rdzw(i,top(i,j),j)/dt )
    xkmh(i,top(i,j),j) =  MAX( xkmh_rp, 1.0E-6*deltas*deltas )
    xkmv(i,top(i,j),j) =  MAX( xkmv_rp, 1.0E-6*deltas*deltas )
    !Calculate diffusivities using Prandtl number and apply lower limit
    xkhh = MIN( xkmh(i,top(i,j),j)/pr, mix_upper_bound*dx/msftx(i,j)*dy/msfty(i,j)/dt )
    xkhv = MIN( xkmv(i,top(i,j),j)/pr, mix_upper_bound/rdzw(i,top(i,j),j)/rdzw(i,top(i,j),j)/dt )
 ENDDO
 ENDDO

 !loop over each side point and set the eddy viscosity/diffusivity
 IF (np .GT. 0) THEN
    DO S=1,np 
       xkmh_ip = 0.0
       xkmv_ip = 0.0
       radius = 0.0
       DO nC=0,anst_at_s(S)-1
          radius(nC) = SQRT(side_neigh(3*nC,S)**2+side_neigh(3*nC+1,S)**2+side_neigh(3*nC+2,S)**2)
          IF (radius(nC) .EQ. 0.0) radius(nC) = epsilon
       ENDDO
       max_rad = MAXVAL(radius)
       weight = 0.0
       DO nC=0,anst_at_s(S)-1
          weight(nC) = ((max_rad-radius(nC))/(max_rad*radius(nC)))**(0.5)
          xkmh_ip = xkmh_ip+weight(nC)*xkmh(side_neigh_i(3*nC,S),side_neigh_i(3*nC+2,S),side_neigh_i(3*nC+1,S))
          xkmv_ip = xkmv_ip+weight(nC)*xkmv(side_neigh_i(3*nC,S),side_neigh_i(3*nC+2,S),side_neigh_i(3*nC+1,S))
       ENDDO
       xkmh_ip = xkmh_ip/SUM(weight)
       xkmv_ip = xkmv_ip/SUM(weight)   
       !Deltas is used for a lower limit, which is grid dependent, which is
       !why I'm using rdzw instead of distance to the IB.
       deltas = ( dx/msftx(side(1,S),side(2,S)) * &
                  dy/msfty(side(1,S),side(2,S)) / &
                  rdzw(side(1,S),side(3,S),side(2,S)) )**0.33333333
       !Calculate value at the reconstruction point using linear interpolation
       !Apply lower and upper limits to the viscosities
       xkmh_rp = MIN( xkmh_ip*side_dist(1,S)/side_dist(2,S), mix_upper_bound*dx/msftx(side(1,S),side(2,S))*dy/msfty(side(1,S),side(2,S))/dt )
       xkmv_rp = MIN( xkmv_ip*side_dist(1,S)/side_dist(2,S), mix_upper_bound/rdzw(side(1,S),side(3,S),side(2,S))/rdzw(side(1,S),side(3,S),side(2,S))/dt )
       xkmh(side(1,S),side(3,S),side(2,S)) = MAX( xkmh_rp, 1.0E-6*deltas*deltas )
       xkmv(side(1,S),side(3,S),side(2,S)) = MAX( xkmv_rp, 1.0E-6*deltas*deltas )
       !Calculate diffusivities using Prandtl number and apply lower limit
       xkhh = MIN( xkmh(side(1,S),side(3,S),side(2,S))/pr, mix_upper_bound*dx/msftx(side(1,S),side(2,S))*dy/msfty(side(1,S),side(2,S))/dt )
       xkhv = MIN( xkmv(side(1,S),side(3,S),side(2,S))/pr, mix_upper_bound/rdzw(side(1,S),side(3,S),side(2,S))/rdzw(side(1,S),side(3,S),side(2,S))/dt )
    ENDDO
 ENDIF

 END SUBROUTINE vel_recon_inverse_dist_eddy

!----------------------------------------------------------------------------------------------------------------- 

 SUBROUTINE shear_stress_recon_inverse_dist ( z_rough, stag,                   &
                                              u, v, w,                         &
                                              xkmv, fnm, fnp,                  &
                                              defor11, defor22, defor33,       &
                                              defor12, defor13, defor23,       &
                                              top, side,                       &
                                              top_neigh, side_neigh,           &
                                              top_neigh_i, side_neigh_i,       &
                                              n, np,                           &
                                              top_norm, top_dist,              &
                                              side_norm, side_dist,            &
                                              antu_at_p, antv_at_p, antw_at_p, &
                                              ansu_at_p, ansv_at_p, answ_at_p, &
                                              ids, ide, jds, jde, kds, kde,    &
                                              ims, ime, jms, jme, kms, kme,    &
                                              its, ite, jts, jte, kts, kte )

 IMPLICIT NONE
 !input data
 REAL, INTENT(IN   )                                       :: z_rough
 CHARACTER, INTENT(IN   )                                  :: stag
 REAL, DIMENSION(ims:ime,kms:kme,jms:jme), INTENT(IN   )   :: u, v, w,    &
                                                              xkmv
 REAL, DIMENSION( kms:kme ), INTENT( IN )                  :: fnm, fnp
 REAL, DIMENSION(ims:ime,kms:kme,jms:jme), INTENT(INOUT)   :: defor11,    &
                                                              defor22,    &
                                                              defor33,    &
                                                              defor12,    &
                                                              defor13,    &
                                                              defor23
 INTEGER, DIMENSION(ims:ime,jms:jme), INTENT(IN   )        :: top,        &
                                                              antu_at_p,  & !actual number of nearest neighbors for top points
                                                              antv_at_p,  &
                                                              antw_at_p
 INTEGER, DIMENSION(3,np), INTENT(IN   )                   :: side          !'side boundary' ghost points					     
 REAL, DIMENSION(ims:ime,jms:jme,0:9*n-1), INTENT(IN   )   :: top_neigh     !(x,y,z) location of neighbors 
 REAL, DIMENSION(0:9*n-1,np), INTENT(IN   )                :: side_neigh    !(x,y,z) location of neighbors							     
 INTEGER, DIMENSION(ims:ime,jms:jme,0:9*n-1), INTENT(IN   ):: top_neigh_i   !(i,j,k) index of top neighbors
 INTEGER, DIMENSION(0:9*n-1,np), INTENT(IN   )             :: side_neigh_i  !(i,j,k) location of neighbors							     
 INTEGER, INTENT(IN   )                                    :: n,          & !desired number of nearest neighbors
                                                              np            !number of side ghost points
 REAL, DIMENSION(ims:ime,jms:jme,3), INTENT(IN   )         :: top_norm      !surface normal vector
 REAL, DIMENSION(ims:ime,jms:jme,2), INTENT(IN   )         :: top_dist      !distance of reconstruction and interpolation points from boundary
 REAL, DIMENSION(3,np), INTENT(IN   )                      :: side_norm     !surface normal vector
 REAL, DIMENSION(2,np), INTENT(IN   )                      :: side_dist     !distance from surface normal to reconstruction and interpolation point
 INTEGER, DIMENSION(np), INTENT(IN   )                     :: ansu_at_p,  & !actual number of nearest neighbors for side points 
                                                              ansv_at_p,  &
                                                              answ_at_p
 INTEGER, INTENT(IN   )                  :: ids, ide, jds, jde, kds, kde, & !d: domain
                                            ims, ime, jms, jme, kms, kme, & !m: memory
                                            its, ite, jts, jte, kts, kte    !p: patch, t: tile

 !local data
 INTEGER                                                  :: i, j,        &
                                                             nC, S,       &
                                                             i_end,       &
                                                             j_end
 DOUBLE PRECISION                                         :: max_rad
 DOUBLE PRECISION, DIMENSION(3)                           :: vel_img, vel_img_temp
 DOUBLE PRECISION, DIMENSION(3,3)                         :: matrix
 DOUBLE PRECISION, DIMENSION(0:n-1)                       :: weight, radius
 REAL                                                     :: Cd, Vmag,       &  !for estimating the surface stress
                                                             tau_xz, tau_yz, &
                                                             xkmv_tmp
 REAL, DIMENSION(3,3)                                     :: shear_stress_recon_pt 

 !for lapack routines
! INTEGER                                                  :: info
! INTEGER, DIMENSION(3)                                    :: ipiv
! REAL, DIMENSION(336)                                     :: work
 !---------------------------------------------------------------------------------
 !the executable begins here
 CALL wrf_debug(100, 'dyn_em/module_ibm.F/subroutine shear_stress_recon_inverse_dist')
 !---------------------------------------------------------------------------------

 IF ((stag .EQ. 'u') .OR. (stag .EQ. 'e')) THEN
    i_end = ite
    j_end = MIN(jte,jde-1)
 ELSEIF ((stag .EQ. 'v') .OR. (stag .EQ. 'f')) THEN
    i_end = MIN(ite,ide-1)
    j_end = jte
 ELSEIF ((stag .EQ. 'w') .OR. (stag .EQ. 't')) THEN
    i_end = MIN(ite,ide-1)
    j_end = MIN(jte,jde-1)
 ELSEIF (stag .EQ. 'd') THEN
    i_end = ite
    j_end = jte
 ENDIF

 DO i=its,i_end
 DO j=jts,j_end 
    
    vel_img = 0.0
    
    !get u velocity at interpolation point 
    radius = 0.0
    DO nC=0,antu_at_p(i,j)-1
       !calculate the radius to image point, and determine the largest radius  
       radius(nC) = SQRT(top_neigh(i,j,3*nC)**2+top_neigh(i,j,3*nC+1)**2+top_neigh(i,j,3*nC+2)**2)
       IF (radius(nC) .EQ. 0.0) radius(nC) = epsilon
    ENDDO
    max_rad = MAXVAL(radius)
    weight = 0.0
    DO nC=0,antu_at_p(i,j)-1
!       weight(nC) = ((max_rad-radius(nC))/(max_rad*radius(nC)))**2
!       weight(nC) = ((max_rad-radius(nC))/(max_rad*radius(nC)))
       IF (radius(nC) .LE. 0.001) THEN
          !DJW if the IP is aligned with a grid-point then radius is 0 and we
          !    end up dividing by 0 when calculating the weight...
          weight = 0.0
          weight(nC) = 1.0
          vel_img(1) = u(top_neigh_i(i,j,3*nC),top_neigh_i(i,j,3*nC+2),top_neigh_i(i,j,3*nC+1))
          GOTO 100
       ELSE
          IF (nC .EQ. 0) THEN
             vel_img(1) = vel_img(1) + weight(nC)*0.0
          ELSE
             weight(nC) = ((max_rad-radius(nC))/(max_rad*radius(nC)))**(0.5)
             vel_img(1) = vel_img(1) + weight(nC)*u(top_neigh_i(i,j,3*nC),top_neigh_i(i,j,3*nC+2),top_neigh_i(i,j,3*nC+1))
          ENDIF
       ENDIF
    ENDDO
100 vel_img(1) = vel_img(1)/SUM(weight)
    
    !get v velocity at interpolation point 
    radius = 0.0
    DO nC=0,antv_at_p(i,j)-1
       !calculate the radius to image point, and determine the largest radius  
       radius(nC) = SQRT(top_neigh(i,j,3*n+3*nC)**2+top_neigh(i,j,3*n+3*nC+1)**2+top_neigh(i,j,3*n+3*nC+2)**2)
       IF (radius(nC) .EQ. 0.0) radius(nC) = epsilon
    ENDDO
    max_rad = MAXVAL(radius)
    weight = 0.0
    DO nC=0,antv_at_p(i,j)-1
!       weight(nC) = ((max_rad-radius(nC))/(max_rad*radius(nC)))**2
!       weight(nC) = ((max_rad-radius(nC))/(max_rad*radius(nC)))
       IF (radius(nC) .LE. 0.001) THEN
          !DJW if the IP is aligned with a grid-point then radius is 0 and we
          !    end up dividing by 0 when calculating the weight...
          weight = 0.0
          weight(nC) = 1.0
          vel_img(2) = v(top_neigh_i(i,j,3*n+3*nC),top_neigh_i(i,j,3*n+3*nC+2),top_neigh_i(i,j,3*n+3*nC+1))
          GOTO 200
       ELSE
          IF (nC .EQ. 0) THEN
             vel_img(2) = vel_img(2) + weight(nC)*0.0
          ELSE
             weight(nC) = ((max_rad-radius(nC))/(max_rad*radius(nC)))**(0.5)
             vel_img(2) = vel_img(2) + weight(nC)*v(top_neigh_i(i,j,3*n+3*nC),top_neigh_i(i,j,3*n+3*nC+2),top_neigh_i(i,j,3*n+3*nC+1))
          ENDIF
       ENDIF
    ENDDO
200 vel_img(2) = vel_img(2)/SUM(weight)

    !get w velocity at interpolation point 
    radius = 0.0
    DO nC=0,antw_at_p(i,j)-1
       !calculate the radius to image point, and determine the largest radius  
       radius(nC) = SQRT(top_neigh(i,j,6*n+3*nC)**2+top_neigh(i,j,6*n+3*nC+1)**2+top_neigh(i,j,6*n+3*nC+2)**2)
       IF (radius(nC) .EQ. 0.0) radius(nC) = epsilon
    ENDDO
    max_rad = MAXVAL(radius)
    weight = 0.0
    DO nC=0,antw_at_p(i,j)-1
!       weight(nC) = ((max_rad-radius(nC))/(max_rad*radius(nC)))**2
!       weight(nC) = ((max_rad-radius(nC))/(max_rad*radius(nC)))
       IF (radius(nC) .LE. 0.001) THEN
          !DJW if the IP is aligned with a grid-point then radius is 0 and we
          !    end up dividing by 0 when calculating the weight...
          weight = 0.0
          weight(nC) = 1.0
          vel_img(3) = w(top_neigh_i(i,j,6*n+3*nC),top_neigh_i(i,j,6*n+3*nC+2),top_neigh_i(i,j,6*n+3*nC+1))
          GOTO 300
       ELSE
          IF (nC .EQ. 0) THEN
             vel_img(3) = vel_img(3) + weight(nC)*0.0
          ELSE
             weight(nC) = ((max_rad-radius(nC))/(max_rad*radius(nC)))**(0.5)
             vel_img(3) = vel_img(3) + weight(nC)*w(top_neigh_i(i,j,6*n+3*nC),top_neigh_i(i,j,6*n+3*nC+2),top_neigh_i(i,j,6*n+3*nC+1))
          ENDIF
       ENDIF
    ENDDO
300 vel_img(3) = vel_img(3)/SUM(weight)

    !calculate the surface normal and tangential components at the interpolation point
    !find the orthonormal basis for the plane representing the immersed boundary
    !the plane is defined as ax+by+cz=0 or n(1)x+n(2)y+n(3)z = 0
    !We know that one vector is the normal vector already calculated
    !to find the second vector set x=1 and y=0 so that [1 0 -a/c] results, then normalize for a unit vector
    !cross these two vectors to find the third
    matrix(1,:) = [1/SQRT(1 + (top_norm(i,j,1)/top_norm(i,j,3))**2), 0.0, (-top_norm(i,j,1)/top_norm(i,j,3))/SQRT(1 + (top_norm(i,j,1)/top_norm(i,j,3))**2)]
    matrix(2,:) = [top_norm(i,j,2)*matrix(1,3), top_norm(i,j,3)*matrix(1,1) - top_norm(i,j,1)*matrix(1,3), -top_norm(i,j,2)*matrix(1,1)]
    matrix(3,:) = top_norm(i,j,1:3)

    !now vel_img(1) and (2) are along the tangent vectors and vel_img(3) is the
    !surface normal velocity at the interpolation point
    vel_img = MATMUL(matrix,vel_img)

    !estimate surface shear stress in surface normal coordinate
    Cd = ( KARMAN / log(top_dist(i,j,2)/z_rough) )**2
    Vmag = sqrt( vel_img(1)**2 + vel_img(2)**2 )
    tau_xz = -Cd*vel_img(1)*Vmag
    tau_yz = -Cd*vel_img(2)*Vmag

    !rotate estimated stress back into grid coordinate
    shear_stress_recon_pt(1,1) = 0.0
    shear_stress_recon_pt(1,2) = 0.0
    shear_stress_recon_pt(1,3) = tau_xz 
    shear_stress_recon_pt(2,1) = 0.0
    shear_stress_recon_pt(2,2) = 0.0
    shear_stress_recon_pt(2,3) = tau_yz 
    shear_stress_recon_pt(3,1) = tau_xz 
    shear_stress_recon_pt(3,2) = tau_yz
    shear_stress_recon_pt(3,3) = 0.0

    matrix = TRANSPOSE(matrix)
    shear_stress_recon_pt = MATMUL(matrix,shear_stress_recon_pt)

    !set deformations at reconstruction point to estimated surface stress value
    !divide by -xkmv so that the correct deformation is recovered in diffusion
    !routines when defor is multiplied by -xkmv. Note that mix_isotropic=1 for
    !now such that xkmv=xkmh.
    IF (stag .EQ. 't') THEN
       xkmv_tmp = xkmv(i,top(i,j),j)
       IF (xkmv_tmp .NE. 0.0) THEN
          defor11(i,top(i,j),j) = shear_stress_recon_pt(1,1) / -xkmv_tmp
          defor22(i,top(i,j),j) = shear_stress_recon_pt(2,2) / -xkmv_tmp
          defor33(i,top(i,j),j) = shear_stress_recon_pt(3,3) / -xkmv_tmp
       ELSE
          defor11(i,top(i,j),j) = 0.0
          defor22(i,top(i,j),j) = 0.0
          defor33(i,top(i,j),j) = 0.0
       ENDIF
    ELSEIF (stag .EQ. 'd') THEN
       xkmv_tmp = 0.25 * ( xkmv(i-1,top(i,j),j  ) + xkmv(i,top(i,j),j  ) &
                         + xkmv(i-1,top(i,j),j-1) + xkmv(i,top(i,j),j-1) )
       IF (xkmv_tmp .NE. 0.0) THEN
          defor12(i,top(i,j),j) = shear_stress_recon_pt(1,2) / -xkmv_tmp
       ELSE
          defor12(i,top(i,j),j) = 0.0
       ENDIF
    ELSEIF (stag .EQ. 'e') THEN
       xkmv_tmp = 0.5 * ( fnm(top(i,j)) * ( xkmv(i,top(i,j)  ,j) + xkmv(i-1,top(i,j)  ,j) ) &
                        + fnp(top(i,j)) * ( xkmv(i,top(i,j)-1,j) + xkmv(i-1,top(i,j)-1,j) ) )
       IF (xkmv_tmp .NE. 0.0) THEN
          defor13(i,top(i,j),j) = shear_stress_recon_pt(1,3) / -xkmv_tmp
       ELSE
          defor13(i,top(i,j),j) = 0.0
       ENDIF
    ELSEIF (stag .EQ. 'f') THEN
       xkmv_tmp = 0.5 * ( fnm(top(i,j)) * ( xkmv(i,top(i,j)  ,j) + xkmv(i,top(i,j)  ,j-1) ) &
                        + fnp(top(i,j)) * ( xkmv(i,top(i,j)-1,j) + xkmv(i,top(i,j)-1,j-1) ) )
       IF (xkmv_tmp .NE. 0.0) THEN
          defor23(i,top(i,j),j) = shear_stress_recon_pt(2,3) / -xkmv_tmp
       ELSE
          defor23(i,top(i,j),j) = 0.0
       ENDIF
    ENDIF

 ENDDO
 ENDDO

 IF (np .GT. 0) THEN
    DO S=1,np 

       vel_img = 0.0
       
       radius = 0.0
       DO nC=0,ansu_at_p(S)-1
          !calculate the radius to image point, and determine the largest radius  
          radius(nC) = SQRT(side_neigh(3*nC,S)**2+side_neigh(3*nC+1,S)**2+side_neigh(3*nC+2,S)**2)
          IF (radius(nC) .EQ. 0.0) radius(nC) = epsilon
       ENDDO
       max_rad = MAXVAL(radius)
       weight = 0.0
       DO nC=0,ansu_at_p(S)-1
!          weight(nC) = ((max_rad-radius(nC))/(max_rad*radius(nC)))**2
!          weight(nC) = ((max_rad-radius(nC))/(max_rad*radius(nC)))
          IF (nC .EQ. 0) THEN
             vel_img(1) = vel_img(1) + weight(nC)*0.0
          ELSE
             weight(nC) = ((max_rad-radius(nC))/(max_rad*radius(nC)))**(0.5)
             vel_img(1) = vel_img(1) + weight(nC)*u(side_neigh_i(3*nC,S),side_neigh_i(3*nC+2,S),side_neigh_i(3*nC+1,S))
          ENDIF
       ENDDO
       vel_img(1) = vel_img(1)/SUM(weight)

       radius = 0.0
       DO nC=0,ansv_at_p(S)-1
          !calculate the radius to image point, and determine the largest radius  
          radius(nC) = SQRT(side_neigh(3*n+3*nC,S)**2+side_neigh(3*n+3*nC+1,S)**2+side_neigh(3*n+3*nC+2,S)**2)
          IF (radius(nC) .EQ. 0.0) radius(nC) = epsilon
       ENDDO
       max_rad = MAXVAL(radius)
       weight = 0.0
       DO nC=0,ansv_at_p(S)-1
!          weight(nC) = ((max_rad-radius(nC))/(max_rad*radius(nC)))**2
!          weight(nC) = ((max_rad-radius(nC))/(max_rad*radius(nC)))
          IF (nC .EQ. 0) THEN
             vel_img(2) = vel_img(2) + weight(nC)*0.0
          ELSE
             weight(nC) = ((max_rad-radius(nC))/(max_rad*radius(nC)))**(0.5)
             vel_img(2) = vel_img(2) + weight(nC)*v(side_neigh_i(3*n+3*nC,S),side_neigh_i(3*n+3*nC+2,S),side_neigh_i(3*n+3*nC+1,S))
          ENDIF
       ENDDO
       vel_img(2) = vel_img(2)/SUM(weight)      

       radius = 0.0
       DO nC=0,answ_at_p(S)-1
          !calculate the radius to image point, and determine the largest radius  
          radius(nC) = SQRT(side_neigh(6*n+3*nC,S)**2+side_neigh(6*n+3*nC+1,S)**2+side_neigh(6*n+3*nC+2,S)**2)
          IF (radius(nC) .EQ. 0.0) radius(nC) = epsilon
       ENDDO
       max_rad = MAXVAL(radius)
       weight = 0.0
       DO nC=0,answ_at_p(S)-1
!          weight(nC) = ((max_rad-radius(nC))/(max_rad*radius(nC)))**2
!          weight(nC) = ((max_rad-radius(nC))/(max_rad*radius(nC)))
          IF (nC .EQ. 0) THEN
             vel_img(3) = vel_img(3) + weight(nC)*0.0
          ELSE
             weight(nC) = ((max_rad-radius(nC))/(max_rad*radius(nC)))**(0.5)
             vel_img(3) = vel_img(3) + weight(nC)*w(side_neigh_i(6*n+3*nC,S),side_neigh_i(6*n+3*nC+2,S),side_neigh_i(6*n+3*nC+1,S))
          ENDIF
       ENDDO
       vel_img(3) = vel_img(3)/SUM(weight)

       !calculate the surface normal and tangential components at the interpolation point
       !find the orthonormal basis for the plane representing the immersed boundary
       !the plane is defined as ax+by+cz=0 or n(1)x+n(2)y+n(3)z = 0
       !We know that one vector is the normal vector already calculated
       !to find the second vector set x=1 and y=0 so that [1 0 -a/c] results, then normalize for a unit vector
       !cross these two vectors to find the third
       matrix(1,:) = [1/SQRT(1 + (side_norm(1,S)/side_norm(3,S))**2), 0.0, (-side_norm(1,S)/side_norm(3,S))/SQRT(1 + (side_norm(1,S)/side_norm(3,S))**2)]
       matrix(2,:) = [side_norm(2,S)*matrix(1,3), side_norm(3,S)*matrix(1,1) - side_norm(1,S)*matrix(1,3), -side_norm(2,S)*matrix(1,1)]
       matrix(3,:) = side_norm(1:3,S)

       !now vel_img(1) and (2) are along the tangent vectors and vel_img(3) is the
       !surface normal velocity at the interpolation point
       vel_img = MATMUL(matrix,vel_img) 

       !estimate surface shear stress in surface normal coordinate
       Cd = ( KARMAN / log(side_dist(2,S)/z_rough) )**2
       Vmag = sqrt( vel_img(1)**2 + vel_img(2)**2 )
       tau_xz = -Cd*vel_img(1)*Vmag
       tau_yz = -Cd*vel_img(2)*Vmag

       !rotate estimated stress back into grid coordinate
       shear_stress_recon_pt(1,1) = 0.0
       shear_stress_recon_pt(1,2) = 0.0
       shear_stress_recon_pt(1,3) = tau_xz 
       shear_stress_recon_pt(2,1) = 0.0
       shear_stress_recon_pt(2,2) = 0.0
       shear_stress_recon_pt(2,3) = tau_yz 
       shear_stress_recon_pt(3,1) = tau_xz 
       shear_stress_recon_pt(3,2) = tau_yz
       shear_stress_recon_pt(3,3) = 0.0

       matrix = TRANSPOSE(matrix)
       shear_stress_recon_pt = MATMUL(matrix,shear_stress_recon_pt)

       !set deformations at reconstruction point to estimated surface stress value
       !divide by -xkmv so that the correct deformation is recovered in diffusion
       !routines when defor is multiplied by -xkmv. Note that mix_isotropic=1 for
       !now such that xkmv=xkmh.
       IF (stag .EQ. 't') THEN
          xkmv_tmp = xkmv(side(1,S),side(3,S),side(2,S))
          IF (xkmv_tmp .NE. 0.0) THEN
             defor11(side(1,S),side(3,S),side(2,S)) = shear_stress_recon_pt(1,1) / -xkmv_tmp
             defor22(side(1,S),side(3,S),side(2,S)) = shear_stress_recon_pt(2,2) / -xkmv_tmp
             defor33(side(1,S),side(3,S),side(2,S)) = shear_stress_recon_pt(3,3) / -xkmv_tmp
          ELSE
             defor11(side(1,S),side(3,S),side(2,S)) = 0.0
             defor22(side(1,S),side(3,S),side(2,S)) = 0.0
             defor33(side(1,S),side(3,S),side(2,S)) = 0.0
          ENDIF
       ELSEIF (stag .EQ. 'd') THEN
          xkmv_tmp = 0.25 * ( xkmv(side(1,S)-1,side(3,S),side(2,S)  ) + xkmv(side(1,S),side(3,S),side(2,S)  ) &
                            + xkmv(side(1,S)-1,side(3,S),side(2,S)-1) + xkmv(side(1,S),side(3,S),side(2,S)-1) )
          IF (xkmv_tmp .NE. 0.0) THEN
             defor12(side(1,S),side(3,S),side(2,S)) = shear_stress_recon_pt(1,2) / -xkmv_tmp
          ELSE
             defor12(side(1,S),side(3,S),side(2,S)) = 0.0
          ENDIF
       ELSEIF (stag .EQ. 'e') THEN
          xkmv_tmp = 0.5 * ( fnm(side(3,S)) * ( xkmv(side(1,S),side(3,S)  ,side(2,S)) + xkmv(side(1,S)-1,side(3,S)  ,side(2,S)) ) &
                           + fnp(side(3,S)) * ( xkmv(side(1,S),side(3,S)-1,side(2,S)) + xkmv(side(1,S)-1,side(3,S)-1,side(2,S)) ) )
          IF (xkmv_tmp .NE. 0.0) THEN
             defor13(side(1,S),side(3,S),side(2,S)) = shear_stress_recon_pt(1,3) / -xkmv_tmp
          ELSE
             defor13(side(1,S),side(3,S),side(2,S)) = 0.0
          ENDIF
       ELSEIF (stag .EQ. 'f') THEN
          xkmv_tmp = 0.5 * ( fnm(side(3,S)) * ( xkmv(side(1,S),side(3,S)  ,side(2,S)) + xkmv(side(1,S),side(3,S)  ,side(2,S)-1) ) &
                           + fnp(side(3,S)) * ( xkmv(side(1,S),side(3,S)-1,side(2,S)) + xkmv(side(1,S),side(3,S)-1,side(2,S)-1) ) )
          IF (xkmv_tmp .NE. 0.0) THEN
             defor23(side(1,S),side(3,S),side(2,S)) = shear_stress_recon_pt(2,3) / -xkmv_tmp
          ELSE
             defor23(side(1,S),side(3,S),side(2,S)) = 0.0
          ENDIF
       ENDIF

    ENDDO 
 ENDIF

 END SUBROUTINE shear_stress_recon_inverse_dist

!----------------------------------------------------------------------------------------------------------------- 

 SUBROUTINE shear_stress_extrap_inverse_dist ( stag,                            &
                                               xkmv, fnm, fnp,                  &
                                               defor11, defor22, defor33,       &
                                               defor12, defor13, defor23,       &
                                               top, side,                       &
                                               top_neigh, side_neigh,           &
                                               top_neigh_i, side_neigh_i,       &
                                               n, np,                           &
                                               top_norm, top_dist,              &
                                               side_norm, side_dist,            &
                                               ant_1, ant_2, ant_3,             &
                                               ans_1, ans_2, ans_3,             &
                                               ids, ide, jds, jde, kds, kde,    &
                                               ims, ime, jms, jme, kms, kme,    &
                                               its, ite, jts, jte, kts, kte )

 IMPLICIT NONE
 !input data
 CHARACTER, INTENT(IN   )                                  :: stag
 REAL, DIMENSION(ims:ime,kms:kme,jms:jme), INTENT(IN   )   :: xkmv
 REAL, DIMENSION( kms:kme ), INTENT( IN )                  :: fnm, fnp
 REAL, DIMENSION(ims:ime,kms:kme,jms:jme), INTENT(INOUT)   :: defor11,    &
                                                              defor22,    &
                                                              defor33,    &
                                                              defor12,    &
                                                              defor13,    &
                                                              defor23
 INTEGER, DIMENSION(ims:ime,jms:jme), INTENT(IN   )        :: top
 INTEGER, DIMENSION(ims:ime,jms:jme), INTENT(IN   )        :: ant_1,      & !actual number of nearest neighbors for top points
                                                              ant_2,      &
                                                              ant_3
 INTEGER, DIMENSION(3,np), INTENT(IN   )                   :: side          !'side boundary' ghost points					     
 REAL, DIMENSION(ims:ime,jms:jme,0:9*n-1), INTENT(IN   )   :: top_neigh     !(x,y,z) location of neighbors 
 REAL, DIMENSION(0:9*n-1,np), INTENT(IN   )                :: side_neigh    !(x,y,z) location of neighbors							     
 INTEGER, DIMENSION(ims:ime,jms:jme,0:9*n-1), INTENT(IN   ):: top_neigh_i   !(i,j,k) index of top neighbors
 INTEGER, DIMENSION(0:9*n-1,np), INTENT(IN   )             :: side_neigh_i  !(i,j,k) location of neighbors							     
 INTEGER, INTENT(IN   )                                    :: n,          & !desired number of nearest neighbors
                                                              np            !number of side ghost points
 REAL, DIMENSION(ims:ime,jms:jme,3), INTENT(IN   )         :: top_norm      !surface normal vector
 REAL, DIMENSION(ims:ime,jms:jme), INTENT(IN   )           :: top_dist      !distance of reconstruction and interpolation points from boundary
 REAL, DIMENSION(3,np), INTENT(IN   )                      :: side_norm     !surface normal vector
 REAL, DIMENSION(np), INTENT(IN   )                        :: side_dist     !distance from surface normal to reconstruction and interpolation point
 INTEGER, DIMENSION(np), INTENT(IN   )                     :: ans_1,      & !actual number of nearest neighbors for side points 
                                                              ans_2,      &
                                                              ans_3
 INTEGER, INTENT(IN   )                  :: ids, ide, jds, jde, kds, kde, & !d: domain
                                            ims, ime, jms, jme, kms, kme, & !m: memory
                                            its, ite, jts, jte, kts, kte    !p: patch, t: tile

 !local data
 INTEGER                                                  :: i, j,          &
                                                             iNc, jNc, kNc, &
                                                             nC, S,         &
                                                             i_end,         &
                                                             j_end
 DOUBLE PRECISION                                         :: max_rad
 DOUBLE PRECISION, DIMENSION(3)                           :: tau_img_1,   &
                                                             tau_img_2,   &
                                                             tau_img_3
 DOUBLE PRECISION, DIMENSION(0:n-1)                       :: weight, radius
 REAL                                                     :: xkmv_tmp

 !for lapack routines
! INTEGER                                                  :: info
! INTEGER, DIMENSION(3)                                    :: ipiv
! REAL, DIMENSION(336)                                     :: work
 !---------------------------------------------------------------------------------
 !the executable begins here
 CALL wrf_debug(100, 'dyn_em/module_ibm.F/subroutine shear_stress_extrap_inverse_dist')
 !---------------------------------------------------------------------------------

 IF ((stag .EQ. 'u') .OR. (stag .EQ. 'e')) THEN
    i_end = ite
    j_end = MIN(jte,jde-1)
 ELSEIF ((stag .EQ. 'v') .OR. (stag .EQ. 'f')) THEN
    i_end = MIN(ite,ide-1)
    j_end = jte
 ELSEIF ((stag .EQ. 'w') .OR. (stag .EQ. 't')) THEN
    i_end = MIN(ite,ide-1)
    j_end = MIN(jte,jde-1)
 ELSEIF (stag .EQ. 'd') THEN
    i_end = ite
    j_end = jte
 ENDIF

 DO i=its,i_end
 DO j=jts,j_end 
    
    tau_img_1 = 0.0
    tau_img_2 = 0.0
    tau_img_3 = 0.0

    !get stress at first extrapolatioin point 
    !stress is -xkmv*defor
    radius = 0.0
    DO nC=0,ant_1(i,j)-1
       !calculate the radius to image point, and determine the largest radius  
       radius(nC) = SQRT(top_neigh(i,j,3*nC)**2+top_neigh(i,j,3*nC+1)**2+top_neigh(i,j,3*nC+2)**2)
       IF (radius(nC) .EQ. 0.0) radius(nC) = epsilon
    ENDDO
    max_rad = MAXVAL(radius)
    weight = 0.0
    DO nC=0,ant_1(i,j)-1
       iNc = top_neigh_i(i,j,3*nC)
       jNc = top_neigh_i(i,j,3*nC+1)
       kNc = top_neigh_i(i,j,3*nC+2)

       !Get xkmv at neighbor
       IF (stag .EQ. 't') THEN
          xkmv_tmp = xkmv(iNc,kNc,jNc)
       ELSEIF (stag .EQ. 'd') THEN
          xkmv_tmp = 0.25 * ( xkmv(iNc-1,kNc,jNc  ) + xkmv(iNc,kNc,jNc  ) &
                            + xkmv(iNc-1,kNc,jNc-1) + xkmv(iNc,kNc,jNc-1) )
       ELSEIF (stag .EQ. 'e') THEN
          xkmv_tmp = 0.5 * ( fnm(kNc) * ( xkmv(iNc,kNc  ,jNc) + xkmv(iNc-1,kNc  ,jNc) ) &
                           + fnp(kNc) * ( xkmv(iNc,kNc-1,jNc) + xkmv(iNc-1,kNc-1,jNc) ) )
       ELSEIF (stag .EQ. 'f') THEN
          xkmv_tmp = 0.5 * ( fnm(kNc) * ( xkmv(iNc,kNc  ,jNc) + xkmv(iNc,kNc  ,jNc-1) ) &
                           + fnp(kNc) * ( xkmv(iNc,kNc-1,jNc) + xkmv(iNc,kNc-1,jNc-1) ) )
       ENDIF

       IF (radius(nC) .LE. 0.001) THEN
          !DJW if the IP is aligned with a grid-point then radius is 0 and we
          !    end up dividing by 0 when calculating the weight...
          weight = 0.0
          weight(nC) = 1.0
          IF (stag .EQ. 't') THEN
             tau_img_1(1) = -defor11(iNc,kNc,jNc) * xkmv_tmp
             tau_img_2(1) = -defor22(iNc,kNc,jNc) * xkmv_tmp
             tau_img_3(1) = -defor33(iNc,kNc,jNc) * xkmv_tmp
          ELSEIF (stag .EQ. 'd') THEN
             tau_img_1(1) = -defor12(iNc,kNc,jNc) * xkmv_tmp
          ELSEIF (stag .EQ. 'e') THEN
             tau_img_1(1) = -defor13(iNc,kNc,jNc) * xkmv_tmp
          ELSEIF (stag .EQ. 'f') THEN
             tau_img_1(1) = -defor23(iNc,kNc,jNc) * xkmv_tmp
          ENDIF
          GOTO 100
       ELSE
          IF (nC .EQ. 0) THEN
             tau_img_1(1) = tau_img_1(1) + weight(nC)*0.0
             tau_img_2(1) = tau_img_2(1) + weight(nC)*0.0
             tau_img_3(1) = tau_img_3(1) + weight(nC)*0.0
          ELSE
             weight(nC) = ((max_rad-radius(nC))/(max_rad*radius(nC)))**(0.5)
             IF (stag .EQ. 't') THEN
                tau_img_1(1) = tau_img_1(1) - weight(nC) * defor11(iNc,kNc,jNc) * xkmv_tmp
                tau_img_2(1) = tau_img_2(1) - weight(nC) * defor22(iNc,kNc,jNc) * xkmv_tmp
                tau_img_3(1) = tau_img_3(1) - weight(nC) * defor33(iNc,kNc,jNc) * xkmv_tmp
             ELSEIF (stag .EQ. 'd') THEN
                tau_img_1(1) = tau_img_1(1) - weight(nC) * defor12(iNc,kNc,jNc) * xkmv_tmp
             ELSEIF (stag .EQ. 'e') THEN
                tau_img_1(1) = tau_img_1(1) - weight(nC) * defor13(iNc,kNc,jNc) * xkmv_tmp
             ELSEIF (stag .EQ. 'f') THEN
                tau_img_1(1) = tau_img_1(1) - weight(nC) * defor23(iNc,kNc,jNc) * xkmv_tmp
             ENDIF
          ENDIF
       ENDIF
    ENDDO
100 tau_img_1(1) = tau_img_1(1)/SUM(weight)
    tau_img_2(1) = tau_img_2(1)/SUM(weight)
    tau_img_3(1) = tau_img_3(1)/SUM(weight)

    !get stress at second extrapolation point
    !stress is -xkmv*defor
    radius = 0.0
    DO nC=0,ant_2(i,j)-1
       !calculate the radius to image point, and determine the largest radius  
       radius(nC) = SQRT(top_neigh(i,j,3*n+3*nC)**2+top_neigh(i,j,3*n+3*nC+1)**2+top_neigh(i,j,3*n+3*nC+2)**2)
       IF (radius(nC) .EQ. 0.0) radius(nC) = epsilon
    ENDDO
    max_rad = MAXVAL(radius)
    weight = 0.0
    DO nC=0,ant_2(i,j)-1
       iNc = top_neigh_i(i,j,3*n+3*nC)
       jNc = top_neigh_i(i,j,3*n+3*nC+1)
       kNc = top_neigh_i(i,j,3*n+3*nC+2)

       !Get xkmv at neighbor
       IF (stag .EQ. 't') THEN
          xkmv_tmp = xkmv(iNc,kNc,jNc)
       ELSEIF (stag .EQ. 'd') THEN
          xkmv_tmp = 0.25 * ( xkmv(iNc-1,kNc,jNc  ) + xkmv(iNc,kNc,jNc  ) &
                            + xkmv(iNc-1,kNc,jNc-1) + xkmv(iNc,kNc,jNc-1) )
       ELSEIF (stag .EQ. 'e') THEN
          xkmv_tmp = 0.5 * ( fnm(kNc) * ( xkmv(iNc,kNc  ,jNc) + xkmv(iNc-1,kNc  ,jNc) ) &
                           + fnp(kNc) * ( xkmv(iNc,kNc-1,jNc) + xkmv(iNc-1,kNc-1,jNc) ) )
       ELSEIF (stag .EQ. 'f') THEN
          xkmv_tmp = 0.5 * ( fnm(kNc) * ( xkmv(iNc,kNc  ,jNc) + xkmv(iNc,kNc  ,jNc-1) ) &
                           + fnp(kNc) * ( xkmv(iNc,kNc-1,jNc) + xkmv(iNc,kNc-1,jNc-1) ) )
       ENDIF
      
       IF (radius(nC) .LE. 0.001) THEN
          !DJW if the IP is aligned with a grid-point then radius is 0 and we
          !    end up dividing by 0 when calculating the weight...
          weight = 0.0
          weight(nC) = 1.0
          IF (stag .EQ. 't') THEN
             tau_img_1(2) = -defor11(iNc,kNc,jNc) * xkmv_tmp
             tau_img_2(2) = -defor22(iNc,kNc,jNc) * xkmv_tmp
             tau_img_3(2) = -defor33(iNc,kNc,jNc) * xkmv_tmp
          ELSEIF (stag .EQ. 'd') THEN
             tau_img_1(2) = -defor12(iNc,kNc,jNc) * xkmv_tmp
          ELSEIF (stag .EQ. 'e') THEN
             tau_img_1(2) = -defor13(iNc,kNc,jNc) * xkmv_tmp
          ELSEIF (stag .EQ. 'f') THEN
             tau_img_1(2) = -defor23(iNc,kNc,jNc) * xkmv_tmp
          ENDIF
          GOTO 200
       ELSE
          IF (nC .EQ. 0) THEN
             tau_img_1(2) = tau_img_1(2) + weight(nC)*0.0
             tau_img_2(2) = tau_img_2(2) + weight(nC)*0.0
             tau_img_3(2) = tau_img_3(2) + weight(nC)*0.0
          ELSE
             weight(nC) = ((max_rad-radius(nC))/(max_rad*radius(nC)))**(0.5)
             IF (stag .EQ. 't') THEN
                tau_img_1(2) = tau_img_1(2) - weight(nC) * defor11(iNc,kNc,jNc) * xkmv_tmp
                tau_img_2(2) = tau_img_2(2) - weight(nC) * defor22(iNc,kNc,jNc) * xkmv_tmp
                tau_img_3(2) = tau_img_3(2) - weight(nC) * defor33(iNc,kNc,jNc) * xkmv_tmp
             ELSEIF (stag .EQ. 'd') THEN
                tau_img_1(2) = tau_img_1(2) - weight(nC) * defor12(iNc,kNc,jNc) * xkmv_tmp
             ELSEIF (stag .EQ. 'e') THEN
                tau_img_1(2) = tau_img_1(2) - weight(nC) * defor13(iNc,kNc,jNc) * xkmv_tmp
             ELSEIF (stag .EQ. 'f') THEN
                tau_img_1(2) = tau_img_1(2) - weight(nC) * defor23(iNc,kNc,jNc) * xkmv_tmp
             ENDIF
          ENDIF
       ENDIF
    ENDDO
200 tau_img_1(2) = tau_img_1(2)/SUM(weight)
    tau_img_2(2) = tau_img_2(2)/SUM(weight)
    tau_img_3(2) = tau_img_3(2)/SUM(weight)

    !get stress at third extrapolation point
    !stress is -xkmv*defor
    radius = 0.0
    DO nC=0,ant_3(i,j)-1
       !calculate the radius to image point, and determine the largest radius  
       radius(nC) = SQRT(top_neigh(i,j,6*n+3*nC)**2+top_neigh(i,j,6*n+3*nC+1)**2+top_neigh(i,j,6*n+3*nC+2)**2)
       IF (radius(nC) .EQ. 0.0) radius(nC) = epsilon
    ENDDO
    max_rad = MAXVAL(radius)
    weight = 0.0
    DO nC=0,ant_3(i,j)-1
       iNc = top_neigh_i(i,j,6*n+3*nC)
       jNc = top_neigh_i(i,j,6*n+3*nC+1)
       kNc = top_neigh_i(i,j,6*n+3*nC+2)

       !Get xkmv at neighbor
       IF (stag .EQ. 't') THEN
          xkmv_tmp = xkmv(iNc,kNc,jNc)
       ELSEIF (stag .EQ. 'd') THEN
          xkmv_tmp = 0.25 * ( xkmv(iNc-1,kNc,jNc  ) + xkmv(iNc,kNc,jNc  ) &
                            + xkmv(iNc-1,kNc,jNc-1) + xkmv(iNc,kNc,jNc-1) )
       ELSEIF (stag .EQ. 'e') THEN
          xkmv_tmp = 0.5 * ( fnm(kNc) * ( xkmv(iNc,kNc  ,jNc) + xkmv(iNc-1,kNc  ,jNc) ) &
                           + fnp(kNc) * ( xkmv(iNc,kNc-1,jNc) + xkmv(iNc-1,kNc-1,jNc) ) )
       ELSEIF (stag .EQ. 'f') THEN
          xkmv_tmp = 0.5 * ( fnm(kNc) * ( xkmv(iNc,kNc  ,jNc) + xkmv(iNc,kNc  ,jNc-1) ) &
                           + fnp(kNc) * ( xkmv(iNc,kNc-1,jNc) + xkmv(iNc,kNc-1,jNc-1) ) )
       ENDIF
      
       IF (radius(nC) .LE. 0.001) THEN
          !DJW if the IP is aligned with a grid-point then radius is 0 and we
          !    end up dividing by 0 when calculating the weight...
          weight = 0.0
          weight(nC) = 1.0
          IF (stag .EQ. 't') THEN
             tau_img_1(3) = -defor11(iNc,kNc,jNc) * xkmv_tmp
             tau_img_2(3) = -defor22(iNc,kNc,jNc) * xkmv_tmp
             tau_img_3(3) = -defor33(iNc,kNc,jNc) * xkmv_tmp
          ELSEIF (stag .EQ. 'd') THEN
             tau_img_1(3) = -defor12(iNc,kNc,jNc) * xkmv_tmp
          ELSEIF (stag .EQ. 'e') THEN
             tau_img_1(3) = -defor13(iNc,kNc,jNc) * xkmv_tmp
          ELSEIF (stag .EQ. 'f') THEN
             tau_img_1(3) = -defor23(iNc,kNc,jNc) * xkmv_tmp
          ENDIF
          GOTO 300
       ELSE
          IF (nC .EQ. 0) THEN
             tau_img_1(3) = tau_img_1(3) + weight(nC)*0.0
             tau_img_2(3) = tau_img_2(3) + weight(nC)*0.0
             tau_img_3(3) = tau_img_3(3) + weight(nC)*0.0
          ELSE
             weight(nC) = ((max_rad-radius(nC))/(max_rad*radius(nC)))**(0.5)
             IF (stag .EQ. 't') THEN
                tau_img_1(3) = tau_img_1(3) - weight(nC) * defor11(iNc,kNc,jNc) * xkmv_tmp
                tau_img_2(3) = tau_img_2(3) - weight(nC) * defor22(iNc,kNc,jNc) * xkmv_tmp
                tau_img_3(3) = tau_img_3(3) - weight(nC) * defor33(iNc,kNc,jNc) * xkmv_tmp
             ELSEIF (stag .EQ. 'd') THEN
                tau_img_1(3) = tau_img_1(3) - weight(nC) * defor12(iNc,kNc,jNc) * xkmv_tmp
             ELSEIF (stag .EQ. 'e') THEN
                tau_img_1(3) = tau_img_1(3) - weight(nC) * defor13(iNc,kNc,jNc) * xkmv_tmp
             ELSEIF (stag .EQ. 'f') THEN
                tau_img_1(3) = tau_img_1(3) - weight(nC) * defor23(iNc,kNc,jNc) * xkmv_tmp
             ENDIF
          ENDIF
       ENDIF
    ENDDO
300 tau_img_1(3) = tau_img_1(3)/SUM(weight)
    tau_img_2(3) = tau_img_2(3)/SUM(weight)
    tau_img_3(3) = tau_img_3(3)/SUM(weight)

    !Extrapolate stress to ghost point with:
    !tau_ghost = 3*tau_img(1) - 3*tau_img(2) + tau_img(3) ...new higher order extrap
    !or
    !tau_ghost = 2*tau_img(1) - tau_img(2) ...linear extrap used in previous studies
    !Divide by -xkmv so that the correct deformation is recovered in diffusion
    !routines when defor is multiplied by -xkmv. Note that mix_isotropic=1 for
    !now such that xkmv=xkmh.
    IF (stag .EQ. 't') THEN
       xkmv_tmp = xkmv(i,top(i,j),j)
       IF (xkmv_tmp .NE. 0.0) THEN
         ! defor11(i,top(i,j),j) = ( 2*tau_img_1(1) - tau_img_1(2) ) / -xkmv_tmp
         ! defor22(i,top(i,j),j) = ( 2*tau_img_2(1) - tau_img_2(2) ) / -xkmv_tmp
         ! defor33(i,top(i,j),j) = ( 2*tau_img_3(1) - tau_img_3(2) ) / -xkmv_tmp
         defor11(i,top(i,j),j) = ( 3*tau_img_1(1) - 3*tau_img_1(2) + tau_img_1(3) ) / -xkmv_tmp
         defor22(i,top(i,j),j) = ( 3*tau_img_2(1) - 3*tau_img_2(2) + tau_img_2(3) ) / -xkmv_tmp
         defor33(i,top(i,j),j) = ( 3*tau_img_3(1) - 3*tau_img_3(2) + tau_img_3(3) ) / -xkmv_tmp
       ELSE
         defor11(i,top(i,j),j) = 0.0
         defor22(i,top(i,j),j) = 0.0
         defor33(i,top(i,j),j) = 0.0
       ENDIF
    ELSEIF (stag .EQ. 'd') THEN
       xkmv_tmp = 0.25 * ( xkmv(i-1,top(i,j),j  ) + xkmv(i,top(i,j),j  ) &
                         + xkmv(i-1,top(i,j),j-1) + xkmv(i,top(i,j),j-1) )
       IF (xkmv_tmp .NE. 0.0) THEN
          ! defor12(i,top(i,j),j) = ( 2*tau_img_1(1) - tau_img_1(2) ) / -xkmv_tmp
          defor12(i,top(i,j),j) = ( 3*tau_img_1(1) - 3*tau_img_1(2) + tau_img_1(3) ) / -xkmv_tmp
       ELSE
          defor12(i,top(i,j),j) = 0.0
       ENDIF
    ELSEIF (stag .EQ. 'e') THEN
       xkmv_tmp = 0.5 * ( fnm(top(i,j)) * ( xkmv(i,top(i,j)  ,j) + xkmv(i-1,top(i,j)  ,j) ) &
                        + fnp(top(i,j)) * ( xkmv(i,top(i,j)-1,j) + xkmv(i-1,top(i,j)-1,j) ) )
       IF (xkmv_tmp .NE. 0.0) THEN
          ! defor13(i,top(i,j),j) = ( 2*tau_img_1(1) - tau_img_1(2) ) / -xkmv_tmp
          defor13(i,top(i,j),j) = ( 3*tau_img_1(1) - 3*tau_img_1(2) + tau_img_1(3) ) / -xkmv_tmp
       ELSE
          defor13(i,top(i,j),j) = 0.0
       ENDIF
    ELSEIF (stag .EQ. 'f') THEN
       xkmv_tmp = 0.5 * ( fnm(top(i,j)) * ( xkmv(i,top(i,j)  ,j) + xkmv(i,top(i,j)  ,j-1) ) &
                        + fnp(top(i,j)) * ( xkmv(i,top(i,j)-1,j) + xkmv(i,top(i,j)-1,j-1) ) )
       IF (xkmv_tmp .NE. 0.0) THEN
          ! defor23(i,top(i,j),j) = ( 2*tau_img_1(1) - tau_img_1(2) ) / -xkmv_tmp
          defor23(i,top(i,j),j) = ( 3*tau_img_1(1) - 3*tau_img_1(2) + tau_img_1(3) ) / -xkmv_tmp
       ELSE
          defor23(i,top(i,j),j) =  0.0
       ENDIF
    ENDIF

 ENDDO
 ENDDO

 IF (np .GT. 0) THEN
    DO S=1,np 

       tau_img_1 = 0.0
       tau_img_2 = 0.0
       tau_img_3 = 0.0

       !get stress at first extrapolatioin point 
       !stress is -xkmv*defor
       radius = 0.0

       DO nC=0,ans_1(S)-1
          !calculate the radius to image point, and determine the largest radius  
          radius(nC) = SQRT(side_neigh(3*nC,S)**2+side_neigh(3*nC+1,S)**2+side_neigh(3*nC+2,S)**2)
          IF (radius(nC) .EQ. 0.0) radius(nC) = epsilon
       ENDDO
       max_rad = MAXVAL(radius)
       weight = 0.0
       DO nC=0,ans_1(S)-1
          iNc = side_neigh_i(3*nC,S)
          jNc = side_neigh_i(3*nC+1,S)
          kNc = side_neigh_i(3*nC+2,S)

          !Get xkmv at neighbor
          IF (stag .EQ. 't') THEN
             xkmv_tmp = xkmv(iNc,kNc,jNc)
          ELSEIF (stag .EQ. 'd') THEN
             xkmv_tmp = 0.25 * ( xkmv(iNc-1,kNc,jNc  ) + xkmv(iNc,kNc,jNc  ) &
                               + xkmv(iNc-1,kNc,jNc-1) + xkmv(iNc,kNc,jNc-1) )
          ELSEIF (stag .EQ. 'e') THEN
             xkmv_tmp = 0.5 * ( fnm(kNc) * ( xkmv(iNc,kNc  ,jNc) + xkmv(iNc-1,kNc  ,jNc) ) &
                              + fnp(kNc) * ( xkmv(iNc,kNc-1,jNc) + xkmv(iNc-1,kNc-1,jNc) ) )
          ELSEIF (stag .EQ. 'f') THEN
             xkmv_tmp = 0.5 * ( fnm(kNc) * ( xkmv(iNc,kNc  ,jNc) + xkmv(iNc,kNc  ,jNc-1) ) &
                              + fnp(kNc) * ( xkmv(iNc,kNc-1,jNc) + xkmv(iNc,kNc-1,jNc-1) ) )
          ENDIF

          IF (nC .EQ. 0) THEN
             tau_img_1(1) = tau_img_1(1) + weight(nC)*0.0
             tau_img_2(1) = tau_img_2(1) + weight(nC)*0.0
             tau_img_3(1) = tau_img_3(1) + weight(nC)*0.0
          ELSE
             weight(nC) = ((max_rad-radius(nC))/(max_rad*radius(nC)))**(0.5)
             IF (stag .EQ. 't') THEN
                tau_img_1(1) = tau_img_1(1) - weight(nC) * defor11(iNc,kNc,jNc) * xkmv_tmp
                tau_img_2(1) = tau_img_2(1) - weight(nC) * defor22(iNc,kNc,jNc) * xkmv_tmp
                tau_img_3(1) = tau_img_3(1) - weight(nC) * defor33(iNc,kNc,jNc) * xkmv_tmp
             ELSEIF (stag .EQ. 'd') THEN
                tau_img_1(1) = tau_img_1(1) - weight(nC) * defor12(iNc,kNc,jNc) * xkmv_tmp
             ELSEIF (stag .EQ. 'e') THEN
                tau_img_1(1) = tau_img_1(1) - weight(nC) * defor13(iNc,kNc,jNc) * xkmv_tmp
             ELSEIF (stag .EQ. 'f') THEN
                tau_img_1(1) = tau_img_1(1) - weight(nC) * defor23(iNc,kNc,jNc) * xkmv_tmp
             ENDIF
          ENDIF
       ENDDO
       tau_img_1(1) = tau_img_1(1)/SUM(weight)
       tau_img_2(1) = tau_img_2(1)/SUM(weight)
       tau_img_3(1) = tau_img_3(1)/SUM(weight)

       !get stress at second extrapolation point
       !stress is -xkmv*defor
       radius = 0.0
       DO nC=0,ans_2(S)-1
          !calculate the radius to image point, and determine the largest radius  
          radius(nC) = SQRT(side_neigh(3*n+3*nC,S)**2+side_neigh(3*n+3*nC+1,S)**2+side_neigh(3*n+3*nC+2,S)**2)
          IF (radius(nC) .EQ. 0.0) radius(nC) = epsilon
       ENDDO
       max_rad = MAXVAL(radius)
       weight = 0.0
       DO nC=0,ans_2(S)-1
          iNc = side_neigh_i(3*nC,S)
          jNc = side_neigh_i(3*nC+1,S)
          kNc = side_neigh_i(3*nC+2,S)

          !Get xkmv at neighbor
          IF (stag .EQ. 't') THEN
             xkmv_tmp = xkmv(iNc,kNc,jNc)
          ELSEIF (stag .EQ. 'd') THEN
             xkmv_tmp = 0.25 * ( xkmv(iNc-1,kNc,jNc  ) + xkmv(iNc,kNc,jNc  ) &
                               + xkmv(iNc-1,kNc,jNc-1) + xkmv(iNc,kNc,jNc-1) )
          ELSEIF (stag .EQ. 'e') THEN
             xkmv_tmp = 0.5 * ( fnm(kNc) * ( xkmv(iNc,kNc  ,jNc) + xkmv(iNc-1,kNc  ,jNc) ) &
                              + fnp(kNc) * ( xkmv(iNc,kNc-1,jNc) + xkmv(iNc-1,kNc-1,jNc) ) )
          ELSEIF (stag .EQ. 'f') THEN
             xkmv_tmp = 0.5 * ( fnm(kNc) * ( xkmv(iNc,kNc  ,jNc) + xkmv(iNc,kNc  ,jNc-1) ) &
                              + fnp(kNc) * ( xkmv(iNc,kNc-1,jNc) + xkmv(iNc,kNc-1,jNc-1) ) )
          ENDIF

          IF (nC .EQ. 0) THEN
             tau_img_1(2) = tau_img_1(2) + weight(nC)*0.0
             tau_img_2(2) = tau_img_2(2) + weight(nC)*0.0
             tau_img_3(2) = tau_img_3(2) + weight(nC)*0.0
          ELSE
             weight(nC) = ((max_rad-radius(nC))/(max_rad*radius(nC)))**(0.5)
             IF (stag .EQ. 't') THEN
                tau_img_1(2) = tau_img_1(2) - weight(nC) * defor11(iNc,kNc,jNc) * xkmv_tmp
                tau_img_2(2) = tau_img_2(2) - weight(nC) * defor22(iNc,kNc,jNc) * xkmv_tmp
                tau_img_3(2) = tau_img_3(2) - weight(nC) * defor33(iNc,kNc,jNc) * xkmv_tmp
             ELSEIF (stag .EQ. 'd') THEN
                tau_img_1(2) = tau_img_1(2) - weight(nC) * defor12(iNc,kNc,jNc) * xkmv_tmp
             ELSEIF (stag .EQ. 'e') THEN
                tau_img_1(2) = tau_img_1(2) - weight(nC) * defor13(iNc,kNc,jNc) * xkmv_tmp
             ELSEIF (stag .EQ. 'f') THEN
                tau_img_1(2) = tau_img_1(2) - weight(nC) * defor23(iNc,kNc,jNc) * xkmv_tmp
             ENDIF
          ENDIF
       ENDDO
       tau_img_1(2) = tau_img_1(2)/SUM(weight)
       tau_img_2(2) = tau_img_2(2)/SUM(weight)
       tau_img_3(2) = tau_img_3(2)/SUM(weight)

       !get stress at third extrapolation point
       !stress is -xkmv*defor
       radius = 0.0
       DO nC=0,ans_3(S)-1
          !calculate the radius to image point, and determine the largest radius  
          radius(nC) = SQRT(side_neigh(6*n+3*nC,S)**2+side_neigh(6*n+3*nC+1,S)**2+side_neigh(6*n+3*nC+2,S)**2)
          IF (radius(nC) .EQ. 0.0) radius(nC) = epsilon
       ENDDO
       max_rad = MAXVAL(radius)
       weight = 0.0
       DO nC=0,ans_3(S)-1
          iNc = side_neigh_i(6*nC,S)
          jNc = side_neigh_i(6*nC+1,S)
          kNc = side_neigh_i(6*nC+2,S)

          !Get xkmv at neighbor
          IF (stag .EQ. 't') THEN
             xkmv_tmp = xkmv(iNc,kNc,jNc)
          ELSEIF (stag .EQ. 'd') THEN
             xkmv_tmp = 0.25 * ( xkmv(iNc-1,kNc,jNc  ) + xkmv(iNc,kNc,jNc  ) &
                               + xkmv(iNc-1,kNc,jNc-1) + xkmv(iNc,kNc,jNc-1) )
          ELSEIF (stag .EQ. 'e') THEN
             xkmv_tmp = 0.5 * ( fnm(kNc) * ( xkmv(iNc,kNc  ,jNc) + xkmv(iNc-1,kNc  ,jNc) ) &
                              + fnp(kNc) * ( xkmv(iNc,kNc-1,jNc) + xkmv(iNc-1,kNc-1,jNc) ) )
          ELSEIF (stag .EQ. 'f') THEN
             xkmv_tmp = 0.5 * ( fnm(kNc) * ( xkmv(iNc,kNc  ,jNc) + xkmv(iNc,kNc  ,jNc-1) ) &
                              + fnp(kNc) * ( xkmv(iNc,kNc-1,jNc) + xkmv(iNc,kNc-1,jNc-1) ) )
          ENDIF

          IF (nC .EQ. 0) THEN
             tau_img_1(3) = tau_img_1(3) + weight(nC)*0.0
             tau_img_2(3) = tau_img_2(3) + weight(nC)*0.0
             tau_img_3(3) = tau_img_3(3) + weight(nC)*0.0
          ELSE
             weight(nC) = ((max_rad-radius(nC))/(max_rad*radius(nC)))**(0.5)
             IF (stag .EQ. 't') THEN
                tau_img_1(3) = tau_img_1(3) - weight(nC) * defor11(iNc,kNc,jNc) * xkmv_tmp
                tau_img_2(3) = tau_img_2(3) - weight(nC) * defor22(iNc,kNc,jNc) * xkmv_tmp
                tau_img_3(3) = tau_img_3(3) - weight(nC) * defor33(iNc,kNc,jNc) * xkmv_tmp
             ELSEIF (stag .EQ. 'd') THEN
                tau_img_1(3) = tau_img_1(3) - weight(nC) * defor12(iNc,kNc,jNc) * xkmv_tmp
             ELSEIF (stag .EQ. 'e') THEN
                tau_img_1(3) = tau_img_1(3) - weight(nC) * defor13(iNc,kNc,jNc) * xkmv_tmp
             ELSEIF (stag .EQ. 'f') THEN
                tau_img_1(3) = tau_img_1(3) - weight(nC) * defor23(iNc,kNc,jNc) * xkmv_tmp
             ENDIF
          ENDIF
       ENDDO
       tau_img_1(3) = tau_img_1(3)/SUM(weight)
       tau_img_2(3) = tau_img_2(3)/SUM(weight)
       tau_img_3(3) = tau_img_3(3)/SUM(weight)

       !Extrapolate stress to ghost point with:
       !tau_ghost = 3*tau_img(1) - 3*tau_img(2) + tau_img(3) ...new higher order extrap
       !or
       !tau_ghost = 2*tau_img(1) - tau_img(2) ...linear extrap used in previous studies
       !Divide by -xkmv so that the correct deformation is recovered in diffusion
       !routines when defor is multiplied by -xkmv. Note that mix_isotropic=1 for
       !now such that xkmv=xkmh.
       IF (stag .EQ. 't') THEN
          xkmv_tmp = xkmv(side(1,S),side(3,S),side(2,S))
          IF (xkmv_tmp .NE. 0.0) THEN
             ! defor11(side(1,S),side(3,S),side(2,S)) = ( 2*tau_img_1(1) - tau_img_1(2) ) / -xkmv_tmp
             ! defor22(side(1,S),side(3,S),side(2,S)) = ( 2*tau_img_2(1) - tau_img_2(2) ) / -xkmv_tmp
             ! defor33(side(1,S),side(3,S),side(2,S)) = ( 2*tau_img_3(1) - tau_img_3(2) ) / -xkmv_tmp
             defor11(side(1,S),side(3,S),side(2,S)) = ( 3*tau_img_1(1) - 3*tau_img_1(2) + tau_img_1(3) ) / -xkmv_tmp
             defor22(side(1,S),side(3,S),side(2,S)) = ( 3*tau_img_1(1) - 3*tau_img_1(2) + tau_img_1(3) ) / -xkmv_tmp
             defor33(side(1,S),side(3,S),side(2,S)) = ( 3*tau_img_1(1) - 3*tau_img_1(2) + tau_img_1(3) ) / -xkmv_tmp
          ELSE
             defor11(side(1,S),side(3,S),side(2,S)) = 0.0
             defor22(side(1,S),side(3,S),side(2,S)) = 0.0
             defor33(side(1,S),side(3,S),side(2,S)) = 0.0
          ENDIF
       ELSEIF (stag .EQ. 'd') THEN
          xkmv_tmp = 0.25 * ( xkmv(side(1,S)-1,side(3,S),side(2,S)  ) + xkmv(side(1,S),side(3,S),side(2,S)  ) &
                            + xkmv(side(1,S)-1,side(3,S),side(2,S)-1) + xkmv(side(1,S),side(3,S),side(2,S)-1) )
          IF (xkmv_tmp .NE. 0.0) THEN
             ! defor12(side(1,S),side(3,S),side(2,S)) = ( 2*tau_img_1(1) - tau_img_1(2) ) / -xkmv_tmp
             defor12(side(1,S),side(3,S),side(2,S)) = ( 3*tau_img_1(1) - 3*tau_img_1(2) + tau_img_1(3) ) / -xkmv_tmp
          ELSE
             defor12(side(1,S),side(3,S),side(2,S)) = 0.0
          ENDIF
       ELSEIF (stag .EQ. 'e') THEN
          xkmv_tmp = 0.5 * ( fnm(side(3,S)) * ( xkmv(side(1,S),side(3,S)  ,side(2,S)) + xkmv(side(1,S)-1,side(3,S)  ,side(2,S)) ) &
                           + fnp(side(3,S)) * ( xkmv(side(1,S),side(3,S)-1,side(2,S)) + xkmv(side(1,S)-1,side(3,S)-1,side(2,S)) ) )
          IF (xkmv_tmp .NE. 0.0) THEN
             ! defor13(side(1,S),side(3,S),side(2,S)) = ( 2*tau_img_1(1) - tau_img_1(2) ) / -xkmv_tmp
             defor13(side(1,S),side(3,S),side(2,S)) = ( 3*tau_img_1(1) - 3*tau_img_1(2) + tau_img_1(3) ) / -xkmv_tmp
          ELSE
             defor13(side(1,S),side(3,S),side(2,S)) = 0.0
          ENDIF
       ELSEIF (stag .EQ. 'f') THEN
          xkmv_tmp = 0.5 * ( fnm(side(3,S)) * ( xkmv(side(1,S),side(3,S)  ,side(2,S)) + xkmv(side(1,S),side(3,S)  ,side(2,S)-1) ) &
                           + fnp(side(3,S)) * ( xkmv(side(1,S),side(3,S)-1,side(2,S)) + xkmv(side(1,S),side(3,S)-1,side(2,S)-1) ) )
          IF (xkmv_tmp .NE. 0.0) THEN
             ! defor23(side(1,S),side(3,S),side(2,S)) = ( 2*tau_img_1(1) - tau_img_1(2) ) / -xkmv_tmp
             defor23(side(1,S),side(3,S),side(2,S)) = ( 3*tau_img_1(1) - 3*tau_img_1(2) + tau_img_1(3) ) / -xkmv_tmp
          ELSE
             defor23(side(1,S),side(3,S),side(2,S)) = 0.0
          ENDIF
       ENDIF

    ENDDO 
 ENDIF

 END SUBROUTINE shear_stress_extrap_inverse_dist

!-------------------------------------------------------------------------------------------------------------------------------------

 SUBROUTINE neumann_lin_ss( grad, prox, dim_terrain,              &
                            var, varfull, varsave,                &
                            mu, mus,                              &
                            h_diabatic,                           &
                            number_of_small_timesteps,dts,        &
                            rk_step, rk_order,                    &
                            top_norm, side_norm,                  &
                            top_dist, side_dist,                  &
                            top, top_img,                         &
                            side, side_img,                       &
                            top_neigh, side_neigh,                &
                            top_neigh_i, side_neigh_i,            &
                            n, np,                                &
                            ids, ide, jds, jde, kds, kde,         &
                            ims, ime, jms, jme, kms, kme,         &
                            its, ite, jts, jte, kts, kte )

 IMPLICIT NONE
 !input data  			    
 REAL, DIMENSION(ims:ime,jms:jme), INTENT(IN   )           :: grad,       &
                                                              top_dist
 REAL, DIMENSION(ims:ime,kms:kme,jms:jme), INTENT(INOUT)   :: var,        &
                                                              varfull
 REAL, DIMENSION(ims:ime,kms:kme,jms:jme), INTENT(IN   )   :: varsave,    &
                                                              h_diabatic
 REAL, DIMENSION(ims:ime,jms:jme), INTENT(IN   )           :: mu,         &
                                                              mus
 INTEGER, DIMENSION(ims:ime,jms:jme), INTENT(IN   )        :: prox,       &
                                                              top  
 INTEGER, DIMENSION(3,np), INTENT(IN   )                   :: side            !'side boundary' ghost points	
 REAL, DIMENSION(ims:ime,jms:jme,3), INTENT(IN   )         :: top_norm
 REAL, DIMENSION(3,np), INTENT(IN   )                      :: side_norm
 REAL, DIMENSION(np), INTENT(IN   )                        :: side_dist
 REAL, DIMENSION(ims:ime,jms:jme,6), INTENT(IN   )         :: top_img         ! (x,y,z) location of ghost point and image point of the 'top boundary' ghost points
 REAL, DIMENSION(6,np), INTENT(IN   )                      :: side_img        ! (x,y,z) location of ghost point and image point of the 'side boundary' ghost points						      
 REAL, DIMENSION(ims:ime,jms:jme,0:3*n-1), INTENT(IN   )   :: top_neigh       ! (x,y,z) location of  neighbors
 REAL, DIMENSION(0:3*n-1,np), INTENT(IN   )                :: side_neigh      ! (x,y,z) location of neighbors							      
 INTEGER, DIMENSION(ims:ime,jms:jme,0:3*n-1), INTENT(IN   ):: top_neigh_i     ! (i,j,k) index of top neighbors
 INTEGER, DIMENSION(0:3*n-1,np), INTENT(IN   )             :: side_neigh_i    ! (i,j,k) location of neighbors						      
 REAL, INTENT(IN   )                                       :: dts
 INTEGER, INTENT(IN   )                                    :: dim_terrain, &
                                                              number_of_small_timesteps, &
                                                              rk_step,     &
                                                              rk_order,    &
                                                              n,           &  ! desired number of nearest neighbors
                                                              np              ! number of side ghost points
 INTEGER, INTENT(IN   )                   :: ids, ide, jds, jde, kds, kde, &  ! d: domain m:memory p:patch t:tile
                                             ims, ime, jms, jme, kms, kme, &
                                             its, ite, jts, jte, kts, kte
 !local data
 INTEGER                                                   :: i, j, nC, S, &
                                                              info
 REAL, DIMENSION(n*n)                                      :: matrix
 REAL, DIMENSION(n)                                        :: RHS
 INTEGER, DIMENSION(n)                                     :: ipiv
 
 !---------------------------------------------------------------------------------
 ! the executable begins here
 CALL wrf_debug(100, 'dyn_em/module_ibm.F/subroutine neumann_lin_ss')
 ! bilinear or trilinear interpolation 
 ! this is the matrix for 2-d problems
 ! if the node is a computational node then
 ! matrix = |1 x z x*z|  a_coef = |a|   RHS = |theta|
 ! if the node is a boundary node then 
 ! matrix = |0 n_x n_z n_x*z+n_z*x|  a_coef = |a|   RHS = |d_theta/d_n|
 ! this is the matrix for 3-d problems
 ! if the node is a computational node then
 ! matrix = |1 x y z x*y x*z y*z x*y*z|  a_coef = |a|  RHS =  |theta|
 ! if the node is a boundary node then
 ! matrix = |0 n_x n_y n_z n_x*y+n_y*x n_x*z+n_z*x n_y*z+n_z*y n_x*y*z+n_y*x*z+n_z*x*y|  a_coef = |a|   RHS = |d_theta/d_n|
 ! matrix*a_coef = RHS or a_coef=(matrix^-1)*RHS
 !---------------------------------------------------------------------------------

 DO i=its,MIN(ite,ide-1)
 DO j=jts,MIN(jte,jde-1)
    DO nC=0,n-1
       if (top_neigh_i(i,j,3*nC+2) == 0) then 
           if (dim_terrain == 2) then
               matrix(n*nC+1:n*nC+n) = [0., top_norm(i,j,1), top_norm(i,j,3), top_norm(i,j,1)*top_neigh(i,j,3*nC+2)+top_norm(i,j,3)*top_neigh(i,j,3*nC)]
           elseif (dim_terrain == 3) then
               matrix(n*nC+1:n*nC+n) = [0., top_norm(i,j,1), top_norm(i,j,2), top_norm(i,j,3),                       &
                                        top_norm(i,j,1)*top_neigh(i,j,3*nC+1)+top_norm(i,j,2)*top_neigh(i,j,3*nC),   &
                                        top_norm(i,j,1)*top_neigh(i,j,3*nC+2)+top_norm(i,j,3)*top_neigh(i,j,3*nC),   &
                                        top_norm(i,j,2)*top_neigh(i,j,3*nC+2)+top_norm(i,j,3)*top_neigh(i,j,3*nC+1), &
                                        top_norm(i,j,1)*top_neigh(i,j,3*nC+1)*top_neigh(i,j,3*nC+2)+top_norm(i,j,2)*top_neigh(i,j,3*nC)*top_neigh(i,j,3*nC+2)+top_norm(i,j,3)*top_neigh(i,j,3*nC)*top_neigh(i,j,3*nC+1)]
           endif
           RHS(nC+1) = grad(i,j)
       else
           if (dim_terrain == 2) then
               matrix(n*nC+1:n*nC+n) = [1., top_neigh(i,j,3*nC), top_neigh(i,j,3*nC+2), top_neigh(i,j,3*nC)*top_neigh(i,j,3*nC+2)]
           elseif (dim_terrain == 3) then
               matrix(n*nC+1:n*nC+n) = [1., top_neigh(i,j,3*nC), top_neigh(i,j,3*nC+1), top_neigh(i,j,3*nC+2), &
                                        top_neigh(i,j,3*nC)*top_neigh(i,j,3*nC+1),                             &
                                        top_neigh(i,j,3*nC)*top_neigh(i,j,3*nC+2),                             &
                                        top_neigh(i,j,3*nC+1)*top_neigh(i,j,3*nC+2),                           &
                                        top_neigh(i,j,3*nC)*top_neigh(i,j,3*nC+1)*top_neigh(i,j,3*nC+2)]
           endif
           RHS(nC+1) = varfull(top_neigh_i(i,j,3*nC),top_neigh_i(i,j,3*nC+2),top_neigh_i(i,j,3*nC+1))
       endif
    ENDDO
    if (KIND(matrix) == 4) then
        CALL SGETRF(n,n,matrix,n,ipiv,info)
        !if (info/=0) CALL wrf_error_fatal('LU Factorization')
        if (info/=0) print '(1A20,2i5,64f20.8)','neumann top LU i,j=',i,j,matrix
        CALL SGETRS('T',n,1,matrix,n,ipiv,RHS,n,info)
        !if (info/=0) CALL wrf_error_fatal('Matrix Solve')
        if (info/=0) print '(1A20,2i5,8f20.8)','neumann top S i,j=',i,j,RHS
    elseif (KIND(matrix) == 8) then    
        CALL DGETRF(n,n,matrix,n,ipiv,info)
        !if (info/=0) CALL wrf_error_fatal('LU Factorization')
        if (info/=0) print '(1A20,2i5,64f20.8)','neumann top LU i,j=',i,j,matrix
        CALL DGETRS('T',n,1,matrix,n,ipiv,RHS,n,info)
        !if (info/=0) CALL wrf_error_fatal('Matrix Solve')
        if (info/=0) print '(1A20,2i5,8f20.8)','neumann top S i,j=',i,j,RHS
    endif
    ! calculate the value at the ghost point
    if (prox(i,j) == 0) then
        varfull(i,top(i,j),j)=RHS(1)-2*top_dist(i,j)*grad(i,j)
    elseif (prox(i,j) == 1) then
        varfull(i,top(i,j),j)=RHS(1)
    endif
       
    if (rk_step < rk_order) then
        var(i,top(i,j),j) = varfull(i,top(i,j),j)*mus(i,j) - varsave(i,top(i,j),j)*mu(i,j)
    else
        var(i,top(i,j),j) = varfull(i,top(i,j),j)*mus(i,j) - varsave(i,top(i,j),j)*mu(i,j) &
                          + dts*number_of_small_timesteps*mu(i,j)*h_diabatic(i,top(i,j),j)
    endif
 ENDDO
 ENDDO   ! end of setting scalar at ghost point

 if (np > 0) then
    DO S=1,np
       DO nC=0,n-1
          if (side_neigh_i(3*nC+2,S) == 0) then
              if (dim_terrain == 2) then
                  matrix(n*nC+1:n*nC+n) = [0., side_norm(1,S), side_norm(3,S), side_norm(1,S)*side_neigh(3*nC+2,S)+side_norm(3,S)*side_neigh(3*nC,S)]
              elseif (dim_terrain == 3) then
                  matrix(n*nC+1:n*nC+n) = [0., side_norm(1,S), side_norm(2,S), side_norm(3,S), &
                                           side_norm(1,S)*side_neigh(3*nC+1,S)+side_norm(2,S)*side_neigh(3*nC,S), &
                                           side_norm(1,S)*side_neigh(3*nC+2,S)+side_norm(3,S)*side_neigh(3*nC,S), &
                                           side_norm(2,S)*side_neigh(3*nC+2,S)+side_norm(3,S)*side_neigh(3*nC+1,S), &
                                           side_norm(1,S)*side_neigh(3*nC+1,S)*side_neigh(3*nC+2,S)+side_norm(2,S)*side_neigh(3*nC,S)*side_neigh(3*nC+2,S)+side_norm(3,S)*side_neigh(3*nC,S)*side_neigh(3*nC+1,S)]
              endif
              RHS(nC+1) = grad(side(1,S),side(2,S))
          else
              if (dim_terrain == 2) then
                  matrix(n*nC+1:n*nC+n) = [1., side_neigh(3*nC,S), side_neigh(3*nC+2,S), side_neigh(3*nC,S)*side_neigh(3*nC+2,S)]
              elseif (dim_terrain == 3) then
                  matrix(n*nC+1:n*nC+n) = [1., side_neigh(3*nC,S), side_neigh(3*nC+1,S), side_neigh(3*nC+2,S), &
                                           side_neigh(3*nC,S)*side_neigh(3*nC+1,S),                            &
                                           side_neigh(3*nC,S)*side_neigh(3*nC+2,S),                            &
                                           side_neigh(3*nC+1,S)*side_neigh(3*nC+2,S),                          &
                                           side_neigh(3*nC,S)*side_neigh(3*nC+1,S)*side_neigh(3*nC+2,S)]
              endif
              RHS(nC+1) = varfull(side_neigh_i(3*nC,S),side_neigh_i(3*nC+2,S),side_neigh_i(3*nC+1,S))
          endif
       ENDDO
       if (KIND(matrix) == 4) then
            CALL SGETRF(n,n,matrix,n,ipiv,info)
            !if (info/=0) CALL wrf_error_fatal('LU Factorization')
            if (info/=0) print '(1A20,1i5,64f20.8)','neumann side LU S=',S,matrix
            CALL SGETRS('T',n,1,matrix,n,ipiv,RHS,n,info)
            !if (info/=0) CALL wrf_error_fatal('Matrix Solve')
            if (info/=0) print '(1A20,1i5,8f20.8)','neumann side S S=',S,RHS
        elseif (KIND(matrix) == 8) then    
            CALL DGETRF(n,n,matrix,n,ipiv,info)
            !if (info/=0) CALL wrf_error_fatal('LU Factorization')
            if (info/=0) print '(1A20,1i5,64f20.8)','neumann side LU S=',S,matrix
            CALL DGETRS('T',n,1,matrix,n,ipiv,RHS,n,info)
            !if (info/=0) CALL wrf_error_fatal('Matrix Solve')
            if (info/=0) print '(1A20,1i5,8f20.8)','neumann side S S=',S,RHS
        endif 
        ! calculate the value at the ghost point 
        varfull(side(1,S),side(3,S),side(2,S))= RHS(1)-2*side_dist(S)*grad(side(1,S),side(2,S))
        if (rk_step < rk_order) then
            var(side(1,S),side(3,S),side(2,S)) = varfull(side(1,S),side(3,S),side(2,S))*mus(side(1,S),side(2,S)) &
                                               - varsave(side(1,S),side(3,S),side(2,S))*mu(side(1,S),side(2,S))
        else
            var(side(1,S),side(3,S),side(2,S)) = varfull(side(1,S),side(3,S),side(2,S))*mus(side(1,S),side(2,S)) &
                                               - varsave(side(1,S),side(3,S),side(2,S))*mu(side(1,S),side(2,S))  &
                                               + dts*number_of_small_timesteps*mu(side(1,S),side(2,S))*h_diabatic(side(1,S),side(3,S),side(2,S))
        endif
    ENDDO 
 endif
  
 END SUBROUTINE neumann_lin_ss

!---------------------------------------------------------------------------------------
 SUBROUTINE neumann_lin(scalar, prox, dim_terrain,          &
                        surf_grad,                          &
                        top_norm, side_norm,                &
			top_dist, side_dist,                &
                        top, top_img,                       &
			side, side_img,                     &
			top_neigh, side_neigh,              &
			top_neigh_i, side_neigh_i,          &
			n, np,                              &
			ids, ide, jds, jde, kds, kde,       &
			ims, ime, jms, jme, kms, kme,       &
			its, ite, jts, jte, kts, kte)
 IMPLICIT NONE
 ! input data  			    
 REAL, DIMENSION(ims:ime,kms:kme,jms:jme), INTENT(INOUT)   :: scalar          			  
 INTEGER, DIMENSION(ims:ime,jms:jme), INTENT(IN   )  	   :: prox,      &
                                                              top  
 INTEGER, DIMENSION(3,np), INTENT(IN   )                   :: side            !'side boundary' ghost points
 REAL, DIMENSION(ims:ime,jms:jme), INTENT(IN   )           :: surf_grad, &
                                                              top_dist	
 REAL, DIMENSION(ims:ime,jms:jme,3), INTENT(IN   )         :: top_norm	
 REAL, DIMENSION(3,np), INTENT(IN   )                      :: side_norm	
 REAL, DIMENSION(np), INTENT(IN   )                        :: side_dist
 REAL, DIMENSION(ims:ime,jms:jme,6), INTENT(IN   )         :: top_img         ! (x,y,z) location of ghost point and image point of the 'top boundary' ghost points
 REAL, DIMENSION(6,np), INTENT(IN   )                      :: side_img        ! (x,y,z) location of ghost point and image point of the 'side boundary' ghost points						      
 REAL, DIMENSION(ims:ime,jms:jme,0:3*n-1), INTENT(IN   )   :: top_neigh       ! (x,y,z) location of  neighbors
 REAL, DIMENSION(0:3*n-1,np), INTENT(IN   )                :: side_neigh      ! (x,y,z) location of neighbors							      
 INTEGER, DIMENSION(ims:ime,jms:jme,0:3*n-1), INTENT(IN   ):: top_neigh_i     ! (i,j,k) index of top neighbors
 INTEGER, DIMENSION(0:3*n-1,np), INTENT(IN   )             :: side_neigh_i    ! (i,j,k) location of neighbors						      
 INTEGER, INTENT(IN   )                                    :: dim_terrain, &
                                                              n,           &  ! desired number of nearest neighbors
                                                              np              ! number of side ghost points
 INTEGER, INTENT(IN   )                   :: ids, ide, jds, jde, kds, kde, &  ! d: domain m:memory p:patch t:tile
                                             ims, ime, jms, jme, kms, kme, &
                                             its, ite, jts, jte, kts, kte		   

 !local data
 INTEGER						   :: i,j,nC,S,    &
							      info
 REAL, DIMENSION(n*n)					   :: matrix
 REAL, DIMENSION(n)					   :: RHS
 INTEGER, DIMENSION(n)                                     :: ipiv
 
 !---------------------------------------------------------------------------------
 ! the executable begins here
  CALL wrf_debug(100,'dyn_em/module_ibm.F/subroutine neumann_lin')
 ! bilinear or trilinear interpolation 
 ! this is the matrix for 2-d problems
 ! if the node is a computational node then
 ! matrix = |1 x z x*z|  a_coef = |a|   RHS = |theta|
 ! if the node is a boundary node then 
 ! matrix = |0 n_x n_z n_x*z+n_z*x|  a_coef = |a|   RHS = |d_theta/d_n|
 ! this is the matrix for 3-d problems
 ! if the node is a computational node then
 ! matrix = |1 x y z x*y x*z y*z x*y*z|  a_coef = |a|  RHS =  |theta|
 ! if the node is a boundary node then
 ! matrix = |0 n_x n_y n_z n_x*y+n_y*x n_x*z+n_z*x n_y*z+n_z*y n_x*y*z+n_y*x*z+n_z*x*y|  a_coef = |a|   RHS = |d_theta/d_n|
 ! matrix*a_coef = RHS or a_coef=(matrix^-1)*RHS 
 !---------------------------------------------------------------------------------


 DO i=its,MIN(ite,ide-1)
 DO j=jts,MIN(jte,jde-1)
    DO nC=0,n-1
       if (top_neigh_i(i,j,3*nC+2) == 0) then     
           if (dim_terrain == 2) then
               matrix(n*nC+1:n*nC+n) = [0., top_norm(i,j,1), top_norm(i,j,3), top_norm(i,j,1)*top_neigh(i,j,3*nC+2)+top_norm(i,j,3)*top_neigh(i,j,3*nC)]
	   elseif (dim_terrain == 3) then
	       matrix(n*nC+1:n*nC+n) = [0., top_norm(i,j,1), top_norm(i,j,2), top_norm(i,j,3),                       &
	                                top_norm(i,j,1)*top_neigh(i,j,3*nC+1)+top_norm(i,j,2)*top_neigh(i,j,3*nC),   &
	                                top_norm(i,j,1)*top_neigh(i,j,3*nC+2)+top_norm(i,j,3)*top_neigh(i,j,3*nC),   &
					top_norm(i,j,2)*top_neigh(i,j,3*nC+2)+top_norm(i,j,3)*top_neigh(i,j,3*nC+1), &
					top_norm(i,j,1)*top_neigh(i,j,3*nC+1)*top_neigh(i,j,3*nC+2)+top_norm(i,j,2)*top_neigh(i,j,3*nC)*top_neigh(i,j,3*nC+2)+top_norm(i,j,3)*top_neigh(i,j,3*nC)*top_neigh(i,j,3*nC+1)]
	   endif
	   RHS(nC+1) = surf_grad(i,j)
       else	
           if (dim_terrain == 2) then	
               matrix(n*nC+1:n*nC+n) = [1., top_neigh(i,j,3*nC), top_neigh(i,j,3*nC+2), top_neigh(i,j,3*nC)*top_neigh(i,j,3*nC+2)]
	   elseif (dim_terrain == 3) then
	       matrix(n*nC+1:n*nC+n) = [1., top_neigh(i,j,3*nC), top_neigh(i,j,3*nC+1), top_neigh(i,j,3*nC+2), &
	                                top_neigh(i,j,3*nC)*top_neigh(i,j,3*nC+1),                             &
	                                top_neigh(i,j,3*nC)*top_neigh(i,j,3*nC+2),                             &
					top_neigh(i,j,3*nC+1)*top_neigh(i,j,3*nC+2),                           &
					top_neigh(i,j,3*nC)*top_neigh(i,j,3*nC+1)*top_neigh(i,j,3*nC+2)]
	   endif
	   RHS(nC+1) = scalar(top_neigh_i(i,j,3*nC),top_neigh_i(i,j,3*nC+2),top_neigh_i(i,j,3*nC+1))
       endif	 
    ENDDO
    !if ((i==24).AND.(j==27)) print *, '[',matrix(1:8),';',matrix(9:16),';',matrix(17:24),';',matrix(25:32),';',matrix(33:40),';',matrix(41:48),';',matrix(49:56),';',matrix(57:64),']'
    if (KIND(matrix) == 4) then
	CALL SGETRF(n,n,matrix,n,ipiv,info)
	!if (info/=0) CALL wrf_error_fatal('LU Factorization')
	if (info/=0) print '(1A20,2i5,64f20.8)','neumann top LU i,j=',i,j,matrix
	CALL SGETRS('T',n,1,matrix,n,ipiv,RHS,n,info)
	!if (info/=0) CALL wrf_error_fatal('Matrix Solve')
	if (info/=0) print '(1A20,2i5,8f20.8)','neumann top S i,j=',i,j,RHS	    
    elseif (KIND(matrix) == 8) then    
	CALL DGETRF(n,n,matrix,n,ipiv,info)
	!if (info/=0) CALL wrf_error_fatal('LU Factorization')
	if (info/=0) print '(1A20,2i5,64f20.8)','neumann top LU i,j=',i,j,matrix
	CALL DGETRS('T',n,1,matrix,n,ipiv,RHS,n,info)
	!if (info/=0) CALL wrf_error_fatal('Matrix Solve')
	if (info/=0) print '(1A20,2i5,8f20.8)','neumann top S i,j=',i,j,RHS
    endif 
    ! calculate the value at the ghost point
    if (prox(i,j) == 0) then
        scalar(i,top(i,j),j)=RHS(1)-2*top_dist(i,j)*surf_grad(i,j)
    elseif (prox(i,j) == 1) then
        scalar(i,top(i,j),j)=RHS(1)
    endif 
 ENDDO
 ENDDO   ! end of setting scalar at ghost point 
 

 if (np > 0) then
    DO S=1,np
       DO nC=0,n-1
	  if (side_neigh_i(3*nC+2,S) == 0) then 
	      if (dim_terrain == 2) then
                  matrix(n*nC+1:n*nC+n) = [0., side_norm(1,S), side_norm(3,S), side_norm(1,S)*side_neigh(3*nC+2,S)+side_norm(3,S)*side_neigh(3*nC,S)]
	      elseif (dim_terrain == 3) then
	          matrix(n*nC+1:n*nC+n) = [0., side_norm(1,S), side_norm(2,S), side_norm(3,S), &
		                           side_norm(1,S)*side_neigh(3*nC+1,S)+side_norm(2,S)*side_neigh(3*nC,S), &
					   side_norm(1,S)*side_neigh(3*nC+2,S)+side_norm(3,S)*side_neigh(3*nC,S), &
					   side_norm(2,S)*side_neigh(3*nC+2,S)+side_norm(3,S)*side_neigh(3*nC+1,S), &
					   side_norm(1,S)*side_neigh(3*nC+1,S)*side_neigh(3*nC+2,S)+side_norm(2,S)*side_neigh(3*nC,S)*side_neigh(3*nC+2,S)+side_norm(3,S)*side_neigh(3*nC,S)*side_neigh(3*nC+1,S)]
	      endif
	      RHS(nC+1) = surf_grad(side(1,S),side(2,S))
	  else	
	      if (dim_terrain == 2) then
                  matrix(n*nC+1:n*nC+n) = [1., side_neigh(3*nC,S), side_neigh(3*nC+2,S), side_neigh(3*nC,S)*side_neigh(3*nC+2,S)]
	      elseif (dim_terrain == 3) then
	          matrix(n*nC+1:n*nC+n) = [1., side_neigh(3*nC,S), side_neigh(3*nC+1,S), side_neigh(3*nC+2,S), &
		                           side_neigh(3*nC,S)*side_neigh(3*nC+1,S),                            &
					   side_neigh(3*nC,S)*side_neigh(3*nC+2,S),                            &
					   side_neigh(3*nC+1,S)*side_neigh(3*nC+2,S),                          &
					   side_neigh(3*nC,S)*side_neigh(3*nC+1,S)*side_neigh(3*nC+2,S)]
	      endif
	      RHS(nC+1) = scalar(side_neigh_i(3*nC,S),side_neigh_i(3*nC+2,S),side_neigh_i(3*nC+1,S))
	  endif		   	   
       ENDDO	     
	if (KIND(matrix) == 4) then
	    CALL SGETRF(n,n,matrix,n,ipiv,info)
	    !if (info/=0) CALL wrf_error_fatal('LU Factorization')
	    if (info/=0) print '(1A20,1i5,64f20.8)','neumann side LU S=',S,matrix
	    CALL SGETRS('T',n,1,matrix,n,ipiv,RHS,n,info)
	    !if (info/=0) CALL wrf_error_fatal('Matrix Solve')
	    if (info/=0) print '(1A20,1i5,8f20.8)','neumann side S S=',S,RHS	    
	elseif (KIND(matrix) == 8) then    
	    CALL DGETRF(n,n,matrix,n,ipiv,info)
	    !if (info/=0) CALL wrf_error_fatal('LU Factorization')
	    if (info/=0) print '(1A20,1i5,64f20.8)','neumann side LU S=',S,matrix
	    CALL DGETRS('T',n,1,matrix,n,ipiv,RHS,n,info)
	    !if (info/=0) CALL wrf_error_fatal('Matrix Solve')
	    if (info/=0) print '(1A20,1i5,8f20.8)','neumann side S S=',S,RHS
	endif 
	! calculate the value at the ghost point 
	scalar(side(1,S),side(3,S),side(2,S))= RHS(1)-2*side_dist(S)*surf_grad(side(1,S),side(2,S))
    ENDDO 
 endif
  
 END SUBROUTINE neumann_lin
!-------------------------------------------------------------------------------------------------------------------------------------

 SUBROUTINE neumann_inverse_dist_ss( grad, prox, dim_terrain,       &
                                     var, varfull, varsave,         &
                                     mu, mus,                       &
                                     h_diabatic,                    &
                                     number_of_small_timesteps,dts, &
                                     rk_step, rk_order,             &
                                     top_norm, side_norm,           &
                                     top_dist, side_dist,           &
                                     top, top_img,                  &
                                     side, side_img,                &
                                     top_neigh, side_neigh,         &
                                     top_neigh_i, side_neigh_i,     &
                                     n, np, ant, ans,               &
                                     ids, ide, jds, jde, kds, kde,  &
                                     ims, ime, jms, jme, kms, kme,  &
                                     its, ite, jts, jte, kts, kte )

 IMPLICIT NONE
 !input data  			    
 REAL, DIMENSION(ims:ime,jms:jme), INTENT(IN   )           :: grad,        &
                                                              top_dist
 REAL, DIMENSION(ims:ime,kms:kme,jms:jme), INTENT(INOUT)   :: var,         &
                                                              varfull
 REAL, DIMENSION(ims:ime,kms:kme,jms:jme), INTENT(IN   )   :: varsave,     &
                                                              h_diabatic
 REAL, DIMENSION(ims:ime,jms:jme), INTENT(IN   )           :: mu,          &
                                                              mus
 INTEGER, DIMENSION(ims:ime,jms:jme), INTENT(IN   )        :: prox,        &
                                                              top ,        &
                                                              ant             !actual number of nearest neighbors for top points 
 INTEGER, DIMENSION(3,np), INTENT(IN   )                   :: side            !'side boundary' ghost points	
 REAL, DIMENSION(ims:ime,jms:jme,3), INTENT(IN   )         :: top_norm
 REAL, DIMENSION(3,np), INTENT(IN   )                      :: side_norm
 REAL, DIMENSION(np), INTENT(IN   )                        :: side_dist
 REAL, DIMENSION(ims:ime,jms:jme,6), INTENT(IN   )         :: top_img         !(x,y,z) location of ghost point and image point of the 'top boundary' ghost points
 REAL, DIMENSION(6,np), INTENT(IN   )                      :: side_img        !(x,y,z) location of ghost point and image point of the 'side boundary' ghost points						      
 REAL, DIMENSION(ims:ime,jms:jme,0:3*n-1), INTENT(IN   )   :: top_neigh       !(x,y,z) location of  neighbors
 REAL, DIMENSION(0:3*n-1,np), INTENT(IN   )                :: side_neigh      !(x,y,z) location of neighbors							      
 INTEGER, DIMENSION(ims:ime,jms:jme,0:3*n-1), INTENT(IN   ):: top_neigh_i     !(i,j,k) index of top neighbors
 INTEGER, DIMENSION(0:3*n-1,np), INTENT(IN   )             :: side_neigh_i    !(i,j,k) location of neighbors						      
 REAL, INTENT(IN   )                                       :: dts
 INTEGER, INTENT(IN   )                                    :: dim_terrain, &
                                                              number_of_small_timesteps, &
                                                              rk_step,     &
                                                              rk_order,    &
                                                              n,           &  !desired number of nearest neighbors
                                                              np              !number of side ghost points
 INTEGER, DIMENSION(np), INTENT(IN   )                     :: ans             !actual number of nearest neighbors for side points
 INTEGER, INTENT(IN   )                   :: ids, ide, jds, jde, kds, kde, &  !d: domain
                                             ims, ime, jms, jme, kms, kme, &  !m: memory
                                             its, ite, jts, jte, kts, kte     !p: patch, t: tile

 !local data
 INTEGER                                                   :: i, j, nC, S
 DOUBLE PRECISION                                          :: max_rad, val_img
 DOUBLE PRECISION, DIMENSION(0:n-1)                        :: weight, radius

! ---------------------------------------------------------------------------------
 !the executable begins here
 CALL wrf_debug(100, 'dyn_em/module_ibm.F/subroutine neumann_inverse_dist_ss')
! ---------------------------------------------------------------------------------

 DO i=its,MIN(ite,ide-1)
 DO j=jts,MIN(jte,jde-1)

    radius = 0.0
!    DO nC=0,n-1
    DO nC=0,ant(i,j)-1
       !calculate the radius to image point, and determine the largest radius  
       radius(nC) = SQRT(top_neigh(i,j,3*nC)**2+top_neigh(i,j,3*nC+1)**2+top_neigh(i,j,3*nC+2)**2)
       IF (radius(nC) .EQ. 0.0) radius(nC) = epsilon
    ENDDO
    max_rad = MAXVAL(radius)
    weight = 0.0
    val_img = 0.0
!    DO nC=0,n-1
    DO nC=0,ant(i,j)-1
!       weight(nC) = ((max_rad-radius(nC))/(max_rad*radius(nC)))**2
!       weight(nC) = ((max_rad-radius(nC))/(max_rad*radius(nC)))
       weight(nC) = ((max_rad-radius(nC))/(max_rad*radius(nC)))**(0.5)
       val_img = val_img + weight(nC)*varfull(top_neigh_i(i,j,3*nC),top_neigh_i(i,j,3*nC+2),top_neigh_i(i,j,3*nC+1))
    ENDDO
    val_img = val_img/SUM(weight)
   
    !calculate the value at the ghost point
!    if (prox(i,j) == 0) then
        varfull(i,top(i,j),j) = val_img-2*top_dist(i,j)*grad(i,j)
!    elseif (prox(i,j) == 1) then
!    	 varfull(i,top(i,j),j)=val_img
!    endif
    IF (rk_step .LT. rk_order) THEN
        var(i,top(i,j),j) = varfull(i,top(i,j),j)*mus(i,j) - varsave(i,top(i,j),j)*mu(i,j)
    ELSE
        var(i,top(i,j),j) = varfull(i,top(i,j),j)*mus(i,j) - varsave(i,top(i,j),j)*mu(i,j) &
                          + dts*number_of_small_timesteps*mu(i,j)*h_diabatic(i,top(i,j),j)
    ENDIF

 ENDDO
 ENDDO !end of setting scalar at ghost point 

 IF (np .GT. 0) THEN
    DO S=1,np
       radius = 0.0
!       DO nC=0,n-1
       DO nC=0,ans(S)-1
          !calculate the radius to image point, and determine the largest radius  
          radius(nC) = SQRT(side_neigh(3*nC,S)**2+side_neigh(3*nC+1,S)**2+side_neigh(3*nC+2,S)**2)
          IF (radius(nC) .EQ. 0.0) radius(nC) = epsilon
       ENDDO
       max_rad = MAXVAL(radius)
       weight = 0.0
       val_img = 0.0
!       DO nC=0,n-1
       DO nC=0,ans(S)-1
!          weight(nC) = ((max_rad-radius(nC))/(max_rad*radius(nC)))**2
!          weight(nC) = ((max_rad-radius(nC))/(max_rad*radius(nC)))
          weight(nC) = ((max_rad-radius(nC))/(max_rad*radius(nC)))**(0.5)
          val_img = val_img + weight(nC)*varfull(side_neigh_i(3*nC,S),side_neigh_i(3*nC+2,S),side_neigh_i(3*nC+1,S))
       ENDDO
       val_img = val_img/SUM(weight)
       !calculate the value at the ghost point 
       varfull(side(1,S),side(3,S),side(2,S)) = val_img-2*side_dist(S)*grad(side(1,S),side(2,S))
       IF (rk_step .LT. rk_order) THEN
           var(side(1,S),side(3,S),side(2,S)) = varfull(side(1,S),side(3,S),side(2,S))*mus(side(1,S),side(2,S)) &
                                              - varsave(side(1,S),side(3,S),side(2,S))*mu(side(1,S),side(2,S))
       ELSE
           var(side(1,S),side(3,S),side(2,S)) = varfull(side(1,S),side(3,S),side(2,S))*mus(side(1,S),side(2,S)) &
                                              - varsave(side(1,S),side(3,S),side(2,S))*mu(side(1,S),side(2,S))  &
                                              + dts*number_of_small_timesteps*mu(side(1,S),side(2,S))*h_diabatic(side(1,S),side(3,S),side(2,S))
       ENDIF
    ENDDO
 ENDIF

 END SUBROUTINE neumann_inverse_dist_ss 
 
!---------------------------------------------------------------------------------------
 SUBROUTINE neumann_inverse_dist(scalar, prox, dim_terrain,          &
                                 surf_grad,                          &
                                 top_norm, side_norm,                &
			         top_dist, side_dist,                &
                                 top, top_img,                       &
			         side, side_img,                     &
			         top_neigh, side_neigh,              &
			         top_neigh_i, side_neigh_i,          &
			         n, np, ant, ans,                    &
			         ids, ide, jds, jde, kds, kde,       &
			         ims, ime, jms, jme, kms, kme,       &
			         its, ite, jts, jte, kts, kte)
 IMPLICIT NONE
 ! input data  			    
 REAL, DIMENSION(ims:ime,kms:kme,jms:jme), INTENT(INOUT)   :: scalar          			  
 INTEGER, DIMENSION(ims:ime,jms:jme), INTENT(IN   )  	   :: prox,      &
                                                              top,       &
							      ant             ! actual number of nearest neighbors for top points  
 INTEGER, DIMENSION(3,np), INTENT(IN   )                   :: side            !'side boundary' ghost points
 REAL, DIMENSION(ims:ime,jms:jme), INTENT(IN   )           :: surf_grad, &
                                                              top_dist	
 REAL, DIMENSION(ims:ime,jms:jme,3), INTENT(IN   )         :: top_norm	
 REAL, DIMENSION(3,np), INTENT(IN   )                      :: side_norm	
 REAL, DIMENSION(np), INTENT(IN   )                        :: side_dist
 REAL, DIMENSION(ims:ime,jms:jme,6), INTENT(IN   )         :: top_img         ! (x,y,z) location of ghost point and image point of the 'top boundary' ghost points
 REAL, DIMENSION(6,np), INTENT(IN   )                      :: side_img        ! (x,y,z) location of ghost point and image point of the 'side boundary' ghost points						      
 REAL, DIMENSION(ims:ime,jms:jme,0:3*n-1), INTENT(IN   )   :: top_neigh       ! (x,y,z) location of  neighbors
 REAL, DIMENSION(0:3*n-1,np), INTENT(IN   )                :: side_neigh      ! (x,y,z) location of neighbors							      
 INTEGER, DIMENSION(ims:ime,jms:jme,0:3*n-1), INTENT(IN   ):: top_neigh_i     ! (i,j,k) index of top neighbors
 INTEGER, DIMENSION(0:3*n-1,np), INTENT(IN   )             :: side_neigh_i    ! (i,j,k) location of neighbors						      
 INTEGER, INTENT(IN   )                                    :: dim_terrain, &
                                                              n,           &  ! desired number of nearest neighbors
                                                              np              ! number of side ghost points
 INTEGER, DIMENSION(np), INTENT(IN   )                     :: ans             ! actual number of nearest neighbors for side points
 INTEGER, INTENT(IN   )                   :: ids, ide, jds, jde, kds, kde, &  ! d: domain m:memory p:patch t:tile
                                             ims, ime, jms, jme, kms, kme, &
                                             its, ite, jts, jte, kts, kte		   

 !local data
 INTEGER						   :: i,j,nC,S
 DOUBLE PRECISION                                          :: max_rad, val_img
 DOUBLE PRECISION, DIMENSION(0:n-1)		           :: weight, radius
 
 !---------------------------------------------------------------------------------
 ! the executable begins here
  CALL wrf_debug(100,'dyn_em/module_ibm.F/subroutine neumann_inverse_distance')

 !---------------------------------------------------------------------------------


 DO i=its,MIN(ite,ide-1)
 DO j=jts,MIN(jte,jde-1)
    radius = 0.
    !DO nC=0,n-1
    DO nC=0,ant(i,j)-1
       ! calculate the radius to image point, and determine the largest radius  
       radius(nC) = SQRT(top_neigh(i,j,3*nC)**2+top_neigh(i,j,3*nC+1)**2+top_neigh(i,j,3*nC+2)**2)
       if (radius(nC)== 0.) radius(nC) = epsilon
    ENDDO
    max_rad = MAXVAL(radius)
    weight = 0.
    val_img = 0.
    !DO nC=0,n-1
    DO nC=0,ant(i,j)-1
       !weight(nC) = ((max_rad-radius(nC))/(max_rad*radius(nC)))**2
       !weight(nC) = ((max_rad-radius(nC))/(max_rad*radius(nC)))
       weight(nC) = ((max_rad-radius(nC))/(max_rad*radius(nC)))**(0.5)
       val_img = val_img + weight(nC)*scalar(top_neigh_i(i,j,3*nC),top_neigh_i(i,j,3*nC+2),top_neigh_i(i,j,3*nC+1))
       !print '(2f50.15)',weight(nC), scalar(top_neigh_i(i,j,3*nC),top_neigh_i(i,j,3*nC+2),top_neigh_i(i,j,3*nC+1))
    ENDDO
    val_img = val_img/SUM(weight)
    ! calculate the value at the ghost point
    !if (prox(i,j) == 0) then
    	 scalar(i,top(i,j),j)=val_img-2*top_dist(i,j)*surf_grad(i,j)
    !elseif (prox(i,j) == 1) then
    !	 scalar(i,top(i,j),j)=val_img
    !endif
    
    !if (j==1) then
    !    print '(1i5,1f20.8)',  i, val_img
    !endif 
    
    
 ENDDO
 ENDDO   ! end of setting scalar at ghost point 
 
 if (np > 0) then
    DO S=1,np
       radius = 0.
       !DO nC=0,n-1
       DO nC=0,ans(S)-1
	  ! calculate the radius to image point, and determine the largest radius  
	  radius(nC) = SQRT(side_neigh(3*nC,S)**2+side_neigh(3*nC+1,S)**2+side_neigh(3*nC+2,S)**2)
	  if (radius(nC)== 0.) radius(nC) = epsilon
       ENDDO
       max_rad = MAXVAL(radius)
       weight = 0.
       val_img = 0.
       !DO nC=0,n-1
       DO nC=0,ans(S)-1
	  !weight(nC) = ((max_rad-radius(nC))/(max_rad*radius(nC)))**2
	  !weight(nC) = ((max_rad-radius(nC))/(max_rad*radius(nC)))
	  weight(nC) = ((max_rad-radius(nC))/(max_rad*radius(nC)))**(0.5)
	  val_img = val_img + weight(nC)*scalar(side_neigh_i(3*nC,S),side_neigh_i(3*nC+2,S),side_neigh_i(3*nC+1,S))
	  !print '(2f50.15)',weight(nC), scalar(side_neigh_i(3*nC,S),side_neigh_i(3*nC+2,S),side_neigh_i(3*nC+1,S))
       ENDDO
       val_img = val_img/SUM(weight)    
       ! calculate the value at the ghost point 
       scalar(side(1,S),side(3,S),side(2,S))= val_img-2*side_dist(S)*surf_grad(side(1,S),side(2,S))
       
       !print '(1i5,1f20.8)', S, val_img
       
    ENDDO 
 endif
  
 END SUBROUTINE neumann_inverse_dist
 
!-------------------------------------------------------------------------------------------------------------------------------------

 SUBROUTINE mom_flux_inverse_dist ( surf_grad,                             &
                                    stag, u, v, w,                         &
			            top, side, prox,      	           &
				    top_img, top_bound,                    &
				    side_img, side_bound,                  &
				    top_neigh, side_neigh,		   &
				    top_neigh_i, side_neigh_i,             &
				    n, np,                                 &
				    top_norm, top_dist,                    &
				    side_norm, side_dist,                  &
				    antu_at_p, antv_at_p, antw_at_p,       &
				    ansu_at_p, ansv_at_p, answ_at_p,       &
				    ids, ide, jds, jde, kds, kde, 	   &
				    ims, ime, jms, jme, kms, kme, 	   &
				    its, ite, jts, jte, kts, kte)
 IMPLICIT NONE
 ! input data
 REAL, DIMENSION(ims:ime,jms:jme), INTENT(IN   )           :: surf_grad  
 CHARACTER, INTENT(IN   )                                  :: stag			   
 REAL, DIMENSION(ims:ime,kms:kme,jms:jme), INTENT(INOUT)   :: u, v, w							      			 
 INTEGER, DIMENSION(ims:ime,jms:jme), INTENT(IN   )	   :: top,        &
                                                              prox,       &
							      antu_at_p,  &   ! actual number of nearest neighbors for top points
							      antv_at_p,  &
							      antw_at_p            
 INTEGER, DIMENSION(3,np), INTENT(IN   )		   :: side	      !'side boundary' ghost points					     
 REAL, DIMENSION(ims:ime,jms:jme,6), INTENT(IN)            :: top_img         ! (x,y,z) location of ghost point and image point of the 'top boundary' ghost points
 REAL, DIMENSION(ims:ime,jms:jme,3), INTENT(IN)            :: top_bound       ! keep the (x,y,z) location of the boundary points
 REAL, DIMENSION(6,np), INTENT(IN   )                      :: side_img        ! (x,y,z) location of ghost point
 REAL, DIMENSION(3,np), INTENT(IN   )                      :: side_bound      ! (x,y,z) location of the boundary for side points					     
 REAL, DIMENSION(ims:ime,jms:jme,0:9*n-1), INTENT(IN   )   :: top_neigh       ! (x,y,z) location of  neighbors 
 REAL, DIMENSION(0:9*n-1,np), INTENT(IN   )		   :: side_neigh      ! (x,y,z) location of neighbors							     
 INTEGER, DIMENSION(ims:ime,jms:jme,0:9*n-1), INTENT(IN   ):: top_neigh_i     ! (i,j,k) index of top neighbors
 INTEGER, DIMENSION(0:9*n-1,np), INTENT(IN   )  	   :: side_neigh_i    ! (i,j,k) location of neighbors							     
 INTEGER, INTENT(IN   ) 				   :: n,	   &  ! desired number of nearest neighbors
							      np	      ! number of side ghost points
 REAL, DIMENSION(ims:ime,jms:jme,3), INTENT(IN   )         :: top_norm        ! surface normal vector
 REAL, DIMENSION(ims:ime,jms:jme), INTENT(IN   )           :: top_dist        ! distance of reconstruction and interpolation points from boundary
 REAL, DIMENSION(3,np), INTENT(IN   )                      :: side_norm       ! surface normal vector
 REAL, DIMENSION(np), INTENT(IN   )                        :: side_dist       ! distance from surface normal to reconstruction and interpolation point
 INTEGER, DIMENSION(np), INTENT(IN   )                     :: ansu_at_p,   &  ! actual number of nearest neighbors for side points 
                                                              ansv_at_p,   &
							      answ_at_p						      
 INTEGER, INTENT(IN   ) 		  :: ids, ide, jds, jde, kds, kde, &  ! d: domain m:memory p:patch t:tile
					     ims, ime, jms, jme, kms, kme, &
					     its, ite, jts, jte, kts, kte		  

 !local data
 INTEGER 						  :: i,j,          &
                                                             nC,S,         &
							     i_end,        &
							     j_end
 REAL                                                     :: bp_ip_dist							     
 DOUBLE PRECISION                                         :: max_rad
 DOUBLE PRECISION, DIMENSION(3)                           :: vel_img						     
 DOUBLE PRECISION, DIMENSION(3,3)                         :: matrix
 DOUBLE PRECISION, DIMENSION(0:n-1)	    	          :: weight, radius
 ! for lapack routines
 !INTEGER                                                  :: info
 !INTEGER, DIMENSION(3)					   :: ipiv
 !REAL, DIMENSION(336)                                     :: work
 !---------------------------------------------------------------------------------
 ! the executable begins here
 CALL wrf_debug(100, 'dyn_em/module_ibm.F/subroutine mom_flux_inverse_dist')
 !---------------------------------------------------------------------------------

 IF (stag == 'u') THEN
    i_end = ite
    j_end = MIN(jte,jde-1)
 ELSEIF (stag == 'v') THEN
    i_end = MIN(ite,ide-1)
    j_end = jte
 ELSEIF ((stag == 'w').OR.(stag == 't')) THEN
    i_end = MIN(ite,ide-1)
    j_end = MIN(jte,jde-1)
 ENDIF

 DO i=its,i_end
 DO j=jts,j_end 
 
    vel_img = 0.
    
    ! get u velocity at interpolation point 
    radius = 0.
    !DO nC=0,n-1
    DO nC=0,antu_at_p(i,j)-1
       ! calculate the radius to image point, and determine the largest radius  
       radius(nC) = SQRT(top_neigh(i,j,3*nC)**2+top_neigh(i,j,3*nC+1)**2+top_neigh(i,j,3*nC+2)**2)
       if (radius(nC)== 0.) radius(nC) = epsilon
    ENDDO
    max_rad = MAXVAL(radius)
    weight = 0.
    !DO nC=0,n-1
    DO nC=0,antu_at_p(i,j)-1
       !weight(nC) = ((max_rad-radius(nC))/(max_rad*radius(nC)))**2
       !weight(nC) = ((max_rad-radius(nC))/(max_rad*radius(nC)))
       weight(nC) = ((max_rad-radius(nC))/(max_rad*radius(nC)))**(0.5)
       vel_img(1) = vel_img(1) + weight(nC)*u(top_neigh_i(i,j,3*nC),top_neigh_i(i,j,3*nC+2),top_neigh_i(i,j,3*nC+1))      
    ENDDO
    vel_img(1) = vel_img(1)/SUM(weight)
    
    ! get v velocity at interpolation point 
    radius = 0.
    !DO nC=0,n-1
    DO nC=0,antv_at_p(i,j)-1
       ! calculate the radius to image point, and determine the largest radius  
       radius(nC) = SQRT(top_neigh(i,j,3*n+3*nC)**2+top_neigh(i,j,3*n+3*nC+1)**2+top_neigh(i,j,3*n+3*nC+2)**2)
       if (radius(nC)== 0.) radius(nC) = epsilon
    ENDDO
    max_rad = MAXVAL(radius)
    weight = 0.
    !DO nC=0,n-1
    DO nC=0,antv_at_p(i,j)-1
       !weight(nC) = ((max_rad-radius(nC))/(max_rad*radius(nC)))**2
       !weight(nC) = ((max_rad-radius(nC))/(max_rad*radius(nC)))
       weight(nC) = ((max_rad-radius(nC))/(max_rad*radius(nC)))**(0.5)
       vel_img(2) = vel_img(2) + weight(nC)*v(top_neigh_i(i,j,3*n+3*nC),top_neigh_i(i,j,3*n+3*nC+2),top_neigh_i(i,j,3*n+3*nC+1))
    ENDDO
    vel_img(2) = vel_img(2)/SUM(weight)

    ! get w velocity at interpolation point 
    radius = 0.
    !DO nC=0,n-1
    DO nC=0,antw_at_p(i,j)-1
       ! calculate the radius to image point, and determine the largest radius  
       radius(nC) = SQRT(top_neigh(i,j,6*n+3*nC)**2+top_neigh(i,j,6*n+3*nC+1)**2+top_neigh(i,j,6*n+3*nC+2)**2)
       if (radius(nC)== 0.) radius(nC) = epsilon
    ENDDO
    max_rad = MAXVAL(radius)
    weight = 0.
    !DO nC=0,n-1
    DO nC=0,antw_at_p(i,j)-1
       !weight(nC) = ((max_rad-radius(nC))/(max_rad*radius(nC)))**2
       !weight(nC) = ((max_rad-radius(nC))/(max_rad*radius(nC)))
       weight(nC) = ((max_rad-radius(nC))/(max_rad*radius(nC)))**(0.5)
       vel_img(3) = vel_img(3) + weight(nC)*w(top_neigh_i(i,j,6*n+3*nC),top_neigh_i(i,j,6*n+3*nC+2),top_neigh_i(i,j,6*n+3*nC+1))
    ENDDO
    vel_img(3) = vel_img(3)/SUM(weight)
  
    ! calculate the surface normal and tangential components at the interpolation point
    ! find the orthonormal basis for the plane representing the immersed boundary
    ! the plane is defined as ax+by+cz=0 or n(1)x+n(2)y+n(3)z = 0
    ! We know that one vector is the normal vector already calculated
    ! to find the second vector set x=1 and y=0 so that [1 0 -a/c] results, then normalize for a unit vector
    ! cross these two vectors to find the third
    matrix(1,:) = [1/SQRT(1 + (top_norm(i,j,1)/top_norm(i,j,3))**2), 0., (-top_norm(i,j,1)/top_norm(i,j,3))/SQRT(1 + (top_norm(i,j,1)/top_norm(i,j,3))**2)]
    matrix(2,:) = [top_norm(i,j,2)*matrix(1,3), top_norm(i,j,3)*matrix(1,1) - top_norm(i,j,1)*matrix(1,3), -top_norm(i,j,2)*matrix(1,1)]
    matrix(3,:) = top_norm(i,j,1:3)
    
    ! now vel_img(1) and (2) are along the tangent vectors and vel_img(3) is the surface normal velocity at the interpolation point
    vel_img = MATMUL(matrix,vel_img)   

    ! top_dist stores one-half of the distance from the ip to the gp.  When the bc=2 and interpolation method = 2, the ip is not a true image
    ! so the distance from the boundary to the ip needs to be calculated
    bp_ip_dist = sqrt((top_img(i,j,4)-top_bound(i,j,1))**2 + (top_img(i,j,5)-top_bound(i,j,2))**2 + (top_img(i,j,6)-top_bound(i,j,3))**2)
  
    ! calculate the normal and tangential components at the ghost point    
    ! could do this with a reflection matrix for surf_grad = 0 (no surface stress) conditions
    
    ! use the surface gradient for the tangential components
    vel_img(1) = vel_img(1)-2*top_dist(i,j)*surf_grad(i,j)
    vel_img(2) = vel_img(2)-2*top_dist(i,j)*surf_grad(i,j)
    
    ! set the normal component to zero at the boundary
    vel_img(3) = vel_img(3)-(2*top_dist(i,j)/bp_ip_dist)*vel_img(3)    
    
    ! now transform back into cartesian coordinates by inverting the transformation matrix 
    ! then multiplying the velocities by the inverted tranformation matrix      
    !if (KIND(matrix) == 4) then
    !	CALL SGETRF(3,3,matrix,3,ipiv,info)
    !	CALL SGETRI(3,matrix,3,ipiv,work,336,info)
    !elseif (KIND(matrix) == 8) then    
    !	CALL DGETRF(3,3,matrix,3,ipiv,info)
    !	CALL DGETRI(3,matrix,3,ipiv,work,336,info)
    !endif
    matrix = TRANSPOSE(matrix)
    vel_img = MATMUL(matrix,vel_img)     

    IF (stag == 'u') THEN
       u(i,top(i,j),j) = vel_img(1)
    ELSEIF (stag == 'v') THEN
       v(i,top(i,j),j) = vel_img(2)
    ELSEIF (stag == 'w') THEN
       w(i,top(i,j),j) = vel_img(3)
    ENDIF

 ENDDO
 ENDDO

 if (np > 0) then
    DO S=1,np 

       vel_img = 0.      
       radius = 0.  
       !DO nC=0,n-1
       DO nC=0,ansu_at_p(S)-1
	  ! calculate the radius to image point, and determine the largest radius  
	  radius(nC) = SQRT(side_neigh(3*nC,S)**2+side_neigh(3*nC+1,S)**2+side_neigh(3*nC+2,S)**2)
	  if (radius(nC)== 0.) radius(nC) = epsilon
       ENDDO
       max_rad = MAXVAL(radius)
       weight = 0.
       !DO nC=0,n-1
       DO nC=0,ansu_at_p(S)-1
	 ! weight(nC) = ((max_rad-radius(nC))/(max_rad*radius(nC)))**2
	  !weight(nC) = ((max_rad-radius(nC))/(max_rad*radius(nC)))
	  weight(nC) = ((max_rad-radius(nC))/(max_rad*radius(nC)))**(0.5)
	  vel_img(1) = vel_img(1) + weight(nC)*u(side_neigh_i(3*nC,S),side_neigh_i(3*nC+2,S),side_neigh_i(3*nC+1,S))
       ENDDO
       vel_img(1) = vel_img(1)/SUM(weight)

       radius = 0.  
       !DO nC=0,n-1
       DO nC=0,ansv_at_p(S)-1
	  ! calculate the radius to image point, and determine the largest radius  
	  radius(nC) = SQRT(side_neigh(3*n+3*nC,S)**2+side_neigh(3*n+3*nC+1,S)**2+side_neigh(3*n+3*nC+2,S)**2)
	  if (radius(nC)== 0.) radius(nC) = epsilon
       ENDDO
       max_rad = MAXVAL(radius)
       weight = 0.
       !DO nC=0,n-1
       DO nC=0,ansv_at_p(S)-1
	 ! weight(nC) = ((max_rad-radius(nC))/(max_rad*radius(nC)))**2
	  !weight(nC) = ((max_rad-radius(nC))/(max_rad*radius(nC)))
	  weight(nC) = ((max_rad-radius(nC))/(max_rad*radius(nC)))**(0.5)
	  vel_img(2) = vel_img(2) + weight(nC)*v(side_neigh_i(3*n+3*nC,S),side_neigh_i(3*n+3*nC+2,S),side_neigh_i(3*n+3*nC+1,S))
       ENDDO
       vel_img(2) = vel_img(2)/SUM(weight)      

       radius = 0.  
       !DO nC=0,n-1
       DO nC=0,answ_at_p(S)-1
	  ! calculate the radius to image point, and determine the largest radius  
	  radius(nC) = SQRT(side_neigh(6*n+3*nC,S)**2+side_neigh(6*n+3*nC+1,S)**2+side_neigh(6*n+3*nC+2,S)**2)
	  if (radius(nC)== 0.) radius(nC) = epsilon
       ENDDO
       max_rad = MAXVAL(radius)
       weight = 0.
       !DO nC=0,n-1
       DO nC=0,answ_at_p(S)-1
	 ! weight(nC) = ((max_rad-radius(nC))/(max_rad*radius(nC)))**2
	  !weight(nC) = ((max_rad-radius(nC))/(max_rad*radius(nC)))
	  weight(nC) = ((max_rad-radius(nC))/(max_rad*radius(nC)))**(0.5)
	  vel_img(3) = vel_img(3) + weight(nC)*w(side_neigh_i(6*n+3*nC,S),side_neigh_i(6*n+3*nC+2,S),side_neigh_i(6*n+3*nC+1,S))
       ENDDO
       vel_img(3) = vel_img(3)/SUM(weight)

       ! calculate the surface normal and tangential components at the interpolation point
       ! find the orthonormal basis for the plane representing the immersed boundary
       ! the plane is defined as ax+by+cz=0 or n(1)x+n(2)y+n(3)z = 0
       ! We know that one vector is the normal vector already calculated
       ! to find the second vector set x=1 and y=0 so that [1 0 -a/c] results, then normalize for a unit vector
       ! cross these two vectors to find the third
       matrix(1,:) = [1/SQRT(1 + (side_norm(1,S)/side_norm(3,S))**2), 0., (-side_norm(1,S)/side_norm(3,S))/SQRT(1 + (side_norm(1,S)/side_norm(3,S))**2)]
       matrix(2,:) = [side_norm(2,S)*matrix(1,3), side_norm(3,S)*matrix(1,1) - side_norm(1,S)*matrix(1,3), -side_norm(2,S)*matrix(1,1)]
       matrix(3,:) = side_norm(1:3,S)

       ! side_dist stores one-half of the distance from the ip to the gp.  When the bc=2 and interpolation method = 2, the ip is not a true image
       ! so the distance from the boundary to the ip needs to be calculated
       bp_ip_dist = sqrt((side_img(4,S)-side_bound(1,S))**2 + (side_img(5,S)-side_bound(2,S))**2 + (side_img(6,S)-side_bound(3,S))**2)

       ! now vel_img(1) and (2) are along the tangent vectors and vel_img(3) is the surface normal velocity at the interpolation point
       vel_img = MATMUL(matrix,vel_img) 

       ! calculate the normal and tangential components at the ghost point    
       ! could do this with a reflection matrix for surf_grad = 0 (no surface stress) conditions

       ! use the surface gradient for the tangential components
       vel_img(1) = vel_img(1)-2*side_dist(S)*surf_grad(side(1,S),side(2,S))
       vel_img(2) = vel_img(2)-2*side_dist(S)*surf_grad(side(1,S),side(2,S))
       
       ! set the normal component to zero at the boundary
       vel_img(3) = vel_img(3)-(2*side_dist(S)/bp_ip_dist)*vel_img(3)

       ! now transform back into cartesian coordinates by inverting the transformation matrix 
       ! then multiplying the velocities by the inverted tranformation matrix      
       !if (KIND(matrix) == 4) then
       !	CALL SGETRF(3,3,matrix,3,ipiv,info)
       !	CALL SGETRI(3,matrix,3,ipiv,work,336,info)
       !elseif (KIND(matrix) == 8) then    
       !	CALL DGETRF(3,3,matrix,3,ipiv,info)
       !	CALL DGETRI(3,matrix,3,ipiv,work,336,info)
       !endif
       matrix = TRANSPOSE(matrix)
       vel_img = MATMUL(matrix,vel_img)     

       IF (stag == 'u') THEN
	  u(side(1,S),side(3,S),side(2,S)) = vel_img(1)
       ELSEIF (stag == 'v') THEN
	  v(side(1,S),side(3,S),side(2,S)) = vel_img(2)
       ELSEIF (stag == 'w') THEN
	  w(side(1,S),side(3,S),side(2,S)) = vel_img(3)
       ENDIF

    ENDDO 
 endif

 END SUBROUTINE mom_flux_inverse_dist

!-------------------------------------------------------------------------------------------------------------------------------------

 SUBROUTINE mom_flux_inverse_dist_ss ( top_s,                                 &
                                       ibm_opt,                               &
                                       tke_drag_coefficient,                  &
                                       z_rough,                               &
                                       stag, u, v, w,                         &
 			               var, varsave,		              &
 				       mu, mus,			              &
			               top, side, prox,       	              &
				       top_img, top_bound,                    &
				       side_img, side_bound,                  &
				       top_neigh, side_neigh,		      &
				       top_neigh_i, side_neigh_i,             &
				       n, np,                                 &
				       top_norm, top_dist,                    &
				       side_norm, side_dist,                  &
				       xkmh, xkmv,                            &
				       antu_at_p, antv_at_p, antw_at_p,       &
				       ansu_at_p, ansv_at_p, answ_at_p,       &
				       ids, ide, jds, jde, kds, kde, 	      &
				       ims, ime, jms, jme, kms, kme, 	      &
				       its, ite, jts, jte, kts, kte)
    IMPLICIT NONE
 ! input data 
 REAL, INTENT(IN   )                                       :: tke_drag_coefficient, &
                                                              z_rough
 CHARACTER, INTENT(IN   )                                  :: stag			   
 REAL, DIMENSION(ims:ime,kms:kme,jms:jme), INTENT(INOUT)   :: u, v, w,    &
                                                              var
 REAL, DIMENSION(ims:ime,kms:kme,jms:jme), INTENT(IN   )   :: varsave,    &
                                                              xkmh,       &
							      xkmv
 REAL, DIMENSION(ims:ime,jms:jme), INTENT(IN   )           :: mu,         &
                                                              mus						      			 
 INTEGER, DIMENSION(ims:ime,jms:jme), INTENT(IN   )	   :: top_s,      &
                                                              top,        &
                                                              prox,       &
							      antu_at_p,  &   ! actual number of nearest neighbors for top points
							      antv_at_p,  &
							      antw_at_p            
 REAL, DIMENSION(ims:ime,jms:jme,6), INTENT(IN)            :: top_img         ! (x,y,z) location of ghost point and image point of the 'top boundary' ghost points
 REAL, DIMENSION(ims:ime,jms:jme,3), INTENT(IN)            :: top_bound       ! keep the (x,y,z) location of the boundary points
 INTEGER, DIMENSION(3,np), INTENT(IN   )		   :: side            !'side boundary' ghost points
 REAL, DIMENSION(6,np), INTENT(IN   )                      :: side_img        ! (x,y,z) location of ghost point
 REAL, DIMENSION(3,np), INTENT(IN   )                      :: side_bound      ! (x,y,z) location of the boundary for side points					     
 REAL, DIMENSION(ims:ime,jms:jme,0:9*n-1), INTENT(IN   )   :: top_neigh       ! (x,y,z) location of  neighbors 
 REAL, DIMENSION(0:9*n-1,np), INTENT(IN   )		   :: side_neigh      ! (x,y,z) location of neighbors							     
 INTEGER, DIMENSION(ims:ime,jms:jme,0:9*n-1), INTENT(IN   ):: top_neigh_i     ! (i,j,k) index of top neighbors
 INTEGER, DIMENSION(0:9*n-1,np), INTENT(IN   )  	   :: side_neigh_i    ! (i,j,k) location of neighbors							     
 INTEGER, INTENT(IN   ) 				   :: n,	   &  ! desired number of nearest neighbors
							      np	      ! number of side ghost points
 REAL, DIMENSION(ims:ime,jms:jme,3), INTENT(IN   )         :: top_norm        ! surface normal vector
 REAL, DIMENSION(ims:ime,jms:jme  ), INTENT(IN   )         :: top_dist        ! distance of reconstruction and interpolation points from boundary
 REAL, DIMENSION(3,np), INTENT(IN   )                      :: side_norm       ! surface normal vector
 REAL, DIMENSION(np), INTENT(IN   )                        :: side_dist       ! distance from surface normal to reconstruction and interpolation point
 INTEGER, DIMENSION(np), INTENT(IN   )                     :: ansu_at_p,   &  ! actual number of nearest neighbors for side points 
                                                              ansv_at_p,   &
							      answ_at_p						      
 INTEGER, INTENT(IN   ) 		                   :: ibm_opt,     &
                                                              ids, ide, jds, jde, kds, kde, &  ! d: domain m:memory p:patch t:tile
					                      ims, ime, jms, jme, kms, kme, &
					                      its, ite, jts, jte, kts, kte		  

 !local data
 INTEGER 						  :: i,j,          &
                                                             nC,S,         &
							     i_end,        &
							     j_end
 REAL                                                     :: Cd,           & 
                                                             V0,           &
                                                             surf_grad,    &
							     bp_ip_dist
 REAL                                                     :: NU, NU2, STAR, xkxavg             !KAL adding for debugging - take this out later							     
 DOUBLE PRECISION                                         :: max_rad
 DOUBLE PRECISION, DIMENSION(3)                           :: vel_img						     
 DOUBLE PRECISION, DIMENSION(3,3)                         :: matrix
 DOUBLE PRECISION, DIMENSION(0:n-1)	    	          :: weight, radius
 
 !---------------------------------------------------------------------------------
 ! the executable begins here
 CALL wrf_debug(100, 'dyn_em/module_ibm.F/subroutine mom_flux_inverse_dist_ss')
 !---------------------------------------------------------------------------------

 IF (stag == 'u') THEN
    i_end = ite
    j_end = MIN(jte,jde-1)
 ELSEIF (stag == 'v') THEN
    i_end = MIN(ite,ide-1)
    j_end = jte
 ELSEIF ((stag == 'w').OR.(stag == 't')) THEN
    i_end = MIN(ite,ide-1)
    j_end = MIN(jte,jde-1)
 ENDIF
 
 DO i=its,i_end
 DO j=jts,j_end 
 
    vel_img = 0.
    
    ! get u velocity at interpolation point 
    radius = 0.
    !DO nC=0,n-1
    DO nC=0,antu_at_p(i,j)-1
       ! calculate the radius to image point, and determine the largest radius  
       radius(nC) = SQRT(top_neigh(i,j,3*nC)**2+top_neigh(i,j,3*nC+1)**2+top_neigh(i,j,3*nC+2)**2)
       if (radius(nC)== 0.) radius(nC) = epsilon
    ENDDO
    max_rad = MAXVAL(radius)
    weight = 0.
    !DO nC=0,n-1
    DO nC=0,antu_at_p(i,j)-1
       !weight(nC) = ((max_rad-radius(nC))/(max_rad*radius(nC)))**2
       !weight(nC) = ((max_rad-radius(nC))/(max_rad*radius(nC)))
       weight(nC) = ((max_rad-radius(nC))/(max_rad*radius(nC)))**(0.5)
       vel_img(1) = vel_img(1) + weight(nC)*u(top_neigh_i(i,j,3*nC),top_neigh_i(i,j,3*nC+2),top_neigh_i(i,j,3*nC+1))    
    ENDDO
    vel_img(1) = vel_img(1)/SUM(weight)    
    
    ! get v velocity at interpolation point 
    radius = 0.
    !DO nC=0,n-1
    DO nC=0,antv_at_p(i,j)-1
       ! calculate the radius to image point, and determine the largest radius  
       radius(nC) = SQRT(top_neigh(i,j,3*n+3*nC)**2+top_neigh(i,j,3*n+3*nC+1)**2+top_neigh(i,j,3*n+3*nC+2)**2)
       if (radius(nC)== 0.) radius(nC) = epsilon
    ENDDO
    max_rad = MAXVAL(radius)
    weight = 0.
    !DO nC=0,n-1
    DO nC=0,antv_at_p(i,j)-1
       !weight(nC) = ((max_rad-radius(nC))/(max_rad*radius(nC)))**2
       !weight(nC) = ((max_rad-radius(nC))/(max_rad*radius(nC)))
       weight(nC) = ((max_rad-radius(nC))/(max_rad*radius(nC)))**(0.5)
       vel_img(2) = vel_img(2) + weight(nC)*v(top_neigh_i(i,j,3*n+3*nC),top_neigh_i(i,j,3*n+3*nC+2),top_neigh_i(i,j,3*n+3*nC+1))
    ENDDO
    vel_img(2) = vel_img(2)/SUM(weight)

    ! get w velocity at interpolation point 
    radius = 0.
    !DO nC=0,n-1
    DO nC=0,antw_at_p(i,j)-1
       ! calculate the radius to image point, and determine the largest radius  
       radius(nC) = SQRT(top_neigh(i,j,6*n+3*nC)**2+top_neigh(i,j,6*n+3*nC+1)**2+top_neigh(i,j,6*n+3*nC+2)**2)
       if (radius(nC)== 0.) radius(nC) = epsilon
    ENDDO
    max_rad = MAXVAL(radius)
    weight = 0.
    !DO nC=0,n-1
    DO nC=0,antw_at_p(i,j)-1
       !weight(nC) = ((max_rad-radius(nC))/(max_rad*radius(nC)))**2
       !weight(nC) = ((max_rad-radius(nC))/(max_rad*radius(nC)))
       weight(nC) = ((max_rad-radius(nC))/(max_rad*radius(nC)))**(0.5)
       vel_img(3) = vel_img(3) + weight(nC)*w(top_neigh_i(i,j,6*n+3*nC),top_neigh_i(i,j,6*n+3*nC+2),top_neigh_i(i,j,6*n+3*nC+1))
    ENDDO
    vel_img(3) = vel_img(3)/SUM(weight)
    
    ! calculate the surface normal and tangential components at the interpolation point
    ! find the orthonormal basis for the plane representing the immersed boundary
    ! the plane is defined as ax+by+cz=0 or n(1)x+n(2)y+n(3)z = 0
    ! We know that one vector is the normal vector already calculated
    ! to find the second vector set x=1 and y=0 so that [1 0 -a/c] results, then normalize for a unit vector
    ! cross these two vectors to find the third
    matrix(1,:) = [1/SQRT(1 + (top_norm(i,j,1)/top_norm(i,j,3))**2), 0., (-top_norm(i,j,1)/top_norm(i,j,3))/SQRT(1 + (top_norm(i,j,1)/top_norm(i,j,3))**2)]
    matrix(2,:) = [top_norm(i,j,2)*matrix(1,3), top_norm(i,j,3)*matrix(1,1) - top_norm(i,j,1)*matrix(1,3), -top_norm(i,j,2)*matrix(1,1)]
    matrix(3,:) = top_norm(i,j,1:3)
     
    ! now vel_img(1) and (2) are along the tangent vectors and vel_img(3) is the surface normal velocity at the interpolation point
    vel_img = MATMUL(matrix,vel_img) 
 
    ! top_dist stores one-half of the distance from the ip to the gp.  When the bc=2 and interpolation method = 2, the ip is not a true image
    ! so the distance from the boundary to the ip needs to be calculated
    bp_ip_dist = sqrt((top_img(i,j,4)-top_bound(i,j,1))**2 + (top_img(i,j,5)-top_bound(i,j,2))**2 + (top_img(i,j,6)-top_bound(i,j,3))**2)
    
    ! calculate the normal and tangential components at the ghost point
    ! could do this with a reflection matrix for surf_grad = 0 (no surface stress) conditions
    
    ! use the surface gradient for the tangential components
    ! set the mom flux gradient boundary condition at the immersed boundary
    ! using the vertical eddy viscosity below.  Eventually I need to change this
    ! to be a combination of vertical and horizontal components based on the 
    ! normal vector to the surface, also average to velocity location
    
    IF (ibm_opt == 1) THEN ! free slip boundary condition  ibm_opt = 1
       surf_grad = 0.
       vel_img(1) = vel_img(1)-2*top_dist(i,j)*surf_grad
       vel_img(2) = vel_img(2)-2*top_dist(i,j)*surf_grad 
    ELSE !ibm_opt should equal 4, momentum flux    
       IF (tke_drag_coefficient /= 0) THEN
	  Cd = tke_drag_coefficient
	  !V0 = sqrt(vel_img(1)**2 + vel_img(2)**2)

	  ! this works well only if the eddy viscosity is constant
	  !surf_grad =  (Cd * V0 * vel_img(1))/xkmv(i,top(i,j)+1,j)
	  !vel_img(1) = vel_img(1)-2*top_dist(i,j)*surf_grad
	  !surf_grad =  (Cd * V0 * vel_img(2))/xkmv(i,top(i,j)+1,j) 
	  !vel_img(2) = vel_img(2)-2*top_dist(i,j)*surf_grad

	  ! try using the mixing length hypothesis- this is for use with constant coefficient smagorinsky
	  ! here dV/dz = ustar/(kappa*z) and ustar = sqrt(cd)*V0
	  surf_grad =  (bp_ip_dist/top_dist(i,j))*sqrt(Cd)*vel_img(1)/(KARMAN*bp_ip_dist) 
	  vel_img(1) = vel_img(1)-2*top_dist(i,j)*surf_grad
	  surf_grad = (bp_ip_dist/top_dist(i,j))*sqrt(Cd)*vel_img(2)/(KARMAN*bp_ip_dist) 
	  vel_img(2) = vel_img(2)-2*top_dist(i,j)*surf_grad     

       ELSEIF (z_rough /= 0) THEN
	  !Cd= (KARMAN / LOG(top_dist(i,j)/z_rough))**2 !top_dist is no longer the distance from the image pt to the boundary point
	  Cd= (KARMAN / LOG(bp_ip_dist/z_rough))**2
	  V0 = sqrt(vel_img(1)**2 + vel_img(2)**2)
	  !NU = KARMAN*top_dist(i,j)*sqrt(Cd)*V0
	  !NU2 = Cd*V0*bp_ip_dist

	  STAR = sqrt(Cd)*V0
	  NU = 0.5*xkmv(i,2,j)+0.5*xkmv(i,3,j) !grid 1
	  !NU = 0.25*xkmv(i,2,j)+0.75*xkmv(i,3,j) !grid 2
	  !NU = xkmv(i,3,j) !grid 3
	  !NU = 0.75*xkmv(i,3,j)+0.25*xkmv(i,4,j) !grid 4
	  !NU = xkmv(i,top_s(i,j)+1,j)

	  ! this works for a constant eddy viscosity
	  !surf_grad = (Cd * V0 * vel_img(1))/xkmv(i,top(i,j)+1,j)
	  !vel_img(1) = vel_img(1)-2*top_dist(i,j)*surf_grad
	  !surf_grad = (Cd * V0 * vel_img(2))/xkmv(i,top(i,j)+1,j) 
	  !vel_img(2) = vel_img(2)-2*top_dist(i,j)*surf_grad        	

	  !surf_grad =  (bp_ip_dist/top_dist(i,j))*sqrt(Cd)*vel_img(1)/(KARMAN*bp_ip_dist) 
	  !vel_img(1) = vel_img(1)-2*top_dist(i,j)*surf_grad
	  !surf_grad = (bp_ip_dist/top_dist(i,j))*sqrt(Cd)*vel_img(2)/(KARMAN*bp_ip_dist) 
	  !vel_img(2) = vel_img(2)-2*top_dist(i,j)*surf_grad  

	  !KAL this is the same as directly above, but simplified
        !surf_grad = vel_img(1)/LOG(bp_ip_dist/z_rough)/top_dist(i,j)
        surf_grad =  (Cd * V0 * vel_img(1))/NU
        vel_img(1) = vel_img(1)-2*top_dist(i,j)*surf_grad
	    surf_grad =  (Cd * V0 * vel_img(2))/NU
        !surf_grad = vel_img(2)/LOG(bp_ip_dist/z_rough)/top_dist(i,j) 
        vel_img(2) = vel_img(2)-2*top_dist(i,j)*surf_grad 

       ! add an else if here for ust       
       ELSE ! set the surface gradient to zero
	  surf_grad = 0.
	  vel_img(1) = vel_img(1)-2*top_dist(i,j)*surf_grad
	  vel_img(2) = vel_img(2)-2*top_dist(i,j)*surf_grad    
       ENDIF	
    ENDIF ! end of ibm_opt = 1 or 4
  

    ! set the normal component to zero at the boundary
    vel_img(3) = vel_img(3)-(2*top_dist(i,j)/bp_ip_dist)*vel_img(3)
     
    ! now transform back into cartesian coordinates by inverting the transformation matrix 
    ! then multiplying the velocities by the inverted tranformation matrix      
    !if (KIND(matrix) == 4) then
    !	CALL SGETRF(3,3,matrix,3,ipiv,info)
    !	CALL SGETRI(3,matrix,3,ipiv,work,336,info)
    !elseif (KIND(matrix) == 8) then    
    !	CALL DGETRF(3,3,matrix,3,ipiv,info)
    !	CALL DGETRI(3,matrix,3,ipiv,work,336,info)
    !endif
    matrix = TRANSPOSE(matrix)
    vel_img = MATMUL(matrix,vel_img)   
    
    IF (stag == 'u') THEN
       u(i,top(i,j),j) = vel_img(1)      
       var(i,top(i,j),j) = u(i,top(i,j),j)*0.5*(mus(i,j)+mus(i-1,j)) - varsave(i,top(i,j),j)*mu(i,j)
    ELSEIF (stag == 'v') THEN
       v(i,top(i,j),j) = vel_img(2)
       var(i,top(i,j),j) = v(i,top(i,j),j)*0.5*(mus(i,j)+mus(i,j-1)) - varsave(i,top(i,j),j)*mu(i,j)
    ELSEIF (stag == 'w') THEN
       w(i,top(i,j),j) = vel_img(3)
       var(i,top(i,j),j) = w(i,top(i,j),j)*mus(i,j) - varsave(i,top(i,j),j)*mu(i,j)
    ENDIF

 ENDDO
 ENDDO
 

 if (np > 0) then
    DO S=1,np 
    
       vel_img = 0.     
       radius = 0.  
       !DO nC=0,n-1
       DO nC=0,ansu_at_p(S)-1
	  ! calculate the radius to image point, and determine the largest radius  
	  radius(nC) = SQRT(side_neigh(3*nC,S)**2+side_neigh(3*nC+1,S)**2+side_neigh(3*nC+2,S)**2)
	  if (radius(nC)== 0.) radius(nC) = epsilon
       ENDDO
       max_rad = MAXVAL(radius)
       weight = 0.
       !DO nC=0,n-1
       DO nC=0,ansu_at_p(S)-1
	 ! weight(nC) = ((max_rad-radius(nC))/(max_rad*radius(nC)))**2
	  !weight(nC) = ((max_rad-radius(nC))/(max_rad*radius(nC)))
	  weight(nC) = ((max_rad-radius(nC))/(max_rad*radius(nC)))**(0.5)
	  vel_img(1) = vel_img(1) + weight(nC)*u(side_neigh_i(3*nC,S),side_neigh_i(3*nC+2,S),side_neigh_i(3*nC+1,S))
       ENDDO
       vel_img(1) = vel_img(1)/SUM(weight)

       radius = 0.  
       !DO nC=0,n-1
       DO nC=0,ansv_at_p(S)-1
	  ! calculate the radius to image point, and determine the largest radius  
	  radius(nC) = SQRT(side_neigh(3*n+3*nC,S)**2+side_neigh(3*n+3*nC+1,S)**2+side_neigh(3*n+3*nC+2,S)**2)
	  if (radius(nC)== 0.) radius(nC) = epsilon
       ENDDO
       max_rad = MAXVAL(radius)
       weight = 0.
       !DO nC=0,n-1
       DO nC=0,ansv_at_p(S)-1
	 ! weight(nC) = ((max_rad-radius(nC))/(max_rad*radius(nC)))**2
	  !weight(nC) = ((max_rad-radius(nC))/(max_rad*radius(nC)))
	  weight(nC) = ((max_rad-radius(nC))/(max_rad*radius(nC)))**(0.5)
	  vel_img(2) = vel_img(2) + weight(nC)*v(side_neigh_i(3*n+3*nC,S),side_neigh_i(3*n+3*nC+2,S),side_neigh_i(3*n+3*nC+1,S))
       ENDDO
       vel_img(2) = vel_img(2)/SUM(weight)      

       radius = 0.  
       !DO nC=0,n-1
       DO nC=0,answ_at_p(S)-1
	  ! calculate the radius to image point, and determine the largest radius  
	  radius(nC) = SQRT(side_neigh(6*n+3*nC,S)**2+side_neigh(6*n+3*nC+1,S)**2+side_neigh(6*n+3*nC+2,S)**2)
	  if (radius(nC)== 0.) radius(nC) = epsilon
       ENDDO
       max_rad = MAXVAL(radius)
       weight = 0.
       !DO nC=0,n-1
       DO nC=0,answ_at_p(S)-1
	 ! weight(nC) = ((max_rad-radius(nC))/(max_rad*radius(nC)))**2
	  !weight(nC) = ((max_rad-radius(nC))/(max_rad*radius(nC)))
	  weight(nC) = ((max_rad-radius(nC))/(max_rad*radius(nC)))**(0.5)
	  vel_img(3) = vel_img(3) + weight(nC)*w(side_neigh_i(6*n+3*nC,S),side_neigh_i(6*n+3*nC+2,S),side_neigh_i(6*n+3*nC+1,S))
       ENDDO
       vel_img(3) = vel_img(3)/SUM(weight)

       ! calculate the surface normal and tangential components at the interpolation point
       ! find the orthonormal basis for the plane representing the immersed boundary
       ! the plane is defined as ax+by+cz=0 or n(1)x+n(2)y+n(3)z = 0
       ! We know that one vector is the normal vector already calculated
       ! to find the second vector set x=1 and y=0 so that [1 0 -a/c] results, then normalize for a unit vector
       ! cross these two vectors to find the third
       matrix(1,:) = [1/SQRT(1 + (side_norm(1,S)/side_norm(3,S))**2), 0., (-side_norm(1,S)/side_norm(3,S))/SQRT(1 + (side_norm(1,S)/side_norm(3,S))**2)]
       matrix(2,:) = [side_norm(2,S)*matrix(1,3), side_norm(3,S)*matrix(1,1) - side_norm(1,S)*matrix(1,3), -side_norm(2,S)*matrix(1,1)]
       matrix(3,:) = side_norm(1:3,S)
       
       ! side_dist stores one-half of the distance from the ip to the gp.  When the bc=2 and interpolation method = 2, the ip is not a true image
       ! so the distance from the boundary to the ip needs to be calculated
       bp_ip_dist = sqrt((side_img(4,S)-side_bound(1,S))**2 + (side_img(5,S)-side_bound(2,S))**2 + (side_img(6,S)-side_bound(3,S))**2)

       ! now vel_img(1) and (2) are along the tangent vectors and vel_img(3) is the surface normal velocity at the interpolation point
       vel_img = MATMUL(matrix,vel_img) 

       ! calculate the normal and tangential components at the ghost point    
       ! could do this with a reflection matrix for surf_grad = 0 (no surface stress) conditions
       
       ! use the surface gradient for the tangential components
       ! set the mom flux gradient boundary condition at the immersed boundary
       ! using the vertical eddy viscosity below.  Eventually I need to change this
       ! to be a combination of vertical and horizontal components based on the 
       ! normal vector to the surface, also average to velocity location
       IF (tke_drag_coefficient /= 0) THEN
	  Cd = tke_drag_coefficient
	  !V0 = sqrt(vel_img(1)**2 + vel_img(2)**2)
	  
	  !surf_grad =  (Cd * V0 * vel_img(1))/xkmv(i,top(i,j)+1,j) 
	  !vel_img(1) = vel_img(1)-2*side_dist(S)*surf_grad
	  !surf_grad =  (Cd * V0 * vel_img(2))/xkmv(i,top(i,j)+1,j) 
	  !vel_img(2) = vel_img(2)-2*side_dist(S)*surf_grad  	

	  surf_grad = (bp_ip_dist/side_dist(S))*sqrt(Cd)*vel_img(1)/(KARMAN*bp_ip_dist)
	  vel_img(1) = vel_img(1)-2*side_dist(S)*surf_grad
	  surf_grad = (bp_ip_dist/side_dist(S))*sqrt(Cd)*vel_img(2)/(KARMAN*bp_ip_dist)    
	  vel_img(2) = vel_img(2)-2*side_dist(S)*surf_grad
	  	
       ELSEIF (z_rough /= 0) THEN
	  !Cd= (KARMAN / LOG(side_dist(S)/z_rough))**2
	  !Cd= (KARMAN / LOG(bp_ip_dist/z_rough))**2
	  !V0 = sqrt(vel_img(1)**2 + vel_img(2)**2)
	  
	  !surf_grad =  (Cd * V0 * vel_img(1))/xkmv(i,top(i,j)+1,j) 
	  !vel_img(1) = vel_img(1)-2*side_dist(S)*surf_grad
	  !surf_grad =  (Cd * V0 * vel_img(2))/xkmv(i,top(i,j)+1,j) 
	  !vel_img(2) = vel_img(2)-2*side_dist(S)*surf_grad 
	    
	  !surf_grad = (bp_ip_dist/side_dist(S))*sqrt(Cd)*vel_img(1)/(KARMAN*bp_ip_dist)
	  !vel_img(1) = vel_img(1)-2*side_dist(S)*surf_grad
	  !surf_grad = (bp_ip_dist/side_dist(S))*sqrt(Cd)*vel_img(2)/(KARMAN*bp_ip_dist)    
	  !vel_img(2) = vel_img(2)-2*side_dist(S)*surf_grad 

          !KAL this is the same as directly above, but simplified
          surf_grad = vel_img(1)/LOG(bp_ip_dist/z_rough)/side_dist(S)
          vel_img(1) = vel_img(1)-2*side_dist(S)*surf_grad
          surf_grad = vel_img(2)/LOG(bp_ip_dist/z_rough)/side_dist(S) 
          vel_img(2) = vel_img(2)-2*side_dist(S)*surf_grad  
	  
       ! add an else if here for ust       
       ELSE ! set the surface gradient to zero
	  surf_grad = 0.
	  vel_img(1) = vel_img(1)-2*side_dist(S)*surf_grad
	  vel_img(2) = vel_img(2)-2*side_dist(S)*surf_grad  
       ENDIF	

       ! set the normal component to zero at the boundary
       vel_img(3) = vel_img(3)-(2*side_dist(S)/bp_ip_dist)*vel_img(3)

       ! now transform back into cartesian coordinates by inverting the transformation matrix 
       ! then multiplying the velocities by the inverted tranformation matrix      
       !if (KIND(matrix) == 4) then
       !	CALL SGETRF(3,3,matrix,3,ipiv,info)
       !	CALL SGETRI(3,matrix,3,ipiv,work,336,info)
       !elseif (KIND(matrix) == 8) then    
       !	CALL DGETRF(3,3,matrix,3,ipiv,info)
       !	CALL DGETRI(3,matrix,3,ipiv,work,336,info)
       !endif
       matrix = TRANSPOSE(matrix)
       vel_img = MATMUL(matrix,vel_img)     

       IF (stag == 'u') THEN
	  u(side(1,S),side(3,S),side(2,S)) = vel_img(1)
	  var(side(1,S),side(3,S),side(2,S)) = u(side(1,S),side(3,S),side(2,S))*0.5*(mus(side(1,S),side(2,S))+mus(side(1,S)-1,side(2,S))) &
				             - varsave(side(1,S),side(3,S),side(2,S))*mu(side(1,S),side(2,S))
       ELSEIF (stag == 'v') THEN
	  v(side(1,S),side(3,S),side(2,S)) = vel_img(2)
	  var(side(1,S),side(3,S),side(2,S)) = v(side(1,S),side(3,S),side(2,S))*0.5*(mus(side(1,S),side(2,S))+mus(side(1,S),side(2,S)-1)) &
					     - varsave(side(1,S),side(3,S),side(2,S))*mu(side(1,S),side(2,S))
       ELSEIF (stag == 'w') THEN
	  w(side(1,S),side(3,S),side(2,S)) = vel_img(3)
	  var(side(1,S),side(3,S),side(2,S)) = w(side(1,S),side(3,S),side(2,S))*mus(side(1,S),side(2,S)) &
					     - varsave(side(1,S),side(3,S),side(2,S))*mu(side(1,S),side(2,S))
       ENDIF

    ENDDO 
 endif

 END SUBROUTINE mom_flux_inverse_dist_ss
 
!-------------------------------------------------------------------------------------------------------------------------------------

SUBROUTINE get_top_pts_fs( istag, stag, dx, dy,          &
                           ibm_ht, ibm_ht_stag,          &
                           ht_p,                         &
			   inside,                       &
			   top, top_img, top_bound,      &
			   top_neigh, top_neigh_i,       &
			   n,                            &
			   ids, ide, jds, jde, kds, kde, &
                           ims, ime, jms, jme, kms, kme, &
                           its, ite, jts, jte, kts, kte)
 IMPLICIT NONE
! input data
 INTEGER, INTENT(IN   )                                    :: istag, &        ! stagger of the image point
                                                              stag            ! stagger of the neighbors
 REAL, INTENT(IN   )                                       :: dx,dy
 REAL, DIMENSION(ims:ime,jms:jme), INTENT(IN   )           :: ibm_ht,     &
                                                              ibm_ht_stag
 REAL, DIMENSION(ims:ime,kms:kme,jms:jme), INTENT(IN   )   :: ht_p            ! ph at the points being computed	     
 INTEGER, DIMENSION(ims:ime,kms:kme,jms:jme), INTENT(IN  ) :: inside          ! one if the pt is inside boundary, zero if it is outside
 INTEGER, DIMENSION(ims:ime,jms:jme), INTENT(IN   )        :: top             !'top boundary' ghost points					      
 REAL, DIMENSION(ims:ime,jms:jme,6), INTENT(IN   )         :: top_img         ! (x,y,z) location of ghost point and image point of the 'top boundary' ghost points
 REAL, DIMENSION(ims:ime,jms:jme,3), INTENT(IN   )         :: top_bound       ! (x,y,z) location of the boundary for top point
                                                                              ! I dont think that I need the boundary point for free slip
! REAL, DIMENSION(ims:ime,jms:jme,0:3*n-1), INTENT(  OUT)   :: top_neigh       ! (x,y,z) location of  neighbors
! INTEGER, DIMENSION(ims:ime,jms:jme,0:3*n-1), INTENT(  OUT):: top_neigh_i     ! (i,j,k) index of top neighbors
 REAL, DIMENSION(ims:ime,jms:jme,0:11), INTENT(  OUT)   :: top_neigh       ! (x,y,z) location of  neighbors
 INTEGER, DIMENSION(ims:ime,jms:jme,0:11), INTENT(  OUT):: top_neigh_i     ! (i,j,k) index of top neighbors
 INTEGER, INTENT(IN   )                                    :: n               ! desired number of nearest neighbors
 INTEGER, INTENT(IN   )                   :: ids, ide, jds, jde, kds, kde, &  ! d: domain m:memory p:patch t:tile
                                             ims, ime, jms, jme, kms, kme, &
                                             its, ite, jts, jte, kts, kte		   

!local data
 INTEGER                                                   :: i,j,       &
                                                              i_end,     &
							      j_end,     &
                                                              nC,        &
							      i1,i2,     &
							      k1,k2   							      
   
!--------------------------------------------------------------------------------
! the executable begins here
! this subroutine stores the (i,j,k) index and (x,y,z) location of the four 
! neighbors of a top image point.
! print *, 'dyn_em/module_ibm.F/subroutine get_top_pts_fs'
!-------------------------------------------------------------------------------- 

! initalize the arrays
top_neigh = 0.
top_neigh_i = 0

 IF (istag == 1) THEN
    i_end = ite
    j_end = MIN(jte,jde-1)
 ELSEIF (istag == 2) THEN
    i_end = MIN(ite,ide-1)
    j_end = jte
 ELSEIF (istag == 3) THEN
    i_end = MIN(ite,ide-1)
    j_end = MIN(jte,jde-1)
 ENDIF

 DO i=its,i_end
 DO j=jts,j_end         
       ! find  neighbors
       ! the point is between x1 and x2
       ! if it is exactly on an x grid value, then x1 is to the left of the image point
       ! and x2 is the x location of the image point
       if (stag == 1) then
	   i1 = ceiling(top_img(i,j,4)/dx) 
	   i2 = ceiling(top_img(i,j,4)/dx)+1       
       elseif ((stag == 2).OR.(stag == 3)) then 
	   i1 = ceiling((top_img(i,j,4)-(dx/2))/dx) 
	   i2 = ceiling((top_img(i,j,4)-(dx/2))/dx)+1
       endif
       k1 = MIN(top(i1,j),top(i2,j))
       k2 = k1
       do while (top_img(i,j,6) >= ht_p(i1,k1,j))
           k1=k1+1
       enddo
       do while (top_img(i,j,6) >= ht_p(i2,k2,j))
           k2=k2+1
       enddo
       ! assign the four neighbors
       if ((inside(i1,k1  ,j) == 0).AND. &
           (inside(i2,k2  ,j) == 0).AND. &
	   (inside(i2,k2-1,j) == 0).AND. &
	   (inside(i1,k1-1,j) == 0)) then
	    top_neigh_i(i,j,0) = i1
	    top_neigh_i(i,j,1) = j
	    top_neigh_i(i,j,2) = k1
	    top_neigh_i(i,j,3) = i2
	    top_neigh_i(i,j,4) = j
	    top_neigh_i(i,j,5) = k2
	    top_neigh_i(i,j,6) = i2
	    top_neigh_i(i,j,7) = j
	    top_neigh_i(i,j,8) = k2-1
	    top_neigh_i(i,j,9) = i1
	    top_neigh_i(i,j,10) = j
	    top_neigh_i(i,j,11) = k1-1
	    DO nC=0,3
	       if (stag ==1 ) then	  		  
		   top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx)
		   top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)
	       elseif (stag == 2) then
		   top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
		   top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy)	       
	       elseif (stag == 3) then
		   top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
		   top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)	       
	       endif
	       top_neigh(i,j,3*nC+2) = ht_p(top_neigh_i(i,j,3*nC),top_neigh_i(i,j,3*nC+2),j)
            ENDDO       
       elseif ((inside(i1,k1  ,j) == 0).AND. &
           (inside(i2,k2  ,j) == 0).AND. &
	   (inside(i2,k2-1,j) == 0).AND. &
	   (inside(i1,k1-1,j) == 1)) then
	    top_neigh_i(i,j,0) = i1
	    top_neigh_i(i,j,1) = j
	    top_neigh_i(i,j,2) = k1
	    top_neigh_i(i,j,3) = i2
	    top_neigh_i(i,j,4) = j
	    top_neigh_i(i,j,5) = k2
	    top_neigh_i(i,j,6) = i2
	    top_neigh_i(i,j,7) = j
	    top_neigh_i(i,j,8) = k2-1
	    top_neigh_i(i,j,9) = i1
	    top_neigh_i(i,j,10) = j
	    top_neigh_i(i,j,11) = 0
	    DO nC=0,2  		  
	       if (stag ==1 ) then	  		  
		   top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx)
		   top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)
	       elseif (stag == 2) then
		   top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
		   top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy)	       
	       elseif (stag == 3) then
		   top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
		   top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)	       
	       endif
	       top_neigh(i,j,3*nC+2) = ht_p(top_neigh_i(i,j,3*nC),top_neigh_i(i,j,3*nC+2),j)
            ENDDO
	    nC=3
	    if (stag ==1 ) then	  		  
		top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx)
		top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)
	    elseif (stag == 2) then
		top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
		top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy)	       
	    elseif (stag == 3) then
		top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
		top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)	       
	    endif
	    top_neigh(i,j,3*nC+2) = ibm_ht(top_neigh_i(i,j,3*nC),top_neigh_i(i,j,3*nC+1))   
       elseif ((inside(i1,k1  ,j) == 0).AND. &
           (inside(i2,k2  ,j) == 0).AND. &
	   (inside(i2,k2-1,j) == 1).AND. &
	   (inside(i1,k1-1,j) == 0)) then
	    top_neigh_i(i,j,0) = i1
	    top_neigh_i(i,j,1) = j
	    top_neigh_i(i,j,2) = k1
	    top_neigh_i(i,j,3) = i2
	    top_neigh_i(i,j,4) = j
	    top_neigh_i(i,j,5) = k2
	    top_neigh_i(i,j,6) = i2
	    top_neigh_i(i,j,7) = j
	    top_neigh_i(i,j,8) = 0
	    top_neigh_i(i,j,9) = i1
	    top_neigh_i(i,j,10) = j
	    top_neigh_i(i,j,11) = k1-1
	    DO nC=0,1  		  
	       if (stag ==1 ) then	  		  
		   top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx)
		   top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)
	       elseif (stag == 2) then
		   top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
		   top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy)	       
	       elseif (stag == 3) then
		   top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
		   top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)	       
	       endif
	       top_neigh(i,j,3*nC+2) = ht_p(top_neigh_i(i,j,3*nC),top_neigh_i(i,j,3*nC+2),j)
            ENDDO
            nC=2
	    if (stag ==1 ) then	  		  
		top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx)
		top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)
	    elseif (stag == 2) then
		top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
		top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy)	       
	    elseif (stag == 3) then
		top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
		top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)	       
	    endif
	    top_neigh(i,j,3*nC+2) = ibm_ht(top_neigh_i(i,j,3*nC),top_neigh_i(i,j,3*nC+1))
	    nC=3  		  
	    if (stag ==1 ) then	  		  
		top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx)
		top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)
	    elseif (stag == 2) then
		top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
		top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy)	       
	    elseif (stag == 3) then
		top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
		top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)	       
	    endif
	    top_neigh(i,j,3*nC+2) = ht_p(top_neigh_i(i,j,3*nC),top_neigh_i(i,j,3*nC+2),j) 
       elseif ((inside(i1,k1  ,j) == 0).AND. &
           (inside(i2,k2  ,j) == 0).AND. &
	   (inside(i2,k2-1,j) == 1).AND. &
	   (inside(i1,k1-1,j) == 1)) then
	    top_neigh_i(i,j,0) = i1
	    top_neigh_i(i,j,1) = j
	    top_neigh_i(i,j,2) = k1
	    top_neigh_i(i,j,3) = i2
	    top_neigh_i(i,j,4) = j
	    top_neigh_i(i,j,5) = k2
	    top_neigh_i(i,j,6) = i2
	    top_neigh_i(i,j,7) = j
	    top_neigh_i(i,j,8) = 0
	    top_neigh_i(i,j,9) = i1
	    top_neigh_i(i,j,10) = j
	    top_neigh_i(i,j,11) = 0
	    DO nC=0,1  		  
	       if (stag ==1 ) then	  		  
		   top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx)
		   top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)
	       elseif (stag == 2) then
		   top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
		   top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy)	       
	       elseif (stag == 3) then
		   top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
		   top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)	       
	       endif
	       top_neigh(i,j,3*nC+2) = ht_p(top_neigh_i(i,j,3*nC),top_neigh_i(i,j,3*nC+2),j)
            ENDDO
	    DO nC=2,3  		  
	       if (stag ==1 ) then	  		  
		   top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx)
		   top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)
	       elseif (stag == 2) then
		   top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
		   top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy)	       
	       elseif (stag == 3) then
		   top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
		   top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)	       
	       endif
	       top_neigh(i,j,3*nC+2) = ibm_ht(top_neigh_i(i,j,3*nC),top_neigh_i(i,j,3*nC+1))
            ENDDO
       elseif ((inside(i1,k1  ,j) == 0).AND. &
           (inside(i2,k2  ,j) == 1).AND. &
	   (inside(i2,k2-1,j) == 1).AND. &
	   (inside(i1,k1-1,j) == 1)) then
	    top_neigh_i(i,j,0) = i1
	    top_neigh_i(i,j,1) = j
	    top_neigh_i(i,j,2) = k1
	    top_neigh_i(i,j,3) = i2
	    top_neigh_i(i,j,4) = j
	    top_neigh_i(i,j,5) = k2+1
	    top_neigh_i(i,j,6) = i2
	    top_neigh_i(i,j,7) = j
	    top_neigh_i(i,j,8) = 0
	    top_neigh_i(i,j,9) = i1
	    top_neigh_i(i,j,10) = j
	    top_neigh_i(i,j,11) = 0
	    DO nC=0,1  		  
	       if (stag ==1 ) then	  		  
		   top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx)
		   top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)
	       elseif (stag == 2) then
		   top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
		   top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy)	       
	       elseif (stag == 3) then
		   top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
		   top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)	       
	       endif
	       top_neigh(i,j,3*nC+2) = ht_p(top_neigh_i(i,j,3*nC),top_neigh_i(i,j,3*nC+2),j)
            ENDDO
	    DO nC=2,3  		  
	       if (stag ==1 ) then	  		  
		   top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx)
		   top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)
	       elseif (stag == 2) then
		   top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
		   top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy)	       
	       elseif (stag == 3) then
		   top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
		   top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)	       
	       endif
	       top_neigh(i,j,3*nC+2) = ibm_ht(top_neigh_i(i,j,3*nC),top_neigh_i(i,j,3*nC+1))
            ENDDO    	    
       elseif ((inside(i1,k1  ,j) == 1).AND. &
           (inside(i2,k2  ,j) == 0).AND. &
	   (inside(i2,k2-1,j) == 1).AND. &
	   (inside(i1,k1-1,j) == 1)) then
	    top_neigh_i(i,j,0) = i1
	    top_neigh_i(i,j,1) = j
	    top_neigh_i(i,j,2) = k1+1
	    top_neigh_i(i,j,3) = i2
	    top_neigh_i(i,j,4) = j
	    top_neigh_i(i,j,5) = k2
	    top_neigh_i(i,j,6) = i2
	    top_neigh_i(i,j,7) = j
	    top_neigh_i(i,j,8) = 0
	    top_neigh_i(i,j,9) = i1
	    top_neigh_i(i,j,10) = j
	    top_neigh_i(i,j,11) = 0
	    DO nC=0,1  		  
	       if (stag ==1 ) then	  		  
		   top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx)
		   top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)
	       elseif (stag == 2) then
		   top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
		   top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy)	       
	       elseif (stag == 3) then
		   top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
		   top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)	       
	       endif
	       top_neigh(i,j,3*nC+2) = ht_p(top_neigh_i(i,j,3*nC),top_neigh_i(i,j,3*nC+2),j)
            ENDDO
	    DO nC=2,3  		  
	       if (stag ==1 ) then	  		  
		   top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx)
		   top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)
	       elseif (stag == 2) then
		   top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
		   top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy)	       
	       elseif (stag == 3) then
		   top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
		   top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)	       
	       endif
	       top_neigh(i,j,3*nC+2) = ibm_ht(top_neigh_i(i,j,3*nC),top_neigh_i(i,j,3*nC+1))
            ENDDO 	    
       else
	    print *, 'there are top neighbors not assigned at i=',i,'j=',j, 'for istag =', istag,'for stag =', stag
	    print *, inside(i1,k1  ,j) ,inside(i2,k2  ,j), inside(i2,k2-1,j), inside(i1,k1-1,j) 
	 !   CALL wrf_error_fatal ('top: the neighbors are not assigned') 
       endif 
       	 !   print '((A),1i5,(A),1i5,(A),5i5)','i=',i,'j=',j,'for stag =', stag, inside(i1,k1  ,j) ,inside(i2,k2  ,j), inside(i2,k2-1,j), inside(i1,k1-1,j)
   ENDDO
   ENDDO   
   
   ! make the image coord the origin (x,y,z,)=(0,0,0)
    DO i=its,ite
    DO j=jts,jte
    DO nC=0,3
       top_neigh(i,j,3*nC) = top_neigh(i,j,3*nC)-top_img(i,j,4)
       top_neigh(i,j,3*nC+1) = top_neigh(i,j,3*nC+1)-top_img(i,j,5)
       top_neigh(i,j,3*nC+2) = top_neigh(i,j,3*nC+2)-top_img(i,j,6)     
    ENDDO
    ENDDO
    ENDDO  

 END SUBROUTINE get_top_pts_fs
!--------------------------------------------------------------------------------

SUBROUTINE get_top_pts_2d( stag, bc_type,                &
                           dx, dy, prox,                 &
                           ibm_ht, ibm_ht_stag,          &
                           ht_p,                         &
			   inside,                       &
			   top, top_img, top_bound,      &
			   top_neigh, top_neigh_i,       &
			   n,                            &
			   ids, ide, jds, jde, kds, kde, &
                           ims, ime, jms, jme, kms, kme, &
                           its, ite, jts, jte, kts, kte)
 IMPLICIT NONE
! input data
 INTEGER, INTENT(IN   )                                    :: stag,       &
                                                              bc_type 
 REAL, INTENT(IN   )                                       :: dx,dy
 INTEGER, DIMENSION(ims:ime,jms:jme), INTENT(IN   )        :: prox
 REAL, DIMENSION(ims:ime,jms:jme), INTENT(IN   )           :: ibm_ht,     &
                                                              ibm_ht_stag
 REAL, DIMENSION(ims:ime,kms:kme,jms:jme), INTENT(IN   )   :: ht_p            ! ht at the points being computed	     
 INTEGER, DIMENSION(ims:ime,kms:kme,jms:jme), INTENT(IN  ) :: inside          ! one if the pt is inside boundary, zero if it is outside
 INTEGER, DIMENSION(ims:ime,jms:jme), INTENT(IN   )        :: top             !'top boundary' ghost points					      
 REAL, DIMENSION(ims:ime,jms:jme,6), INTENT(IN   )         :: top_img         ! (x,y,z) location of ghost point and image point of the 'top boundary' ghost points
 REAL, DIMENSION(ims:ime,jms:jme,3), INTENT(IN   )         :: top_bound       ! (x,y,z) location of the boundary for top point
! REAL, DIMENSION(ims:ime,jms:jme,0:3*n-1), INTENT(  OUT)   :: top_neigh       ! (x,y,z) location of  neighbors
! INTEGER, DIMENSION(ims:ime,jms:jme,0:3*n-1), INTENT(  OUT):: top_neigh_i     ! (i,j,k) index of top neighbors
 REAL, DIMENSION(ims:ime,jms:jme,0:11), INTENT(  OUT)   :: top_neigh       ! (x,y,z) location of  neighbors
 INTEGER, DIMENSION(ims:ime,jms:jme,0:11), INTENT(  OUT):: top_neigh_i     ! (i,j,k) index of top neighbors
 INTEGER, INTENT(IN   )                                    :: n               ! desired number of nearest neighbors
 INTEGER, INTENT(IN   )                   :: ids, ide, jds, jde, kds, kde, &  ! d: domain m:memory p:patch t:tile
                                             ims, ime, jms, jme, kms, kme, &
                                             its, ite, jts, jte, kts, kte		   

!local data
 INTEGER                                                   :: i,j,       &
                                                              i_end,     &
							      j_end,     &
                                                              nC,        &
							      i1,i2,     &
							      k1,k2   							      
   
!--------------------------------------------------------------------------------
! the executable begins here
! this subroutine stores the (i,j,k) index and (x,y,z) location of the four 
! neighbors of a top image point.
! numbering order is  01
!                     32
 CALL wrf_debug(100, 'dyn_em/module_ibm.F/subroutine get_top_pts_2d')
!-------------------------------------------------------------------------------- 

! initalize the arrays
top_neigh = 0.
top_neigh_i = 0

 IF (stag == 1) THEN
    i_end = ite
    j_end = MIN(jte,jde-1)
 ELSEIF (stag == 2) THEN
    i_end = MIN(ite,ide-1)
    j_end = jte
 ELSEIF (stag == 3) THEN
    i_end = MIN(ite,ide-1)
    j_end = MIN(jte,jde-1)
 ENDIF

 DO i=its,i_end
 DO j=jts,j_end 
       ! find  neighbors of the image point
    IF (bc_type == 1) THEN   
       ! the point is between x1 and x2
       ! if it is exactly on an x grid value, then x1 is to the left of the image point
       ! and x2 is the x location of the image point, unless the terrain slope is negative
       ! then the if mod test moves the neighbors so that x1 is the location of the image
       ! point, and x2 is to the right
       if (stag == 1) then
  	  i1 = ceiling(top_img(i,j,4)/dx) 
  	  i2 = ceiling(top_img(i,j,4)/dx)+1
  	  if ((MOD(top_img(i,j,4),dx)==0).AND.(ibm_ht_stag(i-1,j)>ibm_ht_stag(i,j))) then
  	      i1 = i1+1
  	      i2 = i2+1
  	  endif	    
       elseif ((stag == 2).OR.(stag == 3)) then 
  	  i1 = ceiling((top_img(i,j,4)-(dx/2))/dx) 
  	  i2 = ceiling((top_img(i,j,4)-(dx/2))/dx)+1
  	  if ((MOD(top_img(i,j,4)-(dx/2),dx)==0).AND.(ibm_ht_stag(i,j)>ibm_ht_stag(i+1,j))) then
  	      i1 = i1+1
  	      i2 = i2+1
  	  endif 
       endif  
       k1 = MIN(top(i1,j),top(i2,j))
       ! kludge to try to make do while look behave when
       ! topimg(i,j,6) = php(i1,k1,j) and fortran chooses
       ! to ignore this
       if (prox(i,j) == 1) k1=k1+1      
       k2 = k1
       do while (top_img(i,j,6) >= ht_p(i1,k1,j))
  	   k1=k1+1
       enddo
       do while (top_img(i,j,6) >= ht_p(i2,k2,j))      
  	   k2=k2+1
       enddo
    ELSEIF (bc_type == 2) THEN   
       ! find  neighbors of the boundary point
       ! the point is between x1 and x2
       ! if it is exactly on an x grid value, then x1 is to the left of the image point
       ! and x2 is the x location of the image point, unless the terrain slope is negative
       ! then the if mod test moves the neighbors so that x1 is the location of the image
       ! point, and x2 is to the right
       if (stag == 1) then
   	 i1 = ceiling(top_bound(i,j,1)/dx) 
   	 i2 = ceiling(top_bound(i,j,1)/dx)+1
   	 if ((MOD(top_bound(i,j,1),dx)==0).AND.(ibm_ht_stag(i-1,j)>ibm_ht_stag(i,j))) then
   	     i1 = i1+1
   	     i2 = i2+1
   	 endif       
      elseif ((stag == 2).OR.(stag == 3)) then 
   	 i1 = ceiling((top_bound(i,j,1)-(dx/2))/dx) 
   	 i2 = ceiling((top_bound(i,j,1)-(dx/2))/dx)+1
   	 if ((MOD(top_bound(i,j,1)-(dx/2),dx)==0).AND.(ibm_ht_stag(i,j)>ibm_ht_stag(i+1,j))) then
   	     i1 = i1+1
   	     i2 = i2+1
   	 endif 
	 ! for the neumann boundary conditions it can be a problem when a top ghost point is on a flat surface
	 ! next to steep terrain like a building.  This can lead the the boundary normal being straight up, but
	 ! if the neighbors are 1001 or 0110 then the boundary is to the left or right.  Therefore, you are assigning
	 ! the boundary condition to be in the wrong direction (up) when it should actually be to the left or right.
	 ! Below is a fix that I used for one case, but I don't think that it would fix every case. 
	 ! if ((MOD(top_img(i,j,4)-(dx/2),dx)==0).AND.(bc_type==2).AND.(ibm_ht(i-1,j)>ibm_ht(i,j))) then
  	 !     i1 = i1+1
  	 !     i2 = i2+1
  	 ! endif 
       endif       
       k1 = MIN(top(i1,j),top(i2,j))
       ! kludge to try to make do while look behave when
       ! topimg(i,j,6) = php(i1,k1,j) and fortran chooses
       ! to ignore this
       if (prox(i,j) == 1) k1=k1+1    
       k2 = k1
       if (prox(i,j) == 1) then
       	  do while (top_img(i,j,6) >= ht_p(i1,k1,j))
   	     k1=k1+1
	  enddo
	  do while (top_img(i,j,6) >= ht_p(i2,k2,j))    
   	     k2=k2+1
	  enddo 
       else
	  do while (top_bound(i,j,3) >= ht_p(i1,k1,j))
   	     k1=k1+1
	  enddo
	  do while (top_bound(i,j,3) >= ht_p(i2,k2,j))    
   	     k2=k2+1
	  enddo 
       endif
    ENDIF     
       ! assign the four neighbors
       if ((inside(i1,k1  ,j) == 0).AND. &
           (inside(i2,k2  ,j) == 0).AND. &
	   (inside(i2,k2-1,j) == 0).AND. &
	   (inside(i1,k1-1,j) == 0)) then
	 ! KAL this is the code used for hill cases forced with a pressure
	 ! gradient and the NYC case
	 ! I am changing it because it doesnt work when the points closer to 
	 ! the boundary have a velocity higher than the ones further away from the 
	 ! boundary.  In this case, the magnitude needed at the ghost point is underpredicted 
	 if ((bc_type==2).AND.(prox(i,j)==1)) print *, 'Neighbors 0000 with Neumann BC means BC not enforced'
	    top_neigh_i(i,j,0) = i1
	    top_neigh_i(i,j,1) = j
	    top_neigh_i(i,j,2) = k1
	    top_neigh_i(i,j,3) = i2
	    top_neigh_i(i,j,4) = j
	    top_neigh_i(i,j,5) = k2
	    top_neigh_i(i,j,6) = i2
	    top_neigh_i(i,j,7) = j
	    top_neigh_i(i,j,8) = k2-1
	    top_neigh_i(i,j,9) = i1
	    top_neigh_i(i,j,10) = j
	    top_neigh_i(i,j,11) = k1-1
	    DO nC=0,3
	       if (stag ==1 ) then			 
	 	  top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx)
	 	  top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)
	       elseif (stag == 2) then
	 	  top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
	 	  top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy)	      
	 	elseif (stag == 3) then
	 	  top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
	 	  top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)	      
	 	endif
	 	top_neigh(i,j,3*nC+2) = ht_p(top_neigh_i(i,j,3*nC),top_neigh_i(i,j,3*nC+2),j)
             ENDDO      
       elseif ((inside(i1,k1  ,j) == 0).AND. &
           (inside(i2,k2  ,j) == 0).AND. &
	   (inside(i2,k2-1,j) == 0).AND. &
	   (inside(i1,k1-1,j) == 1)) then
	    top_neigh_i(i,j,0) = i1
	    top_neigh_i(i,j,1) = j
	    top_neigh_i(i,j,2) = k1
	    top_neigh_i(i,j,3) = i2
	    top_neigh_i(i,j,4) = j
	    top_neigh_i(i,j,5) = k2
	    top_neigh_i(i,j,6) = i2
	    top_neigh_i(i,j,7) = j
	    top_neigh_i(i,j,8) = k2-1
	    top_neigh_i(i,j,9) = 0
	    top_neigh_i(i,j,10) = 0
	    top_neigh_i(i,j,11) = 0
	    ! the first three neighbors are computational nodes (zero nodes)
	    DO nC=0,2  		  
	       if (stag ==1 ) then	  		  
		   top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx)
		   top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)
	       elseif (stag == 2) then
		   top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
		   top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy)	       
	       elseif (stag == 3) then
		   top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
		   top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)	       
	       endif
	       top_neigh(i,j,3*nC+2) = ht_p(top_neigh_i(i,j,3*nC),top_neigh_i(i,j,3*nC+2),j)
            ENDDO
	    ! if the boundary point is exactly in line with x2, then the boundary 
	    ! point should not be the fourth point.  In this case, use the intersection
	    ! of x1 with ht.  Otherwise, use boundary point.
	    if (top_bound(i,j,1) == top_neigh(i,j,6)) then
	       top_neigh_i(i,j,9) = i1
	       top_neigh_i(i,j,10) = j
	       if (stag == 1) then
		   top_neigh(i,j,9) = (top_neigh_i(i,j,9)*dx)-(dx)
		   top_neigh(i,j,10) = (top_neigh_i(i,j,10)*dy)-(dy/2)
	       elseif (stag == 2) then
		   top_neigh(i,j,9) = (top_neigh_i(i,j,9)*dx)-(dx/2)
		   top_neigh(i,j,10) = (top_neigh_i(i,j,10)*dy)-(dy)	       
	       elseif (stag == 3) then 
		   top_neigh(i,j,9) = (top_neigh_i(i,j,9)*dx)-(dx/2)
		   top_neigh(i,j,10) = (top_neigh_i(i,j,10)*dy)-(dy/2)	       
	       endif	   
	       top_neigh(i,j,11) = ibm_ht(top_neigh_i(i,j,9),top_neigh_i(i,j,10))
	    else
		top_neigh(i,j,9) = top_bound(i,j,1)
		top_neigh(i,j,10) = top_bound(i,j,2)
		top_neigh(i,j,11) = top_bound(i,j,3)
	    endif    
       elseif ((inside(i1,k1  ,j) == 0).AND. &
           (inside(i2,k2  ,j) == 0).AND. &
	   (inside(i2,k2-1,j) == 1).AND. &
	   (inside(i1,k1-1,j) == 0)) then
	    top_neigh_i(i,j,0) = i1
	    top_neigh_i(i,j,1) = j
	    top_neigh_i(i,j,2) = k1
	    top_neigh_i(i,j,3) = i2
	    top_neigh_i(i,j,4) = j
	    top_neigh_i(i,j,5) = k2
	    top_neigh_i(i,j,6) = 0
	    top_neigh_i(i,j,7) = 0
	    top_neigh_i(i,j,8) = 0
	    top_neigh_i(i,j,9) = i1
	    top_neigh_i(i,j,10) = j
	    top_neigh_i(i,j,11) = k1-1
	    ! the first neighbors are computational nodes (zero nodes)
	    DO nC=0,1  		  
	       if (stag ==1 ) then	  		  
		   top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx)
		   top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)
	       elseif (stag == 2) then
		   top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
		   top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy)	       
	       elseif (stag == 3) then
		   top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
		   top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)	       
	       endif
	       top_neigh(i,j,3*nC+2) = ht_p(top_neigh_i(i,j,3*nC),top_neigh_i(i,j,3*nC+2),j)
            ENDDO
	    ! if the boundary point is exactly in line with x1, then the boundary 
	    ! point should not be the fourth point.  In this case, use the intersection
	    ! of x2 with ht.  Otherwise, use boundary point.
	    if (top_bound(i,j,1) == top_neigh(i,j,0)) then
	       top_neigh_i(i,j,6) = i2
	       top_neigh_i(i,j,7) = j
	       if (stag == 1) then
		   top_neigh(i,j,6) = (top_neigh_i(i,j,6)*dx)-(dx)
		   top_neigh(i,j,7) = (top_neigh_i(i,j,7)*dy)-(dy/2)
	       elseif (stag == 2) then
		   top_neigh(i,j,6) = (top_neigh_i(i,j,6)*dx)-(dx/2)
		   top_neigh(i,j,7) = (top_neigh_i(i,j,7)*dy)-(dy)	       
	       elseif (stag == 3) then 
		   top_neigh(i,j,6) = (top_neigh_i(i,j,6)*dx)-(dx/2)
		   top_neigh(i,j,7) = (top_neigh_i(i,j,7)*dy)-(dy/2)	       
	       endif	   
	       top_neigh(i,j,8) = ibm_ht(top_neigh_i(i,j,6),top_neigh_i(i,j,7))
	    else
	       top_neigh(i,j,6) = top_bound(i,j,1)
	       top_neigh(i,j,7) = top_bound(i,j,2)
	       top_neigh(i,j,8) = top_bound(i,j,3)
	    endif
	    ! fourth neighbor is a computational node (zero node)   
	    nC=3  		  
	    if (stag ==1 ) then	  		  
		top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx)
		top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)
	    elseif (stag == 2) then
		top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
		top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy)	       
	    elseif (stag == 3) then
		top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
		top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)	       
	    endif
	    top_neigh(i,j,3*nC+2) = ht_p(top_neigh_i(i,j,3*nC),top_neigh_i(i,j,3*nC+2),j)
       elseif ((inside(i1,k1  ,j) == 0).AND. &
           (inside(i2,k2  ,j) == 0).AND. &
	   (inside(i2,k2-1,j) == 1).AND. &
	   (inside(i1,k1-1,j) == 1)) then
	    top_neigh_i(i,j,0) = i1
	    top_neigh_i(i,j,1) = j
	    top_neigh_i(i,j,2) = k1
	    top_neigh_i(i,j,3) = i2
	    top_neigh_i(i,j,4) = j
	    top_neigh_i(i,j,5) = k2
	    top_neigh_i(i,j,6) = i2
	    top_neigh_i(i,j,7) = j
	    top_neigh_i(i,j,8) = 0
	    top_neigh_i(i,j,9) = i1
	    top_neigh_i(i,j,10) = j
	    top_neigh_i(i,j,11) = 0
	    DO nC=0,1  		  
	       if (stag ==1 ) then	  		  
		   top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx)
		   top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)
	       elseif (stag == 2) then
		   top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
		   top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy)	       
	       elseif (stag == 3) then
		   top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
		   top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)	       
	       endif
	       top_neigh(i,j,3*nC+2) = ht_p(top_neigh_i(i,j,3*nC),top_neigh_i(i,j,3*nC+2),j)
            ENDDO
	    DO nC=2,3  		  
	       if (stag ==1 ) then	  		  
		   top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx)
		   top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)
	       elseif (stag == 2) then
		   top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
		   top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy)	       
	       elseif (stag == 3) then
		   top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
		   top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)	       
	       endif
	       top_neigh(i,j,3*nC+2) = ibm_ht(top_neigh_i(i,j,3*nC),top_neigh_i(i,j,3*nC+1))
            ENDDO
      elseif ((inside(i1,k1  ,j) == 0).AND. &
           (inside(i2,k2  ,j) == 1).AND. &
	   (inside(i2,k2-1,j) == 1).AND. &
	   (inside(i1,k1-1,j) == 0)) then
	    top_neigh_i(i,j,0) = i1
	    top_neigh_i(i,j,1) = j
	    top_neigh_i(i,j,2) = k1
	    top_neigh_i(i,j,3) = 0
	    top_neigh_i(i,j,4) = 0
	    top_neigh_i(i,j,5) = 0
	    top_neigh_i(i,j,6) = 0
	    top_neigh_i(i,j,7) = 0
	    top_neigh_i(i,j,8) = 0
	    top_neigh_i(i,j,9) = i1
	    top_neigh_i(i,j,10) = j
	    top_neigh_i(i,j,11) = k1-1 	
	    ! first point at node
            nC=0
	    if (stag == 1) then
		top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx)
		top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)
	    elseif (stag == 2) then
		top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
		top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy)	       
	    elseif (stag == 3) then
		top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
		top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)	       
	    endif
	    top_neigh(i,j,3*nC+2) = ht_p(top_neigh_i(i,j,3*nC),top_neigh_i(i,j,3*nC+2),j)
	    ! fill in the next two points on the wall          
	    ! first z
	    top_neigh(i,j,5) = ht_p(i2,k2,j)
	    top_neigh(i,j,8) = ht_p(i2,k2-1,j)
	    if (stag == 1) then
		!next y
		top_neigh(i,j,4) = (j*dy)-(dy/2)
		top_neigh(i,j,7) = (j*dy)-(dy/2)
		! solve for x
		if (ibm_ht_stag(i1,j) >= ht_p(i2,k2,j)) then
		   top_neigh(i,j,3) = (i1*dx-dx) + (dx/2)*((top_neigh(i,j,5)-ibm_ht(i1,j)) &
	                               	          /(ibm_ht_stag(i1,j)-ibm_ht(i1,j)))
		   top_neigh(i,j,6) = (i1*dx-dx) + (dx/2)*((top_neigh(i,j,8)-ibm_ht(i1,j)) &
	                                          /(ibm_ht_stag(i1,j)-ibm_ht(i1,j)))
                elseif (ibm_ht_stag(i1,j) > ht_p(i2,k2-1,j)) then
		   top_neigh(i,j,3) = (i1*dx-dx) + dx*((top_neigh(i,j,5)-ibm_ht(i1,j)) &
	                                	     /(ibm_ht(i2,j)-ibm_ht(i1,j)))
		   top_neigh(i,j,6) = (i1*dx-dx) + dx*((top_neigh(i,j,8)-ibm_ht(i1,j)) &
	                                	     /(ibm_ht(i2,j)-ibm_ht(i1,j)))
	        else
		   top_neigh(i,j,3) = (i1*dx-(dx/2)) + (dx/2)*((top_neigh(i,j,5)-ibm_ht_stag(i1,j)) &
	                                	      /(ibm_ht(i2,j)-ibm_ht_stag(i1,j)))
		   top_neigh(i,j,6) = (i1*dx-(dx/2)) + (dx/2)*((top_neigh(i,j,8)-ibm_ht_stag(i1,j)) &
	                                	      /(ibm_ht(i2,j)-ibm_ht_stag(i1,j)))
		endif						   
	    elseif (stag == 2) then
		!next y
		top_neigh(i,j,4) = (j*dy)-(dy)
		top_neigh(i,j,7) = (j*dy)-(dy)
		! solve for x
	        if (ibm_ht_stag(i2,j) >= ht_p(i2,k2,j)) then
		   top_neigh(i,j,3) = (i1*dx-(dx/2)) + (dx/2)*((top_neigh(i,j,5)-ibm_ht(i1,j)) &
	                               	          /(ibm_ht_stag(i2,j)-ibm_ht(i1,j)))
		   top_neigh(i,j,6) = (i1*dx-(dx/2)) + (dx/2)*((top_neigh(i,j,8)-ibm_ht(i1,j)) &
	                                          /(ibm_ht_stag(i2,j)-ibm_ht(i1,j)))
                elseif (ibm_ht_stag(i2,j) > ht_p(i2,k2-1,j)) then
		   top_neigh(i,j,3) = (i1*dx-(dx/2)) + dx*((top_neigh(i,j,5)-ibm_ht(i1,j)) &
	                                	     /(ibm_ht(i2,j)-ibm_ht(i1,j)))
		   top_neigh(i,j,6) = (i1*dx-(dx/2)) + dx*((top_neigh(i,j,8)-ibm_ht(i1,j)) &
	                                	     /(ibm_ht(i2,j)-ibm_ht(i1,j)))
	        else
		   top_neigh(i,j,3) = (i1*dx) + (dx/2)*((top_neigh(i,j,5)-ibm_ht_stag(i2,j)) &
	                                	      /(ibm_ht(i2,j)-ibm_ht_stag(i2,j)))
		   top_neigh(i,j,6) = (i1*dx) + (dx/2)*((top_neigh(i,j,8)-ibm_ht_stag(i2,j)) &
	                                	      /(ibm_ht(i2,j)-ibm_ht_stag(i2,j)))
		endif	    
	    elseif (stag == 3) then
		!next y
		top_neigh(i,j,4) = (j*dy)-(dy/2)
		top_neigh(i,j,7) = (j*dy)-(dy/2)
		! solve for x
	        if (ibm_ht_stag(i2,j) >= ht_p(i2,k2,j)) then
		   top_neigh(i,j,3) = (i1*dx-(dx/2)) + (dx/2)*((top_neigh(i,j,5)-ibm_ht(i1,j)) &
	                               	          /(ibm_ht_stag(i2,j)-ibm_ht(i1,j)))
		   top_neigh(i,j,6) = (i1*dx-(dx/2)) + (dx/2)*((top_neigh(i,j,8)-ibm_ht(i1,j)) &
	                                          /(ibm_ht_stag(i2,j)-ibm_ht(i1,j)))
                elseif (ibm_ht_stag(i2,j) > ht_p(i2,k2-1,j)) then
		   top_neigh(i,j,3) = (i1*dx-(dx/2)) + dx*((top_neigh(i,j,5)-ibm_ht(i1,j)) &
	                                	     /(ibm_ht(i2,j)-ibm_ht(i1,j)))
		   top_neigh(i,j,6) = (i1*dx-(dx/2)) + dx*((top_neigh(i,j,8)-ibm_ht(i1,j)) &
	                                	     /(ibm_ht(i2,j)-ibm_ht(i1,j)))
	        else
		   top_neigh(i,j,3) = (i1*dx) + (dx/2)*((top_neigh(i,j,5)-ibm_ht_stag(i2,j)) &
	                                	      /(ibm_ht(i2,j)-ibm_ht_stag(i2,j)))
		   top_neigh(i,j,6) = (i1*dx) + (dx/2)*((top_neigh(i,j,8)-ibm_ht_stag(i2,j)) &
	                                	      /(ibm_ht(i2,j)-ibm_ht_stag(i2,j)))
		endif	    	    
	    endif					   
 	    ! fourth point at node
            nC=3
	    if (stag == 1) then
		top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx)
		top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)
	    elseif (stag == 2) then
		top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
		top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy)	       
	    elseif (stag == 3) then
		top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
		top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)	       
	    endif
	    top_neigh(i,j,3*nC+2) = ht_p(top_neigh_i(i,j,3*nC),top_neigh_i(i,j,3*nC+2),j)  
       elseif ((inside(i1,k1  ,j) == 1).AND. &
           (inside(i2,k2  ,j) == 0).AND. &
	   (inside(i2,k2-1,j) == 0).AND. &
	   (inside(i1,k1-1,j) == 1)) then
	    top_neigh_i(i,j,0) = 0
	    top_neigh_i(i,j,1) = 0
	    top_neigh_i(i,j,2) = 0
	    top_neigh_i(i,j,3) = i2
	    top_neigh_i(i,j,4) = j
	    top_neigh_i(i,j,5) = k2
	    top_neigh_i(i,j,6) = i2
	    top_neigh_i(i,j,7) = j
	    top_neigh_i(i,j,8) = k2-1
	    top_neigh_i(i,j,9) = 0
	    top_neigh_i(i,j,10) = 0
	    top_neigh_i(i,j,11) = 0   
	    ! first point on the boundary
            ! first z
	    top_neigh(i,j,2) = ht_p(i1,k1,j)
	    if (stag == 1) then
		!next y
		top_neigh(i,j,1) = (j*dy)-(dy/2)
		! solve for x
		if (ibm_ht_stag(i1,j) >= ht_p(i1,k1,j)) then
		    top_neigh(i,j,0) = (i1*dx-(dx/2)) + (dx/2)*((top_neigh(i,j,2)-ibm_ht_stag(i1,j)) &
	                                	              /(ibm_ht(i2,j)-ibm_ht_stag(i1,j)))
                elseif (ibm_ht_stag(i1,j) > ht_p(i1,k1-1,j)) then
		    top_neigh(i,j,0) = (i1*dx-dx) + dx*((top_neigh(i,j,2)-ibm_ht(i1,j)) &
	                                	      /(ibm_ht(i2,j)-ibm_ht(i1,j)))		 
		else
		    top_neigh(i,j,0) = (i1*dx-dx) + (dx/2)*((top_neigh(i,j,2)-ibm_ht(i1,j)) &
	                                	          /(ibm_ht_stag(i1,j)-ibm_ht(i1,j)))
		endif
	    elseif (stag == 2) then
	        !next y
		top_neigh(i,j,1) = (j*dy)-(dy)
		! solve for x
	        if (ibm_ht_stag(i2,j) >= ht_p(i1,k1,j)) then
		    top_neigh(i,j,0) = (i1*dx) + (dx/2)*((top_neigh(i,j,2)-ibm_ht_stag(i2,j)) &
	                                	       /(ibm_ht(i2,j)-ibm_ht_stag(i2,j)))
                elseif (ibm_ht_stag(i2,j) > ht_p(i1,k1-1,j)) then
		    top_neigh(i,j,0) = (i1*dx-(dx/2)) + dx*((top_neigh(i,j,2)-ibm_ht(i1,j)) &
	                                	          /(ibm_ht(i2,j)-ibm_ht(i1,j)))		 
		else
		    top_neigh(i,j,0) = (i1*dx-(dx/2)) + (dx/2)*((top_neigh(i,j,2)-ibm_ht(i1,j)) &
	                                	              /(ibm_ht_stag(i2,j)-ibm_ht(i1,j)))
		endif
	    elseif (stag == 3) then
	        !next y
		top_neigh(i,j,1) = (j*dy)-(dy/2)
		! solve for x
	        if (ibm_ht_stag(i2,j) >= ht_p(i1,k1,j)) then
		    top_neigh(i,j,0) = (i1*dx) + (dx/2)*((top_neigh(i,j,2)-ibm_ht_stag(i2,j)) &
	                                	       /(ibm_ht(i2,j)-ibm_ht_stag(i2,j)))
                elseif (ibm_ht_stag(i2,j) > ht_p(i1,k1-1,j)) then
		    top_neigh(i,j,0) = (i1*dx-(dx/2)) + dx*((top_neigh(i,j,2)-ibm_ht(i1,j)) &
	                                	          /(ibm_ht(i2,j)-ibm_ht(i1,j)))		 
		else
		    top_neigh(i,j,0) = (i1*dx-(dx/2)) + (dx/2)*((top_neigh(i,j,2)-ibm_ht(i1,j)) &
	                                	              /(ibm_ht_stag(i2,j)-ibm_ht(i1,j)))
		endif
	    endif
	    ! next two points are nodes 					   
	    DO nC=1,2
	       if (stag == 1) then
		   top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx)
		   top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)
	       elseif (stag == 2) then
		   top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
		   top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy)	       
	       elseif (stag == 3) then
		   top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
		   top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)	       
	       endif
	       top_neigh(i,j,3*nC+2) = ht_p(top_neigh_i(i,j,3*nC),top_neigh_i(i,j,3*nC+2),j)
	    ENDDO  
	    ! fourth point is on the boundary     
            ! first z
	    top_neigh(i,j,11) = ht_p(i1,k1-1,j)
	    if (stag == 1) then
		!next y
		top_neigh(i,j,10) = (j*dy)-(dy/2)
		! solve for x
		if (ibm_ht_stag(i1,j) >= ht_p(i1,k1,j)) then
		    top_neigh(i,j,9) = (i1*dx-(dx/2)) + (dx/2)*((top_neigh(i,j,11)-ibm_ht_stag(i1,j)) &
	                                	              /(ibm_ht(i2,j)-ibm_ht_stag(i1,j)))
                elseif (ibm_ht_stag(i1,j) > ht_p(i1,k1-1,j)) then
		    top_neigh(i,j,9) = (i1*dx-dx) + dx*((top_neigh(i,j,11)-ibm_ht(i1,j)) &
	                                	      /(ibm_ht(i2,j)-ibm_ht(i1,j)))		 
		else
		    top_neigh(i,j,9) = (i1*dx-dx) + (dx/2)*((top_neigh(i,j,11)-ibm_ht(i1,j)) &
	                                	          /(ibm_ht_stag(i1,j)-ibm_ht(i1,j)))
		endif
	    elseif (stag == 2) then 
		!next y
		top_neigh(i,j,10) = (j*dy)-(dy)
		! solve for x
	        if (ibm_ht_stag(i2,j) >= ht_p(i1,k1,j)) then
		    top_neigh(i,j,9) = (i1*dx) + (dx/2)*((top_neigh(i,j,11)-ibm_ht_stag(i2,j)) &
	                                	       /(ibm_ht(i2,j)-ibm_ht_stag(i2,j)))
                elseif (ibm_ht_stag(i2,j) > ht_p(i1,k1-1,j)) then
		    top_neigh(i,j,9) = (i1*dx-(dx/2)) + dx*((top_neigh(i,j,11)-ibm_ht(i1,j)) &
	                                	          /(ibm_ht(i2,j)-ibm_ht(i1,j)))		 
		else
		    top_neigh(i,j,9) = (i1*dx-(dx/2)) + (dx/2)*((top_neigh(i,j,11)-ibm_ht(i1,j)) &
	                                	              /(ibm_ht_stag(i2,j)-ibm_ht(i1,j)))
		endif	    
	    elseif (stag == 3) then 
		!next y
		top_neigh(i,j,10) = (j*dy)-(dy/2)
		! solve for x
	        if (ibm_ht_stag(i2,j) >= ht_p(i1,k1,j)) then
		    top_neigh(i,j,9) = (i1*dx) + (dx/2)*((top_neigh(i,j,11)-ibm_ht_stag(i2,j)) &
	                                	       /(ibm_ht(i2,j)-ibm_ht_stag(i2,j)))
                elseif (ibm_ht_stag(i2,j) > ht_p(i1,k1-1,j)) then
		    top_neigh(i,j,9) = (i1*dx-(dx/2)) + dx*((top_neigh(i,j,11)-ibm_ht(i1,j)) &
	                                	          /(ibm_ht(i2,j)-ibm_ht(i1,j)))		 
		else
		    top_neigh(i,j,9) = (i1*dx-(dx/2)) + (dx/2)*((top_neigh(i,j,11)-ibm_ht(i1,j)) &
	                                	              /(ibm_ht_stag(i2,j)-ibm_ht(i1,j)))
		endif
	    endif 				    
       elseif ((inside(i1,k1  ,j) == 1).AND. &
           (inside(i2,k2  ,j) == 0).AND. &
	   (inside(i2,k2-1,j) == 1).AND. &
	   (inside(i1,k1-1,j) == 1)) then
	    if (k2 < k1) then
	        print  '((A),1i5,(A),1i5,(A),2i5)','stag =',stag,' bc type =', bc_type,'k2 < k1 with 1011 at ',i,j
		! if (k2 < k1) then move k2 up one regardless of boundary condition, so now it is 1001
		top_neigh_i(i,j,0) = 0
		top_neigh_i(i,j,1) = 0
		top_neigh_i(i,j,2) = 0
		top_neigh_i(i,j,3) = i2
		top_neigh_i(i,j,4) = j
		top_neigh_i(i,j,5) = k2+1
		top_neigh_i(i,j,6) = i2
		top_neigh_i(i,j,7) = j
		top_neigh_i(i,j,8) = k2
		top_neigh_i(i,j,9) = 0
		top_neigh_i(i,j,10) = 0
		top_neigh_i(i,j,11) = 0   
		! first point on the boundary
        	! first z
		top_neigh(i,j,2) = ht_p(i1,k1,j)
		if (stag == 1) then
		    !next y
		    top_neigh(i,j,1) = (j*dy)-(dy/2)
		    ! solve for x
		    if (ibm_ht_stag(i1,j) >= ht_p(i1,k1,j)) then
			top_neigh(i,j,0) = (i1*dx-(dx/2)) + (dx/2)*((top_neigh(i,j,2)-ibm_ht_stag(i1,j)) &
	                                	        	  /(ibm_ht(i2,j)-ibm_ht_stag(i1,j)))
                    elseif (ibm_ht_stag(i1,j) > ht_p(i1,k1-1,j)) then
			top_neigh(i,j,0) = (i1*dx-dx) + dx*((top_neigh(i,j,2)-ibm_ht(i1,j)) &
	                                		  /(ibm_ht(i2,j)-ibm_ht(i1,j)))		 
		    else
			top_neigh(i,j,0) = (i1*dx-dx) + (dx/2)*((top_neigh(i,j,2)-ibm_ht(i1,j)) &
	                                	              /(ibm_ht_stag(i1,j)-ibm_ht(i1,j)))
		    endif
		elseif (stag == 2) then
	            !next y
		    top_neigh(i,j,1) = (j*dy)-(dy)
		    ! solve for x
	            if (ibm_ht_stag(i2,j) >= ht_p(i1,k1,j)) then
			top_neigh(i,j,0) = (i1*dx) + (dx/2)*((top_neigh(i,j,2)-ibm_ht_stag(i2,j)) &
	                                		   /(ibm_ht(i2,j)-ibm_ht_stag(i2,j)))
                    elseif (ibm_ht_stag(i2,j) > ht_p(i1,k1-1,j)) then
			top_neigh(i,j,0) = (i1*dx-(dx/2)) + dx*((top_neigh(i,j,2)-ibm_ht(i1,j)) &
	                                	              /(ibm_ht(i2,j)-ibm_ht(i1,j)))		 
		    else
			top_neigh(i,j,0) = (i1*dx-(dx/2)) + (dx/2)*((top_neigh(i,j,2)-ibm_ht(i1,j)) &
	                                	        	  /(ibm_ht_stag(i2,j)-ibm_ht(i1,j)))
		    endif
		elseif (stag == 3) then
	            !next y
		    top_neigh(i,j,1) = (j*dy)-(dy/2)
		    ! solve for x
	            if (ibm_ht_stag(i2,j) >= ht_p(i1,k1,j)) then
			top_neigh(i,j,0) = (i1*dx) + (dx/2)*((top_neigh(i,j,2)-ibm_ht_stag(i2,j)) &
	                                		   /(ibm_ht(i2,j)-ibm_ht_stag(i2,j)))
                    elseif (ibm_ht_stag(i2,j) > ht_p(i1,k1-1,j)) then
			top_neigh(i,j,0) = (i1*dx-(dx/2)) + dx*((top_neigh(i,j,2)-ibm_ht(i1,j)) &
	                                	              /(ibm_ht(i2,j)-ibm_ht(i1,j)))		 
		    else
			top_neigh(i,j,0) = (i1*dx-(dx/2)) + (dx/2)*((top_neigh(i,j,2)-ibm_ht(i1,j)) &
	                                	        	  /(ibm_ht_stag(i2,j)-ibm_ht(i1,j)))
		    endif
		endif
		! next two points are nodes 					   
		DO nC=1,2
		   if (stag == 1) then
		       top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx)
		       top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)
		   elseif (stag == 2) then
		       top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
		       top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy)	       
		   elseif (stag == 3) then
		       top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
		       top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)	       
		   endif
		   top_neigh(i,j,3*nC+2) = ht_p(top_neigh_i(i,j,3*nC),top_neigh_i(i,j,3*nC+2),j)
		ENDDO  
		! fourth point is on the boundary     
        	! first z
		top_neigh(i,j,11) = ht_p(i1,k1-1,j)
		if (stag == 1) then
		    !next y
		    top_neigh(i,j,10) = (j*dy)-(dy/2)
		    ! solve for x
		    if (ibm_ht_stag(i1,j) >= ht_p(i1,k1,j)) then
			top_neigh(i,j,9) = (i1*dx-(dx/2)) + (dx/2)*((top_neigh(i,j,11)-ibm_ht_stag(i1,j)) &
	                                	        	  /(ibm_ht(i2,j)-ibm_ht_stag(i1,j)))
                    elseif (ibm_ht_stag(i1,j) > ht_p(i1,k1-1,j)) then
			top_neigh(i,j,9) = (i1*dx-dx) + dx*((top_neigh(i,j,11)-ibm_ht(i1,j)) &
	                                		  /(ibm_ht(i2,j)-ibm_ht(i1,j)))		 
		    else
			top_neigh(i,j,9) = (i1*dx-dx) + (dx/2)*((top_neigh(i,j,11)-ibm_ht(i1,j)) &
	                                	              /(ibm_ht_stag(i1,j)-ibm_ht(i1,j)))
		    endif
		elseif (stag == 2) then 
		    !next y
		    top_neigh(i,j,10) = (j*dy)-(dy)
		    ! solve for x
	            if (ibm_ht_stag(i2,j) >= ht_p(i1,k1,j)) then
			top_neigh(i,j,9) = (i1*dx) + (dx/2)*((top_neigh(i,j,11)-ibm_ht_stag(i2,j)) &
	                                		   /(ibm_ht(i2,j)-ibm_ht_stag(i2,j)))
                    elseif (ibm_ht_stag(i2,j) > ht_p(i1,k1-1,j)) then
			top_neigh(i,j,9) = (i1*dx-(dx/2)) + dx*((top_neigh(i,j,11)-ibm_ht(i1,j)) &
	                                	              /(ibm_ht(i2,j)-ibm_ht(i1,j)))		 
		    else
			top_neigh(i,j,9) = (i1*dx-(dx/2)) + (dx/2)*((top_neigh(i,j,11)-ibm_ht(i1,j)) &
	                                	        	  /(ibm_ht_stag(i2,j)-ibm_ht(i1,j)))
		    endif	    
		elseif (stag == 3) then 
		    !next y
		    top_neigh(i,j,10) = (j*dy)-(dy/2)
		    ! solve for x
	            if (ibm_ht_stag(i2,j) >= ht_p(i1,k1,j)) then
			top_neigh(i,j,9) = (i1*dx) + (dx/2)*((top_neigh(i,j,11)-ibm_ht_stag(i2,j)) &
	                                		   /(ibm_ht(i2,j)-ibm_ht_stag(i2,j)))
                    elseif (ibm_ht_stag(i2,j) > ht_p(i1,k1-1,j)) then
			top_neigh(i,j,9) = (i1*dx-(dx/2)) + dx*((top_neigh(i,j,11)-ibm_ht(i1,j)) &
	                                	              /(ibm_ht(i2,j)-ibm_ht(i1,j)))		 
		    else
			top_neigh(i,j,9) = (i1*dx-(dx/2)) + (dx/2)*((top_neigh(i,j,11)-ibm_ht(i1,j)) &
	                                	        	  /(ibm_ht_stag(i2,j)-ibm_ht(i1,j)))
		    endif
		endif 				    
	    elseif (k1 == top(i1,j)) then !if (i1,k1) is also a top ghost point
	        !print '((A),1i5,(A),1i5,(A),2i5)','stag =',stag,' bc type =', bc_type,' top with 1011 at ',i,j
		! if (i1,j,k1) is a top ghost point then regardless of boundary condition
	        ! (i1,j,k1+1) is the first neighbor (a computational node)
	        ! (i2,j,k2) is the second neigbor (the zero computational node)
	        ! (i2,j,ht) is the third neighbor (boundary)
	        ! and (i1,j,ht) is the fourth neighbor (boundary)
		top_neigh_i(i,j,0) = i1
		top_neigh_i(i,j,1) = j
		top_neigh_i(i,j,2) = k1+1
		top_neigh_i(i,j,3) = i2
		top_neigh_i(i,j,4) = j
		top_neigh_i(i,j,5) = k2
		top_neigh_i(i,j,6) = i2
		top_neigh_i(i,j,7) = j
		top_neigh_i(i,j,8) = 0
		top_neigh_i(i,j,9) = i1
		top_neigh_i(i,j,10) = j
		top_neigh_i(i,j,11) = 0
		DO nC=0,1  		  
		   if (stag ==1 ) then	  		  
		       top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx)
		       top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)
		   elseif (stag == 2) then
		       top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
		       top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy)	       
		   elseif (stag == 3) then
		       top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
		       top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)	       
		   endif
		   top_neigh(i,j,3*nC+2) = ht_p(top_neigh_i(i,j,3*nC),top_neigh_i(i,j,3*nC+2),j)
        	ENDDO
		!the third and fourth point are on the boundary at (i1,ht) and (i2,ht)
		DO nC=2,3  		  
		   if (stag ==1 ) then	  		  
		       top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx)
		       top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)
		   elseif (stag == 2) then
		       top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
		       top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy)	       
		   elseif (stag == 3) then
		       top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
		       top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)	       
		   endif
		   top_neigh(i,j,3*nC+2) = ibm_ht(top_neigh_i(i,j,3*nC),top_neigh_i(i,j,3*nC+1))
        	ENDDO
	    else ! if (i1,j,k1) is not a top ghost point then the alorithm is more complicated 
	        ! print '((A),1i5,(A),1i5,(A),2i5)','stag =',stag,' bc type =', bc_type,' not top with 1011 at ',i,j
		! With dirchlet boundary conditions it is ok to have 1 neighbor on a node
		! and three neighbors on a boundary.  With neumann, we need max of two neighbors
	        ! on the boundary, and 2 (or three) on nodes.	  	       
		! first point on the boundary, to the right of (i1,j,k1)
	        top_neigh_i(i,j,0) = 0
	        top_neigh_i(i,j,1) = 0
	        top_neigh_i(i,j,2) = 0
        	! first z
		top_neigh(i,j,2) = ht_p(i1,k1,j)
		if (stag == 1) then
		    !next y
		    top_neigh(i,j,1) = (j*dy)-(dy/2)
		    ! solve for x
		    if (ibm_ht_stag(i1,j) >= ht_p(i1,k1,j)) then
			top_neigh(i,j,0) = (i1*dx-(dx/2)) + (dx/2)*((top_neigh(i,j,2)-ibm_ht_stag(i1,j)) &
								  /(ibm_ht(i2,j)-ibm_ht_stag(i1,j)))
        	     !elseif (ibm_ht_stag(i1,j) > ht_p(i1,k1-1,j)) then
		    !   top_neigh(i,j,0) = (i1*dx-dx) + dx*((top_neigh(i,j,2)-ibm_ht(i1,j)) &
        	     !				     /(ibm_ht(i2,j)-ibm_ht(i1,j)))		
		    else
			top_neigh(i,j,0) = (i1*dx-dx) + (dx/2)*((top_neigh(i,j,2)-ibm_ht(i1,j)) &
							      /(ibm_ht_stag(i1,j)-ibm_ht(i1,j)))
		    endif
		elseif (stag == 2) then
		     !next y
		    top_neigh(i,j,1) = (j*dy)-(dy)
		    ! solve for x
		     if (ibm_ht_stag(i2,j) >= ht_p(i1,k1,j)) then
			top_neigh(i,j,0) = (i1*dx) + (dx/2)*((top_neigh(i,j,2)-ibm_ht_stag(i2,j)) &
							   /(ibm_ht(i2,j)-ibm_ht_stag(i2,j)))
        	     !elseif (ibm_ht_stag(i2,j) > ht_p(i1,k1-1,j)) then
		    !	top_neigh(i,j,0) = (i1*dx-(dx/2)) + dx*((top_neigh(i,j,2)-ibm_ht(i1,j)) &
        	     !				 /(ibm_ht(i2,j)-ibm_ht(i1,j)))  	
		    else
			top_neigh(i,j,0) = (i1*dx-(dx/2)) + (dx/2)*((top_neigh(i,j,2)-ibm_ht(i1,j)) &
								  /(ibm_ht_stag(i2,j)-ibm_ht(i1,j)))
		    endif
		elseif (stag == 3) then
		     !next y
		    !!!!changing
		    top_neigh(i,j,1) = (j*dy)-(dy/2)
		    ! solve for x
		     if (ibm_ht_stag(i2,j) >= ht_p(i1,k1,j)) then
			top_neigh(i,j,0) = (i1*dx) + (dx/2)*((top_neigh(i,j,2)-ibm_ht_stag(i2,j)) &
							   /(ibm_ht(i2,j)-ibm_ht_stag(i2,j)))
        	     !elseif (ibm_ht_stag(i2,j) > ht_p(i1,k1-1,j)) then
		    !	top_neigh(i,j,0) = (i1*dx-(dx/2)) + dx*((top_neigh(i,j,2)-ibm_ht(i1,j)) &
        	     !					 /(ibm_ht(i2,j)-ibm_ht(i1,j)))  	
		    else
			top_neigh(i,j,0) = (i1*dx-(dx/2)) + (dx/2)*((top_neigh(i,j,2)-ibm_ht(i1,j)) &
								  /(ibm_ht_stag(i2,j)-ibm_ht(i1,j)))
		    endif
		endif !end of stagger choice 
	        ! second point is on a node (the node marked zero)
		top_neigh_i(i,j,3) = i2
		top_neigh_i(i,j,4) = j
		top_neigh_i(i,j,5) = k2		   
		nC=1			 
		if (stag ==1 ) then			 
		    top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx)
		    top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)
		elseif (stag == 2) then
		    top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
		    top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy)	      
		elseif (stag == 3) then
		    top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
		    top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)        
		endif
		top_neigh(i,j,3*nC+2) = ht_p(top_neigh_i(i,j,3*nC),top_neigh_i(i,j,3*nC+2),j)
        	! third point on the boundary at (i2,ht)
		top_neigh_i(i,j,6) = i2
		top_neigh_i(i,j,7) = j
		top_neigh_i(i,j,8) = 0
		nC=2		 
		if (stag ==1 ) then			 
		    top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx)
		    top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)
		elseif (stag == 2) then
		    top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
		    top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy)	      
		elseif (stag == 3) then
		    top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
		    top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)        
		endif
		top_neigh(i,j,3*nC+2) = ibm_ht(top_neigh_i(i,j,3*nC),top_neigh_i(i,j,3*nC+1))	  	   
		! fourth point can be a boundary point if Dirchlet, 
		! otherwise for Neumann it must be a node because there are already 2 boundary points
		if (bc_type == 1) then
		   ! fourth point can be the normal boundary point, or
		   ! if third point is normal bp then look left of the image point. 
		   top_neigh_i(i,j,9) = 0
	           top_neigh_i(i,j,10) = 0
	           top_neigh_i(i,j,11) = 0	       
		   if (top_bound(i,j,1) == top_img(i,j,4)) then
		       ! fourth point is on the boundary	 
        	       ! first z
		       top_neigh(i,j,11) = top_img(i,j,6)
		       if (stag == 1) then
			   !next y
			   top_neigh(i,j,10) = (j*dy)-(dy/2)
			   ! solve for x
			   if (ibm_ht_stag(i1,j) >= ht_p(i1,k1,j)) then
			       top_neigh(i,j,9) = (i1*dx-(dx/2)) + (dx/2)*((top_neigh(i,j,11)-ibm_ht_stag(i1,j)) &
									 /(ibm_ht(i2,j)-ibm_ht_stag(i1,j)))
        		   elseif (ibm_ht_stag(i1,j) > ht_p(i1,k1-1,j)) then
			       top_neigh(i,j,9) = (i1*dx-dx) + dx*((top_neigh(i,j,11)-ibm_ht(i1,j)) &
								 /(ibm_ht(i2,j)-ibm_ht(i1,j)))		
			   else
			       top_neigh(i,j,9) = (i1*dx-dx) + (dx/2)*((top_neigh(i,j,11)-ibm_ht(i1,j)) &
								     /(ibm_ht_stag(i1,j)-ibm_ht(i1,j)))
			   endif
		       elseif (stag == 2) then 
			   !next y
			   top_neigh(i,j,10) = (j*dy)-(dy)
			   ! solve for x
			   if (ibm_ht_stag(i2,j) >= ht_p(i1,k1,j)) then
			       top_neigh(i,j,9) = (i1*dx) + (dx/2)*((top_neigh(i,j,11)-ibm_ht_stag(i2,j)) &
								  /(ibm_ht(i2,j)-ibm_ht_stag(i2,j)))
        		   elseif (ibm_ht_stag(i2,j) > ht_p(i1,k1-1,j)) then
			       top_neigh(i,j,9) = (i1*dx-(dx/2)) + dx*((top_neigh(i,j,11)-ibm_ht(i1,j)) &
								     /(ibm_ht(i2,j)-ibm_ht(i1,j)))  	
			   else
			       top_neigh(i,j,9) = (i1*dx-(dx/2)) + (dx/2)*((top_neigh(i,j,11)-ibm_ht(i1,j)) &
									 /(ibm_ht_stag(i2,j)-ibm_ht(i1,j)))
			   endif	   
		       elseif (stag == 3) then 
			   !next y
			   top_neigh(i,j,10) = (j*dy)-(dy/2)
			   ! solve for x
			   if (ibm_ht_stag(i2,j) >= ht_p(i1,k1,j)) then
			       top_neigh(i,j,9) = (i1*dx) + (dx/2)*((top_neigh(i,j,11)-ibm_ht_stag(i2,j)) &
								  /(ibm_ht(i2,j)-ibm_ht_stag(i2,j)))
        		   elseif (ibm_ht_stag(i2,j) > ht_p(i1,k1-1,j)) then
			       top_neigh(i,j,9) = (i1*dx-(dx/2)) + dx*((top_neigh(i,j,11)-ibm_ht(i1,j)) &
								     /(ibm_ht(i2,j)-ibm_ht(i1,j)))  	
			   else
			       top_neigh(i,j,9) = (i1*dx-(dx/2)) + (dx/2)*((top_neigh(i,j,11)-ibm_ht(i1,j)) &
									 /(ibm_ht_stag(i2,j)-ibm_ht(i1,j)))
			   endif
		       endif		      
		   else
		       ! fourth point is normal boundary point
  		       top_neigh(i,j,9) = top_bound(i,j,1)
		       top_neigh(i,j,10) = top_bound(i,j,2)
		       top_neigh(i,j,11) = top_bound(i,j,3)
		   endif	
		elseif (bc_type == 2) then
		   if (k2+1 > top(i2+1,j)) then	
		      ! fourth point is on a node (above and to the right of the node marked zero)
		      top_neigh_i(i,j,9) = i2+1
		      top_neigh_i(i,j,10) = j
		      top_neigh_i(i,j,11) = k2+1		   
		      nC=3		 
		      if (stag ==1 ) then			 
			  top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx)
			  top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)
		      elseif (stag == 2) then
			  top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
			  top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy)	      
		      elseif (stag == 3) then
			  top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
			  top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)        
		      endif
		      top_neigh(i,j,3*nC+2) = ht_p(top_neigh_i(i,j,3*nC),top_neigh_i(i,j,3*nC+2),j)
		   else
		      print *, 'neighbors not assigned for Neumann 1011 at ',i,j
		   endif
	        endif ! end of bc_type is 1 or 2   
           endif ! (k2 < k1) and (i1,j,k1) is / is not a top ghost point	
       elseif ((inside(i1,k1  ,j) == 0).AND. &
           (inside(i2,k2  ,j) == 1).AND. &
	   (inside(i2,k2-1,j) == 1).AND. &
	   (inside(i1,k1-1,j) == 1)) then
	    if (k1 < k2) then
	        print  '((A),1i5,(A),1i5,(A),2i5)','stag =',stag,' bc type =', bc_type,'k1 < k2 with 0111 at ',i,j
		! if (k1 < k2) then move k1 up one regardless of boundary condition, so now it is 0110
		top_neigh_i(i,j,0) = i1
		top_neigh_i(i,j,1) = j
		top_neigh_i(i,j,2) = k1+1
		top_neigh_i(i,j,3) = 0
		top_neigh_i(i,j,4) = 0
		top_neigh_i(i,j,5) = 0
		top_neigh_i(i,j,6) = 0
		top_neigh_i(i,j,7) = 0
		top_neigh_i(i,j,8) = 0
		top_neigh_i(i,j,9) = i1
		top_neigh_i(i,j,10) = j
		top_neigh_i(i,j,11) = k1	
		! first point at node
        	nC=0
		if (stag == 1) then
		    top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx)
		    top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)
		elseif (stag == 2) then
		    top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
		    top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy)	       
		elseif (stag == 3) then
		    top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
		    top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)	       
		endif
		top_neigh(i,j,3*nC+2) = ht_p(top_neigh_i(i,j,3*nC),top_neigh_i(i,j,3*nC+2),j)
		! fill in the next two points on the wall          
		! first z
		top_neigh(i,j,5) = ht_p(i2,k2,j)
		top_neigh(i,j,8) = ht_p(i2,k2-1,j)
		if (stag == 1) then
		    !next y
		    top_neigh(i,j,4) = (j*dy)-(dy/2)
		    top_neigh(i,j,7) = (j*dy)-(dy/2)
		    ! solve for x
		    if (ibm_ht_stag(i1,j) >= ht_p(i2,k2,j)) then
		       top_neigh(i,j,3) = (i1*dx-dx) + (dx/2)*((top_neigh(i,j,5)-ibm_ht(i1,j)) &
	                               	              /(ibm_ht_stag(i1,j)-ibm_ht(i1,j)))
		       top_neigh(i,j,6) = (i1*dx-dx) + (dx/2)*((top_neigh(i,j,8)-ibm_ht(i1,j)) &
	                                              /(ibm_ht_stag(i1,j)-ibm_ht(i1,j)))
                    elseif (ibm_ht_stag(i1,j) > ht_p(i2,k2-1,j)) then
		       top_neigh(i,j,3) = (i1*dx-dx) + dx*((top_neigh(i,j,5)-ibm_ht(i1,j)) &
	                                		 /(ibm_ht(i2,j)-ibm_ht(i1,j)))
		       top_neigh(i,j,6) = (i1*dx-dx) + dx*((top_neigh(i,j,8)-ibm_ht(i1,j)) &
	                                		 /(ibm_ht(i2,j)-ibm_ht(i1,j)))
	            else
		       top_neigh(i,j,3) = (i1*dx-(dx/2)) + (dx/2)*((top_neigh(i,j,5)-ibm_ht_stag(i1,j)) &
	                                		  /(ibm_ht(i2,j)-ibm_ht_stag(i1,j)))
		       top_neigh(i,j,6) = (i1*dx-(dx/2)) + (dx/2)*((top_neigh(i,j,8)-ibm_ht_stag(i1,j)) &
	                                		  /(ibm_ht(i2,j)-ibm_ht_stag(i1,j)))
		    endif						   
		elseif (stag == 2) then
		    !next y
		    top_neigh(i,j,4) = (j*dy)-(dy)
		    top_neigh(i,j,7) = (j*dy)-(dy)
		    ! solve for x
	            if (ibm_ht_stag(i2,j) >= ht_p(i2,k2,j)) then
		       top_neigh(i,j,3) = (i1*dx-(dx/2)) + (dx/2)*((top_neigh(i,j,5)-ibm_ht(i1,j)) &
	                               	              /(ibm_ht_stag(i2,j)-ibm_ht(i1,j)))
		       top_neigh(i,j,6) = (i1*dx-(dx/2)) + (dx/2)*((top_neigh(i,j,8)-ibm_ht(i1,j)) &
	                                              /(ibm_ht_stag(i2,j)-ibm_ht(i1,j)))
                    elseif (ibm_ht_stag(i2,j) > ht_p(i2,k2-1,j)) then
		       top_neigh(i,j,3) = (i1*dx-(dx/2)) + dx*((top_neigh(i,j,5)-ibm_ht(i1,j)) &
	                                		 /(ibm_ht(i2,j)-ibm_ht(i1,j)))
		       top_neigh(i,j,6) = (i1*dx-(dx/2)) + dx*((top_neigh(i,j,8)-ibm_ht(i1,j)) &
	                                		 /(ibm_ht(i2,j)-ibm_ht(i1,j)))
	            else
		       top_neigh(i,j,3) = (i1*dx) + (dx/2)*((top_neigh(i,j,5)-ibm_ht_stag(i2,j)) &
	                                		  /(ibm_ht(i2,j)-ibm_ht_stag(i2,j)))
		       top_neigh(i,j,6) = (i1*dx) + (dx/2)*((top_neigh(i,j,8)-ibm_ht_stag(i2,j)) &
	                                		  /(ibm_ht(i2,j)-ibm_ht_stag(i2,j)))
		    endif	    
		elseif (stag == 3) then
		    !next y
		    top_neigh(i,j,4) = (j*dy)-(dy/2)
		    top_neigh(i,j,7) = (j*dy)-(dy/2)
		    ! solve for x
	            if (ibm_ht_stag(i2,j) >= ht_p(i2,k2,j)) then
		       top_neigh(i,j,3) = (i1*dx-(dx/2)) + (dx/2)*((top_neigh(i,j,5)-ibm_ht(i1,j)) &
	                               	              /(ibm_ht_stag(i2,j)-ibm_ht(i1,j)))
		       top_neigh(i,j,6) = (i1*dx-(dx/2)) + (dx/2)*((top_neigh(i,j,8)-ibm_ht(i1,j)) &
	                                              /(ibm_ht_stag(i2,j)-ibm_ht(i1,j)))
                    elseif (ibm_ht_stag(i2,j) > ht_p(i2,k2-1,j)) then
		       top_neigh(i,j,3) = (i1*dx-(dx/2)) + dx*((top_neigh(i,j,5)-ibm_ht(i1,j)) &
	                                		 /(ibm_ht(i2,j)-ibm_ht(i1,j)))
		       top_neigh(i,j,6) = (i1*dx-(dx/2)) + dx*((top_neigh(i,j,8)-ibm_ht(i1,j)) &
	                                		 /(ibm_ht(i2,j)-ibm_ht(i1,j)))
	            else
		       top_neigh(i,j,3) = (i1*dx) + (dx/2)*((top_neigh(i,j,5)-ibm_ht_stag(i2,j)) &
	                                		  /(ibm_ht(i2,j)-ibm_ht_stag(i2,j)))
		       top_neigh(i,j,6) = (i1*dx) + (dx/2)*((top_neigh(i,j,8)-ibm_ht_stag(i2,j)) &
	                                		  /(ibm_ht(i2,j)-ibm_ht_stag(i2,j)))
		    endif	    	    
		endif					   
 		! fourth point at node
        	nC=3
		if (stag == 1) then
		    top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx)
		    top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)
		elseif (stag == 2) then
		    top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
		    top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy)	       
		elseif (stag == 3) then
		    top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
		    top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)	       
		endif
		top_neigh(i,j,3*nC+2) = ht_p(top_neigh_i(i,j,3*nC),top_neigh_i(i,j,3*nC+2),j)
	    elseif (k2 == top(i2,j)) then !if (i2,k2) is also a top ghost point
	        ! print '((A),1i5,(A),1i5,(A),2i5)','stag =',stag,' bc type =', bc_type,' top with 0111 at ',i,j
		! if (i2,j,k2) is a top ghost point then regardless of boundary condition
	        ! (i1,j,k1) is the first neighbor (the zero computational node)
	        ! (i2,j,k2+1) is the second neigbor (a computational node)
	        ! (i2,j,ht) is the third neighbor (boundary)
	        ! and (i1,j,ht) is the fourth neighbor (boundary
		top_neigh_i(i,j,0) = i1
		top_neigh_i(i,j,1) = j
		top_neigh_i(i,j,2) = k1
		top_neigh_i(i,j,3) = i2
		top_neigh_i(i,j,4) = j
		top_neigh_i(i,j,5) = k2+1
		top_neigh_i(i,j,6) = i2
		top_neigh_i(i,j,7) = j
		top_neigh_i(i,j,8) = 0
		top_neigh_i(i,j,9) = i1
		top_neigh_i(i,j,10) = j
		top_neigh_i(i,j,11) = 0
		DO nC=0,1  		  
		   if (stag ==1 ) then	  		  
		       top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx)
		       top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)
		   elseif (stag == 2) then
		       top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
		       top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy)	       
		   elseif (stag == 3) then
		       top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
		       top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)	       
		   endif
		   top_neigh(i,j,3*nC+2) = ht_p(top_neigh_i(i,j,3*nC),top_neigh_i(i,j,3*nC+2),j)
        	ENDDO
		!the third and fourth point are on the boundary at (i1,ht) and (i2,ht)
		DO nC=2,3  		  
		   if (stag ==1 ) then	  		  
		       top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx)
		       top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)
		   elseif (stag == 2) then
		       top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
		       top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy)	       
		   elseif (stag == 3) then
		       top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
		       top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)	       
		   endif
		   top_neigh(i,j,3*nC+2) = ibm_ht(top_neigh_i(i,j,3*nC),top_neigh_i(i,j,3*nC+1))
        	ENDDO
	    else ! if (i1,j,k1) is not a top ghost point then the alorithm is more complicated 
	        ! print '((A),1i5,(A),1i5,(A),2i5)','stag =',stag,' bc type =', bc_type,' not top with 0111 at ',i,j		
		! first point is on a node (the node marked zero)
		top_neigh_i(i,j,0) = i1
		top_neigh_i(i,j,1) = j
		top_neigh_i(i,j,2) = k1	    	    	    
		nC=0	  		  
		if (stag ==1 ) then	  		  
		    top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx)
		    top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)
		elseif (stag == 2) then
		    top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
		    top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy)	       
		elseif (stag == 3) then
		    top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
		    top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)	       
		endif
		top_neigh(i,j,3*nC+2) = ht_p(top_neigh_i(i,j,3*nC),top_neigh_i(i,j,3*nC+2),j)
	        ! second point on the boundary, to the left of (i2,j,k2)
	        top_neigh_i(i,j,3) = 0
		top_neigh_i(i,j,4) = 0
		top_neigh_i(i,j,5) = 0
		! first z
		top_neigh(i,j,5) = ht_p(i2,k2,j)
		if (stag == 1) then
		    !next y
		    top_neigh(i,j,4) = (j*dy)-(dy/2)
		    ! solve for x
		    if (ibm_ht_stag(i1,j) >= ht_p(i2,k2,j)) then
		       top_neigh(i,j,3) = (i1*dx-dx) + (dx/2)*((top_neigh(i,j,5)-ibm_ht(i1,j)) &
	                               	              /(ibm_ht_stag(i1,j)-ibm_ht(i1,j)))
                    !elseif (ibm_ht_stag(i1,j) > ht_p(i2,k2-1,j)) then
		    !   top_neigh(i,j,3) = (i1*dx-dx) + dx*((top_neigh(i,j,5)-ibm_ht(i1,j)) &
	            !                        	     /(ibm_ht(i2,j)-ibm_ht(i1,j)))
	            else
		       top_neigh(i,j,3) = (i1*dx-(dx/2)) + (dx/2)*((top_neigh(i,j,5)-ibm_ht_stag(i1,j)) &
	                                		  /(ibm_ht(i2,j)-ibm_ht_stag(i1,j)))
		    endif						   
		elseif (stag == 2) then
		    !next y
		    top_neigh(i,j,4) = (j*dy)-(dy)
		    ! solve for x
	            if (ibm_ht_stag(i2,j) >= ht_p(i2,k2,j)) then
		       top_neigh(i,j,3) = (i1*dx-(dx/2)) + (dx/2)*((top_neigh(i,j,5)-ibm_ht(i1,j)) &
	                               	              /(ibm_ht_stag(i2,j)-ibm_ht(i1,j)))
                    !elseif (ibm_ht_stag(i2,j) > ht_p(i2,k2-1,j)) then
		    !   top_neigh(i,j,3) = (i1*dx-(dx/2)) + dx*((top_neigh(i,j,5)-ibm_ht(i1,j)) &
	            !                        	     /(ibm_ht(i2,j)-ibm_ht(i1,j)))
	            else
		       top_neigh(i,j,3) = (i1*dx) + (dx/2)*((top_neigh(i,j,5)-ibm_ht_stag(i2,j)) &
	                                		  /(ibm_ht(i2,j)-ibm_ht_stag(i2,j)))
		    endif	    
		elseif (stag == 3) then
		    !next y
		    top_neigh(i,j,4) = (j*dy)-(dy/2)
		    ! solve for x
	            if (ibm_ht_stag(i2,j) >= ht_p(i2,k2,j)) then
		       top_neigh(i,j,3) = (i1*dx-(dx/2)) + (dx/2)*((top_neigh(i,j,5)-ibm_ht(i1,j)) &
	                               	              /(ibm_ht_stag(i2,j)-ibm_ht(i1,j)))
                    !elseif (ibm_ht_stag(i2,j) > ht_p(i2,k2-1,j)) then
		    !   top_neigh(i,j,3) = (i1*dx-(dx/2)) + dx*((top_neigh(i,j,5)-ibm_ht(i1,j)) &
	            !                        	     /(ibm_ht(i2,j)-ibm_ht(i1,j)))
	            else
		       top_neigh(i,j,3) = (i1*dx) + (dx/2)*((top_neigh(i,j,5)-ibm_ht_stag(i2,j)) &
	                                		  /(ibm_ht(i2,j)-ibm_ht_stag(i2,j)))
		    endif	    	    
		endif
	        ! third point on the boundary at (x1,ht)
	        top_neigh_i(i,j,6) = i1
		top_neigh_i(i,j,7) = j
		top_neigh_i(i,j,8) = 0
		nC=2		  
		if (stag ==1 ) then	  		  
		    top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx)
		    top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)
		elseif (stag == 2) then
		    top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
		    top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy)	       
		elseif (stag == 3) then
		    top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
		    top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)	       
		endif
		top_neigh(i,j,3*nC+2) = ibm_ht(top_neigh_i(i,j,3*nC),top_neigh_i(i,j,3*nC+1))	    
                ! fourth point can be a boundary point if Dirchlet, 
		! otherwise for Neumann it must be a node because there are already 2 boundary points
		if (bc_type == 1) then
		   ! fourth point can be the normal boundary point, or
		   ! if third point is normal bp then look right of the image point. 
	           top_neigh_i(i,j,9) = 0
		   top_neigh_i(i,j,10) = 0
		   top_neigh_i(i,j,11) = 0
		   if (top_bound(i,j,1) == top_img(i,j,4)) then         
		       ! first z
		       top_neigh(i,j,11) = top_img(i,j,6)
		       if (stag == 1) then
			   !next y
			   top_neigh(i,j,10) = (j*dy)-(dy/2)
			   ! solve for x
			   if (ibm_ht_stag(i1,j) >= ht_p(i2,k2,j)) then
			      top_neigh(i,j,9) = (i1*dx-dx) + (dx/2)*((top_neigh(i,j,11)-ibm_ht(i1,j)) &
	                               	        	     /(ibm_ht_stag(i1,j)-ibm_ht(i1,j)))
                	   !elseif (ibm_ht_stag(i1,j) > ht_p(i2,k2-1,j)) then
			   !   top_neigh(i,j,9) = (i1*dx-dx) + dx*((top_neigh(i,j,11)-ibm_ht(i1,j)) &
	        	   !                    		 /(ibm_ht(i2,j)-ibm_ht(i1,j)))
	        	   else
			      top_neigh(i,j,9) = (i1*dx-(dx/2)) + (dx/2)*((top_neigh(i,j,11)-ibm_ht_stag(i1,j)) &
	                                			 /(ibm_ht(i2,j)-ibm_ht_stag(i1,j)))
			   endif						   
		       elseif (stag == 2) then
			   !next y
			   top_neigh(i,j,10) = (j*dy)-(dy)
			   ! solve for x
	        	   if (ibm_ht_stag(i2,j) >= ht_p(i2,k2,j)) then
			      top_neigh(i,j,9) = (i1*dx-(dx/2)) + (dx/2)*((top_neigh(i,j,11)-ibm_ht(i1,j)) &
	                               	        	     /(ibm_ht_stag(i2,j)-ibm_ht(i1,j)))
                	   !elseif (ibm_ht_stag(i2,j) > ht_p(i2,k2-1,j)) then
			   !   top_neigh(i,j,9) = (i1*dx-(dx/2)) + dx*((top_neigh(i,j,11)-ibm_ht(i1,j)) &
	        	   !                    		 /(ibm_ht(i2,j)-ibm_ht(i1,j)))
	        	   else
			      top_neigh(i,j,9) = (i1*dx) + (dx/2)*((top_neigh(i,j,11)-ibm_ht_stag(i2,j)) &
	                                			 /(ibm_ht(i2,j)-ibm_ht_stag(i2,j)))
			   endif	    
		       elseif (stag == 3) then
			   !next y
			   top_neigh(i,j,10) = (j*dy)-(dy/2)
			   ! solve for x
	        	   if (ibm_ht_stag(i2,j) >= ht_p(i2,k2,j)) then
			      top_neigh(i,j,9) = (i1*dx-(dx/2)) + (dx/2)*((top_neigh(i,j,11)-ibm_ht(i1,j)) &
	                               	        	     /(ibm_ht_stag(i2,j)-ibm_ht(i1,j)))
                	   !elseif (ibm_ht_stag(i2,j) > ht_p(i2,k2-1,j)) then
			   !   top_neigh(i,j,9) = (i1*dx-(dx/2)) + dx*((top_neigh(i,j,11)-ibm_ht(i1,j)) &
	        	   !                    		 /(ibm_ht(i2,j)-ibm_ht(i1,j)))
	        	   else
			      top_neigh(i,j,9) = (i1*dx) + (dx/2)*((top_neigh(i,j,11)-ibm_ht_stag(i2,j)) &
	                                			 /(ibm_ht(i2,j)-ibm_ht_stag(i2,j)))
			   endif	    	    
		       endif
		   else
		       ! fourth point is normal boundary point
  		       top_neigh(i,j,9) = top_bound(i,j,1)
		       top_neigh(i,j,10) = top_bound(i,j,2)
		       top_neigh(i,j,11) = top_bound(i,j,3)
        	   endif
                elseif (bc_type == 2) then
		      if (k1+1 > top(i1-1,j)) then	
		      ! fourth point is on a node (above and to the left of the node marked zero)
		      top_neigh_i(i,j,9) = i1-1
		      top_neigh_i(i,j,10) = j
		      top_neigh_i(i,j,11) = k1+1		   
		      nC=3		 
		      if (stag ==1 ) then			 
			  top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx)
			  top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)
		      elseif (stag == 2) then
			  top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
			  top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy)	      
		      elseif (stag == 3) then
			  top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
			  top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)        
		      endif
		      top_neigh(i,j,3*nC+2) = ht_p(top_neigh_i(i,j,3*nC),top_neigh_i(i,j,3*nC+2),j)
		   else
		      print *, 'neighbors not assigned for Neumann 0111 at ',i,j
		   endif		
	        endif ! end of bc_type is 1 or 2   
           endif !  (k1 < k2)  or (i2,j,k2) is / is not a top ghost point
       else
	    print('((A),1i5,(A),1i5,(A),5i4)'), 'there are top neighbors not assigned at i=',i,'j=',j, 'for stag =', stag, inside(i1,k1  ,j) ,inside(i2,k2  ,j), inside(i2,k2-1,j), inside(i1,k1-1,j) 
	    !CALL wrf_error_fatal ('top: the neighbors are not assigned') 
       endif 
       !write(0,'((A),1i5,(A),1i5,(A),5i4, 12f16.8,7i4)')'i=',i,'j=',j,'for stag =', stag, inside(i1,k1,j),inside(i2,k2,j),inside(i2,k2-1,j),inside(i1,k1-1,j), &
       !top_img(i,j,1:6),ibm_ht(i1,j), ht_p(i1,k1,j),ht_p(i1,k1-1,j), ibm_ht(i2,j),ht_p(i2,k2,j),ht_p(i2,k2-1,j),i1,k1,i2,k2,top(i1,j),top(i2,j),prox(i,j)
   ENDDO
   ENDDO  


   !make the image coord the origin (x,y,z,)=(0,0,0)
   DO i=its,ite
   DO j=jts,jte
   DO nC=0,3
      top_neigh(i,j,3*nC) = top_neigh(i,j,3*nC)-top_img(i,j,4)
      top_neigh(i,j,3*nC+1) = top_neigh(i,j,3*nC+1)-top_img(i,j,5)
      top_neigh(i,j,3*nC+2) = top_neigh(i,j,3*nC+2)-top_img(i,j,6)	
   ENDDO
   ENDDO
   ENDDO  

   ! make the ghost point coord the origin (x,y,z,)=(0,0,0)
   !DO i=its,ite
   !DO j=jts,jte
   !DO nC=0,3
   !   top_neigh(i,j,3*nC) = top_neigh(i,j,3*nC)-top_img(i,j,1)
   !   top_neigh(i,j,3*nC+1) = top_neigh(i,j,3*nC+1)-top_img(i,j,2)
   !   top_neigh(i,j,3*nC+2) = top_neigh(i,j,3*nC+2)-top_img(i,j,3)     
   !ENDDO
   !ENDDO
   !ENDDO 
  

 END SUBROUTINE get_top_pts_2d
  	    
!--------------------------------------------------------------------------------

 SUBROUTINE get_side_pts_2d ( stag, bc_type,                &
                              dx, dy, ibm_ht,               &
                              ibm_ht_stag,                  &
                              ht_p,                         &
			      inside,                       &
			      side, side_img, side_bound,   &
			      side_neigh, side_neigh_i,     &
			      n, np,                        &
			      ids, ide, jds, jde, kds, kde, &
                              ims, ime, jms, jme, kms, kme, &
                              its, ite, jts, jte, kts, kte)
  IMPLICIT NONE
 ! input data 
  INTEGER, INTENT(IN   )                                    :: stag,       &
                                                               bc_type 
  REAL, INTENT(IN   )                                       :: dx,dy
  REAL, DIMENSION(ims:ime,jms:jme), INTENT(IN   )           :: ibm_ht,     &
                                                               ibm_ht_stag     ! 
  REAL, DIMENSION(ims:ime,kms:kme,jms:jme), INTENT(IN   )   :: ht_p  			     
  INTEGER, DIMENSION(ims:ime,kms:kme,jms:jme), INTENT(IN  ) :: inside          ! one if the pt is inside boundary, zero if it is outside
  INTEGER, DIMENSION(3,np), INTENT(IN   )                   :: side            !'side boundary' ghost points							      
  REAL, DIMENSION(6,np), INTENT(IN   )                      :: side_img        ! (x,y,z) location of ghost point and image point of the 'side boundary' ghost points 
  REAL, DIMENSION(3,np), INTENT(IN   )                      :: side_bound      ! (x,y,z) location of the boundary for side points
  REAL, DIMENSION(0:3*n-1,np), INTENT(  OUT)                :: side_neigh      ! (x,y,z) location of neighbors
  INTEGER, DIMENSION(0:3*n-1,np), INTENT(  OUT)             :: side_neigh_i    ! (i,j,k) location of neighbors
  INTEGER, INTENT(IN   )                                    :: n,           &  ! desired number of nearest neighbors
                                                               np              ! number of side ghost points
  INTEGER, INTENT(IN   )                   :: ids, ide, jds, jde, kds, kde, &  ! d: domain m:memory p:patch t:tile
                                              ims, ime, jms, jme, kms, kme, &
                                              its, ite, jts, jte, kts, kte		   

 !local data
  INTEGER                                                   :: j,           &
                                                               S,nC,        &
							       i1,i2,       &
							       k1,k2

!-----------------------------------------------------------------------------------
! the executable begins here
! this subroutine stores the (i,j,k) index and (x,y,z) location of the four 
! neighbors of a side image point.
! numbering order is 01
!                    32
 CALL wrf_debug(100,'dyn_em/module_ibm.F/subroutine get_side_pts_2d')
!------------------------------------------------------------------------------------
! initalize the arrays
side_neigh = 0.
side_neigh_i = 0

   DO S=1,np
       IF (bc_type == 1) THEN
	  ! find neighbors of image point
	  if (stag == 1) then
	      i1 = ceiling(side_img(4,S)/dx)
	      i2 = ceiling(side_img(4,S)/dx)+1
	      if ((MOD(side_img(4,S),dx)==0).AND.(ibm_ht_stag(side(1,S)-1,side(2,S))>ibm_ht_stag(side(1,S),side(2,S)))) then
		  i1 = i1+1
		  i2 = i2+1
	      endif
	  elseif ((stag == 2).OR.(stag == 3)) then
	      i1 = ceiling((side_img(4,S)-(dx/2))/dx)
	      i2 = ceiling((side_img(4,S)-(dx/2))/dx)+1
	      if ((MOD(side_img(4,S)-(dx/2),dx)==0).AND.(ibm_ht_stag(side(1,S),side(2,S))>ibm_ht_stag(side(1,S)+1,side(2,S)))) then
		  i1 = i1+1
		  i2 = i2+1
	      endif
	  endif       
	  j = side(2,S)
	  k1 = side(3,S)-1
	  k2 = side(3,S)-1
	  do while (side_img(6,S) >= ht_p(i1,k1,j))
              k1=k1+1
	  enddo  
	  do while (side_img(6,S) >= ht_p(i2,k2,j))
              k2=k2+1
	  enddo  
       ELSEIF (bc_type == 2) THEN  
	  ! find neighbors of the boundary point
	  if (stag == 1) then
	      i1 = ceiling(side_bound(1,S)/dx)
	      i2 = ceiling(side_bound(1,S)/dx)+1
	      if ((MOD(side_bound(1,S),dx)==0).AND.(ibm_ht_stag(side(1,S)-1,side(2,S))>ibm_ht_stag(side(1,S),side(2,S)))) then
		  i1 = i1+1
		  i2 = i2+1
	      endif
	  elseif ((stag == 2).OR.(stag == 3)) then
	      i1 = ceiling((side_bound(1,S)-(dx/2))/dx)
	      i2 = ceiling((side_bound(1,S)-(dx/2))/dx)+1
	      if ((MOD(side_bound(1,S)-(dx/2),dx)==0).AND.(ibm_ht_stag(side(1,S),side(2,S))>ibm_ht_stag(side(1,S)+1,side(2,S)))) then
		  i1 = i1+1
		  i2 = i2+1
	      endif
	  endif       
	  j = side(2,S)
	  k1 = side(3,S)-1
	  k2 = side(3,S)-1
	  do while (side_bound(3,S) >= ht_p(i1,k1,j))
              k1=k1+1
	  enddo  
	  do while (side_bound(3,S) >= ht_p(i2,k2,j))
              k2=k2+1
	  enddo 
       ENDIF 
       if ((inside(i1,k1  ,j) == 0).AND. &
           (inside(i2,k2  ,j) == 0).AND. &
	   (inside(i2,k2-1,j) == 0).AND. &
	   (inside(i1,k1-1,j) == 0)) then
	    side_neigh_i(0,S) = i1
	    side_neigh_i(1,S) = j
	    side_neigh_i(2,S) = k1
	    side_neigh_i(3,S) = i2
	    side_neigh_i(4,S) = j
	    side_neigh_i(5,S) = k2
	    side_neigh_i(6,S) = i2
	    side_neigh_i(7,S) = j
	    side_neigh_i(8,S) = k2-1
	    side_neigh_i(9,S) = i1
	    side_neigh_i(10,S) = j
	    side_neigh_i(11,S) = k1-1     
	    DO nC=0,3
	       if (stag == 1) then
		   side_neigh(3*nC,S) = (side_neigh_i(3*nC,S)*dx)-(dx)
		   side_neigh(3*nC+1,S) = (side_neigh_i(3*nC+1,S)*dy)-(dy/2)
	       elseif (stag == 2) then
		   side_neigh(3*nC,S) = (side_neigh_i(3*nC,S)*dx)-(dx/2)
		   side_neigh(3*nC+1,S) = (side_neigh_i(3*nC+1,S)*dy)-(dy)	       
	       elseif (stag == 3) then
		   side_neigh(3*nC,S) = (side_neigh_i(3*nC,S)*dx)-(dx/2)
		   side_neigh(3*nC+1,S) = (side_neigh_i(3*nC+1,S)*dy)-(dy/2)	       
	       endif
	       side_neigh(3*nC+2,S) = ht_p(side_neigh_i(3*nC,S),side_neigh_i(3*nC+2,S),j)		  
	    ENDDO      
       elseif ((inside(i1,k1  ,j) == 0).AND. &
           (inside(i2,k2  ,j) == 0).AND. &
	   (inside(i2,k2-1,j) == 0).AND. &
	   (inside(i1,k1-1,j) == 1)) then
	    side_neigh_i(0,S) = i1
	    side_neigh_i(1,S) = j
	    side_neigh_i(2,S) = k1
	    side_neigh_i(3,S) = i2
	    side_neigh_i(4,S) = j
	    side_neigh_i(5,S) = k2
	    side_neigh_i(6,S) = i2
	    side_neigh_i(7,S) = j
	    side_neigh_i(8,S) = k2-1
	    side_neigh_i(9,S) = 0
	    side_neigh_i(10,S) = 0
	    side_neigh_i(11,S) = 0
	    DO nC=0,2
	       if (stag == 1) then
		   side_neigh(3*nC,S) = (side_neigh_i(3*nC,S)*dx)-(dx)
		   side_neigh(3*nC+1,S) = (side_neigh_i(3*nC+1,S)*dy)-(dy/2)
	       elseif (stag == 2) then
		   side_neigh(3*nC,S) = (side_neigh_i(3*nC,S)*dx)-(dx/2)
		   side_neigh(3*nC+1,S) = (side_neigh_i(3*nC+1,S)*dy)-(dy)	       
	       elseif (stag == 3) then
		   side_neigh(3*nC,S) = (side_neigh_i(3*nC,S)*dx)-(dx/2)
		   side_neigh(3*nC+1,S) = (side_neigh_i(3*nC+1,S)*dy)-(dy/2)	       
	       endif
	       side_neigh(3*nC+2,S) = ht_p(side_neigh_i(3*nC,S),side_neigh_i(3*nC+2,S),j)		  
	    ENDDO 
	    side_neigh(9,S) = side_bound(1,S)
	    side_neigh(10,S) = side_bound(2,S)
	    side_neigh(11,S) = side_bound(3,S)    
       elseif ((inside(i1,k1  ,j) == 0).AND. &
           (inside(i2,k2  ,j) == 0).AND. &
	   (inside(i2,k2-1,j) == 1).AND. &
	   (inside(i1,k1-1,j) == 0)) then
	    side_neigh_i(0,S) = i1
	    side_neigh_i(1,S) = j
	    side_neigh_i(2,S) = k1
	    side_neigh_i(3,S) = i2
	    side_neigh_i(4,S) = j
	    side_neigh_i(5,S) = k2
	    side_neigh_i(6,S) = 0
	    side_neigh_i(7,S) = 0
	    side_neigh_i(8,S) = 0
	    side_neigh_i(9,S) = i1
	    side_neigh_i(10,S) = j
	    side_neigh_i(11,S) = k1-1     
	    DO nC=0,1
	       if (stag == 1) then
		   side_neigh(3*nC,S) = (side_neigh_i(3*nC,S)*dx)-(dx)
		   side_neigh(3*nC+1,S) = (side_neigh_i(3*nC+1,S)*dy)-(dy/2)
	       elseif (stag == 2) then
		   side_neigh(3*nC,S) = (side_neigh_i(3*nC,S)*dx)-(dx/2)
		   side_neigh(3*nC+1,S) = (side_neigh_i(3*nC+1,S)*dy)-(dy)	       
	       elseif (stag == 3) then
		   side_neigh(3*nC,S) = (side_neigh_i(3*nC,S)*dx)-(dx/2)
		   side_neigh(3*nC+1,S) = (side_neigh_i(3*nC+1,S)*dy)-(dy/2)	       
	       endif
	       side_neigh(3*nC+2,S) = ht_p(side_neigh_i(3*nC,S),side_neigh_i(3*nC+2,S),j)		  
	    ENDDO 
	    side_neigh(6,S) = side_bound(1,S)
	    side_neigh(7,S) = side_bound(2,S)
	    side_neigh(8,S) = side_bound(3,S) 
	    nC=3
	       if (stag == 1) then
		   side_neigh(3*nC,S) = (side_neigh_i(3*nC,S)*dx)-(dx)
		   side_neigh(3*nC+1,S) = (side_neigh_i(3*nC+1,S)*dy)-(dy/2)
	       elseif (stag == 2) then
		   side_neigh(3*nC,S) = (side_neigh_i(3*nC,S)*dx)-(dx/2)
		   side_neigh(3*nC+1,S) = (side_neigh_i(3*nC+1,S)*dy)-(dy)	       
	       elseif (stag == 3) then
		   side_neigh(3*nC,S) = (side_neigh_i(3*nC,S)*dx)-(dx/2)
		   side_neigh(3*nC+1,S) = (side_neigh_i(3*nC+1,S)*dy)-(dy/2)	       
	       endif
	    side_neigh(3*nC+2,S) = ht_p(side_neigh_i(3*nC,S),side_neigh_i(3*nC+2,S),j)		  
       elseif ((inside(i1,k1  ,j) == 0).AND. &
           (inside(i2,k2  ,j) == 1).AND. &
	   (inside(i2,k2-1,j) == 1).AND. &
	   (inside(i1,k1-1,j) == 0)) then
	    side_neigh_i(0,S) = i1
	    side_neigh_i(1,S) = j
	    side_neigh_i(2,S) = k1
	    side_neigh_i(3,S) = 0
	    side_neigh_i(4,S) = 0
	    side_neigh_i(5,S) = 0
	    side_neigh_i(6,S) = 0
	    side_neigh_i(7,S) = 0
	    side_neigh_i(8,S) = 0
	    side_neigh_i(9,S) = i1
	    side_neigh_i(10,S) = j
	    side_neigh_i(11,S) = k1-1     
	    nC=0
	       if (stag == 1) then
		   side_neigh(3*nC,S) = (side_neigh_i(3*nC,S)*dx)-(dx)
		   side_neigh(3*nC+1,S) = (side_neigh_i(3*nC+1,S)*dy)-(dy/2)
	       elseif (stag == 2) then
		   side_neigh(3*nC,S) = (side_neigh_i(3*nC,S)*dx)-(dx/2)
		   side_neigh(3*nC+1,S) = (side_neigh_i(3*nC+1,S)*dy)-(dy)	       
	       elseif (stag == 3) then
		   side_neigh(3*nC,S) = (side_neigh_i(3*nC,S)*dx)-(dx/2)
		   side_neigh(3*nC+1,S) = (side_neigh_i(3*nC+1,S)*dy)-(dy/2)	       
	       endif
	    side_neigh(3*nC+2,S) = ht_p(side_neigh_i(3*nC,S),side_neigh_i(3*nC+2,S),j)
	    ! fill in the next two points on the wall          
	    ! first z
	    side_neigh(5,S) = ht_p(i2,k2,j)
	    side_neigh(8,S) = ht_p(i2,k2-1,j)
	    if (stag == 1) then
		!next y
		side_neigh(4,S) = (j*dy)-(dy/2)
		side_neigh(7,S) = (j*dy)-(dy/2)
		! solve for x
		if (ibm_ht_stag(i1,j) >= ht_p(i2,k2,j)) then
		   side_neigh(3,S) = (i1*dx-dx) + (dx/2)*((side_neigh(5,S)-ibm_ht(i1,j)) &
	                               	          /(ibm_ht_stag(i1,j)-ibm_ht(i1,j)))
		   side_neigh(6,S) = (i1*dx-dx) + (dx/2)*((side_neigh(8,S)-ibm_ht(i1,j)) &
	                                          /(ibm_ht_stag(i1,j)-ibm_ht(i1,j)))
                elseif (ibm_ht_stag(i1,j) > ht_p(i2,k2-1,j)) then
		   side_neigh(3,S) = (i1*dx-dx) + dx*((side_neigh(5,S)-ibm_ht(i1,j)) &
	                                	     /(ibm_ht(i2,j)-ibm_ht(i1,j)))
		   side_neigh(6,S) = (i1*dx-dx) + dx*((side_neigh(8,S)-ibm_ht(i1,j)) &
	                                	     /(ibm_ht(i2,j)-ibm_ht(i1,j)))
	        else
		   side_neigh(3,S) = (i1*dx-(dx/2)) + (dx/2)*((side_neigh(5,S)-ibm_ht_stag(i1,j)) &
	                                	      /(ibm_ht(i2,j)-ibm_ht_stag(i1,j)))
		   side_neigh(6,S) = (i1*dx-(dx/2)) + (dx/2)*((side_neigh(8,S)-ibm_ht_stag(i1,j)) &
	                                	      /(ibm_ht(i2,j)-ibm_ht_stag(i1,j)))
		endif						   
	    elseif (stag == 2) then
		!next y
		side_neigh(4,S) = (j*dy)-(dy)
		side_neigh(7,S) = (j*dy)-(dy)
		! solve for x
	        if (ibm_ht_stag(i2,j) >= ht_p(i2,k2,j)) then
		   side_neigh(3,S) = (i1*dx-(dx/2)) + (dx/2)*((side_neigh(5,S)-ibm_ht(i1,j)) &
	                               	          /(ibm_ht_stag(i2,j)-ibm_ht(i1,j)))
		   side_neigh(6,S) = (i1*dx-(dx/2)) + (dx/2)*((side_neigh(8,S)-ibm_ht(i1,j)) &
	                                          /(ibm_ht_stag(i2,j)-ibm_ht(i1,j)))
                elseif (ibm_ht_stag(i2,j) > ht_p(i2,k2-1,j)) then
		   side_neigh(3,S) = (i1*dx-(dx/2)) + dx*((side_neigh(5,S)-ibm_ht(i1,j)) &
	                                	     /(ibm_ht(i2,j)-ibm_ht(i1,j)))
		   side_neigh(6,S) = (i1*dx-(dx/2)) + dx*((side_neigh(8,S)-ibm_ht(i1,j)) &
	                                	     /(ibm_ht(i2,j)-ibm_ht(i1,j)))
	        else
		   side_neigh(3,S) = (i1*dx) + (dx/2)*((side_neigh(5,S)-ibm_ht_stag(i2,j)) &
	                                	      /(ibm_ht(i2,j)-ibm_ht_stag(i2,j)))
		   side_neigh(6,S) = (i1*dx) + (dx/2)*((side_neigh(8,S)-ibm_ht_stag(i2,j)) &
	                                	      /(ibm_ht(i2,j)-ibm_ht_stag(i2,j)))
		endif	    
	    elseif (stag == 3) then
		!next y
		side_neigh(4,S) = (j*dy)-(dy/2)
		side_neigh(7,S) = (j*dy)-(dy/2)
		! solve for x
	        if (ibm_ht_stag(i2,j) >= ht_p(i2,k2,j)) then
		   side_neigh(3,S) = (i1*dx-(dx/2)) + (dx/2)*((side_neigh(5,S)-ibm_ht(i1,j)) &
	                               	          /(ibm_ht_stag(i2,j)-ibm_ht(i1,j)))
		   side_neigh(6,S) = (i1*dx-(dx/2)) + (dx/2)*((side_neigh(8,S)-ibm_ht(i1,j)) &
	                                          /(ibm_ht_stag(i2,j)-ibm_ht(i1,j)))
                elseif (ibm_ht_stag(i2,j) > ht_p(i2,k2-1,j)) then
		   side_neigh(3,S) = (i1*dx-(dx/2)) + dx*((side_neigh(5,S)-ibm_ht(i1,j)) &
	                                	     /(ibm_ht(i2,j)-ibm_ht(i1,j)))
		   side_neigh(6,S) = (i1*dx-(dx/2)) + dx*((side_neigh(8,S)-ibm_ht(i1,j)) &
	                                	     /(ibm_ht(i2,j)-ibm_ht(i1,j)))
	        else
		   side_neigh(3,S) = (i1*dx) + (dx/2)*((side_neigh(5,S)-ibm_ht_stag(i2,j)) &
	                                	      /(ibm_ht(i2,j)-ibm_ht_stag(i2,j)))
		   side_neigh(6,S) = (i1*dx) + (dx/2)*((side_neigh(8,S)-ibm_ht_stag(i2,j)) &
	                                	      /(ibm_ht(i2,j)-ibm_ht_stag(i2,j)))
		endif	    	    
	    endif					   
	    nC=3
	       if (stag == 1) then
		   side_neigh(3*nC,S) = (side_neigh_i(3*nC,S)*dx)-(dx)
		   side_neigh(3*nC+1,S) = (side_neigh_i(3*nC+1,S)*dy)-(dy/2)
	       elseif (stag == 2) then
		   side_neigh(3*nC,S) = (side_neigh_i(3*nC,S)*dx)-(dx/2)
		   side_neigh(3*nC+1,S) = (side_neigh_i(3*nC+1,S)*dy)-(dy)	       
	       elseif (stag == 3) then
		   side_neigh(3*nC,S) = (side_neigh_i(3*nC,S)*dx)-(dx/2)
		   side_neigh(3*nC+1,S) = (side_neigh_i(3*nC+1,S)*dy)-(dy/2)	       
	       endif
	    side_neigh(3*nC+2,S) = ht_p(side_neigh_i(3*nC,S),side_neigh_i(3*nC+2,S),j)
       elseif ((inside(i1,k1  ,j) == 1).AND. &
           (inside(i2,k2  ,j) == 0).AND. &
	   (inside(i2,k2-1,j) == 0).AND. &
	   (inside(i1,k1-1,j) == 1)) then
	    side_neigh_i(0,S) = 0
	    side_neigh_i(1,S) = 0
	    side_neigh_i(2,S) = 0
	    side_neigh_i(3,S) = i2
	    side_neigh_i(4,S) = j
	    side_neigh_i(5,S) = k2
	    side_neigh_i(6,S) = i2
	    side_neigh_i(7,S) = j
	    side_neigh_i(8,S) = k2-1
	    side_neigh_i(9,S) = 0
	    side_neigh_i(10,S) = 0
	    side_neigh_i(11,S) = 0   
            ! first z
	    side_neigh(2,S) = ht_p(i1,k1,j)
	    if (stag == 1) then
		!next y
		side_neigh(1,S) = (j*dy)-(dy/2)
		! solve for x
		if (ibm_ht_stag(i1,j) >= ht_p(i1,k1,j)) then
		    side_neigh(0,S) = (i1*dx-(dx/2)) + (dx/2)*((side_neigh(2,S)-ibm_ht_stag(i1,j)) &
	                                	              /(ibm_ht(i2,j)-ibm_ht_stag(i1,j)))
                elseif (ibm_ht_stag(i1,j) > ht_p(i1,k1-1,j)) then
		    side_neigh(0,S) = (i1*dx-dx) + dx*((side_neigh(2,S)-ibm_ht(i1,j)) &
	                                	      /(ibm_ht(i2,j)-ibm_ht(i1,j)))		 
		else
		    side_neigh(0,S) = (i1*dx-dx) + (dx/2)*((side_neigh(2,S)-ibm_ht(i1,j)) &
	                                	          /(ibm_ht_stag(i1,j)-ibm_ht(i1,j)))
		endif
	    elseif (stag == 2) then
	        !next y
		side_neigh(1,S) = (j*dy)-(dy)
		! solve for x
		if (ibm_ht_stag(i2,j) >= ht_p(i1,k1,j)) then
		    side_neigh(0,S) = (i1*dx) + (dx/2)*((side_neigh(2,S)-ibm_ht_stag(i2,j)) &
	                                	       /(ibm_ht(i2,j)-ibm_ht_stag(i2,j)))
                elseif (ibm_ht_stag(i2,j) > ht_p(i1,k1-1,j)) then
		    side_neigh(0,S) = (i1*dx-(dx/2)) + dx*((side_neigh(2,S)-ibm_ht(i1,j)) &
	                                	          /(ibm_ht(i2,j)-ibm_ht(i1,j)))		 
		else
		    side_neigh(0,S) = (i1*dx-(dx/2)) + (dx/2)*((side_neigh(2,S)-ibm_ht(i1,j)) &
	                                	              /(ibm_ht_stag(i2,j)-ibm_ht(i1,j)))
		endif
	    elseif (stag == 3) then
	        !next y
		side_neigh(1,S) = (j*dy)-(dy/2)
		! solve for x
		if (ibm_ht_stag(i2,j) >= ht_p(i1,k1,j)) then
		    side_neigh(0,S) = (i1*dx) + (dx/2)*((side_neigh(2,S)-ibm_ht_stag(i2,j)) &
	                                	       /(ibm_ht(i2,j)-ibm_ht_stag(i2,j)))
                elseif (ibm_ht_stag(i2,j) > ht_p(i1,k1-1,j)) then
		    side_neigh(0,S) = (i1*dx-(dx/2)) + dx*((side_neigh(2,S)-ibm_ht(i1,j)) &
	                                	          /(ibm_ht(i2,j)-ibm_ht(i1,j)))		 
		else
		    side_neigh(0,S) = (i1*dx-(dx/2)) + (dx/2)*((side_neigh(2,S)-ibm_ht(i1,j)) &
	                                	              /(ibm_ht_stag(i2,j)-ibm_ht(i1,j)))
		endif
	    endif
	    ! next two points are nodes					   
	    DO nC=1,2
	       if (stag == 1) then
		   side_neigh(3*nC,S) = (side_neigh_i(3*nC,S)*dx)-(dx)
		   side_neigh(3*nC+1,S) = (side_neigh_i(3*nC+1,S)*dy)-(dy/2)
	       elseif (stag == 2) then
		   side_neigh(3*nC,S) = (side_neigh_i(3*nC,S)*dx)-(dx/2)
		   side_neigh(3*nC+1,S) = (side_neigh_i(3*nC+1,S)*dy)-(dy)	       
	       elseif (stag == 3) then
		   side_neigh(3*nC,S) = (side_neigh_i(3*nC,S)*dx)-(dx/2)
		   side_neigh(3*nC+1,S) = (side_neigh_i(3*nC+1,S)*dy)-(dy/2)	       
	       endif
	       side_neigh(3*nC+2,S) = ht_p(side_neigh_i(3*nC,S),side_neigh_i(3*nC+2,S),j)
	    ENDDO
	    ! fourth point is on the boundary     
            ! first z
	    side_neigh(11,S) = ht_p(i1,k1-1,j)
	    if (stag == 1) then
		!next y
		side_neigh(10,S) = (j*dy)-(dy/2)
		! solve for x
		if (ibm_ht_stag(i1,j) >= ht_p(i1,k1,j)) then
		    side_neigh(9,S) = (i1*dx-(dx/2)) + (dx/2)*((side_neigh(11,S)-ibm_ht_stag(i1,j)) &
	                                	       /(ibm_ht(i2,j)-ibm_ht_stag(i1,j)))
                elseif (ibm_ht_stag(i1,j) > ht_p(i1,k1-1,j)) then
		    side_neigh(9,S) = (i1*dx-dx) + dx*((side_neigh(11,S)-ibm_ht(i1,j)) &
	                                	       /(ibm_ht(i2,j)-ibm_ht(i1,j)))		 
		else
		    side_neigh(9,S) = (i1*dx-dx) + (dx/2)*((side_neigh(11,S)-ibm_ht(i1,j)) &
	                                	   /(ibm_ht_stag(i1,j)-ibm_ht(i1,j)))
		endif				
	    elseif (stag == 2) then 
		!next y
		side_neigh(10,S) = (j*dy)-(dy)
		! solve for x
		if (ibm_ht_stag(i2,j) >= ht_p(i1,k1,j)) then
		    side_neigh(9,S) = (i1*dx) + (dx/2)*((side_neigh(11,S)-ibm_ht_stag(i2,j)) &
	                                	       /(ibm_ht(i2,j)-ibm_ht_stag(i2,j)))
                elseif (ibm_ht_stag(i2,j) > ht_p(i1,k1-1,j)) then
		    side_neigh(9,S) = (i1*dx-(dx/2)) + dx*((side_neigh(11,S)-ibm_ht(i1,j)) &
	                                	          /(ibm_ht(i2,j)-ibm_ht(i1,j)))		 
		else
		    side_neigh(9,S) = (i1*dx-(dx/2)) + (dx/2)*((side_neigh(11,S)-ibm_ht(i1,j)) &
	                                	              /(ibm_ht_stag(i2,j)-ibm_ht(i1,j)))
		endif	    
	    elseif (stag == 3) then 
		!next y
		side_neigh(10,S) = (j*dy)-(dy/2)
		! solve for x
		if (ibm_ht_stag(i2,j) >= ht_p(i1,k1,j)) then
		    side_neigh(9,S) = (i1*dx) + (dx/2)*((side_neigh(11,S)-ibm_ht_stag(i2,j)) &
	                                	       /(ibm_ht(i2,j)-ibm_ht_stag(i2,j)))
                elseif (ibm_ht_stag(i2,j) > ht_p(i1,k1-1,j)) then
		    side_neigh(9,S) = (i1*dx-(dx/2)) + dx*((side_neigh(11,S)-ibm_ht(i1,j)) &
	                                	          /(ibm_ht(i2,j)-ibm_ht(i1,j)))		 
		else
		    side_neigh(9,S) = (i1*dx-(dx/2)) + (dx/2)*((side_neigh(11,S)-ibm_ht(i1,j)) &
	                                	              /(ibm_ht_stag(i2,j)-ibm_ht(i1,j)))
		endif
	    endif
       elseif ((inside(i1,k1  ,j) == 1).AND. &
           (inside(i2,k2  ,j) == 0).AND. &
	   (inside(i2,k2-1,j) == 1).AND. &
	   (inside(i1,k1-1,j) == 1)) then
	    if (k2 < k1) then
	        print  '((A),1i5,(A),1i5,(A),1i5)','stag =',stag,' bc type =', bc_type,'k2 < k1 with 1011 at ',S
		! if (k2 < k1) then move k2 up one regardless of boundary condition, so now it is 1001
		side_neigh_i(0,S) = 0
		side_neigh_i(1,S) = 0
		side_neigh_i(2,S) = 0
		side_neigh_i(3,S) = i2
		side_neigh_i(4,S) = j
		side_neigh_i(5,S) = k2+1
		side_neigh_i(6,S) = i2
		side_neigh_i(7,S) = j
		side_neigh_i(8,S) = k2
		side_neigh_i(9,S) = 0
		side_neigh_i(10,S) = 0
		side_neigh_i(11,S) = 0   
		! first point on the boundary
        	! first z
		side_neigh(2,S) = ht_p(i1,k1,j)
		if (stag == 1) then
		    !next y
		    side_neigh(1,S) = (j*dy)-(dy/2)
		    ! solve for x
		    if (ibm_ht_stag(i1,j) >= ht_p(i1,k1,j)) then
			side_neigh(0,S) = (i1*dx-(dx/2)) + (dx/2)*((side_neigh(2,S)-ibm_ht_stag(i1,j)) &
	                                	        	  /(ibm_ht(i2,j)-ibm_ht_stag(i1,j)))
                    elseif (ibm_ht_stag(i1,j) > ht_p(i1,k1-1,j)) then
			side_neigh(0,S) = (i1*dx-dx) + dx*((side_neigh(2,S)-ibm_ht(i1,j)) &
	                                		  /(ibm_ht(i2,j)-ibm_ht(i1,j)))		 
		    else
			side_neigh(0,S) = (i1*dx-dx) + (dx/2)*((side_neigh(2,S)-ibm_ht(i1,j)) &
	                                	              /(ibm_ht_stag(i1,j)-ibm_ht(i1,j)))
		    endif
		elseif (stag == 2) then
	            !next y
		    side_neigh(1,S) = (j*dy)-(dy)
		    ! solve for x
	            if (ibm_ht_stag(i2,j) >= ht_p(i1,k1,j)) then
			side_neigh(0,S) = (i1*dx) + (dx/2)*((side_neigh(2,S)-ibm_ht_stag(i2,j)) &
	                                		   /(ibm_ht(i2,j)-ibm_ht_stag(i2,j)))
                    elseif (ibm_ht_stag(i2,j) > ht_p(i1,k1-1,j)) then
			side_neigh(0,S) = (i1*dx-(dx/2)) + dx*((side_neigh(2,S)-ibm_ht(i1,j)) &
	                                	              /(ibm_ht(i2,j)-ibm_ht(i1,j)))		 
		    else
			side_neigh(0,S) = (i1*dx-(dx/2)) + (dx/2)*((side_neigh(2,S)-ibm_ht(i1,j)) &
	                                	        	  /(ibm_ht_stag(i2,j)-ibm_ht(i1,j)))
		    endif
		elseif (stag == 3) then
	            !next y
		    side_neigh(1,S) = (j*dy)-(dy/2)
		    ! solve for x
	            if (ibm_ht_stag(i2,j) >= ht_p(i1,k1,j)) then
			side_neigh(0,S) = (i1*dx) + (dx/2)*((side_neigh(2,S)-ibm_ht_stag(i2,j)) &
	                                		   /(ibm_ht(i2,j)-ibm_ht_stag(i2,j)))
                    elseif (ibm_ht_stag(i2,j) > ht_p(i1,k1-1,j)) then
			side_neigh(0,S) = (i1*dx-(dx/2)) + dx*((side_neigh(2,S)-ibm_ht(i1,j)) &
	                                	              /(ibm_ht(i2,j)-ibm_ht(i1,j)))		 
		    else
			side_neigh(0,S) = (i1*dx-(dx/2)) + (dx/2)*((side_neigh(2,S)-ibm_ht(i1,j)) &
	                                	        	  /(ibm_ht_stag(i2,j)-ibm_ht(i1,j)))
		    endif
		endif
		! next two points are nodes 					   
		DO nC=1,2
		   if (stag == 1) then
		       side_neigh(3*nC,S) = (side_neigh_i(3*nC,S)*dx)-(dx)
		       side_neigh(3*nC+1,S) = (side_neigh_i(3*nC+1,S)*dy)-(dy/2)
		   elseif (stag == 2) then
		       side_neigh(3*nC,S) = (side_neigh_i(3*nC,S)*dx)-(dx/2)
		       side_neigh(3*nC+1,S) = (side_neigh_i(3*nC+1,S)*dy)-(dy)	       
		   elseif (stag == 3) then
		       side_neigh(3*nC,S) = (side_neigh_i(3*nC,S)*dx)-(dx/2)
		       side_neigh(3*nC+1,S) = (side_neigh_i(3*nC+1,S)*dy)-(dy/2)	       
		   endif
		   side_neigh(3*nC+2,S) = ht_p(side_neigh_i(3*nC,S),side_neigh_i(3*nC+2,S),j)
		ENDDO  
		! fourth point is on the boundary     
        	! first z
		side_neigh(11,S) = ht_p(i1,k1-1,j)
		if (stag == 1) then
		    !next y
		    side_neigh(10,S) = (j*dy)-(dy/2)
		    ! solve for x
		    if (ibm_ht_stag(i1,j) >= ht_p(i1,k1,j)) then
			side_neigh(9,S) = (i1*dx-(dx/2)) + (dx/2)*((side_neigh(11,S)-ibm_ht_stag(i1,j)) &
	                                	        	  /(ibm_ht(i2,j)-ibm_ht_stag(i1,j)))
                    elseif (ibm_ht_stag(i1,j) > ht_p(i1,k1-1,j)) then
			side_neigh(9,S) = (i1*dx-dx) + dx*((side_neigh(11,S)-ibm_ht(i1,j)) &
	                                		  /(ibm_ht(i2,j)-ibm_ht(i1,j)))		 
		    else
			side_neigh(9,S) = (i1*dx-dx) + (dx/2)*((side_neigh(11,S)-ibm_ht(i1,j)) &
	                                	              /(ibm_ht_stag(i1,j)-ibm_ht(i1,j)))
		    endif
		elseif (stag == 2) then 
		    !next y
		    side_neigh(10,S) = (j*dy)-(dy)
		    ! solve for x
	            if (ibm_ht_stag(i2,j) >= ht_p(i1,k1,j)) then
			side_neigh(9,S) = (i1*dx) + (dx/2)*((side_neigh(11,S)-ibm_ht_stag(i2,j)) &
	                                		   /(ibm_ht(i2,j)-ibm_ht_stag(i2,j)))
                    elseif (ibm_ht_stag(i2,j) > ht_p(i1,k1-1,j)) then
			side_neigh(9,S) = (i1*dx-(dx/2)) + dx*((side_neigh(11,S)-ibm_ht(i1,j)) &
	                                	              /(ibm_ht(i2,j)-ibm_ht(i1,j)))		 
		    else
			side_neigh(9,S) = (i1*dx-(dx/2)) + (dx/2)*((side_neigh(11,S)-ibm_ht(i1,j)) &
	                                	        	  /(ibm_ht_stag(i2,j)-ibm_ht(i1,j)))
		    endif	    
		elseif (stag == 3) then 
		    !next y
		    side_neigh(10,S) = (j*dy)-(dy/2)
		    ! solve for x
	            if (ibm_ht_stag(i2,j) >= ht_p(i1,k1,j)) then
			side_neigh(9,S) = (i1*dx) + (dx/2)*((side_neigh(11,S)-ibm_ht_stag(i2,j)) &
	                                		   /(ibm_ht(i2,j)-ibm_ht_stag(i2,j)))
                    elseif (ibm_ht_stag(i2,j) > ht_p(i1,k1-1,j)) then
			side_neigh(9,S) = (i1*dx-(dx/2)) + dx*((side_neigh(11,S)-ibm_ht(i1,j)) &
	                                	              /(ibm_ht(i2,j)-ibm_ht(i1,j)))		 
		    else
			side_neigh(9,S) = (i1*dx-(dx/2)) + (dx/2)*((side_neigh(11,S)-ibm_ht(i1,j)) &
	                                	        	  /(ibm_ht_stag(i2,j)-ibm_ht(i1,j)))
		    endif
		endif 				    
	    else
	        print '((A),1i5,(A),1i5,(A),1i5)','stag =',stag,' bc type =', bc_type,' there are side neighbors not assigned for 1011 at S =',S
            endif ! (k2 < k1)
       elseif ((inside(i1,k1  ,j) == 0).AND. &
           (inside(i2,k2  ,j) == 1).AND. &
	   (inside(i2,k2-1,j) == 1).AND. &
	   (inside(i1,k1-1,j) == 1)) then
	    if (k1 < k2) then
	        print  '((A),1i5,(A),1i5,(A),1i5)','stag =',stag,' bc type =', bc_type,'k1 < k2 with 0111 at ',S
		! if (k1 < k2) then move k1 up one regardless of boundary condition, so now it is 0110
		side_neigh_i(0,S) = i1
		side_neigh_i(1,S) = j
		side_neigh_i(2,S) = k1+1
		side_neigh_i(3,S) = 0
		side_neigh_i(4,S) = 0
		side_neigh_i(5,S) = 0
		side_neigh_i(6,S) = 0
		side_neigh_i(7,S) = 0
		side_neigh_i(8,S) = 0
		side_neigh_i(9,S) = i1
		side_neigh_i(10,S) = j
		side_neigh_i(11,S) = k1    
		nC=0
		   if (stag == 1) then
		       side_neigh(3*nC,S) = (side_neigh_i(3*nC,S)*dx)-(dx)
		       side_neigh(3*nC+1,S) = (side_neigh_i(3*nC+1,S)*dy)-(dy/2)
		   elseif (stag == 2) then
		       side_neigh(3*nC,S) = (side_neigh_i(3*nC,S)*dx)-(dx/2)
		       side_neigh(3*nC+1,S) = (side_neigh_i(3*nC+1,S)*dy)-(dy)	       
		   elseif (stag == 3) then
		       side_neigh(3*nC,S) = (side_neigh_i(3*nC,S)*dx)-(dx/2)
		       side_neigh(3*nC+1,S) = (side_neigh_i(3*nC+1,S)*dy)-(dy/2)	       
		   endif
		side_neigh(3*nC+2,S) = ht_p(side_neigh_i(3*nC,S),side_neigh_i(3*nC+2,S),j)
		! fill in the next two points on the wall          
		! first z
		side_neigh(5,S) = ht_p(i2,k2,j)
		side_neigh(8,S) = ht_p(i2,k2-1,j)
		if (stag == 1) then
		    !next y
		    side_neigh(4,S) = (j*dy)-(dy/2)
		    side_neigh(7,S) = (j*dy)-(dy/2)
		    ! solve for x
		    if (ibm_ht_stag(i1,j) >= ht_p(i2,k2,j)) then
		       side_neigh(3,S) = (i1*dx-dx) + (dx/2)*((side_neigh(5,S)-ibm_ht(i1,j)) &
	                               	              /(ibm_ht_stag(i1,j)-ibm_ht(i1,j)))
		       side_neigh(6,S) = (i1*dx-dx) + (dx/2)*((side_neigh(8,S)-ibm_ht(i1,j)) &
	                                              /(ibm_ht_stag(i1,j)-ibm_ht(i1,j)))
                    elseif (ibm_ht_stag(i1,j) > ht_p(i2,k2-1,j)) then
		       side_neigh(3,S) = (i1*dx-dx) + dx*((side_neigh(5,S)-ibm_ht(i1,j)) &
	                                		 /(ibm_ht(i2,j)-ibm_ht(i1,j)))
		       side_neigh(6,S) = (i1*dx-dx) + dx*((side_neigh(8,S)-ibm_ht(i1,j)) &
	                                		 /(ibm_ht(i2,j)-ibm_ht(i1,j)))
	            else
		       side_neigh(3,S) = (i1*dx-(dx/2)) + (dx/2)*((side_neigh(5,S)-ibm_ht_stag(i1,j)) &
	                                		  /(ibm_ht(i2,j)-ibm_ht_stag(i1,j)))
		       side_neigh(6,S) = (i1*dx-(dx/2)) + (dx/2)*((side_neigh(8,S)-ibm_ht_stag(i1,j)) &
	                                		  /(ibm_ht(i2,j)-ibm_ht_stag(i1,j)))
		    endif						   
		elseif (stag == 2) then
		    !next y
		    side_neigh(4,S) = (j*dy)-(dy)
		    side_neigh(7,S) = (j*dy)-(dy)
		    ! solve for x
	            if (ibm_ht_stag(i2,j) >= ht_p(i2,k2,j)) then
		       side_neigh(3,S) = (i1*dx-(dx/2)) + (dx/2)*((side_neigh(5,S)-ibm_ht(i1,j)) &
	                               	              /(ibm_ht_stag(i2,j)-ibm_ht(i1,j)))
		       side_neigh(6,S) = (i1*dx-(dx/2)) + (dx/2)*((side_neigh(8,S)-ibm_ht(i1,j)) &
	                                              /(ibm_ht_stag(i2,j)-ibm_ht(i1,j)))
                    elseif (ibm_ht_stag(i2,j) > ht_p(i2,k2-1,j)) then
		       side_neigh(3,S) = (i1*dx-(dx/2)) + dx*((side_neigh(5,S)-ibm_ht(i1,j)) &
	                                		 /(ibm_ht(i2,j)-ibm_ht(i1,j)))
		       side_neigh(6,S) = (i1*dx-(dx/2)) + dx*((side_neigh(8,S)-ibm_ht(i1,j)) &
	                                		 /(ibm_ht(i2,j)-ibm_ht(i1,j)))
	            else
		       side_neigh(3,S) = (i1*dx) + (dx/2)*((side_neigh(5,S)-ibm_ht_stag(i2,j)) &
	                                		  /(ibm_ht(i2,j)-ibm_ht_stag(i2,j)))
		       side_neigh(6,S) = (i1*dx) + (dx/2)*((side_neigh(8,S)-ibm_ht_stag(i2,j)) &
	                                		  /(ibm_ht(i2,j)-ibm_ht_stag(i2,j)))
		    endif	    
		elseif (stag == 3) then
		    !next y
		    side_neigh(4,S) = (j*dy)-(dy/2)
		    side_neigh(7,S) = (j*dy)-(dy/2)
		    ! solve for x
	            if (ibm_ht_stag(i2,j) >= ht_p(i2,k2,j)) then
		       side_neigh(3,S) = (i1*dx-(dx/2)) + (dx/2)*((side_neigh(5,S)-ibm_ht(i1,j)) &
	                               	              /(ibm_ht_stag(i2,j)-ibm_ht(i1,j)))
		       side_neigh(6,S) = (i1*dx-(dx/2)) + (dx/2)*((side_neigh(8,S)-ibm_ht(i1,j)) &
	                                              /(ibm_ht_stag(i2,j)-ibm_ht(i1,j)))
                    elseif (ibm_ht_stag(i2,j) > ht_p(i2,k2-1,j)) then
		       side_neigh(3,S) = (i1*dx-(dx/2)) + dx*((side_neigh(5,S)-ibm_ht(i1,j)) &
	                                		 /(ibm_ht(i2,j)-ibm_ht(i1,j)))
		       side_neigh(6,S) = (i1*dx-(dx/2)) + dx*((side_neigh(8,S)-ibm_ht(i1,j)) &
	                                		 /(ibm_ht(i2,j)-ibm_ht(i1,j)))
	            else
		       side_neigh(3,S) = (i1*dx) + (dx/2)*((side_neigh(5,S)-ibm_ht_stag(i2,j)) &
	                                		  /(ibm_ht(i2,j)-ibm_ht_stag(i2,j)))
		       side_neigh(6,S) = (i1*dx) + (dx/2)*((side_neigh(8,S)-ibm_ht_stag(i2,j)) &
	                                		  /(ibm_ht(i2,j)-ibm_ht_stag(i2,j)))
		    endif	    	    
		endif					   
		nC=3
		if (stag == 1) then
		    side_neigh(3*nC,S) = (side_neigh_i(3*nC,S)*dx)-(dx)
		    side_neigh(3*nC+1,S) = (side_neigh_i(3*nC+1,S)*dy)-(dy/2)
		elseif (stag == 2) then
		    side_neigh(3*nC,S) = (side_neigh_i(3*nC,S)*dx)-(dx/2)
		    side_neigh(3*nC+1,S) = (side_neigh_i(3*nC+1,S)*dy)-(dy)	       
		elseif (stag == 3) then
		    side_neigh(3*nC,S) = (side_neigh_i(3*nC,S)*dx)-(dx/2)
		    side_neigh(3*nC+1,S) = (side_neigh_i(3*nC+1,S)*dy)-(dy/2)	       
		endif
		side_neigh(3*nC+2,S) = ht_p(side_neigh_i(3*nC,S),side_neigh_i(3*nC+2,S),j)		
	    else
	        print '((A),1i5,(A),1i5,(A),1i5)','stag =',stag,' bc type =', bc_type,' there are side neighbors not assigned for 0111 at S =',S
            endif ! (k1 < k2)		       
	else 
            print *, 'there are side neighbors not assigned at S =', S ,'for stag =', stag
	    print *, inside(i1,k1  ,j) ,inside(i2,k2  ,j), inside(i2,k2-1,j), inside(i1,k1-1,j)            
	    !CALL wrf_error_fatal ('side: the neighbors are not assigned') 
	endif	
	!print '((A),1i5,(A),1i5,(A),1i5,4i3)', 'S =',S ,' stag =',stag, ' bc_type =',bc_type, inside(i1,k1,j) ,inside(i2,k2,j), inside(i2,k2-1,j), inside(i1,k1-1,j)
   ENDDO 
   
   ! make the image coord the origin (x,y,z,)=(0,0,0)
   DO S=1,np
   DO nC=0,3
      side_neigh(3*nC,S) = side_neigh(3*nC,S)-side_img(4,S)
      side_neigh(3*nC+1,S) = side_neigh(3*nC+1,S)-side_img(5,S)
      side_neigh(3*nC+2,S) = side_neigh(3*nC+2,S)-side_img(6,S)     
   ENDDO
   ENDDO
   
   !! make the ghost point coord the origin (x,y,z,)=(0,0,0)
   ! DO S=1,np
   ! DO nC=0,3
   !    side_neigh(3*nC,S) = side_neigh(3*nC,S)-side_img(1,S)
   !    side_neigh(3*nC+1,S) = side_neigh(3*nC+1,S)-side_img(2,S)
   !    side_neigh(3*nC+2,S) = side_neigh(3*nC+2,S)-side_img(3,S)     
   ! ENDDO
   ! ENDDO    

 END SUBROUTINE get_side_pts_2d	
 
!------------------------------------------------------------------------------------    

SUBROUTINE get_top_pts_idw_2d( stag, bc_type,                &
                               dx, dy,                       &
                               ht_p,                         &
			       inside,                       &
			       top_img, top_bound,           &
			       top_neigh, top_neigh_i,       &
			       n, ant,                       &
			       ids, ide, jds, jde, kds, kde, &
                               ims, ime, jms, jme, kms, kme, &
                               its, ite, jts, jte, kts, kte)
 IMPLICIT NONE
! input data
 INTEGER, INTENT(IN   )                                    :: stag,       &
                                                              bc_type 
 REAL, INTENT(IN   )                                       :: dx,dy
 REAL, DIMENSION(ims:ime,kms:kme,jms:jme), INTENT(IN   )   :: ht_p            ! ht at the points being computed	     
 INTEGER, DIMENSION(ims:ime,kms:kme,jms:jme), INTENT(IN  ) :: inside          ! one if the pt is inside boundary, zero if it is outside					      
 REAL, DIMENSION(ims:ime,jms:jme,6), INTENT(IN   )         :: top_img         ! (x,y,z) location of ghost point and image point of the 'top boundary' ghost points
 REAL, DIMENSION(ims:ime,jms:jme,3), INTENT(IN   )         :: top_bound       ! (x,y,z) location of the boundary for top point
 REAL, DIMENSION(ims:ime,jms:jme,0:3*n-1), INTENT(  OUT)   :: top_neigh       ! (x,y,z) location of  neighbors
 INTEGER, DIMENSION(ims:ime,jms:jme,0:3*n-1), INTENT(  OUT):: top_neigh_i     ! (i,j,k) index of top neighbors
 INTEGER, INTENT(IN   )                                    :: n               ! desired number of nearest neighbors
 INTEGER, DIMENSION(ims:ime,jms:jme), INTENT(  OUT)        :: ant             ! actual number of nearest neighbors for top pts
 INTEGER, INTENT(IN   )                   :: ids, ide, jds, jde, kds, kde, &  ! d: domain m:memory p:patch t:tile
                                             ims, ime, jms, jme, kms, kme, &
                                             its, ite, jts, jte, kts, kte		   

!local data
  INTEGER                                                  :: i,j,       & 
                                                              i_end,     &
							      j_end,     &
                                                              nC,        &
							      ii,ki,     &
							      is,ks,     &
							      count							      
  REAL                                                     :: a,b,c
  REAL, DIMENSION(16)                                      :: dist
  INTEGER, DIMENSION(n)                                    :: index_rank
  INTEGER, DIMENSION(16,3)      	                   :: index_store						      
   
!--------------------------------------------------------------------------------
! the executable begins here
! this subroutine stores the (i,j,k) index and (x,y,z) location of the eight 
! neighbors of a top image point.
 CALL wrf_debug(100, 'dyn_em/module_ibm.F/subroutine get_top_pts_idw_2d') 
!--------------------------------------------------------------------------------
    
    IF (stag == 1) THEN
       i_end = ite
       j_end = MIN(jte,jde-1)
    ELSEIF (stag == 2) THEN
       i_end = MIN(ite,ide-1)
       j_end = jte
    ELSEIF (stag == 3) THEN
       i_end = MIN(ite,ide-1)
       j_end = MIN(jte,jde-1)
    ENDIF

    DO i=its,i_end
    DO j=jts,j_end
       ! find  neighbors of the image point 
       if (stag == 1) then
	     ii = ceiling(top_img(i,j,4)/dx)     
       elseif ((stag == 2).OR.(stag == 3)) then 
	     ii = ceiling((top_img(i,j,4)-(dx/2))/dx) 
       endif  
       ! get k indicies
       ki = 1
       do while (top_img(i,j,6) >= ht_p(i,ki,j))
	     ki=ki+1
       enddo
       ki = ki-1

      ! look at the closest 64 points, and determine which are outside the terrain
      ! calculate the distance of those points that are outside the terrain
      dist = 0.
      index_rank = 0
      index_store = 0
      count = 0
      DO is = ii-1,ii+2
      DO ks = ki-1,ki+2        
      !DO js = ji-1,ji+2
         ! see if it could possibly be a neighbor by checking that it is outside of terrain
	 if (inside(is,ks,j) == 0) then
	    count = count +1
	    if (stag ==1 ) then 		       
		a = (is*dx)-(dx)-top_img(i,j,4)
		b = (j*dy)-(dy/2)-top_img(i,j,5)
	    elseif (stag == 2) then
		a = (is*dx)-(dx/2)-top_img(i,j,4)
		b = (j*dy)-(dy)-top_img(i,j,5) 	    
	    elseif (stag == 3) then
		a = (is*dx)-(dx/2)-top_img(i,j,4)
		b = (j*dy)-(dy/2)-top_img(i,j,5)	    
	    endif
	    c = ht_p(is,ks,j)-top_img(i,j,6)
	    dist(count) = SQRT(a**2+b**2+c**2)
	    index_store(count,1:3) = [is,j,ks]
	 endif
      !ENDDO 
      ENDDO
      ENDDO
      	  
      !print *,count
      !if (count < n) write(*,'((A),1i5,(A),1i5,(A),1i5,(A),1i5,(A),1i5)') 'get_top_pts_idw only ',count,' neighbors at i=',i,' j=',j,' for stag =',stag, ' bc type =', bc_type 

      if (bc_type == 1) then
          if (count < n-1) then
	     ant(i,j) = count+1
	  else
	     ant(i,j) = n
	  endif
	  ! the first neighbor is the boundary point
	  nC = 0
	  top_neigh_i(i,j,3*nC) = 0
	  top_neigh_i(i,j,3*nC+1) = 0
	  top_neigh_i(i,j,3*nC+2) = 0
	  top_neigh(i,j,3*nC) = top_bound(i,j,1)
	  top_neigh(i,j,3*nC+1) = top_bound(i,j,2)
	  top_neigh(i,j,3*nC+2) = top_bound(i,j,3)
	  
	  CALL rnkpar(dist(1:count),index_rank,ant(i,j)-1)
	  !CALL rnkpar(dist(1:count),index_rank,n-1)
	  
	  ! the rest of the neighbors are computational nodes
	  DO nC = 1,ant(i,j)-1
	 ! DO nC = 1,n-1
	     top_neigh_i(i,j,3*nC) = index_store(index_rank(nC),1)
	     top_neigh_i(i,j,3*nC+1) = index_store(index_rank(nC),2)
	     top_neigh_i(i,j,3*nC+2) = index_store(index_rank(nC),3)	       
	     if (stag ==1 ) then		       
		 top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx)
		 top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)
	     elseif (stag == 2) then
		 top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
		 top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy)	   
	     elseif (stag == 3) then
		 top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
		 top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2) 	    
	     endif
	     top_neigh(i,j,3*nC+2) = ht_p(top_neigh_i(i,j,3*nC),top_neigh_i(i,j,3*nC+2),top_neigh_i(i,j,3*nC+1))
	  ENDDO
      elseif (bc_type == 2) then
          if (count < n) then
	     ant(i,j) = count
	  else
	     ant(i,j) = n
	  endif
	  !CALL rnkpar(dist(1:count),index_rank,n)
	  CALL rnkpar(dist(1:count),index_rank,ant(i,j))
	  ! the rest of the neighbors are computational nodes
	  !DO nC = 0,n-1
	  DO nC = 0,ant(i,j)-1
	     top_neigh_i(i,j,3*nC) = index_store(index_rank(nC+1),1)
	     top_neigh_i(i,j,3*nC+1) = index_store(index_rank(nC+1),2)
	     top_neigh_i(i,j,3*nC+2) = index_store(index_rank(nC+1),3)	       
	     if (stag ==1 ) then		       
		 top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx)
		 top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)
	     elseif (stag == 2) then
		 top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
		 top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy)	   
	     elseif (stag == 3) then
		 top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
		 top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2) 	    
	     endif
	     top_neigh(i,j,3*nC+2) = ht_p(top_neigh_i(i,j,3*nC),top_neigh_i(i,j,3*nC+2),top_neigh_i(i,j,3*nC+1))
	  ENDDO	  
      endif
   ENDDO
   ENDDO
   
  

   !make the image coord the origin (x,y,z,)=(0,0,0)
   DO i=its,i_end
   DO j=jts,j_end
   !DO nC=0,n-1
   DO nC=0,ant(i,j)-1
      top_neigh(i,j,3*nC) = top_neigh(i,j,3*nC)-top_img(i,j,4)
      top_neigh(i,j,3*nC+1) = top_neigh(i,j,3*nC+1)-top_img(i,j,5)
      top_neigh(i,j,3*nC+2) = top_neigh(i,j,3*nC+2)-top_img(i,j,6)	
   ENDDO
   ENDDO
   ENDDO 
 
END SUBROUTINE get_top_pts_idw_2d


!--------------------------------------------------------------------------------

 SUBROUTINE get_side_pts_idw_2d ( stag, bc_type,                &
                        	  dx, dy,                       &
                        	  ht_p,                         &
				  inside,                       &
				  side, side_img, side_bound,   &
				  side_neigh, side_neigh_i,     &
				  n, np, ans,                   &
				  ids, ide, jds, jde, kds, kde, &
                        	  ims, ime, jms, jme, kms, kme, &
                        	  its, ite, jts, jte, kts, kte)
  IMPLICIT NONE
 ! input data 
  INTEGER, INTENT(IN   )                                    :: stag,       &
                                                               bc_type 
  REAL, INTENT(IN   )                                       :: dx,dy
  REAL, DIMENSION(ims:ime,kms:kme,jms:jme), INTENT(IN   )   :: ht_p  			     
  INTEGER, DIMENSION(ims:ime,kms:kme,jms:jme), INTENT(IN  ) :: inside          ! one if the pt is inside boundary, zero if it is outside
  INTEGER, DIMENSION(3,np), INTENT(IN   )                   :: side            !'side boundary' ghost points							      
  REAL, DIMENSION(6,np), INTENT(IN   )                      :: side_img        ! (x,y,z) location of ghost point and image point of the 'side boundary' ghost points 
  REAL, DIMENSION(3,np), INTENT(IN   )                      :: side_bound      ! (x,y,z) location of the boundary for side points
  REAL, DIMENSION(0:3*n-1,np), INTENT(  OUT)                :: side_neigh      ! (x,y,z) location of neighbors
  INTEGER, DIMENSION(0:3*n-1,np), INTENT(  OUT)             :: side_neigh_i    ! (i,j,k) location of neighbors
  INTEGER, INTENT(IN   )                                    :: n,           &  ! desired number of nearest neighbors
                                                               np              ! number of side ghost points
  INTEGER, DIMENSION(np), INTENT(  OUT)                     :: ans             ! actual number of nearest neighbors side
  INTEGER, INTENT(IN   )                   :: ids, ide, jds, jde, kds, kde, &  ! d: domain m:memory p:patch t:tile
                                              ims, ime, jms, jme, kms, kme, &
                                              its, ite, jts, jte, kts, kte		   

 !local data
  INTEGER                                                  :: S,         & 
                                                              nC,        &
							      ii,ji,ki,  &
							      is,ks,  &
							      count							      
  REAL                                                     :: a,b,c
  REAL, DIMENSION(16)                                      :: dist
  INTEGER, DIMENSION(n)                                    :: index_rank
  INTEGER, DIMENSION(16,3)      	                   :: index_store						       

!-----------------------------------------------------------------------------------
! the executable begins here
! this subroutine stores the (i,j,k) index and (x,y,z) location of the eight
! neighbors of a side image point.
 CALL wrf_debug(100,'dyn_em/module_ibm.F/subroutine get_side_pts_idw_2d')
!------------------------------------------------------------------------------------

 DO S=1,np
    ! find neighbors of the image point
    if (stag == 1) then
       ii = ceiling(side_img(4,S)/dx)  
    elseif ((stag == 2).OR.(stag == 3)) then
       ii = ceiling((side_img(4,S)-(dx/2))/dx)
    endif
    if (stag == 2) then
       ji = ceiling(side_img(5,S)/dy)
    elseif ((stag == 1).OR.(stag == 3)) then
      ji = ceiling((side_img(5,S)-(dy/2))/dy)  
    endif  
    ji = ji+1
    ki = 1     
    do while (side_img(6,S) >= ht_p(side(1,S),ki,side(2,S)))
       ki=ki+1
    enddo
    ki = ki-1
    
    ! look at the closest 64 points, and determine which are outside the terrain
    ! calculate the distance of those points that are outside the terrain
    dist = 0.
    index_rank = 0
    index_store = 0
    count = 0
    DO is = ii-1,ii+2
    DO ks = ki-1,ki+2        
       ! see if it could possibly be a neighbor by checking that it is outside of terrain
       if (inside(is,ks,ji) == 0) then
	  count = count +1
	  if (stag ==1 ) then 		       
	      a = (is*dx)-(dx)-side_img(4,S)
	      b = (ji*dy)-(dy/2)-side_img(5,S)
	  elseif (stag == 2) then
	      a = (is*dx)-(dx/2)-side_img(4,S)
	      b = (ji*dy)-(dy)-side_img(5,S) 	    
	  elseif (stag == 3) then
	      a = (is*dx)-(dx/2)-side_img(4,S)
	      b = (ji*dy)-(dy/2)-side_img(5,S)	    
	  endif
	  c = ht_p(is,ks,ji)-side_img(6,S)
	  dist(count) = SQRT(a**2+b**2+c**2)
	  index_store(count,1:3) = [is,ji,ks]
       endif
    ENDDO
    ENDDO
    
    !if (count < n) write(*,'((A),1i5,(A),1i5,(A),1i5,(A),1i5)') 'get_side_pts_idw only',count,' neighbors at S=',S,'for stag =',stag,'for bc =', bc_type
    
    if (bc_type == 1) then
       if (count < n-1) then
	  ans(S) = count+1
       else
	  ans(S) = n
       endif
       ! the first neighbor is the boundary point
       nC = 0
       side_neigh_i(3*nC,S) = 0
       side_neigh_i(3*nC+1,S) = 0
       side_neigh_i(3*nC+2,S) = 0 
       side_neigh(3*nC,S) = side_bound(1,S)
       side_neigh(3*nC+1,S) = side_bound(2,S)
       side_neigh(3*nC+2,S) = side_bound(3,S)

       !CALL rnkpar(dist(1:count),index_rank,n-1)
       CALL rnkpar(dist(1:count),index_rank,ans(S)-1)
       
       DO nC = 1,n-1
	  side_neigh_i(3*nC,S) = index_store(index_rank(nC),1)
	  side_neigh_i(3*nC+1,S) = index_store(index_rank(nC),2)
	  side_neigh_i(3*nC+2,S) = index_store(index_rank(nC),3)		
	  if (stag ==1 ) then 			
	      side_neigh(3*nC,S) = (side_neigh_i(3*nC,S)*dx)-(dx)
	      side_neigh(3*nC+1,S) = (side_neigh_i(3*nC+1,S)*dy)-(dy/2)
	  elseif (stag == 2) then
	      side_neigh(3*nC,S) = (side_neigh_i(3*nC,S)*dx)-(dx/2)
	      side_neigh(3*nC+1,S) = (side_neigh_i(3*nC+1,S)*dy)-(dy)	     
	  elseif (stag == 3) then
	      side_neigh(3*nC,S) = (side_neigh_i(3*nC,S)*dx)-(dx/2)
	      side_neigh(3*nC+1,S) = (side_neigh_i(3*nC+1,S)*dy)-(dy/2)	     
	  endif
	  side_neigh(3*nC+2,S) = ht_p(side_neigh_i(3*nC,S),side_neigh_i(3*nC+2,S),side_neigh_i(3*nC+1,S))
       ENDDO	      
    elseif (bc_type == 2) then
       if (count < n) then
	  ans(S) = count
       else
	  ans(S) = n
       endif
       !CALL rnkpar(dist(1:count),index_rank,n)
       CALL rnkpar(dist(1:count),index_rank,ans(S))
       DO nC = 0,n-1
	  side_neigh_i(3*nC,S) = index_store(index_rank(nC+1),1)
	  side_neigh_i(3*nC+1,S) = index_store(index_rank(nC+1),2)
	  side_neigh_i(3*nC+2,S) = index_store(index_rank(nC+1),3)		
	  if (stag ==1 ) then 			
	      side_neigh(3*nC,S) = (side_neigh_i(3*nC,S)*dx)-(dx)
	      side_neigh(3*nC+1,S) = (side_neigh_i(3*nC+1,S)*dy)-(dy/2)
	  elseif (stag == 2) then
	      side_neigh(3*nC,S) = (side_neigh_i(3*nC,S)*dx)-(dx/2)
	      side_neigh(3*nC+1,S) = (side_neigh_i(3*nC+1,S)*dy)-(dy)	     
	  elseif (stag == 3) then
	      side_neigh(3*nC,S) = (side_neigh_i(3*nC,S)*dx)-(dx/2)
	      side_neigh(3*nC+1,S) = (side_neigh_i(3*nC+1,S)*dy)-(dy/2)	     
	  endif
	  side_neigh(3*nC+2,S) = ht_p(side_neigh_i(3*nC,S),side_neigh_i(3*nC+2,S),side_neigh_i(3*nC+1,S))  
       ENDDO
    endif
 ENDDO

 ! make the image coord the origin (x,y,z,)=(0,0,0)
 DO S=1,np
 !DO nC=0,n-1
 DO nC = 0,ans(S)-1
    side_neigh(3*nC,S) = side_neigh(3*nC,S)-side_img(4,S)
    side_neigh(3*nC+1,S) = side_neigh(3*nC+1,S)-side_img(5,S)
    side_neigh(3*nC+2,S) = side_neigh(3*nC+2,S)-side_img(6,S)     
 ENDDO
 ENDDO

 !! make the ghost point coord the origin (x,y,z,)=(0,0,0)
 ! DO S=1,np
 ! DO nC=0,n-1
 !    side_neigh(3*nC,S) = side_neigh(3*nC,S)-side_img(1,S)
 !    side_neigh(3*nC+1,S) = side_neigh(3*nC+1,S)-side_img(2,S)
 !    side_neigh(3*nC+2,S) = side_neigh(3*nC+2,S)-side_img(3,S)     
 ! ENDDO
 ! ENDDO    
	
END SUBROUTINE get_side_pts_idw_2d

!------------------------------------------------------------------------------------    

SUBROUTINE get_top_pts_idw_3d( ibm_opt,                      &
                               p_stag, n_stag, bc_type,      &
                               ibm_nn_horz,                  &
                               ibm_nn_vert,                  &
                               dx, dy,                       &
                               ht_p,                         &
                               inside,                       &
                               inside_all,                   & !RSA
                               recon_pts_as_neigh,           & !RSA
                               in_vel_recon,                 & !RSA
                               top_img, top_bound,           &
                               top_neigh, top_neigh_i,       &
                               n, ant,                       &
                               ids, ide, jds, jde, kds, kde, &
                               ims, ime, jms, jme, kms, kme, &
                               its, ite, jts, jte, kts, kte )

  IMPLICIT NONE
  !input data
  INTEGER, INTENT(IN   )                                    :: ibm_opt,      &
                                                               p_stag,       & ! stagger of the ghost/reconstruction point
                                                               n_stag,       & ! stagger of the neighbor points (to be found)
                                                               bc_type,      &
                                                               ibm_nn_horz,  &
                                                               ibm_nn_vert
  REAL, INTENT(IN   )                                       :: dx, dy
  REAL, DIMENSION(ims:ime,kms:kme,jms:jme), INTENT(IN   )   :: ht_p            ! ht at the points being computed	     
  INTEGER, DIMENSION(ims:ime,kms:kme,jms:jme), INTENT(IN  ) :: inside          ! one if the pt is inside boundary, zero if it is outside
  INTEGER, DIMENSION(ims:ime,kms:kme,jms:jme), INTENT(IN  ) :: inside_all      ! RSA inside includes recon pts, inside_all does not
  LOGICAL, INTENT(IN   )                                    :: recon_pts_as_neigh, in_vel_recon !RSA
  REAL, DIMENSION(ims:ime,jms:jme,6), INTENT(IN   )         :: top_img         ! (x,y,z) location of ghost point and image point of the 'top boundary' ghost points
  REAL, DIMENSION(ims:ime,jms:jme,3), INTENT(IN   )         :: top_bound       ! (x,y,z) location of the boundary for top point
  REAL, DIMENSION(ims:ime,jms:jme,0:3*n-1), INTENT(  OUT)   :: top_neigh       ! (x,y,z) location of  neighbors
  INTEGER, DIMENSION(ims:ime,jms:jme,0:3*n-1), INTENT(  OUT):: top_neigh_i     ! (i,j,k) index of top neighbors
  INTEGER, INTENT(IN   )                                    :: n               ! desired number of nearest neighbors
  INTEGER, DIMENSION(ims:ime,jms:jme), INTENT(  OUT)        :: ant             ! actual number of nearest neighbors for top pts
  INTEGER, INTENT(IN   )                   :: ids, ide, jds, jde, kds, kde, &  ! d: domain m:memory p:patch t:tile
                                              ims, ime, jms, jme, kms, kme, &
                                              its, ite, jts, jte, kts, kte
  !local data
  INTEGER                                                   :: i, j, k,    & 
                                                               i_end,      &
                                                               j_end,      &
                                                               nC,         &
                                                               ii, ji, ki, &
                                                               is, js, ks, &
                                                               count,      &
                                                               offset,     &
                                                               stag
  REAL                                                      :: a, b, c
  REAL, DIMENSION(ibm_nn_vert*ibm_nn_horz**2)               :: dist
  INTEGER, DIMENSION(n)                                     :: index_rank
  INTEGER, DIMENSION(ibm_nn_vert*ibm_nn_horz**2,3)          :: index_store
   
!--------------------------------------------------------------------------------
! the executable begins here
! this subroutine stores the (i,j,k) index and (x,y,z) location of the eight 
! neighbors of a top image point.
    CALL wrf_debug(100, 'dyn_em/module_ibm.F/subroutine get_top_pts_idw_3d') 
!--------------------------------------------------------------------------------

    top_neigh = 0.0

    IF (p_stag .EQ. 1) THEN
       i_end = ite
       j_end = MIN(jte,jde-1)
    ELSEIF (p_stag .EQ. 2) THEN
       i_end = MIN(ite,ide-1)
       j_end = jte
    ELSEIF (p_stag .EQ. 3) THEN
       i_end = MIN(ite,ide-1)
       j_end = MIN(jte,jde-1)
    ELSEIF (p_stag .EQ. 4) THEN
       i_end = ite
       j_end = jte
    ENDIF

    IF ((ibm_opt .EQ. 3) .OR. (ibm_opt .EQ. 5)) THEN
       !DJW I added +1 to ii and ji since we're starting at ii=1 not ii=0
       offset = 1
       !DJW changed n_stag to p_stag. This seems correct but I need to
       !    look more closely to determine if that is actually correct.
       stag = p_stag
    ELSE
       offset = 0
       stag = n_stag
    ENDIF 

    DO i=its,i_end
    DO j=jts,j_end
       !Find  neighbors of the image point or interpolation point
       !First determine the 4x4x4 block of cells to loop over looking for
       !nearest neighbors to the IP.
       IF ((stag .EQ. 1) .OR. (stag .EQ. 4)) THEN
          ii = CEILING(top_img(i,j,4)/dx)+offset
       ELSEIF ((stag .EQ. 2) .OR. (stag .EQ. 3)) THEN
          ii = CEILING((top_img(i,j,4)-(dx/2.0))/dx)+offset
       ENDIF
       !get j indicies
       IF ((stag .EQ. 2) .OR. (stag .EQ. 4)) THEN
          ji = CEILING(top_img(i,j,5)/dy)+offset
       ELSEIF ((stag .EQ. 1) .OR. (stag .EQ. 3)) THEN
          ji = CEILING((top_img(i,j,5)-(dy/2.0))/dy)+offset
       ENDIF
       !get k indicies
       ki = 1
       DO WHILE (top_img(i,j,6) .GE. ht_p(i,ki,j))
          ki=ki+1
       ENDDO
       ki = ki-1
       ki = MAX(ki,ibm_nn_vert/2)

       !look at the closest 64 points, and determine which are outside the terrain
       !calculate the distance of those points that are outside the terrain
       dist = 0.0
       index_rank = 0
       index_store = 0
       count = 0
       DO is=ii-ibm_nn_horz/2+1,ii+ibm_nn_horz/2
       DO ks=ki-ibm_nn_vert/2+1,ki+ibm_nn_vert/2
       DO js=ji-ibm_nn_horz/2+1,ji+ibm_nn_horz/2
          !see if it could possibly be a neighbor by checking that it is outside of terrain
          IF (inside(is,ks,js) .EQ. 0) THEN
             count = count+1
             IF (n_stag .EQ. 1 ) THEN
                a = (is*dx)-(dx)-top_img(i,j,4)
                b = (js*dy)-(dy/2)-top_img(i,j,5)
             ELSEIF (n_stag .EQ. 2) THEN
                a = (is*dx)-(dx/2)-top_img(i,j,4)
                b = (js*dy)-(dy)-top_img(i,j,5)
             ELSEIF (n_stag .EQ. 3) THEN
                a = (is*dx)-(dx/2)-top_img(i,j,4)
                b = (js*dy)-(dy/2)-top_img(i,j,5)
             ELSEIF (n_stag .EQ. 4) THEN
                a = (is*dx)-(dx)-top_img(i,j,4)
                b = (js*dy)-(dy)-top_img(i,j,5)
             ENDIF
             c = ht_p(is,ks,js)-top_img(i,j,6)
             dist(count) = SQRT(a**2+b**2+c**2)
             index_store(count,1:3) = [is,js,ks]
          ENDIF
       ENDDO 
       ENDDO
       ENDDO

      !RSA if no neighbors are found and we are in a vel recon routine, retry including reconstruction pts as neighbors
      IF (recon_pts_as_neigh .and. in_vel_recon) THEN
         IF (count .LE. 1) THEN
            dist = 0.0
            index_rank = 0
            index_store = 0
            count = 0
            DO is=ii-ibm_nn_horz/2+1,ii+ibm_nn_horz/2
            DO ks=ki-ibm_nn_vert/2+1,ki+ibm_nn_vert/2
            DO js=ji-ibm_nn_horz/2+1,ji+ibm_nn_horz/2
               !see if it could possibly be a neighbor by checking that it is outside of terrain
               IF (inside_all(is,ks,js) .EQ. 0) THEN
                  count = count+1
                  IF (n_stag .EQ. 1 ) THEN
                     a = (is*dx)-(dx)-top_img(i,j,4)
                     b = (js*dy)-(dy/2)-top_img(i,j,5)
                  ELSEIF (n_stag .EQ. 2) THEN
                     a = (is*dx)-(dx/2)-top_img(i,j,4)
                     b = (js*dy)-(dy)-top_img(i,j,5)
                  ELSEIF (n_stag .EQ. 3) THEN
                     a = (is*dx)-(dx/2)-top_img(i,j,4)
                     b = (js*dy)-(dy/2)-top_img(i,j,5)
                  ENDIF
                  c = ht_p(is,ks,js)-top_img(i,j,6)
                  dist(count) = SQRT(a**2+b**2+c**2)
                  index_store(count,1:3) = [is,js,ks]
               ENDIF
            ENDDO 
            ENDDO
            ENDDO
            write(*,'(4(A,1i5))') "RSA[module_ibm/get_top_pts_idw_3d]: using recon pts as neighbors. i=",i," j=",j," count=",count," for stag=",stag
         ENDIF
      ELSE !RSA original code
         ! print *,count
         !if (count < n) write(*,'((A),1i5,(A),1i5,(A),1i5,(A),1i5,(A),1i5)') 'get_top_pts_idw only ',count,' neighbors at i=',i,' j=',j,' for stag =',stag, ' bc type =', bc_type 
      ENDIF !RSA

      IF (bc_type .EQ. 1) THEN
          IF (count .LT. n-1) THEN
             ant(i,j) = count+1
          ELSE
             ant(i,j) = n
          ENDIF
          !the first neighbor is the boundary point
          nC = 0
          top_neigh_i(i,j,3*nC) = 0
          top_neigh_i(i,j,3*nC+1) = 0
          top_neigh_i(i,j,3*nC+2) = 0
          top_neigh(i,j,3*nC) = top_bound(i,j,1)
          top_neigh(i,j,3*nC+1) = top_bound(i,j,2)
          top_neigh(i,j,3*nC+2) = top_bound(i,j,3)

          CALL rnkpar(dist(1:count),index_rank,ant(i,j)-1)

          !the rest of the neighbors are computational nodes
          DO nC=1,ant(i,j)-1
             top_neigh_i(i,j,3*nC) = index_store(index_rank(nC),1)
             top_neigh_i(i,j,3*nC+1) = index_store(index_rank(nC),2)
             top_neigh_i(i,j,3*nC+2) = index_store(index_rank(nC),3)
             IF (n_stag .EQ. 1) THEN
                top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx)
                top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)
             ELSEIF (n_stag .EQ. 2) THEN
                top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
                top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy)
             ELSEIF (n_stag .EQ. 3) THEN
                top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
                top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)
             ELSEIF (n_stag .EQ. 4) THEN
                top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx)
                top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy)
             ENDIF
             top_neigh(i,j,3*nC+2) = ht_p(top_neigh_i(i,j,3*nC),top_neigh_i(i,j,3*nC+2),top_neigh_i(i,j,3*nC+1))   
          ENDDO
      ELSEIF (bc_type .EQ. 2) THEN
          IF (count .LT. n) THEN
             ant(i,j) = count
          ELSE
             ant(i,j) = n
          ENDIF
          CALL rnkpar(dist(1:count),index_rank,ant(i,j))
          !the rest of the neighbors are computational nodes
          DO nC=0,ant(i,j)-1
             top_neigh_i(i,j,3*nC  ) = index_store(index_rank(nC+1),1)
             top_neigh_i(i,j,3*nC+1) = index_store(index_rank(nC+1),2)
             top_neigh_i(i,j,3*nC+2) = index_store(index_rank(nC+1),3)
             IF (n_stag .EQ. 1) THEN
                top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx)
                top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)
             ELSEIF (n_stag .EQ. 2) THEN
                top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
                top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy)
             ELSEIF (n_stag .EQ. 3) THEN
                top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
                top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)
             ELSEIF (n_stag .EQ. 4) THEN
                top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx)
                top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy)
             ENDIF
             top_neigh(i,j,3*nC+2) = ht_p(top_neigh_i(i,j,3*nC),top_neigh_i(i,j,3*nC+2),top_neigh_i(i,j,3*nC+1))
          ENDDO
      ENDIF
   ENDDO
   ENDDO

   !make the image coord the origin (x,y,z,)=(0,0,0)
   DO i=its,i_end
   DO j=jts,j_end
      DO nC=0,ant(i,j)-1
         top_neigh(i,j,3*nC  ) = top_neigh(i,j,3*nC  )-top_img(i,j,4)
         top_neigh(i,j,3*nC+1) = top_neigh(i,j,3*nC+1)-top_img(i,j,5)
         top_neigh(i,j,3*nC+2) = top_neigh(i,j,3*nC+2)-top_img(i,j,6)
      ENDDO
   ENDDO
   ENDDO 

END SUBROUTINE get_top_pts_idw_3d

!--------------------------------------------------------------------------------

SUBROUTINE get_side_pts_idw_3d( stag, bc_type,                &
                                ibm_nn_horz,                  &
                                ibm_nn_vert,                  &
                                dx, dy,                       &
                                ht_p,                         &
                                inside,                       &
                                inside_all,                   & !RSA
                                recon_pts_as_neigh,           & !RSA
                                in_vel_recon,                 & !RSA
                                side, side_img, side_bound,   &
                                side_neigh, side_neigh_i,     &
                                n, np, ans,                   &
                                ids, ide, jds, jde, kds, kde, &
                                ims, ime, jms, jme, kms, kme, &
                                its, ite, jts, jte, kts, kte )

 IMPLICIT NONE
 !input data 
 INTEGER, INTENT(IN   )                                    :: stag,        & !stagger of the neighbors to be found (1=u, 2=v, 3=w)
                                                              bc_type,     &
                                                              ibm_nn_horz, &
                                                              ibm_nn_vert
 REAL, INTENT(IN   )                                       :: dx,dy
 REAL, DIMENSION(ims:ime,kms:kme,jms:jme), INTENT(IN   )   :: ht_p
 INTEGER, DIMENSION(ims:ime,kms:kme,jms:jme), INTENT(IN  ) :: inside         !one if the pt is inside boundary, zero if it is outside
 INTEGER, DIMENSION(ims:ime,kms:kme,jms:jme), INTENT(IN  ) :: inside_all     !RSA inside includes recon pts, inside_all does not
 LOGICAL, INTENT(IN   )                                    :: recon_pts_as_neigh, in_vel_recon !RSA
 INTEGER, DIMENSION(3,np), INTENT(IN   )                   :: side           !'side boundary' ghost points
 REAL, DIMENSION(6,np), INTENT(IN   )                      :: side_img       !(x,y,z) location of ghost point and image point of the 'side boundary' ghost points 
 REAL, DIMENSION(3,np), INTENT(IN   )                      :: side_bound     !(x,y,z) location of the boundary for side points
 REAL, DIMENSION(0:3*n-1,np), INTENT(  OUT)                :: side_neigh     !(x,y,z) location of neighbors
 INTEGER, DIMENSION(0:3*n-1,np), INTENT(  OUT)             :: side_neigh_i   !(i,j,k) location of neighbors
 INTEGER, INTENT(IN   )                                    :: n,           & !desired number of nearest neighbors
                                                              np             !number of side ghost points
 INTEGER, DIMENSION(np), INTENT(  OUT)                     :: ans            !actual number of nearest neighbors side
 INTEGER, INTENT(IN   )                   :: ids, ide, jds, jde, kds, kde, & !d: domain
                                             ims, ime, jms, jme, kms, kme, & !m: memory
                                             its, ite, jts, jte, kts, kte    !p: patch, t: tile
 !local data
 INTEGER                                                  :: S,            & 
                                                             nC,           &
                                                             ii, ji, ki,   &
                                                             is, js, ks,   &
                                                             count
 REAL                                                     :: a,b,c
 REAL, DIMENSION(ibm_nn_vert*ibm_nn_horz**2)              :: dist
 INTEGER, DIMENSION(n)                                    :: index_rank
 INTEGER, DIMENSION(ibm_nn_vert*ibm_nn_horz**2,3)         :: index_store

!-----------------------------------------------------------------------------------
 !the executable begins here
 !this subroutine stores the (i,j,k) index and (x,y,z) location of the eight
 !neighbors of a side image point.
 CALL wrf_debug(100,'dyn_em/module_ibm.F/subroutine get_side_pts_idw_3d')
!------------------------------------------------------------------------------------

 DO S=1,np
    !find neighbors of the image point
    IF ((stag .EQ. 1) .OR. (stag .EQ. 4)) THEN
       ii = ceiling(side_img(4,S)/dx)
    ELSEIF ((stag .EQ. 2) .OR. (stag .EQ. 3)) THEN
       ii = ceiling((side_img(4,S)-(dx/2))/dx)
    ENDIF
    IF ((stag .EQ. 2) .OR. (stag .EQ. 4)) THEN
       ji = ceiling(side_img(5,S)/dy)
    ELSEIF ((stag .EQ. 1) .OR. (stag .EQ. 3)) THEN
       ji = ceiling((side_img(5,S)-(dy/2))/dy)
    ENDIF
    ki = 1
    DO WHILE (side_img(6,S) .GE. ht_p(side(1,S),ki,side(2,S)))
       ki=ki+1
    ENDDO
    ki = ki-1
    ki = max(ki,ibm_nn_vert/2)
    !look at the closest 64 points, and determine which are outside the terrain
    !calculate the distance of those points that are outside the terrain
    dist = 0.0
    index_rank = 0
    index_store = 0
    count = 0
    DO is=ii-ibm_nn_horz/2+1,ii+ibm_nn_horz/2
    DO ks=ki-ibm_nn_vert/2+1,ki+ibm_nn_vert/2
    DO js=ji-ibm_nn_horz/2+1,ji+ibm_nn_horz/2
       !see if it could possibly be a neighbor by checking that it is outside of terrain
       IF (inside(is,ks,js) .EQ. 0) THEN
          count = count +1
          IF (stag .EQ. 1) THEN
              a = (is*dx)-(dx)-side_img(4,S)
              b = (js*dy)-(dy/2)-side_img(5,S)
          ELSEIF (stag .EQ. 2) THEN
              a = (is*dx)-(dx/2)-side_img(4,S)
              b = (js*dy)-(dy)-side_img(5,S)
          ELSEIF (stag .EQ. 3) THEN
              a = (is*dx)-(dx/2)-side_img(4,S)
              b = (js*dy)-(dy/2)-side_img(5,S)
          ELSEIF (stag .EQ. 4) THEN
              a = (is*dx)-(dx)-side_img(4,S)
              b = (js*dy)-(dy)-side_img(5,S)
          ENDIF
          c = ht_p(is,ks,js)-side_img(6,S)
          dist(count) = SQRT(a**2+b**2+c**2)
          index_store(count,1:3) = [is,js,ks]
       ENDIF
    ENDDO 
    ENDDO
    ENDDO
   
    !RSA if no neighbors are found and we are in a vel recon routine, retry including reconstruction pts as neighbors
    IF (recon_pts_as_neigh .and. in_vel_recon) THEN
       IF (count .EQ. 0) THEN
          dist = 0.0
          index_rank = 0
          index_store = 0
          count = 0
          DO is=ii-ibm_nn_horz/2+1,ii+ibm_nn_horz/2
          DO ks=ki-ibm_nn_vert/2+1,ki+ibm_nn_vert/2
          DO js=ji-ibm_nn_horz/2+1,ji+ibm_nn_horz/2
             !see if it could possibly be a neighbor by checking that it is outside of terrain
             IF (inside_all(is,ks,js) .EQ. 0) THEN
                count = count +1
                IF (stag .EQ. 1) THEN
                    a = (is*dx)-(dx)-side_img(4,S)
                    b = (js*dy)-(dy/2)-side_img(5,S)
                ELSEIF (stag .EQ. 2) THEN
                    a = (is*dx)-(dx/2)-side_img(4,S)
                    b = (js*dy)-(dy)-side_img(5,S)
                ELSEIF (stag .EQ. 3) THEN
                    a = (is*dx)-(dx/2)-side_img(4,S)
                    b = (js*dy)-(dy/2)-side_img(5,S)
                ENDIF
                c = ht_p(is,ks,js)-side_img(6,S)
                dist(count) = SQRT(a**2+b**2+c**2)
                index_store(count,1:3) = [is,js,ks]
             ENDIF
          ENDDO 
          ENDDO
          ENDDO
          write(*,'(3(A,1i5))') "RSA[module_ibm/get_side_pts_idw_3d]: using recon pts as neighbors. S=",S," count=",count," for stag=",stag
       ENDIF
    ELSE !RSA original code
       ! print *,count
       !if (count < n) write(*,'((A),1i5,(A),1i5,(A),1i5,(A),1i5)') 'get_side_pts_idw only',count,' neighbors at S=',S,' for stag =',stag,' for bc =', bc_type
    ENDIF !RSA

    IF (bc_type .EQ. 1) THEN
       IF (count .LT. n-1) THEN
          ans(S) = count+1
       ELSE
          ans(S) = n
       ENDIF
       !the first neighbor is the boundary point
       nC = 0
       side_neigh_i(3*nC,  S) = 0
       side_neigh_i(3*nC+1,S) = 0
       side_neigh_i(3*nC+2,S) = 0 
       side_neigh(3*nC,  S) = side_bound(1,S)
       side_neigh(3*nC+1,S) = side_bound(2,S)
       side_neigh(3*nC+2,S) = side_bound(3,S)
       CALL rnkpar(dist(1:count),index_rank,ans(S)-1)
       DO nC=1,ans(S)-1
          side_neigh_i(3*nC,  S) = index_store(index_rank(nC),1)
          side_neigh_i(3*nC+1,S) = index_store(index_rank(nC),2)
          side_neigh_i(3*nC+2,S) = index_store(index_rank(nC),3)
          IF (stag .EQ. 1) THEN
              side_neigh(3*nC,S) = (side_neigh_i(3*nC,S)*dx)-(dx)
              side_neigh(3*nC+1,S) = (side_neigh_i(3*nC+1,S)*dy)-(dy/2)
          ELSEIF (stag .EQ. 2) THEN
              side_neigh(3*nC,S) = (side_neigh_i(3*nC,S)*dx)-(dx/2)
              side_neigh(3*nC+1,S) = (side_neigh_i(3*nC+1,S)*dy)-(dy)
          ELSEIF (stag .EQ. 3) THEN
              side_neigh(3*nC,S) = (side_neigh_i(3*nC,S)*dx)-(dx/2)
              side_neigh(3*nC+1,S) = (side_neigh_i(3*nC+1,S)*dy)-(dy/2)
          ELSEIF (stag .EQ. 4) THEN
              side_neigh(3*nC,S) = (side_neigh_i(3*nC,S)*dx)-(dx)
              side_neigh(3*nC+1,S) = (side_neigh_i(3*nC+1,S)*dy)-(dy)
          ENDIF
          side_neigh(3*nC+2,S) = ht_p(side_neigh_i(3*nC,S),side_neigh_i(3*nC+2,S),side_neigh_i(3*nC+1,S))  
       ENDDO
    ELSEIF (bc_type .EQ. 2) THEN
       IF (count .LT. n) THEN
          ans(S) = count
       ELSE
          ans(S) = n
       ENDIF
       CALL rnkpar(dist(1:count),index_rank,ans(S))
       DO nC = 0,ans(S)-1
          side_neigh_i(3*nC,  S) = index_store(index_rank(nC+1),1)
          side_neigh_i(3*nC+1,S) = index_store(index_rank(nC+1),2)
          side_neigh_i(3*nC+2,S) = index_store(index_rank(nC+1),3)
          IF (stag .EQ. 1 ) THEN
              side_neigh(3*nC,S) = (side_neigh_i(3*nC,S)*dx)-(dx)
              side_neigh(3*nC+1,S) = (side_neigh_i(3*nC+1,S)*dy)-(dy/2)
          ELSEIF (stag .EQ. 2) THEN
              side_neigh(3*nC,S) = (side_neigh_i(3*nC,S)*dx)-(dx/2)
              side_neigh(3*nC+1,S) = (side_neigh_i(3*nC+1,S)*dy)-(dy)
          ELSEIF (stag .EQ. 3) THEN
              side_neigh(3*nC,S) = (side_neigh_i(3*nC,S)*dx)-(dx/2)
              side_neigh(3*nC+1,S) = (side_neigh_i(3*nC+1,S)*dy)-(dy/2)
          ELSEIF (stag .EQ. 4) THEN
              side_neigh(3*nC,S) = (side_neigh_i(3*nC,S)*dx)-(dx)
              side_neigh(3*nC+1,S) = (side_neigh_i(3*nC+1,S)*dy)-(dy)
          ENDIF
          side_neigh(3*nC+2,S) = ht_p(side_neigh_i(3*nC,S),side_neigh_i(3*nC+2,S),side_neigh_i(3*nC+1,S))  
       ENDDO
    ENDIF
 ENDDO

 !make the image coord the origin (x,y,z,)=(0,0,0)
 DO S=1,np
    DO nC=0,ans(S)-1
       side_neigh(3*nC,S)   = side_neigh(3*nC,  S)-side_img(4,S)
       side_neigh(3*nC+1,S) = side_neigh(3*nC+1,S)-side_img(5,S)
       side_neigh(3*nC+2,S) = side_neigh(3*nC+2,S)-side_img(6,S)     
    ENDDO
 ENDDO

 !make the ghost point coord the origin (x,y,z,)=(0,0,0)
! DO S=1,np
! DO nC=0,n-1
!    side_neigh(3*nC,S) = side_neigh(3*nC,S)-side_img(1,S)
!    side_neigh(3*nC+1,S) = side_neigh(3*nC+1,S)-side_img(2,S)
!    side_neigh(3*nC+2,S) = side_neigh(3*nC+2,S)-side_img(3,S)     
! ENDDO
! ENDDO    

END SUBROUTINE get_side_pts_idw_3d

!------------------------------------------------------------------------------------    

SUBROUTINE get_top_pts_3d( stag, bc_type,                &
                           dx, dy, prox,                 &
                           ibm_ht,                       &
			   ibm_ht_xstag, ibm_ht_ystag,   &
                           ht_p,                         &
			   inside,                       &
			   top, top_img, top_bound,      &
			   top_neigh, top_neigh_i,       &
			   n,                            &
			   ids, ide, jds, jde, kds, kde, &
                           ims, ime, jms, jme, kms, kme, &
                           its, ite, jts, jte, kts, kte)
 IMPLICIT NONE
! input data
 INTEGER, INTENT(IN   )                                    :: stag,       &
                                                              bc_type 
 REAL, INTENT(IN   )                                       :: dx,dy
 INTEGER, DIMENSION(ims:ime,jms:jme), INTENT(IN   )        :: prox
 REAL, DIMENSION(ims:ime,jms:jme), INTENT(IN   )           :: ibm_ht,     &
                                                              ibm_ht_xstag,&
							      ibm_ht_ystag
 REAL, DIMENSION(ims:ime,kms:kme,jms:jme), INTENT(IN   )   :: ht_p            ! ht at the points being computed	     
 INTEGER, DIMENSION(ims:ime,kms:kme,jms:jme), INTENT(IN  ) :: inside          ! one if the pt is inside boundary, zero if it is outside
 INTEGER, DIMENSION(ims:ime,jms:jme), INTENT(IN   )        :: top             !'top boundary' ghost points					      
 REAL, DIMENSION(ims:ime,jms:jme,6), INTENT(IN   )         :: top_img         ! (x,y,z) location of ghost point and image point of the 'top boundary' ghost points
 REAL, DIMENSION(ims:ime,jms:jme,3), INTENT(IN   )         :: top_bound       ! (x,y,z) location of the boundary for top point
 REAL, DIMENSION(ims:ime,jms:jme,0:3*n-1), INTENT(  OUT)   :: top_neigh       ! (x,y,z) location of  neighbors
 INTEGER, DIMENSION(ims:ime,jms:jme,0:3*n-1), INTENT(  OUT):: top_neigh_i     ! (i,j,k) index of top neighbors
 INTEGER, INTENT(IN   )                                    :: n               ! desired number of nearest neighbors
 INTEGER, INTENT(IN   )                   :: ids, ide, jds, jde, kds, kde, &  ! d: domain m:memory p:patch t:tile
                                             ims, ime, jms, jme, kms, kme, &
                                             its, ite, jts, jte, kts, kte		   

!local data
 INTEGER                                                   :: i,j,       & 
                                                              i_end,     &
							      j_end,     &
                                                              nC,        &
							      test_k
  INTEGER, DIMENSION(0:n-1)                                :: ii,ji,ki	
  REAL                                                     :: ht_stag, dist						        							      
   
!--------------------------------------------------------------------------------
! the executable begins here
! this subroutine stores the (i,j,k) index and (x,y,z) location of the eight 
! neighbors of a top image point.
! numbering order is 01   45
!                    23   67
 CALL wrf_debug(100, 'dyn_em/module_ibm.F/subroutine get_top_pts_3d')
!-------------------------------------------------------------------------------- 

! dist is the percent of dz that the grid must vary by in order to start choosing
! neighbors that are not rectangular
dist = 0.10

! initalize the arrays
!top_neigh = 0.
!top_neigh_i = 0

 IF (stag == 1) THEN
    i_end = ite
    j_end = MIN(jte,jde-1)
 ELSEIF (stag == 2) THEN
    i_end = MIN(ite,ide-1)
    j_end = jte
 ELSEIF (stag == 3) THEN
    i_end = MIN(ite,ide-1)
    j_end = MIN(jte,jde-1)
 ENDIF

 DO i=its,i_end
 DO j=jts,j_end
    
    ! identify the eight nearest computational nodes regardless of being fluid or solid nodes
!    IF (bc_type == 1) THEN  
       ! find  neighbors of the image point 
       ! the point is between x1 and x2
       ! if it is exactly on an x grid value, then x1 is to the left of the image point
       ! and x2 is the x location of the image point, unless the terrain slope is negative
       ! then the if mod test moves the neighbors so that x1 is the location of the image
       ! point, and x2 is to the right
       if (stag == 1) then
          do nC = 0,6,2
	     ii(nC) = ceiling(top_img(i,j,4)/dx) 
	  enddo
	  do nC = 1,7,2
	     ii(nC) = ceiling(top_img(i,j,4)/dx)+1
	  enddo
	  if ((MOD(top_img(i,j,4),dx)==0).AND.(ibm_ht_xstag(i-1,j)>ibm_ht_xstag(i,j))) then
	      ii = ii+1
	  endif     
       elseif ((stag == 2).OR.(stag == 3)) then 
          do nC = 0,6,2
	     ii(nC) = ceiling((top_img(i,j,4)-(dx/2))/dx)
	  enddo
	  do nC = 1,7,2
	     ii(nC) = ceiling((top_img(i,j,4)-(dx/2))/dx)+1
	  enddo        
	  if ((MOD(top_img(i,j,4)-(dx/2),dx)==0).AND.(ibm_ht_xstag(i,j)>ibm_ht_xstag(i+1,j))) then
	      ii = ii+1
	  endif 
       endif  
       ! get j indicies
       if (stag == 2) then
          do nC = 0,3
	     ji(nC) = ceiling(top_img(i,j,5)/dy) 
	  enddo
	  do nC = 4,7   
	     ji(nC) = ceiling(top_img(i,j,5)/dy)+1
	  enddo	
	  if ((MOD(top_img(i,j,5),dy)==0).AND.(ibm_ht_ystag(i,j-1)>ibm_ht_ystag(i,j))) then
	      ji = ji+1
	  endif 	  
       elseif ((stag == 1).OR.(stag == 3)) then 
          do nC = 0,3
	     ji(nC) = ceiling((top_img(i,j,5)-(dy/2))/dy) 
	  enddo
	  do nC = 4,7  	     
	     ji(nC) = ceiling((top_img(i,j,5)-(dy/2))/dy)+1
	  enddo
	  if ((MOD(top_img(i,j,5)-(dy/2),dy)==0).AND.(ibm_ht_ystag(i,j)>ibm_ht_ystag(i,j+1))) then
	      ji = ji+1
	  endif 
       endif  
!   ELSEIF (bc_type == 2) THEN  
!      ! find  neighbors of the boundary point
!      ! the point is between x1 and x2
!      ! if it is exactly on an x grid value, then x1 is to the left of the image point
!      ! and x2 is the x location of the image point, unless the terrain slope is negative
!      ! then the if mod test moves the neighbors so that x1 is the location of the image
!      ! point, and x2 is to the right
!      if (stag == 1) then
!	 do nC = 0,6,2
!	    ii(nC) = ceiling(top_bound(i,j,1)/dx) 
!	 enddo
!	 do nC = 1,7,2
!	    ii(nC) = ceiling(top_bound(i,j,1)/dx)+1
!	 enddo
!	 if ((MOD(top_bound(i,j,1),dx)==0).AND.(ibm_ht(i-1,j)>ibm_ht(i,j))) then
!	     ii = ii+1
!	 endif      
!      elseif ((stag == 2).OR.(stag == 3)) then
!	 do nC = 0,6,2
!	    ii(nC) = ceiling((top_bound(i,j,1)-(dx/2))/dx) 
!	 enddo
!	 do nC = 1,7,2
!	    ii(nC) = ceiling((top_bound(i,j,1)-(dx/2))/dx)+1
!	 enddo
!	 if ((MOD(top_bound(i,j,1)-(dx/2),dx)==0).AND.(ibm_ht(i-1,j)>ibm_ht(i,j))) then
!	     ii = ii+1
!	 endif  
!     endif  
!     ! get j indicies     
!     if (stag == 2) then
!	  do nC = 0,3
!	     ji(nC) = ceiling(top_bound(i,j,2)/dy) 
!	  enddo
!	  do nC = 4,7	
!	     ji(nC) = ceiling(top_bound(i,j,2)/dy)+1
!	  enddo 
!	  if ((MOD(top_bound(i,j,2),dy)==0).AND.((ibm_ht(i,j-1)>ibm_ht(i,j)).OR.(ibm_ht(i-1,j-1)>ibm_ht(i,j)))) then
!	      ji = ji+1
!	  endif 
!      elseif ((stag == 1).OR.(stag == 3)) then 
!	  do nC = 0,3
!	     ji(nC) = ceiling((top_bound(i,j,2)-(dy/2))/dy) 
!	  enddo
!	  do nC = 4,7	     
!	     ji(nC) = ceiling((top_bound(i,j,2)-(dy/2))/dy)+1
!	  enddo
!	  if ((MOD(top_bound(i,j,2)-(dy/2),dy)==0).AND.((ibm_ht(i,j-1)>ibm_ht(i,j)).OR.(ibm_ht(i-1,j-1)>ibm_ht(i,j)))) then
!	      ji = ji+1
!	  endif 
!      endif  
!   ENDIF ! end of bc_type equals 1 or 2
    ! get k indicies
    test_k = MIN(top(ii(0),ji(0)),top(ii(1),ji(1)),top(ii(4),ji(4)),top(ii(5),ji(5)))
    ki = MIN(top(ii(0),ji(0)),top(ii(1),ji(1)),top(ii(4),ji(4)),top(ii(5),ji(5)))
!    IF (bc_type == 1) THEN  
       do while (top_img(i,j,6) >= ht_p(i,test_k,j))
	     test_k=test_k+1
       enddo
       do nC = 0,1
	 do while (top_img(i,j,6) >= ht_p(ii(nC),ki(nC),ji(nC)))
	     ki(nC)=ki(nC)+1
	 enddo
	 !if (ki(nC)<test_k) write(*,'(6i5,1f20.8)') stag,i,j,nC,ki(nC),test_k,(ht_p(ii(nC),ki(nC),ji(nC))-top_img(i,j,6))/(ht_p(ii(nC),ki(nC),ji(nC))-ht_p(ii(nC),ki(nC)-1,ji(nC)))
	 if ((ki(nC)<test_k).AND.((ht_p(ii(nC),ki(nC),ji(nC))-top_img(i,j,6))/(ht_p(ii(nC),ki(nC),ji(nC))-ht_p(ii(nC),ki(nC)-1,ji(nC)))<dist)) ki(nC)=ki(nC)+1
	 ki(nC+2) = ki(nC)-1
       enddo
       do nC = 4,5
	 do while (top_img(i,j,6) >= ht_p(ii(nC),ki(nC),ji(nC)))
	     ki(nC)=ki(nC)+1
	 enddo
	 !if (ki(nC)<test_k) write(*,'(6i5,1f20.8)') stag,i,j,nC,ki(nC),test_k,(ht_p(ii(nC),ki(nC),ji(nC))-top_img(i,j,6))/(ht_p(ii(nC),ki(nC),ji(nC))-ht_p(ii(nC),ki(nC)-1,ji(nC)))
	 if ((ki(nC)<test_k).AND.((ht_p(ii(nC),ki(nC),ji(nC))-top_img(i,j,6))/(ht_p(ii(nC),ki(nC),ji(nC))-ht_p(ii(nC),ki(nC)-1,ji(nC)))<dist)) ki(nC)=ki(nC)+1
	 ki(nC+2) = ki(nC)-1
       enddo
!   ELSEIF (bc_type == 2) THEN    
!     if (prox(i,j) == 1) then
!	 do while (top_img(i,j,6) >= ht_p(i,test_k,j))
!	     test_k=test_k+1
!	 enddo
!	 do nC = 0,1
!	   do while (top_img(i,j,6) >= ht_p(ii(nC),ki(nC),ji(nC)))
!	       ki(nC)=ki(nC)+1
!	   enddo
!	   ! check 
!	   !if (ki(nC)<test_k) write(*,'(6i5,1f20.8)') stag,i,j,nC,ki(nC),test_k,(ht_p(ii(nC),ki(nC),ji(nC))-top_img(i,j,6))/(ht_p(ii(nC),ki(nC),ji(nC))-ht_p(ii(nC),ki(nC)-1,ji(nC)))
!	   if ((ki(nC)<test_k).AND.((ht_p(ii(nC),ki(nC),ji(nC))-top_img(i,j,6))/(ht_p(ii(nC),ki(nC),ji(nC))-ht_p(ii(nC),ki(nC)-1,ji(nC)))<dist)) ki(nC)=ki(nC)+1
!	   ki(nC+2) = ki(nC)-1
!	 enddo
!	do nC = 4,5
!	   do while (top_img(i,j,6) >= ht_p(ii(nC),ki(nC),ji(nC)))
!	       ki(nC)=ki(nC)+1
!	   enddo
!	   ! check 
!	   !if (ki(nC)<test_k) write(*,'(6i5,1f20.8)') stag,i,j,nC,ki(nC),test_k,(ht_p(ii(nC),ki(nC),ji(nC))-top_img(i,j,6))/(ht_p(ii(nC),ki(nC),ji(nC))-ht_p(ii(nC),ki(nC)-1,ji(nC)))
!	   if ((ki(nC)<test_k).AND.((ht_p(ii(nC),ki(nC),ji(nC))-top_img(i,j,6))/(ht_p(ii(nC),ki(nC),ji(nC))-ht_p(ii(nC),ki(nC)-1,ji(nC)))<dist)) ki(nC)=ki(nC)+1
!	   ki(nC+2) = ki(nC)-1
!	 enddo
!     else
!	 do while (top_bound(i,j,3) >= ht_p(i,test_k,j))
!	     test_k=test_k+1
!	 enddo
!	 do nC = 0,1
!	   do while (top_bound(i,j,3) >= ht_p(ii(nC),ki(nC),ji(nC)))
!	       ki(nC)=ki(nC)+1
!	   enddo
!	   ! check 
!	   !if (ki(nC)<test_k) write(*,'(6i5,1f20.8)') stag,i,j,nC,ki(nC),test_k,(ht_p(ii(nC),ki(nC),ji(nC))-top_bound(i,j,3))/(ht_p(ii(nC),ki(nC),ji(nC))-ht_p(ii(nC),ki(nC)-1,ji(nC)))
!	   if ((ki(nC)<test_k).AND.((ht_p(ii(nC),ki(nC),ji(nC))-top_bound(i,j,3))/(ht_p(ii(nC),ki(nC),ji(nC))-ht_p(ii(nC),ki(nC)-1,ji(nC)))<dist)) ki(nC)=ki(nC)+1
!	   ki(nC+2) = ki(nC)-1
!	 enddo
!	 do nC = 4,5
!	   do while (top_bound(i,j,3) >= ht_p(ii(nC),ki(nC),ji(nC)))
!	       ki(nC)=ki(nC)+1
!	   enddo
!	   ! check 
!	   !if (ki(nC)<test_k) write(*,'(6i5,1f20.8)') stag,i,j,nC,ki(nC),test_k,(ht_p(ii(nC),ki(nC),ji(nC))-top_bound(i,j,3))/(ht_p(ii(nC),ki(nC),ji(nC))-ht_p(ii(nC),ki(nC)-1,ji(nC)))
!	   if ((ki(nC)<test_k).AND.((ht_p(ii(nC),ki(nC),ji(nC))-top_bound(i,j,3))/(ht_p(ii(nC),ki(nC),ji(nC))-ht_p(ii(nC),ki(nC)-1,ji(nC)))<dist)) ki(nC)=ki(nC)+1
!	   ki(nC+2) = ki(nC)-1
!	 enddo
!     endif	 
!   ENDIF 

    200 continue ! this is contining from points that have seven inside nodes, so I am moving them, and trying again
    IF	 ((inside(ii(0),ki(0),ji(0)) == 0).AND. &
	  (inside(ii(1),ki(1),ji(1)) == 0).AND. &
          (inside(ii(2),ki(2),ji(2)) == 0).AND. &
	  (inside(ii(3),ki(3),ji(3)) == 0).AND. &
	  (inside(ii(4),ki(4),ji(4)) == 0).AND. &
	  (inside(ii(5),ki(5),ji(5)) == 0).AND. &
	  (inside(ii(6),ki(6),ji(6)) == 0).AND. &
	  (inside(ii(7),ki(7),ji(7)) == 0)) THEN
	  ! neighbors 0,1,2,3,4,5,6,7 are the zero computational nodes
	  do nC = 0,7
	     top_neigh_i(i,j,3*nC) = ii(nC)
	     top_neigh_i(i,j,3*nC+1) = ji(nC)
	     top_neigh_i(i,j,3*nC+2) = ki(nC)		
	     if (stag ==1 ) then 			
		 top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx)
		 top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)
	     elseif (stag == 2) then
		 top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
		 top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy)	     
	     elseif (stag == 3) then
		 top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
		 top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)	     
	     endif
	     top_neigh(i,j,3*nC+2) = ht_p(top_neigh_i(i,j,3*nC),top_neigh_i(i,j,3*nC+2),top_neigh_i(i,j,3*nC+1))  
	  enddo 
    ELSEIF ((inside(ii(0),ki(0),ji(0)) == 0).AND. &
	   (inside(ii(1),ki(1),ji(1)) == 0).AND. &
	   (inside(ii(2),ki(2),ji(2)) == 1).AND. &
	   (inside(ii(3),ki(3),ji(3)) == 0).AND. &
	   (inside(ii(4),ki(4),ji(4)) == 0).AND. &
	   (inside(ii(5),ki(5),ji(5)) == 0).AND. &
	   (inside(ii(6),ki(6),ji(6)) == 0).AND. &
	   (inside(ii(7),ki(7),ji(7)) == 0)) THEN
	  ! neighbors 0,1,3,4,5,6,7 are the zero computational nodes
	  do nC = 0,1
	     top_neigh_i(i,j,3*nC) = ii(nC)
	     top_neigh_i(i,j,3*nC+1) = ji(nC)
	     top_neigh_i(i,j,3*nC+2) = ki(nC)		
	     if (stag ==1 ) then 			
		 top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx)
		 top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)
	     elseif (stag == 2) then
		 top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
		 top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy)	     
	     elseif (stag == 3) then
		 top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
		 top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)	     
	     endif
	     top_neigh(i,j,3*nC+2) = ht_p(top_neigh_i(i,j,3*nC),top_neigh_i(i,j,3*nC+2),top_neigh_i(i,j,3*nC+1))  
	  enddo
	  ! neighbor 2 is on the boundary at either the boundary point or (ii,jj,ibm_ht(ii,jj))
	  ! if the image point is below ibm_ht (like on corners), then choose the boundary point as the neighbor
	  nC = 2
	  !KAL changed from top_bound(i,j,3) to top_img(i,j,6)	  
	  if (top_img(i,j,6) <= ibm_ht(ii(nC),ji(nC))) then
	     !! neighbor 2 is the boundary point 
	     !top_neigh_i(i,j,3*nC) = 0
	     !top_neigh_i(i,j,3*nC+1) = 0
	     !top_neigh_i(i,j,3*nC+2) = 0
	     !top_neigh(i,j,3*nC) = top_bound(i,j,1)
	     !top_neigh(i,j,3*nC+1) = top_bound(i,j,2)
	     !top_neigh(i,j,3*nC+2) = top_bound(i,j,3)
	      ! neighbor 2 on the boundary on the 2367 plane
	      top_neigh_i(i,j,3*nC) = 0
	      top_neigh_i(i,j,3*nC+1) = 0
	      top_neigh_i(i,j,3*nC+2) = 0
	      ! first z
	      top_neigh(i,j,3*nC+2) = ht_p(ii(nC),ki(nC),ji(nC))
	      if (stag == 1) then
		  ! solve for x
		  if (ibm_ht_xstag(ii(nC),ji(nC)) >= top_neigh(i,j,3*nC+2)) then
		     top_neigh(i,j,3*nC) = (ii(nC)*dx)-dx + (dx/4)+(dx/4)*((top_neigh(i,j,3*nC+2)-ibm_ht_xstag(ii(nC),ji(nC))) &
						                	/(ibm_ht(ii(nC)+1,ji(nC))-ibm_ht_xstag(ii(nC),ji(nC))))
		  else
		     top_neigh(i,j,3*nC) = (ii(nC)*dx)-dx + (dx/4)*((top_neigh(i,j,3*nC+2)-ibm_ht(ii(nC),ji(nC))) &
							     /(ibm_ht_xstag(ii(nC),ji(nC))-ibm_ht(ii(nC),ji(nC))))
		  endif						  
	       	  ! solve for y
		  if (ibm_ht_ystag(ii(nC),ji(nC)+1) >= top_neigh(i,j,3*nC+2)) then
		     top_neigh(i,j,3*nC+1) = (ji(nC)*dy)-(dy/2) + (dy/4)+(dy/4)*((top_neigh(i,j,3*nC+2)-ibm_ht_ystag(ii(nC),ji(nC)+1)) &
						                              /(ibm_ht(ii(nC),ji(nC)+1)-ibm_ht_ystag(ii(nC),ji(nC)+1)))
		  else
		     top_neigh(i,j,3*nC+1) = (ji(nC)*dy)-(dy/2) + (dy/4)*((top_neigh(i,j,3*nC+2)-ibm_ht(ii(nC),ji(nC))) &
								 /(ibm_ht_ystag(ii(nC),ji(nC)+1)-ibm_ht(ii(nC),ji(nC))))
		  endif
	      elseif (stag == 2) then
		  ! solve for x
		  if (ibm_ht_xstag(ii(nC)+1,ji(nC)) >= top_neigh(i,j,3*nC+2)) then
		     top_neigh(i,j,3*nC) = (ii(nC)*dx)-(dx/2) + (dx/4)+(dx/4)*((top_neigh(i,j,3*nC+2)-ibm_ht_xstag(ii(nC)+1,ji(nC))) &
						                            /(ibm_ht(ii(nC)+1,ji(nC))-ibm_ht_xstag(ii(nC)+1,ji(nC))))
		  else
		     top_neigh(i,j,3*nC) = (ii(nC)*dx)-(dx/2) + (dx/4)*((top_neigh(i,j,3*nC+2)-ibm_ht(ii(nC),ji(nC))) &
						               /(ibm_ht_xstag(ii(nC)+1,ji(nC))-ibm_ht(ii(nC),ji(nC))))
		  endif
		  ! solve for y
		  if (ibm_ht_ystag(ii(nC),ji(nC)) >= top_neigh(i,j,3*nC+2)) then
		     top_neigh(i,j,3*nC+1) = (ji(nC)*dy)-dy + (dy/4)+(dy/4)*((top_neigh(i,j,3*nC+2)-ibm_ht_ystag(ii(nC),ji(nC))) &
						                          /(ibm_ht(ii(nC),ji(nC)+1)-ibm_ht_ystag(ii(nC),ji(nC))))
		  else
		     top_neigh(i,j,3*nC+1) = (ji(nC)*dy)-dy + (dy/4)*((top_neigh(i,j,3*nC+2)-ibm_ht(ii(nC),ji(nC))) &
						               /(ibm_ht_ystag(ii(nC),ji(nC))-ibm_ht(ii(nC),ji(nC))))
		  endif
	     elseif (stag == 3) then
		  ! solve for x
		  if (ibm_ht_xstag(ii(nC)+1,ji(nC)) >= top_neigh(i,j,3*nC+2)) then
		     top_neigh(i,j,3*nC) = (ii(nC)*dx)-(dx/2) + (dx/4)+(dx/4)*((top_neigh(i,j,3*nC+2)-ibm_ht_xstag(ii(nC)+1,ji(nC))) &
						                            /(ibm_ht(ii(nC)+1,ji(nC))-ibm_ht_xstag(ii(nC)+1,ji(nC))))
		  else
		     top_neigh(i,j,3*nC) = (ii(nC)*dx)-(dx/2) + (dx/4)*((top_neigh(i,j,3*nC+2)-ibm_ht(ii(nC),ji(nC))) &
						               /(ibm_ht_xstag(ii(nC)+1,ji(nC))-ibm_ht(ii(nC),ji(nC))))
		  endif
		  ! solve for y
		  if (ibm_ht_ystag(ii(nC),ji(nC)+1) >= top_neigh(i,j,3*nC+2)) then
		     top_neigh(i,j,3*nC+1) = (ji(nC)*dy)-(dy/2) + (dy/4)+(dy/4)*((top_neigh(i,j,3*nC+2)-ibm_ht_ystag(ii(nC),ji(nC)+1)) &
						                               /(ibm_ht(ii(nC),ji(nC)+1)-ibm_ht_ystag(ii(nC),ji(nC)+1)))
		  else
		     top_neigh(i,j,3*nC+1) = (ji(nC)*dy)-(dy/2) + (dy/4)*((top_neigh(i,j,3*nC+2)-ibm_ht(ii(nC),ji(nC))) &
								 /(ibm_ht_ystag(ii(nC),ji(nC)+1)-ibm_ht(ii(nC),ji(nC))))
		  endif
	     endif
	  else
	     ! neighbor 2 is at (ii,jj,ibm_ht(ii,jj)) on the boundary 
	     top_neigh_i(i,j,3*nC) = ii(nC)
	     top_neigh_i(i,j,3*nC+1) = ji(nC)
	     top_neigh_i(i,j,3*nC+2) = 0		
	     if (stag ==1 ) then 			
		 top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx)
		 top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)
	     elseif (stag == 2) then
		 top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
		 top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy)	     
	     elseif (stag == 3) then
		 top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
		 top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)	     
	     endif
	     top_neigh(i,j,3*nC+2) = ibm_ht(top_neigh_i(i,j,3*nC),top_neigh_i(i,j,3*nC+1))
	  endif 
	  do nC = 3,7
	     top_neigh_i(i,j,3*nC) = ii(nC)
	     top_neigh_i(i,j,3*nC+1) = ji(nC)
	     top_neigh_i(i,j,3*nC+2) = ki(nC)		
	     if (stag ==1 ) then 			
		 top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx)
		 top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)
	     elseif (stag == 2) then
		 top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
		 top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy)	     
	     elseif (stag == 3) then
		 top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
		 top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)	     
	     endif
	     top_neigh(i,j,3*nC+2) = ht_p(top_neigh_i(i,j,3*nC),top_neigh_i(i,j,3*nC+2),top_neigh_i(i,j,3*nC+1))  
	  enddo
    ELSEIF ((inside(ii(0),ki(0),ji(0)) == 0).AND. &
	   (inside(ii(1),ki(1),ji(1)) == 0).AND. &
	   (inside(ii(2),ki(2),ji(2)) == 0).AND. &
	   (inside(ii(3),ki(3),ji(3)) == 1).AND. &
	   (inside(ii(4),ki(4),ji(4)) == 0).AND. &
	   (inside(ii(5),ki(5),ji(5)) == 0).AND. &
	   (inside(ii(6),ki(6),ji(6)) == 0).AND. &
	   (inside(ii(7),ki(7),ji(7)) == 0)) THEN
	  ! neighbors 0,1,2,4,5,6,7 are the zero computational nodes
	  do nC = 0,2
	     top_neigh_i(i,j,3*nC) = ii(nC)
	     top_neigh_i(i,j,3*nC+1) = ji(nC)
	     top_neigh_i(i,j,3*nC+2) = ki(nC)		
	     if (stag ==1 ) then 			
		 top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx)
		 top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)
	     elseif (stag == 2) then
		 top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
		 top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy)	     
	     elseif (stag == 3) then
		 top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
		 top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)	     
	     endif
	     top_neigh(i,j,3*nC+2) = ht_p(top_neigh_i(i,j,3*nC),top_neigh_i(i,j,3*nC+2),top_neigh_i(i,j,3*nC+1))  
	  enddo
	  ! neighbor 3 is on the boundary at either the boundary point or (ii,jj,ibm_ht(ii,jj)) 
	  ! if the image point is below ibm_ht (like on corners), then choose the boundary point as the neighbor
	  nC = 3	  
	  !KAL changed from top_bound(i,j,3) to top_img(i,j,6)
	  if (top_img(i,j,6) <= ibm_ht(ii(nC),ji(nC))) then
	     !! neighbor 3 is the boundary point 
	     !top_neigh_i(i,j,3*nC) = 0
	     !top_neigh_i(i,j,3*nC+1) = 0
	     !top_neigh_i(i,j,3*nC+2) = 0
	     !top_neigh(i,j,3*nC) = top_bound(i,j,1)
	     !top_neigh(i,j,3*nC+1) = top_bound(i,j,2)
	     !top_neigh(i,j,3*nC+2) = top_bound(i,j,3)
	     ! neighbor 3 on the boundary face that cuts the 2367 plane
	     top_neigh_i(i,j,3*nC) = 0
	     top_neigh_i(i,j,3*nC+1) = 0
	     top_neigh_i(i,j,3*nC+2) = 0
	     ! first z
	     top_neigh(i,j,3*nC+2) = ht_p(ii(nC),ki(nC),ji(nC))
	     if (stag == 1) then
		 ! solve for x/2
		 if (ibm_ht_xstag(ii(nC)-1,ji(nC)) >= top_neigh(i,j,3*nC+2)) then
		    top_neigh(i,j,3*nC) = ((ii(nC)-1)*dx)-dx + (dx/2)+(dx/4)*((top_neigh(i,j,3*nC+2)-ibm_ht(ii(nC)-1,ji(nC))) &
						                     /(ibm_ht_xstag(ii(nC)-1,ji(nC))-ibm_ht(ii(nC)-1,ji(nC))))
		 else
		    top_neigh(i,j,3*nC) = ((ii(nC)-1)*dx)-(dx/2) +  (dx/4)+(dx/4)*((top_neigh(i,j,3*nC+2)-ibm_ht_xstag(ii(nC)-1,ji(nC))) &
							                          /(ibm_ht(ii(nC),ji(nC))-ibm_ht_xstag(ii(nC)-1,ji(nC))))
		 endif	
		 ! solve for y/2
		 if (ibm_ht_ystag(ii(nC),ji(nC)+1) >= top_neigh(i,j,3*nC+2)) then
		    top_neigh(i,j,3*nC+1) = (ji(nC)*dy)-(dy/2) + (dy/4)+(dy/4)*((top_neigh(i,j,3*nC+2)-ibm_ht_ystag(ii(nC),ji(nC)+1)) &
						                             /(ibm_ht(ii(nC),ji(nC)+1)-ibm_ht_ystag(ii(nC),ji(nC)+1)))
		 else 
		    top_neigh(i,j,3*nC+1) = (ji(nC)*dy)-(dy/2) + (dy/4)*((top_neigh(i,j,3*nC+2)-ibm_ht(ii(nC),ji(nC))) &
						        	/(ibm_ht_ystag(ii(nC),ji(nC)+1)-ibm_ht(ii(nC),ji(nC))))
		 endif					  
	     elseif (stag == 2) then
		 ! solve for x/2
		 if (ibm_ht_xstag(ii(nC),ji(nC)) >= top_neigh(i,j,3*nC+2)) then
		    top_neigh(i,j,3*nC) = ((ii(nC)-1)*dx)-(dx/2) +  (dx/2)+(dx/4)*((top_neigh(i,j,3*nC+2)-ibm_ht(ii(nC)-1,ji(nC))) &
						                            /(ibm_ht_xstag(ii(nC),ji(nC))-ibm_ht(ii(nC)-1,ji(nC))))
		 else
		    top_neigh(i,j,3*nC) = (ii(nC)*dx)-dx +  (dx/4)+(dx/4)*((top_neigh(i,j,3*nC+2)-ibm_ht_xstag(ii(nC),ji(nC))) &
						                          /(ibm_ht(ii(nC),ji(nC))-ibm_ht_xstag(ii(nC),ji(nC))))
		 endif
		 ! solve for y/2
		 if (ibm_ht_ystag(ii(nC),ji(nC)) >= top_neigh(i,j,3*nC+2)) then
		    top_neigh(i,j,3*nC+1) = (ji(nC)*dy)-dy + (dy/4)+(dy/4)*((top_neigh(i,j,3*nC+2)-ibm_ht_ystag(ii(nC),ji(nC))) &
						                      /(ibm_ht(ii(nC),ji(nC)+1)-ibm_ht_ystag(ii(nC),ji(nC))))
		 else
		    top_neigh(i,j,3*nC+1) = (ji(nC)*dy)-dy + (dy/4)*((top_neigh(i,j,3*nC+2)-ibm_ht(ii(nC),ji(nC))) &
						              /(ibm_ht_ystag(ii(nC),ji(nC))-ibm_ht(ii(nC),ji(nC))))
		 endif
	     elseif (stag == 3) then
		 ! solve for x/2
		 if (ibm_ht_xstag(ii(nC),ji(nC)) >= top_neigh(i,j,3*nC+2)) then
		    top_neigh(i,j,3*nC) = ((ii(nC)-1)*dx)-(dx/2) +  (dx/2)+(dx/4)*((top_neigh(i,j,3*nC+2)-ibm_ht(ii(nC)-1,ji(nC))) &
						                            /(ibm_ht_xstag(ii(nC),ji(nC))-ibm_ht(ii(nC)-1,ji(nC))))
		 else
		    top_neigh(i,j,3*nC) = (ii(nC)*dx)-dx +  (dx/4)+(dx/4)*((top_neigh(i,j,3*nC+2)-ibm_ht_xstag(ii(nC),ji(nC))) &
						                          /(ibm_ht(ii(nC),ji(nC))-ibm_ht_xstag(ii(nC),ji(nC))))
		 endif
		 ! solve for y/2
		 if (ibm_ht_ystag(ii(nC),ji(nC)+1) >= top_neigh(i,j,3*nC+2)) then
		    top_neigh(i,j,3*nC+1) = (ji(nC)*dy)-(dy/2) + (dy/4)+(dy/4)*((top_neigh(i,j,3*nC+2)-ibm_ht_ystag(ii(nC),ji(nC)+1)) &
						                             /(ibm_ht(ii(nC),ji(nC)+1)-ibm_ht_ystag(ii(nC),ji(nC)+1)))
		 else
		    top_neigh(i,j,3*nC+1) = (ji(nC)*dy)-(dy/2) + (dy/4)*((top_neigh(i,j,3*nC+2)-ibm_ht(ii(nC),ji(nC))) &
								/(ibm_ht_ystag(ii(nC),ji(nC)+1)-ibm_ht(ii(nC),ji(nC))))
		 endif
	     endif	  
	  else
	     ! neighbor 3 is at (ii,jj,ibm_ht(ii,jj)) on the boundary 
	     top_neigh_i(i,j,3*nC) = ii(nC)
	     top_neigh_i(i,j,3*nC+1) = ji(nC)
	     top_neigh_i(i,j,3*nC+2) = 0		
	     if (stag ==1 ) then 			
		 top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx)
		 top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)
	     elseif (stag == 2) then
		 top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
		 top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy)	     
	     elseif (stag == 3) then
		 top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
		 top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)	     
	     endif
	     top_neigh(i,j,3*nC+2) = ibm_ht(top_neigh_i(i,j,3*nC),top_neigh_i(i,j,3*nC+1))
	  endif  	 
	  ! neighbors 0,1,2,4,5,6,7 are the zero computational nodes
	  do nC = 4,7
	     top_neigh_i(i,j,3*nC) = ii(nC)
	     top_neigh_i(i,j,3*nC+1) = ji(nC)
	     top_neigh_i(i,j,3*nC+2) = ki(nC)		
	     if (stag ==1 ) then 			
		 top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx)
		 top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)
	     elseif (stag == 2) then
		 top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
		 top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy)	     
	     elseif (stag == 3) then
		 top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
		 top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)	     
	     endif
	     top_neigh(i,j,3*nC+2) = ht_p(top_neigh_i(i,j,3*nC),top_neigh_i(i,j,3*nC+2),top_neigh_i(i,j,3*nC+1))  
	  enddo
    ELSEIF ((inside(ii(0),ki(0),ji(0)) == 0).AND. &
	    (inside(ii(1),ki(1),ji(1)) == 0).AND. &
	    (inside(ii(2),ki(2),ji(2)) == 0).AND. &
	    (inside(ii(3),ki(3),ji(3)) == 0).AND. &
	    (inside(ii(4),ki(4),ji(4)) == 0).AND. &
	    (inside(ii(5),ki(5),ji(5)) == 0).AND. &
	    (inside(ii(6),ki(6),ji(6)) == 1).AND. &
	    (inside(ii(7),ki(7),ji(7)) == 0)) THEN
	  ! neighbors 0,1,2,3,4,5,7 are the zero computational nodes
	  do nC = 0,5
	     top_neigh_i(i,j,3*nC) = ii(nC)
	     top_neigh_i(i,j,3*nC+1) = ji(nC)
	     top_neigh_i(i,j,3*nC+2) = ki(nC)		
	     if (stag ==1 ) then 			
		 top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx)
		 top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)
	     elseif (stag == 2) then
		 top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
		 top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy)	     
	     elseif (stag == 3) then
		 top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
		 top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)	     
	     endif
	     top_neigh(i,j,3*nC+2) = ht_p(top_neigh_i(i,j,3*nC),top_neigh_i(i,j,3*nC+2),top_neigh_i(i,j,3*nC+1))  
	  enddo 
	  ! neighbor 6 is on the boundary at either the boundary point or (ii,jj,ibm_ht(ii,jj)) 
	  ! if the boundary point is exactly in line with x2, then the boundary 
	  ! point should not be the fourth point.  In this case, use the intersection
	  ! of x1 with ht.  Otherwise, use boundary point.
!	  nC = 6
!	  if (top_bound(i,j,1)==top_neigh(i,j,3)) then	
!	     ! neighbor 6 is at (ii,jj,ibm_ht(ii,jj)) on the boundary 
!	     top_neigh_i(i,j,3*nC) = ii(nC)
!	     top_neigh_i(i,j,3*nC+1) = ji(nC)
!	     top_neigh_i(i,j,3*nC+2) = 0		
!	     if (stag ==1 ) then 			
!		 top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx)
!		 top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)
!	     elseif (stag == 2) then
!		 top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
!		 top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy)	     
!	     elseif (stag == 3) then
!		 top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
!		 top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)	     
!	     endif
!	     top_neigh(i,j,3*nC+2) = ibm_ht(top_neigh_i(i,j,3*nC),top_neigh_i(i,j,3*nC+1))
!	 else
!	     !if (top_bound(i,j,3) <= ibm_ht(ii(nC),ji(nC))) then
!	     ! neighbor 6 is the boundary point 
!	     top_neigh_i(i,j,3*nC) = 0
!	     top_neigh_i(i,j,3*nC+1) = 0
!	     top_neigh_i(i,j,3*nC+2) = 0
!	     top_neigh(i,j,3*nC) = top_bound(i,j,1)
!	     top_neigh(i,j,3*nC+1) = top_bound(i,j,2)
!	     top_neigh(i,j,3*nC+2) = top_bound(i,j,3)
!	  endif 
	  ! neighbor 6 is on the boundary at either the boundary point or (ii,jj,ibm_ht(ii,jj))
	  ! if the image point is below ibm_ht (like on corners), then choose the boundary point as the neighbor
	  nC = 6
	  !KAL changed from top_bound(i,j,3) to top_img(i,j,6)	 	  
	  if (top_img(i,j,6) <= ibm_ht(ii(nC),ji(nC))) then
	     !! neighbor 6 is the boundary point 
	     !top_neigh_i(i,j,3*nC) = 0
	     !top_neigh_i(i,j,3*nC+1) = 0
	     !top_neigh_i(i,j,3*nC+2) = 0
	     !top_neigh(i,j,3*nC) = top_bound(i,j,1)
	     !top_neigh(i,j,3*nC+1) = top_bound(i,j,2)
	     !top_neigh(i,j,3*nC+2) = top_bound(i,j,3)
	     ! neighbor 6 on the boundary on the 2367 plane
	      top_neigh_i(i,j,3*nC) = 0
	      top_neigh_i(i,j,3*nC+1) = 0
	      top_neigh_i(i,j,3*nC+2) = 0
	      ! first z
	      top_neigh(i,j,3*nC+2) = ht_p(ii(nC),ki(nC),ji(nC))
	      if (stag == 1) then
		  ! solve for x
		  if (ibm_ht_xstag(ii(nC),ji(nC)) >= top_neigh(i,j,3*nC+2)) then
		     top_neigh(i,j,3*nC) = (ii(nC)*dx)-dx +(dx/4)+(dx/4)*((top_neigh(i,j,3*nC+2)-ibm_ht_xstag(ii(nC),ji(nC))) &
						                	 /(ibm_ht(ii(nC)+1,ji(nC))-ibm_ht_xstag(ii(nC),ji(nC))))
		  else
		     top_neigh(i,j,3*nC) = (ii(nC)*dx)-dx + (dx/4)*((top_neigh(i,j,3*nC+2)-ibm_ht(ii(nC),ji(nC))) &
						             /(ibm_ht_xstag(ii(nC),ji(nC))-ibm_ht(ii(nC),ji(nC))))
		  endif						  
		  ! solve for y
		  if (ibm_ht_ystag(ii(nC),ji(nC)) >= top_neigh(i,j,3*nC+2)) then
		     top_neigh(i,j,3*nC+1) = ((ji(nC)-1)*dy) +(dy/4)*((top_neigh(i,j,3*nC+2)-ibm_ht(ii(nC),ji(nC)-1)) &
						               /(ibm_ht_ystag(ii(nC),ji(nC))-ibm_ht(ii(nC),ji(nC)-1)))
		  else
		     top_neigh(i,j,3*nC+1) = ((ji(nC)-1)*dy)-dy + (dy/4)+(dy/4)*((top_neigh(i,j,3*nC+2)-ibm_ht_ystag(ii(nC),ji(nC))) &
							                            /(ibm_ht(ii(nC),ji(nC))-ibm_ht_ystag(ii(nC),ji(nC))))
		  endif
	      elseif (stag == 2) then
		  ! solve for x
		  if (ibm_ht_xstag(ii(nC)+1,ji(nC)) >= top_neigh(i,j,3*nC+2)) then
		     top_neigh(i,j,3*nC) = (ii(nC)*dx)-(dx/2) + (dx/4)+(dx/4)*((top_neigh(i,j,3*nC+2)-ibm_ht_xstag(ii(nC)+1,ji(nC))) &
						                            /(ibm_ht(ii(nC)+1,ji(nC))-ibm_ht_xstag(ii(nC)+1,ji(nC))))
		  else
		     top_neigh(i,j,3*nC) = (ii(nC)*dx)-(dx/2) + (dx/4)*((top_neigh(i,j,3*nC+2)-ibm_ht(ii(nC),ji(nC))) &
						               /(ibm_ht_xstag(ii(nC)+1,ji(nC))-ibm_ht(ii(nC),ji(nC))))
		  endif
		  ! solve for y
		  if (ibm_ht_ystag(ii(nC),ji(nC)-1) >= top_neigh(i,j,3*nC+2)) then
		     top_neigh(i,j,3*nC+1) = ((ji(nC)-1)*dy)-dy + (dy/2)+(dy/4)*((top_neigh(i,j,3*nC+2)-ibm_ht(ii(nC),ji(nC)-1)) &
						                	/(ibm_ht_ystag(ii(nC),ji(nC)-1)-ibm_ht(ii(nC),ji(nC)-1)))
		  else
		     top_neigh(i,j,3*nC+1) = ((ji(nC)-1)*dy)-(dy/2) + (dy/4)+(dy/4)*((top_neigh(i,j,3*nC+2)-ibm_ht_ystag(ii(nC),ji(nC)-1)) &
						                                    /(ibm_ht(ii(nC),ji(nC))-ibm_ht_ystag(ii(nC),ji(nC)-1)))
		  endif
	      elseif (stag == 3) then
		  ! solve for x
		  if (ibm_ht_xstag(ii(nC)+1,ji(nC)) >= top_neigh(i,j,3*nC+2)) then
		     top_neigh(i,j,3*nC) = (ii(nC)*dx)-(dx/2) + (dx/4)+(dx/4)*((top_neigh(i,j,3*nC+2)-ibm_ht_xstag(ii(nC)+1,ji(nC))) &
						                            /(ibm_ht(ii(nC)+1,ji(nC))-ibm_ht_xstag(ii(nC)+1,ji(nC))))
		  else
		     top_neigh(i,j,3*nC) = (ii(nC)*dx)-(dx/2) + (dx/4)*((top_neigh(i,j,3*nC+2)-ibm_ht(ii(nC),ji(nC))) &
						               /(ibm_ht_xstag(ii(nC)+1,ji(nC))-ibm_ht(ii(nC),ji(nC))))
		  endif
		  ! solve for y
		  if (ibm_ht_ystag(ii(nC),ji(nC)) >= top_neigh(i,j,3*nC+2)) then
		     top_neigh(i,j,3*nC+1) = ((ji(nC)-1)*dy) + (dy/4)*((top_neigh(i,j,3*nC+2)-ibm_ht(ii(nC),ji(nC)-1)) &
						        	/(ibm_ht_ystag(ii(nC),ji(nC))-ibm_ht(ii(nC),ji(nC)-1)))
		  else
		     top_neigh(i,j,3*nC+1) = ((ji(nC)-1)*dy) + (dy/4)+(dy/4)*((top_neigh(i,j,3*nC+2)-ibm_ht_ystag(ii(nC),ji(nC))) &
							                    /(ibm_ht(ii(nC),ji(nC))-ibm_ht_ystag(ii(nC),ji(nC))))
		  endif
	      endif
	  else
	     ! neighbor 6 is at (ii,jj,ibm_ht(ii,jj)) on the boundary 
	     top_neigh_i(i,j,3*nC) = ii(nC)
	     top_neigh_i(i,j,3*nC+1) = ji(nC)
	     top_neigh_i(i,j,3*nC+2) = 0		
	     if (stag ==1 ) then 			
		 top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx)
		 top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)
	     elseif (stag == 2) then
		 top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
		 top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy)	     
	     elseif (stag == 3) then
		 top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
		 top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)	     
	     endif
	     top_neigh(i,j,3*nC+2) = ibm_ht(top_neigh_i(i,j,3*nC),top_neigh_i(i,j,3*nC+1))
	  endif  	 
	  ! neighbor 7 is the zero computational nodes
	  nC = 7
	  top_neigh_i(i,j,3*nC) = ii(nC)
	  top_neigh_i(i,j,3*nC+1) = ji(nC)
	  top_neigh_i(i,j,3*nC+2) = ki(nC)		
	  if (stag ==1 ) then 			
	      top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx)
	      top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)
	  elseif (stag == 2) then
	      top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
	      top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy)	     
	  elseif (stag == 3) then
	      top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
	      top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)	     
	  endif
	  top_neigh(i,j,3*nC+2) = ht_p(top_neigh_i(i,j,3*nC),top_neigh_i(i,j,3*nC+2),top_neigh_i(i,j,3*nC+1))
    ELSEIF ((inside(ii(0),ki(0),ji(0)) == 0).AND. &
	    (inside(ii(1),ki(1),ji(1)) == 0).AND. &
	    (inside(ii(2),ki(2),ji(2)) == 0).AND. &
	    (inside(ii(3),ki(3),ji(3)) == 0).AND. &
	    (inside(ii(4),ki(4),ji(4)) == 0).AND. &
	    (inside(ii(5),ki(5),ji(5)) == 0).AND. &
	    (inside(ii(6),ki(6),ji(6)) == 0).AND. &
	    (inside(ii(7),ki(7),ji(7)) == 1)) THEN
	  ! neighbors 0,1,2,3,4,5,6 are the zero computational nodes
	  do nC = 0,6
	     top_neigh_i(i,j,3*nC) = ii(nC)
	     top_neigh_i(i,j,3*nC+1) = ji(nC)
	     top_neigh_i(i,j,3*nC+2) = ki(nC)		
	     if (stag ==1 ) then 			
		 top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx)
		 top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)
	     elseif (stag == 2) then
		 top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
		 top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy)	     
	     elseif (stag == 3) then
		 top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
		 top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)	     
	     endif
	     top_neigh(i,j,3*nC+2) = ht_p(top_neigh_i(i,j,3*nC),top_neigh_i(i,j,3*nC+2),top_neigh_i(i,j,3*nC+1))  
	  enddo 
	  ! neighbor 7 is on the boundary at either the boundary point or (ii,jj,ibm_ht(ii,jj)) 
	  ! if the image point is below ibm_ht (like on corners), then choose the boundary point as the neighbor
	  nC = 7
	  !KAL changed from top_bound(i,j,3) to top_img(i,j,6)		  
	  if (top_img(i,j,6) <= ibm_ht(ii(nC),ji(nC))) then
	     !! neighbor 7 is the boundary point 
	     !top_neigh_i(i,j,3*nC) = 0
	     !top_neigh_i(i,j,3*nC+1) = 0
	     !top_neigh_i(i,j,3*nC+2) = 0
	     !top_neigh(i,j,3*nC) = top_bound(i,j,1)
	     !top_neigh(i,j,3*nC+1) = top_bound(i,j,2)
	     !top_neigh(i,j,3*nC+2) = top_bound(i,j,3)
	     ! neighbor 7 on the boundary on the 2367 plane
	     top_neigh_i(i,j,3*nC) = 0
	     top_neigh_i(i,j,3*nC+1) = 0
	     top_neigh_i(i,j,3*nC+2) = 0
	     ! first z
	     top_neigh(i,j,3*nC+2) = ht_p(ii(nC),ki(nC),ji(nC))
 	     if (stag == 1) then
 		 ! solve for x
 		 if (ibm_ht_xstag(ii(nC)-1,ji(nC)) >= top_neigh(i,j,3*nC+2)) then
 		    top_neigh(i,j,3*nC) = ((ii(nC)-1)*dx)-dx + (dx/2)+(dx/4)*((top_neigh(i,j,3*nC+2)-ibm_ht(ii(nC)-1,ji(nC))) &
 								     /(ibm_ht_xstag(ii(nC)-1,ji(nC))-ibm_ht(ii(nC)-1,ji(nC))))
 		 else
 		    top_neigh(i,j,3*nC) = ((ii(nC)-1)*dx)-(dx/2) + (dx/4)+(dx/4)*((top_neigh(i,j,3*nC+2)-ibm_ht_xstag(ii(nC)-1,ji(nC))) &
 									         /(ibm_ht(ii(nC),ji(nC))-ibm_ht_xstag(ii(nC)-1,ji(nC))))
 		 endif						  
 		 ! solve for y
 		 if (ibm_ht_ystag(ii(nC),ji(nC)) >= top_neigh(i,j,3*nC+2)) then
 		    top_neigh(i,j,3*nC+1) = ((ji(nC)-1)*dy)-(dy/2) + (dy/2)+(dy/4)*((top_neigh(i,j,3*nC+2)-ibm_ht(ii(nC),ji(nC)-1)) &
 									     /(ibm_ht_ystag(ii(nC),ji(nC))-ibm_ht(ii(nC),ji(nC)-1)))
 		 else
 		    top_neigh(i,j,3*nC+1) = (ji(nC)*dy)-dy + (dy/4)+(dy/4)*((top_neigh(i,j,3*nC+2)-ibm_ht_ystag(ii(nC),ji(nC))) &
 									   /(ibm_ht(ii(nC),ji(nC))-ibm_ht_ystag(ii(nC),ji(nC))))
 		 endif
 	     elseif (stag == 2) then
 		 ! solve for x
 		 if (ibm_ht_xstag(ii(nC),ji(nC)) >= top_neigh(i,j,3*nC+2)) then
 		    top_neigh(i,j,3*nC) = ((ii(nC)-1)*dx)-(dx/2) + (dx/2)+(dx/4)*((top_neigh(i,j,3*nC+2)-ibm_ht(ii(nC)-1,ji(nC))) &
 								         /(ibm_ht_xstag(ii(nC)+1,ji(nC))-ibm_ht(ii(nC)-1,ji(nC))))
 		 else
 		    top_neigh(i,j,3*nC) = (ii(nC)*dx)-dx + (dx/4)+(dx/4)*((top_neigh(i,j,3*nC+2)-ibm_ht_xstag(ii(nC),ji(nC))) &
 								         /(ibm_ht(ii(nC),ji(nC))-ibm_ht_xstag(ii(nC),ji(nC))))
 		 endif
 		 ! solve for y
 		 if (ibm_ht_ystag(ii(nC),ji(nC)-1) >= top_neigh(i,j,3*nC+2)) then
 		    top_neigh(i,j,3*nC+1) = ((ji(nC)-1)*dy)-dy + (dy/2)+(dy/4)*((top_neigh(i,j,3*nC+2)-ibm_ht(ii(nC),ji(nC)-1)) &
 								       /(ibm_ht_ystag(ii(nC),ji(nC)-1)-ibm_ht(ii(nC),ji(nC)-1)))
 		 else
 		    top_neigh(i,j,3*nC+1) = ((ji(nC)-1)*dy)-(dy/2) + (dy/4)+(dy/4)*((top_neigh(i,j,3*nC+2)-ibm_ht_ystag(ii(nC),ji(nC)-1)) &
 									    	   /(ibm_ht(ii(nC),ji(nC))-ibm_ht_ystag(ii(nC),ji(nC)-1)))
 		 endif
 	     elseif (stag == 3) then
 		 ! solve for x
 		 if (ibm_ht_xstag(ii(nC),ji(nC)) >= top_neigh(i,j,3*nC+2)) then
 		    top_neigh(i,j,3*nC) = ((ii(nC)-1)*dx)-(dx/2) + (dx/2)+(dx/4)*((top_neigh(i,j,3*nC+2)-ibm_ht(ii(nC)-1,ji(nC))) &
 									   /(ibm_ht_xstag(ii(nC),ji(nC))-ibm_ht(ii(nC)-1,ji(nC))))
 		 else
 		    top_neigh(i,j,3*nC) = (ii(nC)*dx)-dx + (dx/4)+(dx/4)*((top_neigh(i,j,3*nC+2)-ibm_ht_xstag(ii(nC),ji(nC))) &
 								         /(ibm_ht(ii(nC),ji(nC))-ibm_ht_xstag(ii(nC),ji(nC))))
 		 endif
 		 ! solve for y
 		 if (ibm_ht_ystag(ii(nC),ji(nC)) >= top_neigh(i,j,3*nC+2)) then
 		    top_neigh(i,j,3*nC+1) = ((ji(nC)-1)*dy)-(dy/2) + (dy/2)+(dy/4)*((top_neigh(i,j,3*nC+2)-ibm_ht(ii(nC),ji(nC)-1)) &
 									     /(ibm_ht_ystag(ii(nC),ji(nC))-ibm_ht(ii(nC),ji(nC)-1)))
 		 else
 		    top_neigh(i,j,3*nC+1) = (ji(nC)*dy)-dy + (dy/4)+(dy/4)*((top_neigh(i,j,3*nC+2)-ibm_ht_ystag(ii(nC),ji(nC))) &
 									 /(ibm_ht(ii(nC),ji(nC))-ibm_ht_ystag(ii(nC),ji(nC))))
 		 endif
 	     endif
	  else
	     ! neighbor 7 is at (ii,jj,ibm_ht(ii,jj)) on the boundary 
	     top_neigh_i(i,j,3*nC) = ii(nC)
	     top_neigh_i(i,j,3*nC+1) = ji(nC)
	     top_neigh_i(i,j,3*nC+2) = 0		
	     if (stag ==1 ) then 			
		 top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx)
		 top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)
	     elseif (stag == 2) then
		 top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
		 top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy)	     
	     elseif (stag == 3) then
		 top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
		 top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)	     
	     endif
	     top_neigh(i,j,3*nC+2) = ibm_ht(top_neigh_i(i,j,3*nC),top_neigh_i(i,j,3*nC+1))
	  endif 
    ELSEIF ((inside(ii(0),ki(0),ji(0)) == 0).AND. &
	   (inside(ii(1),ki(1),ji(1)) == 0).AND. &
	   (inside(ii(2),ki(2),ji(2)) == 1).AND. &
	   (inside(ii(3),ki(3),ji(3)) == 1).AND. &
	   (inside(ii(4),ki(4),ji(4)) == 0).AND. &
	   (inside(ii(5),ki(5),ji(5)) == 0).AND. &
	   (inside(ii(6),ki(6),ji(6)) == 0).AND. &
	   (inside(ii(7),ki(7),ji(7)) == 0)) THEN
	  ! neighbors 0,1,4,5,6,7 are the zero computational nodes
	  do nC = 0,1
	     top_neigh_i(i,j,3*nC) = ii(nC)
	     top_neigh_i(i,j,3*nC+1) = ji(nC)
	     top_neigh_i(i,j,3*nC+2) = ki(nC)		
	     if (stag ==1 ) then 			
		 top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx)
		 top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)
	     elseif (stag == 2) then
		 top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
		 top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy)	     
	     elseif (stag == 3) then
		 top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
		 top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)	     
	     endif
	     top_neigh(i,j,3*nC+2) = ht_p(top_neigh_i(i,j,3*nC),top_neigh_i(i,j,3*nC+2),top_neigh_i(i,j,3*nC+1))  
	  enddo
	  ! neighbors 2,3 are on the boundary either interpolated in y or at (ii,jj,ibm_ht(ii,jj))
	  if ((top_bound(i,j,3) < ibm_ht(ii(2),ji(2))).AND.(top_bound(i,j,3) < ibm_ht(ii(3),ji(3)))) then
	     ! neighbor 2 is on the boundary between 2 and 6
	    ! neighbor 3 is on the boundary between 3 and 7
	    do nC = 2,3
	       top_neigh_i(i,j,3*nC) = ii(nC)
	       top_neigh_i(i,j,3*nC+1) = 0
	       top_neigh_i(i,j,3*nC+2) = 0
	       ! first z
	       top_neigh(i,j,3*nC+2) = ht_p(ii(nC),ki(nC),ji(nC))
	       if (stag == 1) then
		   !next x
		   top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx)
		   ! solve for y
		   if (ibm_ht_ystag(ii(nC),ji(nC)+1) >= top_neigh(i,j,3*nC+2)) then
		      top_neigh(i,j,3*nC+1) = (ji(nC)*dy) + (dy/2)*((top_neigh(i,j,3*nC+2)-ibm_ht_ystag(ii(nC),ji(nC)+1)) &
								 /(ibm_ht(ii(nC),ji(nC)+1)-ibm_ht_ystag(ii(nC),ji(nC)+1)))
		   else
		      top_neigh(i,j,3*nC+1) = (ji(nC)*dy)-(dy/2) + (dy/2)*((top_neigh(i,j,3*nC+2)-ibm_ht(ii(nC),ji(nC))) &
								  /(ibm_ht_ystag(ii(nC),ji(nC)+1)-ibm_ht(ii(nC),ji(nC))))
		   endif						 
	       elseif (stag == 2) then
		   !next x
		   top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
		   ! solve for y
		   if (ibm_ht_ystag(ii(nC),ji(nC)) >= top_neigh(i,j,3*nC+2)) then
		      top_neigh(i,j,3*nC+1) = (ji(nC)*dy-(dy/2)) + (dy/2)*((top_neigh(i,j,3*nC+2)-ibm_ht_ystag(ii(nC),ji(nC))) &
									/(ibm_ht(ii(nC),ji(nC)+1)-ibm_ht_ystag(ii(nC),ji(nC))))
		   else
		      top_neigh(i,j,3*nC+1) = (ji(nC)*dy)-dy + (dy/2)*((top_neigh(i,j,3*nC+2)-ibm_ht(ii(nC),ji(nC))) &
								/(ibm_ht_ystag(ii(nC),ji(nC))-ibm_ht(ii(nC),ji(nC))))
		   endif
	       elseif (stag == 3) then
		   !next x
		   top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
		   ! solve for y
		   if (ibm_ht_ystag(ii(nC),ji(nC)+1) >= top_neigh(i,j,3*nC+2)) then
		      top_neigh(i,j,3*nC+1) = (ji(nC)*dy) + (dy/2)*((top_neigh(i,j,3*nC+2)-ibm_ht_ystag(ii(nC),ji(nC)+1)) &
								 /(ibm_ht(ii(nC),ji(nC)+1)-ibm_ht_ystag(ii(nC),ji(nC)+1)))
		   else
		      top_neigh(i,j,3*nC+1) = (ji(nC)*dy)-(dy/2) + (dy/2)*((top_neigh(i,j,3*nC+2)-ibm_ht(ii(nC),ji(nC))) &
								  /(ibm_ht_ystag(ii(nC),ji(nC)+1)-ibm_ht(ii(nC),ji(nC))))
		   endif       
	       endif
	     enddo	    
	 else
	     ! neighbors 2,3 is at (ii,jj,ibm_ht(ii,jj)) on the boundary 
	     do nC = 2,3
		top_neigh_i(i,j,3*nC) = ii(nC)
		top_neigh_i(i,j,3*nC+1) = ji(nC)
		top_neigh_i(i,j,3*nC+2) = 0		
		if (stag ==1 ) then 			
		    top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx)
		    top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)
		elseif (stag == 2) then
		    top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
		    top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy)	     
		elseif (stag == 3) then
		    top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
		    top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)	     
		endif
		top_neigh(i,j,3*nC+2) = ibm_ht(top_neigh_i(i,j,3*nC),top_neigh_i(i,j,3*nC+1))
	     enddo
	  endif
	  do nC = 4,7
	     top_neigh_i(i,j,3*nC) = ii(nC)
	     top_neigh_i(i,j,3*nC+1) = ji(nC)
	     top_neigh_i(i,j,3*nC+2) = ki(nC)		
	     if (stag ==1 ) then 			
		 top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx)
		 top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)
	     elseif (stag == 2) then
		 top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
		 top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy)	     
	     elseif (stag == 3) then
		 top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
		 top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)	     
	     endif
	     top_neigh(i,j,3*nC+2) = ht_p(top_neigh_i(i,j,3*nC),top_neigh_i(i,j,3*nC+2),top_neigh_i(i,j,3*nC+1))  
	  enddo
    ELSEIF ((inside(ii(0),ki(0),ji(0)) == 0).AND. &
	   (inside(ii(1),ki(1),ji(1)) == 0).AND. &
	   (inside(ii(2),ki(2),ji(2)) == 1).AND. &
	   (inside(ii(3),ki(3),ji(3)) == 0).AND. &
	   (inside(ii(4),ki(4),ji(4)) == 0).AND. &
	   (inside(ii(5),ki(5),ji(5)) == 0).AND. &
	   (inside(ii(6),ki(6),ji(6)) == 1).AND. &
	   (inside(ii(7),ki(7),ji(7)) == 0)) THEN
	  ! neighbors 0,1,3,4,5,7 are the zero computational nodes
	  do nC = 0,1
	     top_neigh_i(i,j,3*nC) = ii(nC)
	     top_neigh_i(i,j,3*nC+1) = ji(nC)
	     top_neigh_i(i,j,3*nC+2) = ki(nC)		
	     if (stag ==1 ) then 			
		 top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx)
		 top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)
	     elseif (stag == 2) then
		 top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
		 top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy)	     
	     elseif (stag == 3) then
		 top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
		 top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)	     
	     endif
	     top_neigh(i,j,3*nC+2) = ht_p(top_neigh_i(i,j,3*nC),top_neigh_i(i,j,3*nC+2),top_neigh_i(i,j,3*nC+1))  
	  enddo
	  ! neighbors 2,6 are on the boundary either interpolated in x or at (ii,jj,ibm_ht(ii,jj))
	  if ((top_bound(i,j,3) < ibm_ht(ii(2),ji(2))).AND.(top_bound(i,j,3) < ibm_ht(ii(6),ji(6)))) then
	     ! neighbor 2 is on the boundary between 2 and 3 
	     nC = 2
	     top_neigh_i(i,j,3*nC) = 0
	     top_neigh_i(i,j,3*nC+1) = ji(nC)
	     top_neigh_i(i,j,3*nC+2) = 0
	     ! first z
	     top_neigh(i,j,3*nC+2) = ht_p(ii(nC),ki(nC),ji(nC))
	     if (stag == 1) then
		 !next y
		 top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)
		 ! solve for x
		 if (ibm_ht_xstag(ii(nC),ji(nC)) >= top_neigh(i,j,3*nC+2)) then
		    top_neigh(i,j,3*nC) = (ii(nC)*dx)-(dx/2) + (dx/2)*((top_neigh(i,j,3*nC+2)-ibm_ht_xstag(ii(nC),ji(nC))) &
								    /(ibm_ht(ii(nC)+1,ji(nC))-ibm_ht_xstag(ii(nC),ji(nC))))
		 else
		    top_neigh(i,j,3*nC) = (ii(nC)*dx)-dx + (dx/2)*((top_neigh(i,j,3*nC+2)-ibm_ht(ii(nC),ji(nC))) &
							    /(ibm_ht_xstag(ii(nC),ji(nC))-ibm_ht(ii(nC),ji(nC))))
		 endif						 
	     elseif (stag == 2) then
		 !next y
		 top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy)
		 ! solve for x
		 if (ibm_ht_xstag(ii(nC)+1,ji(nC)) >= top_neigh(i,j,3*nC+2)) then
		    top_neigh(i,j,3*nC) = (ii(nC)*dx) + (dx/2)*((top_neigh(i,j,3*nC+2)-ibm_ht_xstag(ii(nC)+1,ji(nC))) &
							     /(ibm_ht(ii(nC)+1,ji(nC))-ibm_ht_xstag(ii(nC)+1,ji(nC))))
		 else
		    top_neigh(i,j,3*nC) = (ii(nC)*dx)-(dx/2) + (dx/2)*((top_neigh(i,j,3*nC+2)-ibm_ht(ii(nC),ji(nC))) &
							      /(ibm_ht_xstag(ii(nC)+1,ji(nC))-ibm_ht(ii(nC),ji(nC))))
		 endif
	     elseif (stag == 3) then
		 !next y
		 top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)
		 ! solve for x
		 if (ibm_ht_xstag(ii(nC)+1,ji(nC)) >= top_neigh(i,j,3*nC+2)) then
		    top_neigh(i,j,3*nC) = (ii(nC)*dx) + (dx/2)*((top_neigh(i,j,3*nC+2)-ibm_ht_xstag(ii(nC)+1,ji(nC))) &
							     /(ibm_ht(ii(nC)+1,ji(nC))-ibm_ht_xstag(ii(nC)+1,ji(nC))))
		 else
		    top_neigh(i,j,3*nC) = (ii(nC)*dx)-(dx/2) + (dx/2)*((top_neigh(i,j,3*nC+2)-ibm_ht(ii(nC),ji(nC))) &
							      /(ibm_ht_xstag(ii(nC)+1,ji(nC))-ibm_ht(ii(nC),ji(nC))))
		 endif
	     endif
	  else
	     ! neighbors 2,6 are at (ii,jj,ibm_ht(ii,jj)) on the boundary 
	     nC = 2
	     top_neigh_i(i,j,3*nC) = ii(nC)
	     top_neigh_i(i,j,3*nC+1) = ji(nC)
	     top_neigh_i(i,j,3*nC+2) = 0		
	     if (stag ==1 ) then 			
		 top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx)
		 top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)
	     elseif (stag == 2) then
		 top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
		 top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy)	     
	     elseif (stag == 3) then
		 top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
		 top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)	     
	     endif
	     top_neigh(i,j,3*nC+2) = ibm_ht(top_neigh_i(i,j,3*nC),top_neigh_i(i,j,3*nC+1))
	  endif
	  do nC = 3,5
	     top_neigh_i(i,j,3*nC) = ii(nC)
	     top_neigh_i(i,j,3*nC+1) = ji(nC)
	     top_neigh_i(i,j,3*nC+2) = ki(nC)		
	     if (stag ==1 ) then 			
		 top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx)
		 top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)
	     elseif (stag == 2) then
		 top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
		 top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy)	     
	     elseif (stag == 3) then
		 top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
		 top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)	     
	     endif
	     top_neigh(i,j,3*nC+2) = ht_p(top_neigh_i(i,j,3*nC),top_neigh_i(i,j,3*nC+2),top_neigh_i(i,j,3*nC+1))  
	  enddo
	  ! neighbors 2,6 are on the boundary either interpolated in x or at (ii,jj,ibm_ht(ii,jj))
	  if ((top_bound(i,j,3) < ibm_ht(ii(2),ji(2))).AND.(top_bound(i,j,3) < ibm_ht(ii(6),ji(6)))) then
	     ! neighbor 6 is on the boundary between 6 and 7
	     nC = 6
	     top_neigh_i(i,j,3*nC) = 0
	     top_neigh_i(i,j,3*nC+1) = ji(nC)
	     top_neigh_i(i,j,3*nC+2) = 0
	     ! first z
	     top_neigh(i,j,3*nC+2) = ht_p(ii(nC),ki(nC),ji(nC))
	     if (stag == 1) then
		 !next y
		 top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)
		 ! solve for x
		 if (ibm_ht_xstag(ii(nC),ji(nC)) >= top_neigh(i,j,3*nC+2)) then
		    top_neigh(i,j,3*nC) = (ii(nC)*dx)-(dx/2) + (dx/2)*((top_neigh(i,j,3*nC+2)-ibm_ht_xstag(ii(nC),ji(nC))) &
								    /(ibm_ht(ii(nC)+1,ji(nC))-ibm_ht_xstag(ii(nC),ji(nC))))
		 else
		    top_neigh(i,j,3*nC) = (ii(nC)*dx)-dx + (dx/2)*((top_neigh(i,j,3*nC+2)-ibm_ht(ii(nC),ji(nC))) &
							    /(ibm_ht_xstag(ii(nC),ji(nC))-ibm_ht(ii(nC),ji(nC))))
		 endif						 
	     elseif (stag == 2) then
		 !next y
		 top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy)
		 ! solve for x
		 if (ibm_ht_xstag(ii(nC)+1,ji(nC)) >= top_neigh(i,j,3*nC+2)) then
		    top_neigh(i,j,3*nC) = (ii(nC)*dx) + (dx/2)*((top_neigh(i,j,3*nC+2)-ibm_ht_xstag(ii(nC)+1,ji(nC))) &
							     /(ibm_ht(ii(nC)+1,ji(nC))-ibm_ht_xstag(ii(nC)+1,ji(nC))))
		 else
		    top_neigh(i,j,3*nC) = (ii(nC)*dx)-(dx/2) + (dx/2)*((top_neigh(i,j,3*nC+2)-ibm_ht(ii(nC),ji(nC))) &
							      /(ibm_ht_xstag(ii(nC)+1,ji(nC))-ibm_ht(ii(nC),ji(nC))))
		 endif
	     elseif (stag == 3) then
		 !next y
		 top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)
		 ! solve for x
		 if (ibm_ht_xstag(ii(nC)+1,ji(nC)) >= top_neigh(i,j,3*nC+2)) then
		    top_neigh(i,j,3*nC) = (ii(nC)*dx) + (dx/2)*((top_neigh(i,j,3*nC+2)-ibm_ht_xstag(ii(nC)+1,ji(nC))) &
							     /(ibm_ht(ii(nC)+1,ji(nC))-ibm_ht_xstag(ii(nC)+1,ji(nC))))
		 else
		    top_neigh(i,j,3*nC) = (ii(nC)*dx)-(dx/2) + (dx/2)*((top_neigh(i,j,3*nC+2)-ibm_ht(ii(nC),ji(nC))) &
							      /(ibm_ht_xstag(ii(nC)+1,ji(nC))-ibm_ht(ii(nC),ji(nC))))
		 endif
	     endif
	  else
	     nC = 6
	     top_neigh_i(i,j,3*nC) = ii(nC)
	     top_neigh_i(i,j,3*nC+1) = ji(nC)
	     top_neigh_i(i,j,3*nC+2) = 0		
	     if (stag ==1 ) then 			
		 top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx)
		 top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)
	     elseif (stag == 2) then
		 top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
		 top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy)	     
	     elseif (stag == 3) then
		 top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
		 top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)	     
	     endif
	     top_neigh(i,j,3*nC+2) = ibm_ht(top_neigh_i(i,j,3*nC),top_neigh_i(i,j,3*nC+1))
	  endif
	  nC = 7
	  top_neigh_i(i,j,3*nC) = ii(nC)
	  top_neigh_i(i,j,3*nC+1) = ji(nC)
	  top_neigh_i(i,j,3*nC+2) = ki(nC)		
	  if (stag ==1 ) then 			
	      top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx)
	      top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)
	  elseif (stag == 2) then
	      top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
	      top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy)	     
	  elseif (stag == 3) then
	      top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
	      top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)	     
	  endif
	  top_neigh(i,j,3*nC+2) = ht_p(top_neigh_i(i,j,3*nC),top_neigh_i(i,j,3*nC+2),top_neigh_i(i,j,3*nC+1)) 	  
    ELSEIF ((inside(ii(0),ki(0),ji(0)) == 0).AND. &
	   (inside(ii(1),ki(1),ji(1)) == 0).AND. &
	   (inside(ii(2),ki(2),ji(2)) == 0).AND. &
	   (inside(ii(3),ki(3),ji(3)) == 1).AND. &
	   (inside(ii(4),ki(4),ji(4)) == 0).AND. &
	   (inside(ii(5),ki(5),ji(5)) == 0).AND. &
	   (inside(ii(6),ki(6),ji(6)) == 0).AND. &
	   (inside(ii(7),ki(7),ji(7)) == 1)) THEN
	  ! neighbors 0,1,2,4,5,6 are the zero computational nodes
	  do nC = 0,2
	     top_neigh_i(i,j,3*nC) = ii(nC)
	     top_neigh_i(i,j,3*nC+1) = ji(nC)
	     top_neigh_i(i,j,3*nC+2) = ki(nC)		
	     if (stag ==1 ) then 			
		 top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx)
		 top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)
	     elseif (stag == 2) then
		 top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
		 top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy)	     
	     elseif (stag == 3) then
		 top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
		 top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)	     
	     endif
	     top_neigh(i,j,3*nC+2) = ht_p(top_neigh_i(i,j,3*nC),top_neigh_i(i,j,3*nC+2),top_neigh_i(i,j,3*nC+1))  
	  enddo	  
	  ! neighbors 3,7 are on the boundary either interpolated in x or at (ii,jj,ibm_ht(ii,jj))
	  if ((top_bound(i,j,3) < ibm_ht(ii(3),ji(3))).AND.(top_bound(i,j,3) < ibm_ht(ii(7),ji(7)))) then
	     ! neighbor 3 is on the boundary between 3 and 2 
	       nC = 3 
	       top_neigh_i(i,j,3*nC) = 0
	       top_neigh_i(i,j,3*nC+1) = ji(nC)
	       top_neigh_i(i,j,3*nC+2) = 0
	       ! first z
	       top_neigh(i,j,3*nC+2) = ht_p(ii(nC),ki(nC),ji(nC))
	       if (stag == 1) then
		   !next y
		   top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)
		   ! solve for x
		   if (ibm_ht_xstag(ii(nC)-1,ji(nC)) >= top_neigh(i,j,3*nC+2)) then
		      top_neigh(i,j,3*nC) = ((ii(nC)-1)*dx)-dx + (dx/2)*((top_neigh(i,j,3*nC+2)-ibm_ht(ii(nC)-1,ji(nC))) &
								/(ibm_ht_xstag(ii(nC)-1,ji(nC))-ibm_ht(ii(nC)-1,ji(nC))))
		   else
		      top_neigh(i,j,3*nC) = ((ii(nC)-1)*dx)-(dx/2) + (dx/2)*((top_neigh(i,j,3*nC+2)-ibm_ht_xstag(ii(nC)-1,ji(nC))) &
									    /(ibm_ht(ii(nC),ji(nC))-ibm_ht_xstag(ii(nC)-1,ji(nC))))
		   endif 						 
	       elseif (stag == 2) then
		   !next y
		   top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy)
		   ! solve for x
		   if (ibm_ht_xstag(ii(nC),ji(nC)) >= top_neigh(i,j,3*nC+2)) then
		      top_neigh(i,j,3*nC) = ((ii(nC)-1)*dx)-(dx/2) + (dx/2)*((top_neigh(i,j,3*nC+2)-ibm_ht(ii(nC)-1,ji(nC))) &
								      /(ibm_ht_xstag(ii(nC),ji(nC))-ibm_ht(ii(nC)-1,ji(nC))))
		   else
		      top_neigh(i,j,3*nC) = (ii(nC)*dx)-dx + (dx/2)*((top_neigh(i,j,3*nC+2)-ibm_ht_xstag(ii(nC),ji(nC))) &
								    /(ibm_ht(ii(nC),ji(nC))-ibm_ht_xstag(ii(nC),ji(nC))))
		   endif
	       elseif (stag == 3) then
		   !next y
		   top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)
		   ! solve for x
		   if (ibm_ht_xstag(ii(nC),ji(nC)) >= top_neigh(i,j,3*nC+2)) then
		      top_neigh(i,j,3*nC) = ((ii(nC)-1)*dx)-(dx/2) + (dx/2)*((top_neigh(i,j,3*nC+2)-ibm_ht(ii(nC)-1,ji(nC))) &
								      /(ibm_ht_xstag(ii(nC),ji(nC))-ibm_ht(ii(nC)-1,ji(nC))))
		   else
		      top_neigh(i,j,3*nC) = (ii(nC)*dx)-dx + (dx/2)*((top_neigh(i,j,3*nC+2)-ibm_ht_xstag(ii(nC),ji(nC))) &
								     /(ibm_ht(ii(nC),ji(nC))-ibm_ht_xstag(ii(nC),ji(nC))))
		   endif
	       endif	    
	  else
	     ! neighbor 3 is at (ii,jj,ibm_ht(ii,jj)) on the boundary 
	     nC = 3
	     top_neigh_i(i,j,3*nC) = ii(nC)
	     top_neigh_i(i,j,3*nC+1) = ji(nC)
	     top_neigh_i(i,j,3*nC+2) = 0		
	     if (stag ==1 ) then 			
		 top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx)
		 top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)
	     elseif (stag == 2) then
		 top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
		 top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy)	     
	     elseif (stag == 3) then
		 top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
		 top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)	     
	     endif
	     top_neigh(i,j,3*nC+2) = ibm_ht(top_neigh_i(i,j,3*nC),top_neigh_i(i,j,3*nC+1))
	  endif   	  	  
	  do nC = 4,6
	     top_neigh_i(i,j,3*nC) = ii(nC)
	     top_neigh_i(i,j,3*nC+1) = ji(nC)
	     top_neigh_i(i,j,3*nC+2) = ki(nC)		
	     if (stag ==1 ) then 			
		 top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx)
		 top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)
	     elseif (stag == 2) then
		 top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
		 top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy)	     
	     elseif (stag == 3) then
		 top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
		 top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)	     
	     endif
	     top_neigh(i,j,3*nC+2) = ht_p(top_neigh_i(i,j,3*nC),top_neigh_i(i,j,3*nC+2),top_neigh_i(i,j,3*nC+1))  
	  enddo 
	  ! neighbors 3,7 are on the boundary either interpolated in x or at (ii,jj,ibm_ht(ii,jj))
	  if ((top_bound(i,j,3) < ibm_ht(ii(3),ji(3))).AND.(top_bound(i,j,3) < ibm_ht(ii(7),ji(7)))) then
	     ! neighbor 7 is on the boundary between 6 and 7 
	       nC = 7
	       top_neigh_i(i,j,3*nC) = 0
	       top_neigh_i(i,j,3*nC+1) = ji(nC)
	       top_neigh_i(i,j,3*nC+2) = 0
	       ! first z
	       top_neigh(i,j,3*nC+2) = ht_p(ii(nC),ki(nC),ji(nC))
	       if (stag == 1) then
		   !next y
		   top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)
		   ! solve for x
		   if (ibm_ht_xstag(ii(nC)-1,ji(nC)) >= top_neigh(i,j,3*nC+2)) then
		      top_neigh(i,j,3*nC) = ((ii(nC)-1)*dx)-dx + (dx/2)*((top_neigh(i,j,3*nC+2)-ibm_ht(ii(nC)-1,ji(nC))) &
								/(ibm_ht_xstag(ii(nC)-1,ji(nC))-ibm_ht(ii(nC)-1,ji(nC))))
		   else
		      top_neigh(i,j,3*nC) = ((ii(nC)-1)*dx)-(dx/2) + (dx/2)*((top_neigh(i,j,3*nC+2)-ibm_ht_xstag(ii(nC)-1,ji(nC))) &
									    /(ibm_ht(ii(nC),ji(nC))-ibm_ht_xstag(ii(nC)-1,ji(nC))))
		   endif 						 
	       elseif (stag == 2) then
		   !next y
		   top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy)
		   ! solve for x
		   if (ibm_ht_xstag(ii(nC),ji(nC)) >= top_neigh(i,j,3*nC+2)) then
		      top_neigh(i,j,3*nC) = ((ii(nC)-1)*dx)-(dx/2) + (dx/2)*((top_neigh(i,j,3*nC+2)-ibm_ht(ii(nC)-1,ji(nC))) &
								      /(ibm_ht_xstag(ii(nC),ji(nC))-ibm_ht(ii(nC)-1,ji(nC))))
		   else
		      top_neigh(i,j,3*nC) = (ii(nC)*dx)-dx + (dx/2)*((top_neigh(i,j,3*nC+2)-ibm_ht_xstag(ii(nC),ji(nC))) &
								    /(ibm_ht(ii(nC),ji(nC))-ibm_ht_xstag(ii(nC),ji(nC))))
		   endif
	       elseif (stag == 3) then
		   !next y
		   top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)
		   ! solve for x
		   if (ibm_ht_xstag(ii(nC),ji(nC)) >= top_neigh(i,j,3*nC+2)) then
		      top_neigh(i,j,3*nC) = ((ii(nC)-1)*dx)-(dx/2) + (dx/2)*((top_neigh(i,j,3*nC+2)-ibm_ht(ii(nC)-1,ji(nC))) &
								      /(ibm_ht_xstag(ii(nC),ji(nC))-ibm_ht(ii(nC)-1,ji(nC))))
		   else
		      top_neigh(i,j,3*nC) = (ii(nC)*dx)-dx + (dx/2)*((top_neigh(i,j,3*nC+2)-ibm_ht_xstag(ii(nC),ji(nC))) &
								     /(ibm_ht(ii(nC),ji(nC))-ibm_ht_xstag(ii(nC),ji(nC))))
		   endif
	       endif
	  else
	     ! neighbor 7 is at (ii,jj,ibm_ht(ii,jj)) on the boundary 
	     nC = 7
	     top_neigh_i(i,j,3*nC) = ii(nC)
	     top_neigh_i(i,j,3*nC+1) = ji(nC)
	     top_neigh_i(i,j,3*nC+2) = 0		
	     if (stag ==1 ) then 			
		 top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx)
		 top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)
	     elseif (stag == 2) then
		 top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
		 top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy)	     
	     elseif (stag == 3) then
		 top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
		 top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)	     
	     endif
	     top_neigh(i,j,3*nC+2) = ibm_ht(top_neigh_i(i,j,3*nC),top_neigh_i(i,j,3*nC+1))
	  endif     
    ELSEIF ((inside(ii(0),ki(0),ji(0)) == 0).AND. &
	    (inside(ii(1),ki(1),ji(1)) == 0).AND. &
	    (inside(ii(2),ki(2),ji(2)) == 0).AND. &
	    (inside(ii(3),ki(3),ji(3)) == 0).AND. &
	    (inside(ii(4),ki(4),ji(4)) == 0).AND. &
	    (inside(ii(5),ki(5),ji(5)) == 0).AND. &
	    (inside(ii(6),ki(6),ji(6)) == 1).AND. &
	    (inside(ii(7),ki(7),ji(7)) == 1)) THEN
	  ! neighbors 0,1,2,3,4,5 are the zero computational nodes
	  do nC = 0,5
	     top_neigh_i(i,j,3*nC) = ii(nC)
	     top_neigh_i(i,j,3*nC+1) = ji(nC)
	     top_neigh_i(i,j,3*nC+2) = ki(nC)		
	     if (stag ==1 ) then 			
		 top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx)
		 top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)
	     elseif (stag == 2) then
		 top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
		 top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy)	     
	     elseif (stag == 3) then
		 top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
		 top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)	     
	     endif
	     top_neigh(i,j,3*nC+2) = ht_p(top_neigh_i(i,j,3*nC),top_neigh_i(i,j,3*nC+2),top_neigh_i(i,j,3*nC+1))  
	  enddo
	  ! neighbors 6,7 are on the boundary either interpolated in y or at (ii,jj,ibm_ht(ii,jj))
	  if ((top_bound(i,j,3) < ibm_ht(ii(6),ji(6))).AND.(top_bound(i,j,3) < ibm_ht(ii(7),ji(7)))) then
	     ! neighbor 6 is on the boundary between 6 and 2 
	     ! neighbor 7 is on the boundary between 7 and 3
	     do nC = 6,7
		top_neigh_i(i,j,3*nC) = ii(nC)
		top_neigh_i(i,j,3*nC+1) = 0
		top_neigh_i(i,j,3*nC+2) = 0
		! first z
		top_neigh(i,j,3*nC+2) = ht_p(ii(nC),ki(nC),ji(nC))
		if (stag == 1) then
		    !next x
		    top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx)
		    ! solve for y
		    if (ibm_ht_ystag(ii(nC),ji(nC)) >= top_neigh(i,j,3*nC+2)) then
		       top_neigh(i,j,3*nC+1) = ((ji(nC)-1)*dy)-(dy/2) + (dy/2)*((top_neigh(i,j,3*nC+2)-ibm_ht(ii(nC),ji(nC)-1)) &
									 /(ibm_ht_ystag(ii(nC),ji(nC))-ibm_ht(ii(nC),ji(nC)-1)))
		    else
		       top_neigh(i,j,3*nC+1) = (ji(nC)*dy)-dy + (dy/2)*((top_neigh(i,j,3*nC+2)-ibm_ht_ystag(ii(nC),ji(nC))) &
								       /(ibm_ht(ii(nC),ji(nC))-ibm_ht_ystag(ii(nC),ji(nC))))
		    endif						 
		elseif (stag == 2) then
		    !next x
		    top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
		    ! solve for y
		    if (ibm_ht_ystag(ii(nC),ji(nC)-1) >= top_neigh(i,j,3*nC+2)) then
		       top_neigh(i,j,3*nC+1) = ((ji(nC)-1)*dy)-dy + (dy/2)*((top_neigh(i,j,3*nC+2)-ibm_ht(ii(nC),ji(nC)-1)) &
								   /(ibm_ht_ystag(ii(nC),ji(nC)-1)-ibm_ht(ii(nC),ji(nC)-1)))
		    else
		       top_neigh(i,j,3*nC+1) = ((ji(nC)-1)*dy)-(dy/2) + (dy/2)*((top_neigh(i,j,3*nC+2)-ibm_ht_ystag(ii(nC),ji(nC)-1)) &
									       /(ibm_ht(ii(nC),ji(nC))-ibm_ht_ystag(ii(nC),ji(nC)-1)))
		    endif
		elseif (stag == 3) then
		    !next x
		    top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
		    ! solve for y
		    if (ibm_ht_ystag(ii(nC),ji(nC)) >= top_neigh(i,j,3*nC+2)) then
		       top_neigh(i,j,3*nC+1) = ((ji(nC)-1)*dy)-(dy/2) + (dy/2)*((top_neigh(i,j,3*nC+2)-ibm_ht(ii(nC),ji(nC)-1)) &
									 /(ibm_ht_ystag(ii(nC),ji(nC))-ibm_ht(ii(nC),ji(nC)-1)))
		    else
		       top_neigh(i,j,3*nC+1) = (ji(nC)*dy)-dy + (dy/2)*((top_neigh(i,j,3*nC+2)-ibm_ht_ystag(ii(nC),ji(nC))) &
								       /(ibm_ht(ii(nC),ji(nC))-ibm_ht_ystag(ii(nC),ji(nC))))
		    endif
		endif	 
	     enddo
	  else
	     ! neighbors 6,7 are at (ii,jj,ibm_ht(ii,jj)) on the boundary 
	     do nC = 6,7
		top_neigh_i(i,j,3*nC) = ii(nC)
		top_neigh_i(i,j,3*nC+1) = ji(nC)
		top_neigh_i(i,j,3*nC+2) = 0		
		if (stag ==1 ) then 			
		    top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx)
		    top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)
		elseif (stag == 2) then
		    top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
		    top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy)	     
		elseif (stag == 3) then
		    top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
		    top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)	     
		endif
		top_neigh(i,j,3*nC+2) = ibm_ht(top_neigh_i(i,j,3*nC),top_neigh_i(i,j,3*nC+1))	
	     enddo  
	  endif  
   ELSEIF ((inside(ii(0),ki(0),ji(0)) == 1).AND. &
	   (inside(ii(1),ki(1),ji(1)) == 0).AND. &
	   (inside(ii(2),ki(2),ji(2)) == 1).AND. &
	   (inside(ii(3),ki(3),ji(3)) == 0).AND. &
	   (inside(ii(4),ki(4),ji(4)) == 0).AND. &
	   (inside(ii(5),ki(5),ji(5)) == 0).AND. &
	   (inside(ii(6),ki(6),ji(6)) == 0).AND. &
	   (inside(ii(7),ki(7),ji(7)) == 0)) THEN
	    ! neighbor 0 on the boundary on the 0145 plane
	    nC = 0 
	    top_neigh_i(i,j,3*nC) = 0
	    top_neigh_i(i,j,3*nC+1) = 0
	    top_neigh_i(i,j,3*nC+2) = 0
	    ! first z
	    top_neigh(i,j,3*nC+2) = ht_p(ii(nC),ki(nC),ji(nC))
	    if (stag == 1) then
		! solve for x
		if (ibm_ht_xstag(ii(nC),ji(nC)) >= top_neigh(i,j,3*nC+2)) then
		   top_neigh(i,j,3*nC) = (ii(nC)*dx)-dx + (dx/4)+(dx/4)*((top_neigh(i,j,3*nC+2)-ibm_ht_xstag(ii(nC),ji(nC))) &
						                      /(ibm_ht(ii(nC)+1,ji(nC))-ibm_ht_xstag(ii(nC),ji(nC))))
		else
		   top_neigh(i,j,3*nC) = (ii(nC)*dx)-dx + (dx/4)*((top_neigh(i,j,3*nC+2)-ibm_ht(ii(nC),ji(nC))) &
							   /(ibm_ht_xstag(ii(nC),ji(nC))-ibm_ht(ii(nC),ji(nC))))
		endif						  
	       	! solve for y
		if (ibm_ht_ystag(ii(nC),ji(nC)+1) >= top_neigh(i,j,3*nC+2)) then
		   top_neigh(i,j,3*nC+1) = (ji(nC)*dy)-(dy/2) + (dy/4)+(dy/4)*((top_neigh(i,j,3*nC+2)-ibm_ht_ystag(ii(nC),ji(nC)+1)) &
						                            /(ibm_ht(ii(nC),ji(nC)+1)-ibm_ht_ystag(ii(nC),ji(nC)+1)))
		else
		   top_neigh(i,j,3*nC+1) = (ji(nC)*dy)-(dy/2) + (dy/4)*((top_neigh(i,j,3*nC+2)-ibm_ht(ii(nC),ji(nC))) &
							       /(ibm_ht_ystag(ii(nC),ji(nC)+1)-ibm_ht(ii(nC),ji(nC))))
		endif
	    elseif (stag == 2) then
		! solve for x
		if (ibm_ht_xstag(ii(nC)+1,ji(nC)) >= top_neigh(i,j,3*nC+2)) then
		   top_neigh(i,j,3*nC) = (ii(nC)*dx)-(dx/2) + (dx/4)+(dx/4)*((top_neigh(i,j,3*nC+2)-ibm_ht_xstag(ii(nC)+1,ji(nC))) &
						                          /(ibm_ht(ii(nC)+1,ji(nC))-ibm_ht_xstag(ii(nC)+1,ji(nC))))
		else
		   top_neigh(i,j,3*nC) = (ii(nC)*dx)-(dx/2) + (dx/4)*((top_neigh(i,j,3*nC+2)-ibm_ht(ii(nC),ji(nC))) &
						             /(ibm_ht_xstag(ii(nC)+1,ji(nC))-ibm_ht(ii(nC),ji(nC))))
		endif
		! solve for y
		if (ibm_ht_ystag(ii(nC),ji(nC)) >= top_neigh(i,j,3*nC+2)) then
		   top_neigh(i,j,3*nC+1) = (ji(nC)*dy)-dy + (dy/4)+(dy/4)*((top_neigh(i,j,3*nC+2)-ibm_ht_ystag(ii(nC),ji(nC))) &
						                        /(ibm_ht(ii(nC),ji(nC)+1)-ibm_ht_ystag(ii(nC),ji(nC))))
		else
		   top_neigh(i,j,3*nC+1) = (ji(nC)*dy)-dy + (dy/4)*((top_neigh(i,j,3*nC+2)-ibm_ht(ii(nC),ji(nC))) &
						             /(ibm_ht_ystag(ii(nC),ji(nC))-ibm_ht(ii(nC),ji(nC))))
		endif
	   elseif (stag == 3) then
		! solve for x
		if (ibm_ht_xstag(ii(nC)+1,ji(nC)) >= top_neigh(i,j,3*nC+2)) then
		   top_neigh(i,j,3*nC) = (ii(nC)*dx)-(dx/2) + (dx/4)+(dx/4)*((top_neigh(i,j,3*nC+2)-ibm_ht_xstag(ii(nC)+1,ji(nC))) &
						                          /(ibm_ht(ii(nC)+1,ji(nC))-ibm_ht_xstag(ii(nC)+1,ji(nC))))
		else
		   top_neigh(i,j,3*nC) = (ii(nC)*dx)-(dx/2) + (dx/4)*((top_neigh(i,j,3*nC+2)-ibm_ht(ii(nC),ji(nC))) &
						             /(ibm_ht_xstag(ii(nC)+1,ji(nC))-ibm_ht(ii(nC),ji(nC))))
		endif
		! solve for y
		if (ibm_ht_ystag(ii(nC),ji(nC)+1) >= top_neigh(i,j,3*nC+2)) then
		   top_neigh(i,j,3*nC+1) = (ji(nC)*dy)-(dy/2) + (dy/4)+(dy/4)*((top_neigh(i,j,3*nC+2)-ibm_ht_ystag(ii(nC),ji(nC)+1)) &
						                             /(ibm_ht(ii(nC),ji(nC)+1)-ibm_ht_ystag(ii(nC),ji(nC)+1)))
		else
		   top_neigh(i,j,3*nC+1) = (ji(nC)*dy)-(dy/2) + (dy/4)*((top_neigh(i,j,3*nC+2)-ibm_ht(ii(nC),ji(nC))) &
							       /(ibm_ht_ystag(ii(nC),ji(nC)+1)-ibm_ht(ii(nC),ji(nC))))
		endif
	   endif
	   ! neighbors 1,3,4,5,6,7 are zero computational node
	   nC = 1
	   top_neigh_i(i,j,3*nC) = ii(nC)
	   top_neigh_i(i,j,3*nC+1) = ji(nC)
	   top_neigh_i(i,j,3*nC+2) = ki(nC)		
	   if (stag ==1 ) then 			
	       top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx)
	       top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)
	   elseif (stag == 2) then
	       top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
	       top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy)	     
	   elseif (stag == 3) then
	       top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
	       top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)	     
	   endif
           top_neigh(i,j,3*nC+2) = ht_p(top_neigh_i(i,j,3*nC),top_neigh_i(i,j,3*nC+2),top_neigh_i(i,j,3*nC+1))
	   ! neighbor 2 on the boundary on the 2367 plane
	   nC = 2
	   top_neigh_i(i,j,3*nC) = 0
	   top_neigh_i(i,j,3*nC+1) = 0
	   top_neigh_i(i,j,3*nC+2) = 0
	   ! first z
	   top_neigh(i,j,3*nC+2) = ht_p(ii(nC),ki(nC),ji(nC))
	    if (stag == 1) then
		! solve for x
		if (ibm_ht_xstag(ii(nC),ji(nC)) >= top_neigh(i,j,3*nC+2)) then
		   top_neigh(i,j,3*nC) = (ii(nC)*dx)-dx + (dx/4)+(dx/4)*((top_neigh(i,j,3*nC+2)-ibm_ht_xstag(ii(nC),ji(nC))) &
						                      /(ibm_ht(ii(nC)+1,ji(nC))-ibm_ht_xstag(ii(nC),ji(nC))))
		else
		   top_neigh(i,j,3*nC) = (ii(nC)*dx)-dx + (dx/4)*((top_neigh(i,j,3*nC+2)-ibm_ht(ii(nC),ji(nC))) &
							   /(ibm_ht_xstag(ii(nC),ji(nC))-ibm_ht(ii(nC),ji(nC))))
		endif						  
	       	! solve for y
		if (ibm_ht_ystag(ii(nC),ji(nC)+1) >= top_neigh(i,j,3*nC+2)) then
		   top_neigh(i,j,3*nC+1) = (ji(nC)*dy)-(dy/2) + (dy/4)+(dy/4)*((top_neigh(i,j,3*nC+2)-ibm_ht_ystag(ii(nC),ji(nC)+1)) &
						                            /(ibm_ht(ii(nC),ji(nC)+1)-ibm_ht_ystag(ii(nC),ji(nC)+1)))
		else
		   top_neigh(i,j,3*nC+1) = (ji(nC)*dy)-(dy/2) + (dy/4)*((top_neigh(i,j,3*nC+2)-ibm_ht(ii(nC),ji(nC))) &
							       /(ibm_ht_ystag(ii(nC),ji(nC)+1)-ibm_ht(ii(nC),ji(nC))))
		endif
	    elseif (stag == 2) then
		! solve for x
		if (ibm_ht_xstag(ii(nC)+1,ji(nC)) >= top_neigh(i,j,3*nC+2)) then
		   top_neigh(i,j,3*nC) = (ii(nC)*dx)-(dx/2) + (dx/4)+(dx/4)*((top_neigh(i,j,3*nC+2)-ibm_ht_xstag(ii(nC)+1,ji(nC))) &
						                          /(ibm_ht(ii(nC)+1,ji(nC))-ibm_ht_xstag(ii(nC)+1,ji(nC))))
		else
		   top_neigh(i,j,3*nC) = (ii(nC)*dx)-(dx/2) + (dx/4)*((top_neigh(i,j,3*nC+2)-ibm_ht(ii(nC),ji(nC))) &
						             /(ibm_ht_xstag(ii(nC)+1,ji(nC))-ibm_ht(ii(nC),ji(nC))))
		endif
		! solve for y
		if (ibm_ht_ystag(ii(nC),ji(nC)) >= top_neigh(i,j,3*nC+2)) then
		   top_neigh(i,j,3*nC+1) = (ji(nC)*dy)-dy + (dy/4)+(dy/4)*((top_neigh(i,j,3*nC+2)-ibm_ht_ystag(ii(nC),ji(nC))) &
						                        /(ibm_ht(ii(nC),ji(nC)+1)-ibm_ht_ystag(ii(nC),ji(nC))))
		else
		   top_neigh(i,j,3*nC+1) = (ji(nC)*dy)-dy + (dy/4)*((top_neigh(i,j,3*nC+2)-ibm_ht(ii(nC),ji(nC))) &
						             /(ibm_ht_ystag(ii(nC),ji(nC))-ibm_ht(ii(nC),ji(nC))))
		endif
	   elseif (stag == 3) then
		! solve for x
		if (ibm_ht_xstag(ii(nC)+1,ji(nC)) >= top_neigh(i,j,3*nC+2)) then
		   top_neigh(i,j,3*nC) = (ii(nC)*dx)-(dx/2) + (dx/4)+(dx/4)*((top_neigh(i,j,3*nC+2)-ibm_ht_xstag(ii(nC)+1,ji(nC))) &
						                          /(ibm_ht(ii(nC)+1,ji(nC))-ibm_ht_xstag(ii(nC)+1,ji(nC))))
		else
		   top_neigh(i,j,3*nC) = (ii(nC)*dx)-(dx/2) + (dx/4)*((top_neigh(i,j,3*nC+2)-ibm_ht(ii(nC),ji(nC))) &
						             /(ibm_ht_xstag(ii(nC)+1,ji(nC))-ibm_ht(ii(nC),ji(nC))))
		endif
		! solve for y
		if (ibm_ht_ystag(ii(nC),ji(nC)+1) >= top_neigh(i,j,3*nC+2)) then
		   top_neigh(i,j,3*nC+1) = (ji(nC)*dy)-(dy/2) + (dy/4)+(dy/4)*((top_neigh(i,j,3*nC+2)-ibm_ht_ystag(ii(nC),ji(nC)+1)) &
						                             /(ibm_ht(ii(nC),ji(nC)+1)-ibm_ht_ystag(ii(nC),ji(nC)+1)))
		else
		   top_neigh(i,j,3*nC+1) = (ji(nC)*dy)-(dy/2) + (dy/4)*((top_neigh(i,j,3*nC+2)-ibm_ht(ii(nC),ji(nC))) &
							       /(ibm_ht_ystag(ii(nC),ji(nC)+1)-ibm_ht(ii(nC),ji(nC))))
		endif
	   endif
	   ! neighbors 1,3,4,5,6,7 are zero computational node
	   do nC = 3,7
	      top_neigh_i(i,j,3*nC) = ii(nC)
	      top_neigh_i(i,j,3*nC+1) = ji(nC)
	      top_neigh_i(i,j,3*nC+2) = ki(nC)		
	      if (stag ==1 ) then 			
		  top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx)
		  top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)
	      elseif (stag == 2) then
		  top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
		  top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy)	     
	      elseif (stag == 3) then
		  top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
		  top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)	     
	      endif
              top_neigh(i,j,3*nC+2) = ht_p(top_neigh_i(i,j,3*nC),top_neigh_i(i,j,3*nC+2),top_neigh_i(i,j,3*nC+1))
	   enddo
   ELSEIF ((inside(ii(0),ki(0),ji(0)) == 0).AND. &
	   (inside(ii(1),ki(1),ji(1)) == 1).AND. &
	   (inside(ii(2),ki(2),ji(2)) == 0).AND. &
	   (inside(ii(3),ki(3),ji(3)) == 1).AND. &
	   (inside(ii(4),ki(4),ji(4)) == 0).AND. &
	   (inside(ii(5),ki(5),ji(5)) == 0).AND. &
	   (inside(ii(6),ki(6),ji(6)) == 0).AND. &
	   (inside(ii(7),ki(7),ji(7)) == 0)) THEN
	   ! neighbors 0,2,4,5,6,7 are the zero computational nodes
           nC = 0
	   top_neigh_i(i,j,3*nC) = ii(nC)
	   top_neigh_i(i,j,3*nC+1) = ji(nC)
	   top_neigh_i(i,j,3*nC+2) = ki(nC)		
	   if (stag ==1 ) then 			
	       top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx)
	       top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)
	   elseif (stag == 2) then
	       top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
	       top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy)	     
	   elseif (stag == 3) then
	       top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
	       top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)	     
	   endif
	   top_neigh(i,j,3*nC+2) = ht_p(top_neigh_i(i,j,3*nC),top_neigh_i(i,j,3*nC+2),top_neigh_i(i,j,3*nC+1))
	   ! neighbor 1 on the boundary face that cuts the 0145 plane
	   nC = 1 
	   top_neigh_i(i,j,3*nC) = 0
	   top_neigh_i(i,j,3*nC+1) = 0
	   top_neigh_i(i,j,3*nC+2) = 0
	   ! first z
	   top_neigh(i,j,3*nC+2) = ht_p(ii(nC),ki(nC),ji(nC))
	   if (stag == 1) then
	       ! solve for x/2
	       if (ibm_ht_xstag(ii(nC)-1,ji(nC)) >= top_neigh(i,j,3*nC+2)) then
		  top_neigh(i,j,3*nC) = ((ii(nC)-1)*dx)-dx + (dx/2)+(dx/4)*((top_neigh(i,j,3*nC+2)-ibm_ht(ii(nC)-1,ji(nC))) &
						                   /(ibm_ht_xstag(ii(nC)-1,ji(nC))-ibm_ht(ii(nC)-1,ji(nC))))
	       else
		  top_neigh(i,j,3*nC) = ((ii(nC)-1)*dx)-(dx/2) +  (dx/4)+(dx/4)*((top_neigh(i,j,3*nC+2)-ibm_ht_xstag(ii(nC)-1,ji(nC))) &
							                        /(ibm_ht(ii(nC),ji(nC))-ibm_ht_xstag(ii(nC)-1,ji(nC))))
	       endif	
	       ! solve for y/2
	       if (ibm_ht_ystag(ii(nC),ji(nC)+1) >= top_neigh(i,j,3*nC+2)) then
		  top_neigh(i,j,3*nC+1) = (ji(nC)*dy)-(dy/2) + (dy/4)+(dy/4)*((top_neigh(i,j,3*nC+2)-ibm_ht_ystag(ii(nC),ji(nC)+1)) &
						                           /(ibm_ht(ii(nC),ji(nC)+1)-ibm_ht_ystag(ii(nC),ji(nC)+1)))
	       else 
		  top_neigh(i,j,3*nC+1) = (ji(nC)*dy)-(dy/2) + (dy/4)*((top_neigh(i,j,3*nC+2)-ibm_ht(ii(nC),ji(nC))) &
						              /(ibm_ht_ystag(ii(nC),ji(nC)+1)-ibm_ht(ii(nC),ji(nC))))
	       endif					  
	   elseif (stag == 2) then
	       ! solve for x/2
	       if (ibm_ht_xstag(ii(nC),ji(nC)) >= top_neigh(i,j,3*nC+2)) then
		  top_neigh(i,j,3*nC) = ((ii(nC)-1)*dx)-(dx/2) +  (dx/2)+(dx/4)*((top_neigh(i,j,3*nC+2)-ibm_ht(ii(nC)-1,ji(nC))) &
						                          /(ibm_ht_xstag(ii(nC),ji(nC))-ibm_ht(ii(nC)-1,ji(nC))))
	       else
		  top_neigh(i,j,3*nC) = (ii(nC)*dx)-dx +  (dx/4)+(dx/4)*((top_neigh(i,j,3*nC+2)-ibm_ht_xstag(ii(nC),ji(nC))) &
						                        /(ibm_ht(ii(nC),ji(nC))-ibm_ht_xstag(ii(nC),ji(nC))))
	       endif
	       ! solve for y/2
	       if (ibm_ht_ystag(ii(nC),ji(nC)) >= top_neigh(i,j,3*nC+2)) then
		  top_neigh(i,j,3*nC+1) = (ji(nC)*dy)-dy + (dy/4)+(dy/4)*((top_neigh(i,j,3*nC+2)-ibm_ht_ystag(ii(nC),ji(nC))) &
						                    /(ibm_ht(ii(nC),ji(nC)+1)-ibm_ht_ystag(ii(nC),ji(nC))))
	       else
		  top_neigh(i,j,3*nC+1) = (ji(nC)*dy)-dy + (dy/4)*((top_neigh(i,j,3*nC+2)-ibm_ht(ii(nC),ji(nC))) &
						            /(ibm_ht_ystag(ii(nC),ji(nC))-ibm_ht(ii(nC),ji(nC))))
	       endif
	   elseif (stag == 3) then
	       ! solve for x/2
	       if (ibm_ht_xstag(ii(nC),ji(nC)) >= top_neigh(i,j,3*nC+2)) then
		  top_neigh(i,j,3*nC) = ((ii(nC)-1)*dx)-(dx/2) +  (dx/2)+(dx/4)*((top_neigh(i,j,3*nC+2)-ibm_ht(ii(nC)-1,ji(nC))) &
						                          /(ibm_ht_xstag(ii(nC),ji(nC))-ibm_ht(ii(nC)-1,ji(nC))))
	       else
		  top_neigh(i,j,3*nC) = (ii(nC)*dx)-dx +  (dx/4)+(dx/4)*((top_neigh(i,j,3*nC+2)-ibm_ht_xstag(ii(nC),ji(nC))) &
						                        /(ibm_ht(ii(nC),ji(nC))-ibm_ht_xstag(ii(nC),ji(nC))))
	       endif
	       ! solve for y/2
	       if (ibm_ht_ystag(ii(nC),ji(nC)+1) >= top_neigh(i,j,3*nC+2)) then
		  top_neigh(i,j,3*nC+1) = (ji(nC)*dy)-(dy/2) + (dy/4)+(dy/4)*((top_neigh(i,j,3*nC+2)-ibm_ht_ystag(ii(nC),ji(nC)+1)) &
						                           /(ibm_ht(ii(nC),ji(nC)+1)-ibm_ht_ystag(ii(nC),ji(nC)+1)))
	       else
		  top_neigh(i,j,3*nC+1) = (ji(nC)*dy)-(dy/2) + (dy/4)*((top_neigh(i,j,3*nC+2)-ibm_ht(ii(nC),ji(nC))) &
							      /(ibm_ht_ystag(ii(nC),ji(nC)+1)-ibm_ht(ii(nC),ji(nC))))
	       endif
	   endif
	   nC = 2
	   top_neigh_i(i,j,3*nC) = ii(nC)
	   top_neigh_i(i,j,3*nC+1) = ji(nC)
	   top_neigh_i(i,j,3*nC+2) = ki(nC)		
	   if (stag ==1 ) then 			
	       top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx)
	       top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)
	   elseif (stag == 2) then
	       top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
	       top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy)	     
	   elseif (stag == 3) then
	       top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
	       top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)	     
	   endif
	   top_neigh(i,j,3*nC+2) = ht_p(top_neigh_i(i,j,3*nC),top_neigh_i(i,j,3*nC+2),top_neigh_i(i,j,3*nC+1))
	   ! neighbor 3 on the boundary face that cuts the 2367 plane
	   nC = 3
	   top_neigh_i(i,j,3*nC) = 0
	   top_neigh_i(i,j,3*nC+1) = 0
	   top_neigh_i(i,j,3*nC+2) = 0
	   ! first z
	   top_neigh(i,j,3*nC+2) = ht_p(ii(nC),ki(nC),ji(nC))
	   if (stag == 1) then
	       ! solve for x/2
	       if (ibm_ht_xstag(ii(nC)-1,ji(nC)) >= top_neigh(i,j,3*nC+2)) then
		  top_neigh(i,j,3*nC) = ((ii(nC)-1)*dx)-dx + (dx/2)+(dx/4)*((top_neigh(i,j,3*nC+2)-ibm_ht(ii(nC)-1,ji(nC))) &
						                   /(ibm_ht_xstag(ii(nC)-1,ji(nC))-ibm_ht(ii(nC)-1,ji(nC))))
	       else
		  top_neigh(i,j,3*nC) = ((ii(nC)-1)*dx)-(dx/2) +  (dx/4)+(dx/4)*((top_neigh(i,j,3*nC+2)-ibm_ht_xstag(ii(nC)-1,ji(nC))) &
							                        /(ibm_ht(ii(nC),ji(nC))-ibm_ht_xstag(ii(nC)-1,ji(nC))))
	       endif	
	       ! solve for y/2
	       if (ibm_ht_ystag(ii(nC),ji(nC)+1) >= top_neigh(i,j,3*nC+2)) then
		  top_neigh(i,j,3*nC+1) = (ji(nC)*dy)-(dy/2) + (dy/4)+(dy/4)*((top_neigh(i,j,3*nC+2)-ibm_ht_ystag(ii(nC),ji(nC)+1)) &
						                           /(ibm_ht(ii(nC),ji(nC)+1)-ibm_ht_ystag(ii(nC),ji(nC)+1)))
	       else 
		  top_neigh(i,j,3*nC+1) = (ji(nC)*dy)-(dy/2) + (dy/4)*((top_neigh(i,j,3*nC+2)-ibm_ht(ii(nC),ji(nC))) &
						              /(ibm_ht_ystag(ii(nC),ji(nC)+1)-ibm_ht(ii(nC),ji(nC))))
	       endif					  
	   elseif (stag == 2) then
	       ! solve for x/2
	       if (ibm_ht_xstag(ii(nC),ji(nC)) >= top_neigh(i,j,3*nC+2)) then
		  top_neigh(i,j,3*nC) = ((ii(nC)-1)*dx)-(dx/2) +  (dx/2)+(dx/4)*((top_neigh(i,j,3*nC+2)-ibm_ht(ii(nC)-1,ji(nC))) &
						                          /(ibm_ht_xstag(ii(nC),ji(nC))-ibm_ht(ii(nC)-1,ji(nC))))
	       else
		  top_neigh(i,j,3*nC) = (ii(nC)*dx)-dx +  (dx/4)+(dx/4)*((top_neigh(i,j,3*nC+2)-ibm_ht_xstag(ii(nC),ji(nC))) &
						                        /(ibm_ht(ii(nC),ji(nC))-ibm_ht_xstag(ii(nC),ji(nC))))
	       endif
	       ! solve for y/2
	       if (ibm_ht_ystag(ii(nC),ji(nC)) >= top_neigh(i,j,3*nC+2)) then
		  top_neigh(i,j,3*nC+1) = (ji(nC)*dy)-dy + (dy/4)+(dy/4)*((top_neigh(i,j,3*nC+2)-ibm_ht_ystag(ii(nC),ji(nC))) &
						                    /(ibm_ht(ii(nC),ji(nC)+1)-ibm_ht_ystag(ii(nC),ji(nC))))
	       else
		  top_neigh(i,j,3*nC+1) = (ji(nC)*dy)-dy + (dy/4)*((top_neigh(i,j,3*nC+2)-ibm_ht(ii(nC),ji(nC))) &
						            /(ibm_ht_ystag(ii(nC),ji(nC))-ibm_ht(ii(nC),ji(nC))))
	       endif
	   elseif (stag == 3) then
	       ! solve for x/2
	       if (ibm_ht_xstag(ii(nC),ji(nC)) >= top_neigh(i,j,3*nC+2)) then
		  top_neigh(i,j,3*nC) = ((ii(nC)-1)*dx)-(dx/2) +  (dx/2)+(dx/4)*((top_neigh(i,j,3*nC+2)-ibm_ht(ii(nC)-1,ji(nC))) &
						                          /(ibm_ht_xstag(ii(nC),ji(nC))-ibm_ht(ii(nC)-1,ji(nC))))
	       else
		  top_neigh(i,j,3*nC) = (ii(nC)*dx)-dx +  (dx/4)+(dx/4)*((top_neigh(i,j,3*nC+2)-ibm_ht_xstag(ii(nC),ji(nC))) &
						                        /(ibm_ht(ii(nC),ji(nC))-ibm_ht_xstag(ii(nC),ji(nC))))
	       endif
	       ! solve for y/2
	       if (ibm_ht_ystag(ii(nC),ji(nC)+1) >= top_neigh(i,j,3*nC+2)) then
		  top_neigh(i,j,3*nC+1) = (ji(nC)*dy)-(dy/2) + (dy/4)+(dy/4)*((top_neigh(i,j,3*nC+2)-ibm_ht_ystag(ii(nC),ji(nC)+1)) &
						                           /(ibm_ht(ii(nC),ji(nC)+1)-ibm_ht_ystag(ii(nC),ji(nC)+1)))
	       else
		  top_neigh(i,j,3*nC+1) = (ji(nC)*dy)-(dy/2) + (dy/4)*((top_neigh(i,j,3*nC+2)-ibm_ht(ii(nC),ji(nC))) &
							      /(ibm_ht_ystag(ii(nC),ji(nC)+1)-ibm_ht(ii(nC),ji(nC))))
	       endif
	   endif
	   ! neighbors 0,2,4,5,6,7 are the zero computational nodes
	   do nC = 4,7
	      top_neigh_i(i,j,3*nC) = ii(nC)
	      top_neigh_i(i,j,3*nC+1) = ji(nC)
	      top_neigh_i(i,j,3*nC+2) = ki(nC)		
	      if (stag ==1 ) then 			
		  top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx)
		  top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)
	      elseif (stag == 2) then
		  top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
		  top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy)	     
	      elseif (stag == 3) then
		  top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
		  top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)	     
	      endif
	      top_neigh(i,j,3*nC+2) = ht_p(top_neigh_i(i,j,3*nC),top_neigh_i(i,j,3*nC+2),top_neigh_i(i,j,3*nC+1))  
	   enddo
    ELSEIF ((inside(ii(0),ki(0),ji(0)) == 0).AND. &
	    (inside(ii(1),ki(1),ji(1)) == 0).AND. &
	    (inside(ii(2),ki(2),ji(2)) == 0).AND. &
	    (inside(ii(3),ki(3),ji(3)) == 0).AND. &
	    (inside(ii(4),ki(4),ji(4)) == 1).AND. &
	    (inside(ii(5),ki(5),ji(5)) == 0).AND. &
	    (inside(ii(6),ki(6),ji(6)) == 1).AND. &
	    (inside(ii(7),ki(7),ji(7)) == 0)) THEN
	    ! neighbors 0,1,2,3,5,7 are the zero computational nodes
	    do nC = 0,3
	       top_neigh_i(i,j,3*nC) = ii(nC)
	       top_neigh_i(i,j,3*nC+1) = ji(nC)
	       top_neigh_i(i,j,3*nC+2) = ki(nC)		
	       if (stag ==1 ) then 			
		   top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx)
		   top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)
	       elseif (stag == 2) then
		   top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
		   top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy)	     
	       elseif (stag == 3) then
		   top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
		   top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)	     
	       endif
	       top_neigh(i,j,3*nC+2) = ht_p(top_neigh_i(i,j,3*nC),top_neigh_i(i,j,3*nC+2),top_neigh_i(i,j,3*nC+1))  
	    enddo	  
	    ! neighbor 4 on the boundary on the 0145 plane 
	    nC = 4 
	    top_neigh_i(i,j,3*nC) = 0
	    top_neigh_i(i,j,3*nC+1) = 0
	    top_neigh_i(i,j,3*nC+2) = 0
	    ! first z
	    top_neigh(i,j,3*nC+2) = ht_p(ii(nC),ki(nC),ji(nC))
	    if (stag == 1) then
		! solve for x
		if (ibm_ht_xstag(ii(nC),ji(nC)) >= top_neigh(i,j,3*nC+2)) then
		   top_neigh(i,j,3*nC) = (ii(nC)*dx)-dx +(dx/4)+(dx/4)*((top_neigh(i,j,3*nC+2)-ibm_ht_xstag(ii(nC),ji(nC))) &
						                       /(ibm_ht(ii(nC)+1,ji(nC))-ibm_ht_xstag(ii(nC),ji(nC))))
		else
		   top_neigh(i,j,3*nC) = (ii(nC)*dx)-dx + (dx/4)*((top_neigh(i,j,3*nC+2)-ibm_ht(ii(nC),ji(nC))) &
						           /(ibm_ht_xstag(ii(nC),ji(nC))-ibm_ht(ii(nC),ji(nC))))
		endif						  
		! solve for y
		if (ibm_ht_ystag(ii(nC),ji(nC)) >= top_neigh(i,j,3*nC+2)) then
		   top_neigh(i,j,3*nC+1) = ((ji(nC)-1)*dy) +(dy/4)*((top_neigh(i,j,3*nC+2)-ibm_ht(ii(nC),ji(nC)-1)) &
						             /(ibm_ht_ystag(ii(nC),ji(nC))-ibm_ht(ii(nC),ji(nC)-1)))
		else
		   top_neigh(i,j,3*nC+1) = ((ji(nC)-1)*dy)-dy + (dy/4)+(dy/4)*((top_neigh(i,j,3*nC+2)-ibm_ht_ystag(ii(nC),ji(nC))) &
							                          /(ibm_ht(ii(nC),ji(nC))-ibm_ht_ystag(ii(nC),ji(nC))))
		endif
	    elseif (stag == 2) then
		! solve for x
		if (ibm_ht_xstag(ii(nC)+1,ji(nC)) >= top_neigh(i,j,3*nC+2)) then
		   top_neigh(i,j,3*nC) = (ii(nC)*dx)-(dx/2) + (dx/4)+(dx/4)*((top_neigh(i,j,3*nC+2)-ibm_ht_xstag(ii(nC)+1,ji(nC))) &
						                          /(ibm_ht(ii(nC)+1,ji(nC))-ibm_ht_xstag(ii(nC)+1,ji(nC))))
		else
		   top_neigh(i,j,3*nC) = (ii(nC)*dx)-(dx/2) + (dx/4)*((top_neigh(i,j,3*nC+2)-ibm_ht(ii(nC),ji(nC))) &
						             /(ibm_ht_xstag(ii(nC)+1,ji(nC))-ibm_ht(ii(nC),ji(nC))))
		endif
		! solve for y
		if (ibm_ht_ystag(ii(nC),ji(nC)-1) >= top_neigh(i,j,3*nC+2)) then
		   top_neigh(i,j,3*nC+1) = ((ji(nC)-1)*dy)-dy + (dy/2)+(dy/4)*((top_neigh(i,j,3*nC+2)-ibm_ht(ii(nC),ji(nC)-1)) &
						                      /(ibm_ht_ystag(ii(nC),ji(nC)-1)-ibm_ht(ii(nC),ji(nC)-1)))
		else
		   top_neigh(i,j,3*nC+1) = ((ji(nC)-1)*dy)-(dy/2) + (dy/4)+(dy/4)*((top_neigh(i,j,3*nC+2)-ibm_ht_ystag(ii(nC),ji(nC)-1)) &
						                                  /(ibm_ht(ii(nC),ji(nC))-ibm_ht_ystag(ii(nC),ji(nC)-1)))
		endif
	    elseif (stag == 3) then
		! solve for x
		if (ibm_ht_xstag(ii(nC)+1,ji(nC)) >= top_neigh(i,j,3*nC+2)) then
		   top_neigh(i,j,3*nC) = (ii(nC)*dx)-(dx/2) + (dx/4)+(dx/4)*((top_neigh(i,j,3*nC+2)-ibm_ht_xstag(ii(nC)+1,ji(nC))) &
						                          /(ibm_ht(ii(nC)+1,ji(nC))-ibm_ht_xstag(ii(nC)+1,ji(nC))))
		else
		   top_neigh(i,j,3*nC) = (ii(nC)*dx)-(dx/2) + (dx/4)*((top_neigh(i,j,3*nC+2)-ibm_ht(ii(nC),ji(nC))) &
						             /(ibm_ht_xstag(ii(nC)+1,ji(nC))-ibm_ht(ii(nC),ji(nC))))
		endif
		! solve for y
		if (ibm_ht_ystag(ii(nC),ji(nC)) >= top_neigh(i,j,3*nC+2)) then
		   top_neigh(i,j,3*nC+1) = ((ji(nC)-1)*dy) + (dy/4)*((top_neigh(i,j,3*nC+2)-ibm_ht(ii(nC),ji(nC)-1)) &
						              /(ibm_ht_ystag(ii(nC),ji(nC))-ibm_ht(ii(nC),ji(nC)-1)))
		else
		   top_neigh(i,j,3*nC+1) = ((ji(nC)-1)*dy) + (dy/4)+(dy/4)*((top_neigh(i,j,3*nC+2)-ibm_ht_ystag(ii(nC),ji(nC))) &
							                  /(ibm_ht(ii(nC),ji(nC))-ibm_ht_ystag(ii(nC),ji(nC))))
		endif
	    endif
	    ! neighbors 0,1,2,3,5,7 are the zero computational nodes
	    nC = 5
	    top_neigh_i(i,j,3*nC) = ii(nC)
	    top_neigh_i(i,j,3*nC+1) = ji(nC)
	    top_neigh_i(i,j,3*nC+2) = ki(nC)		
	    if (stag ==1 ) then 			
		top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx)
		top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)
	    elseif (stag == 2) then
		top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
		top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy)	     
	    elseif (stag == 3) then
		top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
		top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)	     
	    endif
	    top_neigh(i,j,3*nC+2) = ht_p(top_neigh_i(i,j,3*nC),top_neigh_i(i,j,3*nC+2),top_neigh_i(i,j,3*nC+1))
	    ! neighbor 6 on the boundary on the 2367 plane 
	    nC = 6
	    top_neigh_i(i,j,3*nC) = 0
	    top_neigh_i(i,j,3*nC+1) = 0
	    top_neigh_i(i,j,3*nC+2) = 0
	    ! first z
	    top_neigh(i,j,3*nC+2) = ht_p(ii(nC),ki(nC),ji(nC))
	    if (stag == 1) then
		! solve for x
		if (ibm_ht_xstag(ii(nC),ji(nC)) >= top_neigh(i,j,3*nC+2)) then
		   top_neigh(i,j,3*nC) = (ii(nC)*dx)-dx +(dx/4)+(dx/4)*((top_neigh(i,j,3*nC+2)-ibm_ht_xstag(ii(nC),ji(nC))) &
						                       /(ibm_ht(ii(nC)+1,ji(nC))-ibm_ht_xstag(ii(nC),ji(nC))))
		else
		   top_neigh(i,j,3*nC) = (ii(nC)*dx)-dx + (dx/4)*((top_neigh(i,j,3*nC+2)-ibm_ht(ii(nC),ji(nC))) &
						           /(ibm_ht_xstag(ii(nC),ji(nC))-ibm_ht(ii(nC),ji(nC))))
		endif						  
		! solve for y
		if (ibm_ht_ystag(ii(nC),ji(nC)) >= top_neigh(i,j,3*nC+2)) then
		   top_neigh(i,j,3*nC+1) = ((ji(nC)-1)*dy) +(dy/4)*((top_neigh(i,j,3*nC+2)-ibm_ht(ii(nC),ji(nC)-1)) &
						             /(ibm_ht_ystag(ii(nC),ji(nC))-ibm_ht(ii(nC),ji(nC)-1)))
		else
		   top_neigh(i,j,3*nC+1) = ((ji(nC)-1)*dy)-dy + (dy/4)+(dy/4)*((top_neigh(i,j,3*nC+2)-ibm_ht_ystag(ii(nC),ji(nC))) &
							                          /(ibm_ht(ii(nC),ji(nC))-ibm_ht_ystag(ii(nC),ji(nC))))
		endif
	    elseif (stag == 2) then
		! solve for x
		if (ibm_ht_xstag(ii(nC)+1,ji(nC)) >= top_neigh(i,j,3*nC+2)) then
		   top_neigh(i,j,3*nC) = (ii(nC)*dx)-(dx/2) + (dx/4)+(dx/4)*((top_neigh(i,j,3*nC+2)-ibm_ht_xstag(ii(nC)+1,ji(nC))) &
						                          /(ibm_ht(ii(nC)+1,ji(nC))-ibm_ht_xstag(ii(nC)+1,ji(nC))))
		else
		   top_neigh(i,j,3*nC) = (ii(nC)*dx)-(dx/2) + (dx/4)*((top_neigh(i,j,3*nC+2)-ibm_ht(ii(nC),ji(nC))) &
						             /(ibm_ht_xstag(ii(nC)+1,ji(nC))-ibm_ht(ii(nC),ji(nC))))
		endif
		! solve for y
		if (ibm_ht_ystag(ii(nC),ji(nC)-1) >= top_neigh(i,j,3*nC+2)) then
		   top_neigh(i,j,3*nC+1) = ((ji(nC)-1)*dy)-dy + (dy/2)+(dy/4)*((top_neigh(i,j,3*nC+2)-ibm_ht(ii(nC),ji(nC)-1)) &
						                      /(ibm_ht_ystag(ii(nC),ji(nC)-1)-ibm_ht(ii(nC),ji(nC)-1)))
		else
		   top_neigh(i,j,3*nC+1) = ((ji(nC)-1)*dy)-(dy/2) + (dy/4)+(dy/4)*((top_neigh(i,j,3*nC+2)-ibm_ht_ystag(ii(nC),ji(nC)-1)) &
						                                  /(ibm_ht(ii(nC),ji(nC))-ibm_ht_ystag(ii(nC),ji(nC)-1)))
		endif
	    elseif (stag == 3) then
		! solve for x
		if (ibm_ht_xstag(ii(nC)+1,ji(nC)) >= top_neigh(i,j,3*nC+2)) then
		   top_neigh(i,j,3*nC) = (ii(nC)*dx)-(dx/2) + (dx/4)+(dx/4)*((top_neigh(i,j,3*nC+2)-ibm_ht_xstag(ii(nC)+1,ji(nC))) &
						                          /(ibm_ht(ii(nC)+1,ji(nC))-ibm_ht_xstag(ii(nC)+1,ji(nC))))
		else
		   top_neigh(i,j,3*nC) = (ii(nC)*dx)-(dx/2) + (dx/4)*((top_neigh(i,j,3*nC+2)-ibm_ht(ii(nC),ji(nC))) &
						             /(ibm_ht_xstag(ii(nC)+1,ji(nC))-ibm_ht(ii(nC),ji(nC))))
		endif
		! solve for y
		if (ibm_ht_ystag(ii(nC),ji(nC)) >= top_neigh(i,j,3*nC+2)) then
		   top_neigh(i,j,3*nC+1) = ((ji(nC)-1)*dy) + (dy/4)*((top_neigh(i,j,3*nC+2)-ibm_ht(ii(nC),ji(nC)-1)) &
						              /(ibm_ht_ystag(ii(nC),ji(nC))-ibm_ht(ii(nC),ji(nC)-1)))
		else
		   top_neigh(i,j,3*nC+1) = ((ji(nC)-1)*dy) + (dy/4)+(dy/4)*((top_neigh(i,j,3*nC+2)-ibm_ht_ystag(ii(nC),ji(nC))) &
							                  /(ibm_ht(ii(nC),ji(nC))-ibm_ht_ystag(ii(nC),ji(nC))))
		endif
	    endif
	    ! neighbors 0,1,2,3,5,7 are the zero computational nodes
	    nC = 7
	    top_neigh_i(i,j,3*nC) = ii(nC)
	    top_neigh_i(i,j,3*nC+1) = ji(nC)
	    top_neigh_i(i,j,3*nC+2) = ki(nC)		
	    if (stag ==1 ) then 			
		top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx)
		top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)
	    elseif (stag == 2) then
		top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
		top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy)	     
	    elseif (stag == 3) then
		top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
		top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)	     
	    endif
	    top_neigh(i,j,3*nC+2) = ht_p(top_neigh_i(i,j,3*nC),top_neigh_i(i,j,3*nC+2),top_neigh_i(i,j,3*nC+1))
    ELSEIF ((inside(ii(0),ki(0),ji(0)) == 0).AND. &
	    (inside(ii(1),ki(1),ji(1)) == 0).AND. &
	    (inside(ii(2),ki(2),ji(2)) == 0).AND. &
	    (inside(ii(3),ki(3),ji(3)) == 0).AND. &
	    (inside(ii(4),ki(4),ji(4)) == 0).AND. &
	    (inside(ii(5),ki(5),ji(5)) == 1).AND. &
	    (inside(ii(6),ki(6),ji(6)) == 0).AND. &
	    (inside(ii(7),ki(7),ji(7)) == 1)) THEN
	    ! neighbors 0,1,2,3,4,6 are the zero computational nodes
	    do nC = 0,4
	       top_neigh_i(i,j,3*nC) = ii(nC)
	       top_neigh_i(i,j,3*nC+1) = ji(nC)
	       top_neigh_i(i,j,3*nC+2) = ki(nC)		
	       if (stag ==1 ) then 			
		   top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx)
		   top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)
	       elseif (stag == 2) then
		   top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
		   top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy)	     
	       elseif (stag == 3) then
		   top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
		   top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)	     
	       endif
	       top_neigh(i,j,3*nC+2) = ht_p(top_neigh_i(i,j,3*nC),top_neigh_i(i,j,3*nC+2),top_neigh_i(i,j,3*nC+1))
	    enddo
	    ! neighbor 5 on the boundary on the 0145 plane 
	    nC = 5
	    top_neigh_i(i,j,3*nC) = 0
	    top_neigh_i(i,j,3*nC+1) = 0
	    top_neigh_i(i,j,3*nC+2) = 0
	    ! first z
	    top_neigh(i,j,3*nC+2) = ht_p(ii(nC),ki(nC),ji(nC))
 	    if (stag == 1) then
 		! solve for x
 		if (ibm_ht_xstag(ii(nC)-1,ji(nC)) >= top_neigh(i,j,3*nC+2)) then
 		   top_neigh(i,j,3*nC) = ((ii(nC)-1)*dx)-dx + (dx/2)+(dx/4)*((top_neigh(i,j,3*nC+2)-ibm_ht(ii(nC)-1,ji(nC))) &
 								    /(ibm_ht_xstag(ii(nC)-1,ji(nC))-ibm_ht(ii(nC)-1,ji(nC))))
 		else
 		   top_neigh(i,j,3*nC) = ((ii(nC)-1)*dx)-(dx/2) + (dx/4)+(dx/4)*((top_neigh(i,j,3*nC+2)-ibm_ht_xstag(ii(nC)-1,ji(nC))) &
 									        /(ibm_ht(ii(nC),ji(nC))-ibm_ht_xstag(ii(nC)-1,ji(nC))))
 		endif						  
 		! solve for y
 		if (ibm_ht_ystag(ii(nC),ji(nC)) >= top_neigh(i,j,3*nC+2)) then
 		   top_neigh(i,j,3*nC+1) = ((ji(nC)-1)*dy)-(dy/2) + (dy/2)+(dy/4)*((top_neigh(i,j,3*nC+2)-ibm_ht(ii(nC),ji(nC)-1)) &
 									    /(ibm_ht_ystag(ii(nC),ji(nC))-ibm_ht(ii(nC),ji(nC)-1)))
 		else
 		   top_neigh(i,j,3*nC+1) = (ji(nC)*dy)-dy + (dy/4)+(dy/4)*((top_neigh(i,j,3*nC+2)-ibm_ht_ystag(ii(nC),ji(nC))) &
 									  /(ibm_ht(ii(nC),ji(nC))-ibm_ht_ystag(ii(nC),ji(nC))))
 		endif
 	    elseif (stag == 2) then
 		! solve for x
 		if (ibm_ht_xstag(ii(nC),ji(nC)) >= top_neigh(i,j,3*nC+2)) then
 		   top_neigh(i,j,3*nC) = ((ii(nC)-1)*dx)-(dx/2) + (dx/2)+(dx/4)*((top_neigh(i,j,3*nC+2)-ibm_ht(ii(nC)-1,ji(nC))) &
 								        /(ibm_ht_xstag(ii(nC)+1,ji(nC))-ibm_ht(ii(nC)-1,ji(nC))))
 		else
 		   top_neigh(i,j,3*nC) = (ii(nC)*dx)-dx + (dx/4)+(dx/4)*((top_neigh(i,j,3*nC+2)-ibm_ht_xstag(ii(nC),ji(nC))) &
 								        /(ibm_ht(ii(nC),ji(nC))-ibm_ht_xstag(ii(nC),ji(nC))))
 		endif
 		! solve for y
 		if (ibm_ht_ystag(ii(nC),ji(nC)-1) >= top_neigh(i,j,3*nC+2)) then
 		   top_neigh(i,j,3*nC+1) = ((ji(nC)-1)*dy)-dy + (dy/2)+(dy/4)*((top_neigh(i,j,3*nC+2)-ibm_ht(ii(nC),ji(nC)-1)) &
 								      /(ibm_ht_ystag(ii(nC),ji(nC)-1)-ibm_ht(ii(nC),ji(nC)-1)))
 		else
 		   top_neigh(i,j,3*nC+1) = ((ji(nC)-1)*dy)-(dy/2) + (dy/4)+(dy/4)*((top_neigh(i,j,3*nC+2)-ibm_ht_ystag(ii(nC),ji(nC)-1)) &
 									    	  /(ibm_ht(ii(nC),ji(nC))-ibm_ht_ystag(ii(nC),ji(nC)-1)))
 		endif
 	    elseif (stag == 3) then
 		! solve for x
 		if (ibm_ht_xstag(ii(nC),ji(nC)) >= top_neigh(i,j,3*nC+2)) then
 		   top_neigh(i,j,3*nC) = ((ii(nC)-1)*dx)-(dx/2) + (dx/2)+(dx/4)*((top_neigh(i,j,3*nC+2)-ibm_ht(ii(nC)-1,ji(nC))) &
 									  /(ibm_ht_xstag(ii(nC),ji(nC))-ibm_ht(ii(nC)-1,ji(nC))))
 		else
 		   top_neigh(i,j,3*nC) = (ii(nC)*dx)-dx + (dx/4)+(dx/4)*((top_neigh(i,j,3*nC+2)-ibm_ht_xstag(ii(nC),ji(nC))) &
 								        /(ibm_ht(ii(nC),ji(nC))-ibm_ht_xstag(ii(nC),ji(nC))))
 		endif
 		! solve for y
 		if (ibm_ht_ystag(ii(nC),ji(nC)) >= top_neigh(i,j,3*nC+2)) then
 		   top_neigh(i,j,3*nC+1) = ((ji(nC)-1)*dy)-(dy/2) + (dy/2)+(dy/4)*((top_neigh(i,j,3*nC+2)-ibm_ht(ii(nC),ji(nC)-1)) &
 									    /(ibm_ht_ystag(ii(nC),ji(nC))-ibm_ht(ii(nC),ji(nC)-1)))
 		else
 		   top_neigh(i,j,3*nC+1) = (ji(nC)*dy)-dy + (dy/4)+(dy/4)*((top_neigh(i,j,3*nC+2)-ibm_ht_ystag(ii(nC),ji(nC))) &
 									/(ibm_ht(ii(nC),ji(nC))-ibm_ht_ystag(ii(nC),ji(nC))))
 		endif
 	    endif
	    ! neighbors 0,1,2,3,4,6 are the zero computational nodes
	    nC = 6
	    top_neigh_i(i,j,3*nC) = ii(nC)
	    top_neigh_i(i,j,3*nC+1) = ji(nC)
	    top_neigh_i(i,j,3*nC+2) = ki(nC)		
	    if (stag ==1 ) then 			
		top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx)
		top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)
	    elseif (stag == 2) then
		top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
		top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy)	     
	    elseif (stag == 3) then
		top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
		top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)	     
	    endif
	    top_neigh(i,j,3*nC+2) = ht_p(top_neigh_i(i,j,3*nC),top_neigh_i(i,j,3*nC+2),top_neigh_i(i,j,3*nC+1))
	    ! neighbor 7 on the boundary on the 2367 plane 
	    nC = 7
	    top_neigh_i(i,j,3*nC) = 0
	    top_neigh_i(i,j,3*nC+1) = 0
	    top_neigh_i(i,j,3*nC+2) = 0
	    ! first z
	    top_neigh(i,j,3*nC+2) = ht_p(ii(nC),ki(nC),ji(nC))
 	    if (stag == 1) then
 		! solve for x
 		if (ibm_ht_xstag(ii(nC)-1,ji(nC)) >= top_neigh(i,j,3*nC+2)) then
 		   top_neigh(i,j,3*nC) = ((ii(nC)-1)*dx)-dx + (dx/2)+(dx/4)*((top_neigh(i,j,3*nC+2)-ibm_ht(ii(nC)-1,ji(nC))) &
 								    /(ibm_ht_xstag(ii(nC)-1,ji(nC))-ibm_ht(ii(nC)-1,ji(nC))))
 		else
 		   top_neigh(i,j,3*nC) = ((ii(nC)-1)*dx)-(dx/2) + (dx/4)+(dx/4)*((top_neigh(i,j,3*nC+2)-ibm_ht_xstag(ii(nC)-1,ji(nC))) &
 									        /(ibm_ht(ii(nC),ji(nC))-ibm_ht_xstag(ii(nC)-1,ji(nC))))
 		endif						  
 		! solve for y
 		if (ibm_ht_ystag(ii(nC),ji(nC)) >= top_neigh(i,j,3*nC+2)) then
 		   top_neigh(i,j,3*nC+1) = ((ji(nC)-1)*dy)-(dy/2) + (dy/2)+(dy/4)*((top_neigh(i,j,3*nC+2)-ibm_ht(ii(nC),ji(nC)-1)) &
 									    /(ibm_ht_ystag(ii(nC),ji(nC))-ibm_ht(ii(nC),ji(nC)-1)))
 		else
 		   top_neigh(i,j,3*nC+1) = (ji(nC)*dy)-dy + (dy/4)+(dy/4)*((top_neigh(i,j,3*nC+2)-ibm_ht_ystag(ii(nC),ji(nC))) &
 									  /(ibm_ht(ii(nC),ji(nC))-ibm_ht_ystag(ii(nC),ji(nC))))
 		endif
 	    elseif (stag == 2) then
 		! solve for x
 		if (ibm_ht_xstag(ii(nC),ji(nC)) >= top_neigh(i,j,3*nC+2)) then
 		   top_neigh(i,j,3*nC) = ((ii(nC)-1)*dx)-(dx/2) + (dx/2)+(dx/4)*((top_neigh(i,j,3*nC+2)-ibm_ht(ii(nC)-1,ji(nC))) &
 								        /(ibm_ht_xstag(ii(nC)+1,ji(nC))-ibm_ht(ii(nC)-1,ji(nC))))
 		else
 		   top_neigh(i,j,3*nC) = (ii(nC)*dx)-dx + (dx/4)+(dx/4)*((top_neigh(i,j,3*nC+2)-ibm_ht_xstag(ii(nC),ji(nC))) &
 								        /(ibm_ht(ii(nC),ji(nC))-ibm_ht_xstag(ii(nC),ji(nC))))
 		endif
 		! solve for y
 		if (ibm_ht_ystag(ii(nC),ji(nC)-1) >= top_neigh(i,j,3*nC+2)) then
 		   top_neigh(i,j,3*nC+1) = ((ji(nC)-1)*dy)-dy + (dy/2)+(dy/4)*((top_neigh(i,j,3*nC+2)-ibm_ht(ii(nC),ji(nC)-1)) &
 								      /(ibm_ht_ystag(ii(nC),ji(nC)-1)-ibm_ht(ii(nC),ji(nC)-1)))
 		else
 		   top_neigh(i,j,3*nC+1) = ((ji(nC)-1)*dy)-(dy/2) + (dy/4)+(dy/4)*((top_neigh(i,j,3*nC+2)-ibm_ht_ystag(ii(nC),ji(nC)-1)) &
 									    	  /(ibm_ht(ii(nC),ji(nC))-ibm_ht_ystag(ii(nC),ji(nC)-1)))
 		endif
 	    elseif (stag == 3) then
 		! solve for x
 		if (ibm_ht_xstag(ii(nC),ji(nC)) >= top_neigh(i,j,3*nC+2)) then
 		   top_neigh(i,j,3*nC) = ((ii(nC)-1)*dx)-(dx/2) + (dx/2)+(dx/4)*((top_neigh(i,j,3*nC+2)-ibm_ht(ii(nC)-1,ji(nC))) &
 									  /(ibm_ht_xstag(ii(nC),ji(nC))-ibm_ht(ii(nC)-1,ji(nC))))
 		else
 		   top_neigh(i,j,3*nC) = (ii(nC)*dx)-dx + (dx/4)+(dx/4)*((top_neigh(i,j,3*nC+2)-ibm_ht_xstag(ii(nC),ji(nC))) &
 								        /(ibm_ht(ii(nC),ji(nC))-ibm_ht_xstag(ii(nC),ji(nC))))
 		endif
 		! solve for y
 		if (ibm_ht_ystag(ii(nC),ji(nC)) >= top_neigh(i,j,3*nC+2)) then
 		   top_neigh(i,j,3*nC+1) = ((ji(nC)-1)*dy)-(dy/2) + (dy/2)+(dy/4)*((top_neigh(i,j,3*nC+2)-ibm_ht(ii(nC),ji(nC)-1)) &
 									    /(ibm_ht_ystag(ii(nC),ji(nC))-ibm_ht(ii(nC),ji(nC)-1)))
 		else
 		   top_neigh(i,j,3*nC+1) = (ji(nC)*dy)-dy + (dy/4)+(dy/4)*((top_neigh(i,j,3*nC+2)-ibm_ht_ystag(ii(nC),ji(nC))) &
 									/(ibm_ht(ii(nC),ji(nC))-ibm_ht_ystag(ii(nC),ji(nC))))
 		endif
 	    endif
    ELSEIF ((inside(ii(0),ki(0),ji(0)) == 0).AND. &
	   (inside(ii(1),ki(1),ji(1)) == 0).AND. &
	   (inside(ii(2),ki(2),ji(2)) == 1).AND. &
	   (inside(ii(3),ki(3),ji(3)) == 0).AND. &
	   (inside(ii(4),ki(4),ji(4)) == 0).AND. &
	   (inside(ii(5),ki(5),ji(5)) == 0).AND. &
	   (inside(ii(6),ki(6),ji(6)) == 0).AND. &
	   (inside(ii(7),ki(7),ji(7)) == 1)) THEN
	  ! neighbors 0,1,3,4,5,6 are the zero computational nodes
	  do nC = 0,1
	     top_neigh_i(i,j,3*nC) = ii(nC)
	     top_neigh_i(i,j,3*nC+1) = ji(nC)
	     top_neigh_i(i,j,3*nC+2) = ki(nC)		
	     if (stag ==1 ) then 			
		 top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx)
		 top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)
	     elseif (stag == 2) then
		 top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
		 top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy)	     
	     elseif (stag == 3) then
		 top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
		 top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)	     
	     endif
	     top_neigh(i,j,3*nC+2) = ht_p(top_neigh_i(i,j,3*nC),top_neigh_i(i,j,3*nC+2),top_neigh_i(i,j,3*nC+1))  
	  enddo
	 ! neighbors 2,7 are at (ii,jj,ibm_ht(ii,jj)) on the boundary 
	  nC = 2
	  top_neigh_i(i,j,3*nC) = ii(nC)
	  top_neigh_i(i,j,3*nC+1) = ji(nC)
	  top_neigh_i(i,j,3*nC+2) = 0		
	  if (stag ==1 ) then 			
	      top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx)
	      top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)
	  elseif (stag == 2) then
	      top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
	      top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy)	     
	  elseif (stag == 3) then
	      top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
	      top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)	     
	  endif
	  top_neigh(i,j,3*nC+2) = ibm_ht(top_neigh_i(i,j,3*nC),top_neigh_i(i,j,3*nC+1))
	  do nC = 3,6
	     top_neigh_i(i,j,3*nC) = ii(nC)
	     top_neigh_i(i,j,3*nC+1) = ji(nC)
	     top_neigh_i(i,j,3*nC+2) = ki(nC)		
	     if (stag ==1 ) then 			
		 top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx)
		 top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)
	     elseif (stag == 2) then
		 top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
		 top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy)	     
	     elseif (stag == 3) then
		 top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
		 top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)	     
	     endif
	     top_neigh(i,j,3*nC+2) = ht_p(top_neigh_i(i,j,3*nC),top_neigh_i(i,j,3*nC+2),top_neigh_i(i,j,3*nC+1))  
	  enddo
	 ! neighbors 2,7 are at (ii,jj,ibm_ht(ii,jj)) on the boundary 
	  nC = 7
	  top_neigh_i(i,j,3*nC) = ii(nC)
	  top_neigh_i(i,j,3*nC+1) = ji(nC)
	  top_neigh_i(i,j,3*nC+2) = 0		
	  if (stag ==1 ) then 			
	      top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx)
	      top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)
	  elseif (stag == 2) then
	      top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
	      top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy)	     
	  elseif (stag == 3) then
	      top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
	      top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)	     
	  endif
	  top_neigh(i,j,3*nC+2) = ibm_ht(top_neigh_i(i,j,3*nC),top_neigh_i(i,j,3*nC+1))
    ELSEIF ((inside(ii(0),ki(0),ji(0)) == 0).AND. &
	   (inside(ii(1),ki(1),ji(1)) == 0).AND. &
	   (inside(ii(2),ki(2),ji(2)) == 0).AND. &
	   (inside(ii(3),ki(3),ji(3)) == 1).AND. &
	   (inside(ii(4),ki(4),ji(4)) == 0).AND. &
	   (inside(ii(5),ki(5),ji(5)) == 0).AND. &
	   (inside(ii(6),ki(6),ji(6)) == 1).AND. &
	   (inside(ii(7),ki(7),ji(7)) == 0)) THEN
	  ! neighbors 0,1,2,4,5,7 are the zero computational nodes
	  do nC = 0,2
	     top_neigh_i(i,j,3*nC) = ii(nC)
	     top_neigh_i(i,j,3*nC+1) = ji(nC)
	     top_neigh_i(i,j,3*nC+2) = ki(nC)		
	     if (stag ==1 ) then 			
		 top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx)
		 top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)
	     elseif (stag == 2) then
		 top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
		 top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy)	     
	     elseif (stag == 3) then
		 top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
		 top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)	     
	     endif
	     top_neigh(i,j,3*nC+2) = ht_p(top_neigh_i(i,j,3*nC),top_neigh_i(i,j,3*nC+2),top_neigh_i(i,j,3*nC+1))  
	  enddo	
	 ! neighbor 3 is at (ii,jj,ibm_ht(ii,jj)) on the boundary 
	  nC = 3
	  top_neigh_i(i,j,3*nC) = ii(nC)
	  top_neigh_i(i,j,3*nC+1) = ji(nC)
	  top_neigh_i(i,j,3*nC+2) = 0		
	  if (stag ==1 ) then 			
	      top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx)
	      top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)
	  elseif (stag == 2) then
	      top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
	      top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy)	     
	  elseif (stag == 3) then
	      top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
	      top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)	     
	  endif
	  top_neigh(i,j,3*nC+2) = ibm_ht(top_neigh_i(i,j,3*nC),top_neigh_i(i,j,3*nC+1))  
	  do nC = 4,5
	     top_neigh_i(i,j,3*nC) = ii(nC)
	     top_neigh_i(i,j,3*nC+1) = ji(nC)
	     top_neigh_i(i,j,3*nC+2) = ki(nC)		
	     if (stag ==1 ) then 			
		 top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx)
		 top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)
	     elseif (stag == 2) then
		 top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
		 top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy)	     
	     elseif (stag == 3) then
		 top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
		 top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)	     
	     endif
	     top_neigh(i,j,3*nC+2) = ht_p(top_neigh_i(i,j,3*nC),top_neigh_i(i,j,3*nC+2),top_neigh_i(i,j,3*nC+1))  
	  enddo 
	  ! neighbor 6 is at (ii,jj,ibm_ht(ii,jj)) on the boundary 
	  nC = 6
	  top_neigh_i(i,j,3*nC) = ii(nC)
	  top_neigh_i(i,j,3*nC+1) = ji(nC)
	  top_neigh_i(i,j,3*nC+2) = 0		
	  if (stag ==1 ) then 			
	      top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx)
	      top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)
	  elseif (stag == 2) then
	      top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
	      top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy)	     
	  elseif (stag == 3) then
	      top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
	      top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)	     
	  endif
	  top_neigh(i,j,3*nC+2) = ibm_ht(top_neigh_i(i,j,3*nC),top_neigh_i(i,j,3*nC+1))
	  nC = 7
	  top_neigh_i(i,j,3*nC) = ii(nC)
	  top_neigh_i(i,j,3*nC+1) = ji(nC)
	  top_neigh_i(i,j,3*nC+2) = ki(nC)		
	  if (stag ==1 ) then 			
	      top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx)
	      top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)
	  elseif (stag == 2) then
	      top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
	      top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy)	     
	  elseif (stag == 3) then
	      top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
	      top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)	     
	  endif
	  top_neigh(i,j,3*nC+2) = ht_p(top_neigh_i(i,j,3*nC),top_neigh_i(i,j,3*nC+2),top_neigh_i(i,j,3*nC+1)) 
    ELSEIF ((inside(ii(0),ki(0),ji(0)) == 0).AND. &
	   (inside(ii(1),ki(1),ji(1)) == 0).AND. &
	   (inside(ii(2),ki(2),ji(2)) == 1).AND. &
	   (inside(ii(3),ki(3),ji(3)) == 1).AND. &
	   (inside(ii(4),ki(4),ji(4)) == 0).AND. &
	   (inside(ii(5),ki(5),ji(5)) == 0).AND. &
	   (inside(ii(6),ki(6),ji(6)) == 1).AND. &
	   (inside(ii(7),ki(7),ji(7)) == 0)) THEN
	  ! neighbors 0,1,4,5,7 are the zero computational nodes
	  do nC = 0,1
	     top_neigh_i(i,j,3*nC) = ii(nC)
	     top_neigh_i(i,j,3*nC+1) = ji(nC)
	     top_neigh_i(i,j,3*nC+2) = ki(nC)		
	     if (stag ==1 ) then 			
		 top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx)
		 top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)
	     elseif (stag == 2) then
		 top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
		 top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy)	     
	     elseif (stag == 3) then
		 top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
		 top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)	     
	     endif
	     top_neigh(i,j,3*nC+2) = ht_p(top_neigh_i(i,j,3*nC),top_neigh_i(i,j,3*nC+2),top_neigh_i(i,j,3*nC+1))  
	  enddo	
	  ! neighbor 2,3 is at (ii,jj,ibm_ht(ii,jj)) on the boundary 
	  do nC = 2,3
	     top_neigh_i(i,j,3*nC) = ii(nC)
	     top_neigh_i(i,j,3*nC+1) = ji(nC)
	     top_neigh_i(i,j,3*nC+2) = 0		
	     if (stag ==1 ) then 			
		 top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx)
		 top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)
	     elseif (stag == 2) then
		 top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
		 top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy)	     
	     elseif (stag == 3) then
		 top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
		 top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)	     
	     endif
	     top_neigh(i,j,3*nC+2) = ibm_ht(top_neigh_i(i,j,3*nC),top_neigh_i(i,j,3*nC+1))
	  enddo 
	  do nC = 4,5
	     top_neigh_i(i,j,3*nC) = ii(nC)
	     top_neigh_i(i,j,3*nC+1) = ji(nC)
	     top_neigh_i(i,j,3*nC+2) = ki(nC)		
	     if (stag ==1 ) then 			
		 top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx)
		 top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)
	     elseif (stag == 2) then
		 top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
		 top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy)	     
	     elseif (stag == 3) then
		 top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
		 top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)	     
	     endif
	     top_neigh(i,j,3*nC+2) = ht_p(top_neigh_i(i,j,3*nC),top_neigh_i(i,j,3*nC+2),top_neigh_i(i,j,3*nC+1))  
	  enddo 
	  ! neighbor 6 is at (ii,jj,ibm_ht(ii,jj)) on the boundary 
	  nC = 6
	  top_neigh_i(i,j,3*nC) = ii(nC)
	  top_neigh_i(i,j,3*nC+1) = ji(nC)
	  top_neigh_i(i,j,3*nC+2) = 0		
	  if (stag ==1 ) then 			
	      top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx)
	      top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)
	  elseif (stag == 2) then
	      top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
	      top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy)	     
	  elseif (stag == 3) then
	      top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
	      top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)	     
	  endif
	  top_neigh(i,j,3*nC+2) = ibm_ht(top_neigh_i(i,j,3*nC),top_neigh_i(i,j,3*nC+1))
	  nC = 7
	  top_neigh_i(i,j,3*nC) = ii(nC)
	  top_neigh_i(i,j,3*nC+1) = ji(nC)
	  top_neigh_i(i,j,3*nC+2) = ki(nC)		
	  if (stag ==1 ) then 			
	      top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx)
	      top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)
	  elseif (stag == 2) then
	      top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
	      top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy)	     
	  elseif (stag == 3) then
	      top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
	      top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)	     
	  endif
	  top_neigh(i,j,3*nC+2) = ht_p(top_neigh_i(i,j,3*nC),top_neigh_i(i,j,3*nC+2),top_neigh_i(i,j,3*nC+1))	  
    ELSEIF ((inside(ii(0),ki(0),ji(0)) == 0).AND. &
	   (inside(ii(1),ki(1),ji(1)) == 0).AND. &
	   (inside(ii(2),ki(2),ji(2)) == 1).AND. &
	   (inside(ii(3),ki(3),ji(3)) == 0).AND. &
	   (inside(ii(4),ki(4),ji(4)) == 0).AND. &
	   (inside(ii(5),ki(5),ji(5)) == 0).AND. &
	   (inside(ii(6),ki(6),ji(6)) == 1).AND. &
	   (inside(ii(7),ki(7),ji(7)) == 1)) THEN
	  ! neighbors 0,1,3,4,5 are the zero computational nodes
	  do nC = 0,1
	     top_neigh_i(i,j,3*nC) = ii(nC)
	     top_neigh_i(i,j,3*nC+1) = ji(nC)
	     top_neigh_i(i,j,3*nC+2) = ki(nC)		
	     if (stag ==1 ) then 			
		 top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx)
		 top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)
	     elseif (stag == 2) then
		 top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
		 top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy)	     
	     elseif (stag == 3) then
		 top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
		 top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)	     
	     endif
	     top_neigh(i,j,3*nC+2) = ht_p(top_neigh_i(i,j,3*nC),top_neigh_i(i,j,3*nC+2),top_neigh_i(i,j,3*nC+1))  
	  enddo	
	  ! neighbor 2 is at (ii,jj,ibm_ht(ii,jj)) on the boundary 
	  nC = 2
	  top_neigh_i(i,j,3*nC) = ii(nC)
	  top_neigh_i(i,j,3*nC+1) = ji(nC)
	  top_neigh_i(i,j,3*nC+2) = 0		
	  if (stag ==1 ) then 			
	      top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx)
	      top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)
	  elseif (stag == 2) then
	      top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
	      top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy)	     
	  elseif (stag == 3) then
	      top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
	      top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)	     
	  endif
	  top_neigh(i,j,3*nC+2) = ibm_ht(top_neigh_i(i,j,3*nC),top_neigh_i(i,j,3*nC+1)) 
	  do nC = 3,5
	     top_neigh_i(i,j,3*nC) = ii(nC)
	     top_neigh_i(i,j,3*nC+1) = ji(nC)
	     top_neigh_i(i,j,3*nC+2) = ki(nC)		
	     if (stag ==1 ) then 			
		 top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx)
		 top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)
	     elseif (stag == 2) then
		 top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
		 top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy)	     
	     elseif (stag == 3) then
		 top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
		 top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)	     
	     endif
	     top_neigh(i,j,3*nC+2) = ht_p(top_neigh_i(i,j,3*nC),top_neigh_i(i,j,3*nC+2),top_neigh_i(i,j,3*nC+1))  
	  enddo 
	  ! neighbor 6,7 is at (ii,jj,ibm_ht(ii,jj)) on the boundary 
	  do nC = 6,7
	     top_neigh_i(i,j,3*nC) = ii(nC)
	     top_neigh_i(i,j,3*nC+1) = ji(nC)
	     top_neigh_i(i,j,3*nC+2) = 0		
	     if (stag ==1 ) then 			
		 top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx)
		 top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)
	     elseif (stag == 2) then
		 top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
		 top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy)	     
	     elseif (stag == 3) then
		 top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
		 top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)	     
	     endif
	     top_neigh(i,j,3*nC+2) = ibm_ht(top_neigh_i(i,j,3*nC),top_neigh_i(i,j,3*nC+1))
          enddo
    ELSEIF ((inside(ii(0),ki(0),ji(0)) == 0).AND. &
	   (inside(ii(1),ki(1),ji(1)) == 0).AND. &
	   (inside(ii(2),ki(2),ji(2)) == 1).AND. &
	   (inside(ii(3),ki(3),ji(3)) == 1).AND. &
	   (inside(ii(4),ki(4),ji(4)) == 0).AND. &
	   (inside(ii(5),ki(5),ji(5)) == 0).AND. &
	   (inside(ii(6),ki(6),ji(6)) == 0).AND. &
	   (inside(ii(7),ki(7),ji(7)) == 1)) THEN
	  ! neighbors 0,1,4,5,6 are the zero computational nodes
	  do nC = 0,1
	     top_neigh_i(i,j,3*nC) = ii(nC)
	     top_neigh_i(i,j,3*nC+1) = ji(nC)
	     top_neigh_i(i,j,3*nC+2) = ki(nC)		
	     if (stag ==1 ) then 			
		 top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx)
		 top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)
	     elseif (stag == 2) then
		 top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
		 top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy)	     
	     elseif (stag == 3) then
		 top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
		 top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)	     
	     endif
	     top_neigh(i,j,3*nC+2) = ht_p(top_neigh_i(i,j,3*nC),top_neigh_i(i,j,3*nC+2),top_neigh_i(i,j,3*nC+1))  
	  enddo	
	  ! neighbors 2,3 are at (ii,jj,ibm_ht(ii,jj)) on the boundary 
	  do nC = 2,3
	     top_neigh_i(i,j,3*nC) = ii(nC)
	     top_neigh_i(i,j,3*nC+1) = ji(nC)
	     top_neigh_i(i,j,3*nC+2) = 0		
	     if (stag ==1 ) then 			
		 top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx)
		 top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)
	     elseif (stag == 2) then
		 top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
		 top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy)	     
	     elseif (stag == 3) then
		 top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
		 top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)	     
	     endif
	     top_neigh(i,j,3*nC+2) = ibm_ht(top_neigh_i(i,j,3*nC),top_neigh_i(i,j,3*nC+1)) 
	  enddo 
	  do nC = 4,6
	     top_neigh_i(i,j,3*nC) = ii(nC)
	     top_neigh_i(i,j,3*nC+1) = ji(nC)
	     top_neigh_i(i,j,3*nC+2) = ki(nC)		
	     if (stag ==1 ) then 			
		 top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx)
		 top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)
	     elseif (stag == 2) then
		 top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
		 top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy)	     
	     elseif (stag == 3) then
		 top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
		 top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)	     
	     endif
	     top_neigh(i,j,3*nC+2) = ht_p(top_neigh_i(i,j,3*nC),top_neigh_i(i,j,3*nC+2),top_neigh_i(i,j,3*nC+1))  
	  enddo 
	 ! neighbor 7 is at (ii,jj,ibm_ht(ii,jj)) on the boundary 
	  nC = 7
	  top_neigh_i(i,j,3*nC) = ii(nC)
	  top_neigh_i(i,j,3*nC+1) = ji(nC)
	  top_neigh_i(i,j,3*nC+2) = 0		
	  if (stag ==1 ) then 			
	      top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx)
	      top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)
	  elseif (stag == 2) then
	      top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
	      top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy)	     
	  elseif (stag == 3) then
	      top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
	      top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)	     
	  endif
	  top_neigh(i,j,3*nC+2) = ibm_ht(top_neigh_i(i,j,3*nC),top_neigh_i(i,j,3*nC+1))
    ELSEIF ((inside(ii(0),ki(0),ji(0)) == 0).AND. &
	   (inside(ii(1),ki(1),ji(1)) == 0).AND. &
	   (inside(ii(2),ki(2),ji(2)) == 0).AND. &
	   (inside(ii(3),ki(3),ji(3)) == 1).AND. &
	   (inside(ii(4),ki(4),ji(4)) == 0).AND. &
	   (inside(ii(5),ki(5),ji(5)) == 0).AND. &
	   (inside(ii(6),ki(6),ji(6)) == 1).AND. &
	   (inside(ii(7),ki(7),ji(7)) == 1)) THEN
	  ! neighbors 0,1,2,4,5 are the zero computational nodes
	  do nC = 0,2
	     top_neigh_i(i,j,3*nC) = ii(nC)
	     top_neigh_i(i,j,3*nC+1) = ji(nC)
	     top_neigh_i(i,j,3*nC+2) = ki(nC)		
	     if (stag ==1 ) then 			
		 top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx)
		 top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)
	     elseif (stag == 2) then
		 top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
		 top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy)	     
	     elseif (stag == 3) then
		 top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
		 top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)	     
	     endif
	     top_neigh(i,j,3*nC+2) = ht_p(top_neigh_i(i,j,3*nC),top_neigh_i(i,j,3*nC+2),top_neigh_i(i,j,3*nC+1))  
	  enddo	
	 ! neighbor 3 is at (ii,jj,ibm_ht(ii,jj)) on the boundary 
	  nC = 3
	  top_neigh_i(i,j,3*nC) = ii(nC)
	  top_neigh_i(i,j,3*nC+1) = ji(nC)
	  top_neigh_i(i,j,3*nC+2) = 0		
	  if (stag ==1 ) then 			
	      top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx)
	      top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)
	  elseif (stag == 2) then
	      top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
	      top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy)	     
	  elseif (stag == 3) then
	      top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
	      top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)	     
	  endif
	  top_neigh(i,j,3*nC+2) = ibm_ht(top_neigh_i(i,j,3*nC),top_neigh_i(i,j,3*nC+1))  
	  do nC = 4,5
	     top_neigh_i(i,j,3*nC) = ii(nC)
	     top_neigh_i(i,j,3*nC+1) = ji(nC)
	     top_neigh_i(i,j,3*nC+2) = ki(nC)		
	     if (stag ==1 ) then 			
		 top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx)
		 top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)
	     elseif (stag == 2) then
		 top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
		 top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy)	     
	     elseif (stag == 3) then
		 top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
		 top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)	     
	     endif
	     top_neigh(i,j,3*nC+2) = ht_p(top_neigh_i(i,j,3*nC),top_neigh_i(i,j,3*nC+2),top_neigh_i(i,j,3*nC+1))  
	  enddo 
	 ! neighbor 6,7 is at (ii,jj,ibm_ht(ii,jj)) on the boundary 
	  do nC = 6,7
	     top_neigh_i(i,j,3*nC) = ii(nC)
	     top_neigh_i(i,j,3*nC+1) = ji(nC)
	     top_neigh_i(i,j,3*nC+2) = 0		
	     if (stag ==1 ) then 			
		 top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx)
		 top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)
	     elseif (stag == 2) then
		 top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
		 top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy)	     
	     elseif (stag == 3) then
		 top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
		 top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)	     
	     endif
	     top_neigh(i,j,3*nC+2) = ibm_ht(top_neigh_i(i,j,3*nC),top_neigh_i(i,j,3*nC+1))
	  enddo
    ELSEIF ((inside(ii(0),ki(0),ji(0)) == 1).AND. &
	   (inside(ii(1),ki(1),ji(1)) == 0).AND. &
	   (inside(ii(2),ki(2),ji(2)) == 1).AND. &
	   (inside(ii(3),ki(3),ji(3)) == 0).AND. &
	   (inside(ii(4),ki(4),ji(4)) == 0).AND. &
	   (inside(ii(5),ki(5),ji(5)) == 0).AND. &
	   (inside(ii(6),ki(6),ji(6)) == 1).AND. &
	   (inside(ii(7),ki(7),ji(7)) == 0)) THEN
	   ! neighbor 0 on the boundary between 0 and 1
	   nC = 0
	   top_neigh_i(i,j,3*nC) = 0
	   top_neigh_i(i,j,3*nC+1) = ji(nC)
	   top_neigh_i(i,j,3*nC+2) = 0
	   ! first z
	   top_neigh(i,j,3*nC+2) = ht_p(ii(nC),ki(nC),ji(nC))
	   if (stag == 1) then
	       !next y
	       top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)
	       ! solve for x
	       if (ibm_ht_xstag(ii(nC),ji(nC)) >= top_neigh(i,j,3*nC+2)) then
		  top_neigh(i,j,3*nC) = (ii(nC)*dx)-(dx/2) + (dx/2)*((top_neigh(i,j,3*nC+2)-ibm_ht_xstag(ii(nC),ji(nC))) &
						                  /(ibm_ht(ii(nC)+1,ji(nC))-ibm_ht_xstag(ii(nC),ji(nC))))
	       else
		  top_neigh(i,j,3*nC) = (ii(nC)*dx)-dx + (dx/2)*((top_neigh(i,j,3*nC+2)-ibm_ht(ii(nC),ji(nC))) &
							  /(ibm_ht_xstag(ii(nC),ji(nC))-ibm_ht(ii(nC),ji(nC))))
	       endif						  
	   elseif (stag == 2) then
	       !next y
	       top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy)
	       ! solve for x
	       if (ibm_ht_xstag(ii(nC)+1,ji(nC)) >= top_neigh(i,j,3*nC+2)) then
		  top_neigh(i,j,3*nC) = (ii(nC)*dx) + (dx/2)*((top_neigh(i,j,3*nC+2)-ibm_ht_xstag(ii(nC)+1,ji(nC))) &
						           /(ibm_ht(ii(nC)+1,ji(nC))-ibm_ht_xstag(ii(nC)+1,ji(nC))))
	       else
		  top_neigh(i,j,3*nC) = (ii(nC)*dx)-(dx/2) + (dx/2)*((top_neigh(i,j,3*nC+2)-ibm_ht(ii(nC),ji(nC))) &
						            /(ibm_ht_xstag(ii(nC)+1,ji(nC))-ibm_ht(ii(nC),ji(nC))))
	       endif
	   elseif (stag == 3) then
	       !next y
	       top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)
	       ! solve for x
	       if (ibm_ht_xstag(ii(nC)+1,ji(nC)) >= top_neigh(i,j,3*nC+2)) then
		  top_neigh(i,j,3*nC) = (ii(nC)*dx) + (dx/2)*((top_neigh(i,j,3*nC+2)-ibm_ht_xstag(ii(nC)+1,ji(nC))) &
						           /(ibm_ht(ii(nC)+1,ji(nC))-ibm_ht_xstag(ii(nC)+1,ji(nC))))
	       else
		  top_neigh(i,j,3*nC) = (ii(nC)*dx)-(dx/2) + (dx/2)*((top_neigh(i,j,3*nC+2)-ibm_ht(ii(nC),ji(nC))) &
						            /(ibm_ht_xstag(ii(nC)+1,ji(nC))-ibm_ht(ii(nC),ji(nC))))
	       endif
	   endif
           ! neighbors 1,3,4,5,7 are computational nodes
	   nC = 1
	   top_neigh_i(i,j,3*nC) = ii(nC)
	   top_neigh_i(i,j,3*nC+1) = ji(nC)
	   top_neigh_i(i,j,3*nC+2) = ki(nC)		
	   if (stag ==1 ) then 			
	       top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx)
	       top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)
	   elseif (stag == 2) then
	       top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
	       top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy)	     
	   elseif (stag == 3) then
	       top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
	       top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)	     
	   endif
	   top_neigh(i,j,3*nC+2) = ht_p(top_neigh_i(i,j,3*nC),top_neigh_i(i,j,3*nC+2),top_neigh_i(i,j,3*nC+1)) 
	   ! neighbor 2 on the boundary between 2 and 3
	   nC = 2
	   top_neigh_i(i,j,3*nC) = 0
	   top_neigh_i(i,j,3*nC+1) = ji(nC)
	   top_neigh_i(i,j,3*nC+2) = 0
	   ! first z
	   top_neigh(i,j,3*nC+2) = ht_p(ii(nC),ki(nC),ji(nC))
	   if (stag == 1) then
	       !next y
	       top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)
	       ! solve for x
	       if (ibm_ht_xstag(ii(nC),ji(nC)) >= top_neigh(i,j,3*nC+2)) then
		  top_neigh(i,j,3*nC) = (ii(nC)*dx)-(dx/2) + (dx/2)*((top_neigh(i,j,3*nC+2)-ibm_ht_xstag(ii(nC),ji(nC))) &
						                  /(ibm_ht(ii(nC)+1,ji(nC))-ibm_ht_xstag(ii(nC),ji(nC))))
	       else
		  top_neigh(i,j,3*nC) = (ii(nC)*dx)-dx + (dx/2)*((top_neigh(i,j,3*nC+2)-ibm_ht(ii(nC),ji(nC))) &
							  /(ibm_ht_xstag(ii(nC),ji(nC))-ibm_ht(ii(nC),ji(nC))))
	       endif						  
	   elseif (stag == 2) then
	       !next y
	       top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy)
	       ! solve for x
	       if (ibm_ht_xstag(ii(nC)+1,ji(nC)) >= top_neigh(i,j,3*nC+2)) then
		  top_neigh(i,j,3*nC) = (ii(nC)*dx) + (dx/2)*((top_neigh(i,j,3*nC+2)-ibm_ht_xstag(ii(nC)+1,ji(nC))) &
						           /(ibm_ht(ii(nC)+1,ji(nC))-ibm_ht_xstag(ii(nC)+1,ji(nC))))
	       else
		  top_neigh(i,j,3*nC) = (ii(nC)*dx)-(dx/2) + (dx/2)*((top_neigh(i,j,3*nC+2)-ibm_ht(ii(nC),ji(nC))) &
						            /(ibm_ht_xstag(ii(nC)+1,ji(nC))-ibm_ht(ii(nC),ji(nC))))
	       endif
	   elseif (stag == 3) then
	       !next y
	       top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)
	       ! solve for x
	       if (ibm_ht_xstag(ii(nC)+1,ji(nC)) >= top_neigh(i,j,3*nC+2)) then
		  top_neigh(i,j,3*nC) = (ii(nC)*dx) + (dx/2)*((top_neigh(i,j,3*nC+2)-ibm_ht_xstag(ii(nC)+1,ji(nC))) &
						           /(ibm_ht(ii(nC)+1,ji(nC))-ibm_ht_xstag(ii(nC)+1,ji(nC))))
	       else
		  top_neigh(i,j,3*nC) = (ii(nC)*dx)-(dx/2) + (dx/2)*((top_neigh(i,j,3*nC+2)-ibm_ht(ii(nC),ji(nC))) &
						            /(ibm_ht_xstag(ii(nC)+1,ji(nC))-ibm_ht(ii(nC),ji(nC))))
	       endif
	   endif
	   ! neighbors 1,3,4,5,7 are computational nodes
	   do nC = 3,5
	      top_neigh_i(i,j,3*nC) = ii(nC)
	      top_neigh_i(i,j,3*nC+1) = ji(nC)
	      top_neigh_i(i,j,3*nC+2) = ki(nC)		
	      if (stag ==1 ) then 			
		  top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx)
		  top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)
	      elseif (stag == 2) then
		  top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
		  top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy)	     
	      elseif (stag == 3) then
		  top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
		  top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)	     
	      endif
	      top_neigh(i,j,3*nC+2) = ht_p(top_neigh_i(i,j,3*nC),top_neigh_i(i,j,3*nC+2),top_neigh_i(i,j,3*nC+1))
	   enddo
	   ! neighbor 6 on the boundary between 6 and 7
	   nC = 6
	   top_neigh_i(i,j,3*nC) = 0
	   top_neigh_i(i,j,3*nC+1) = ji(nC)
	   top_neigh_i(i,j,3*nC+2) = 0
	   ! first z
	   top_neigh(i,j,3*nC+2) = ht_p(ii(nC),ki(nC),ji(nC))
	   if (stag == 1) then
	       !next y
	       top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)
	       ! solve for x
	       if (ibm_ht_xstag(ii(nC),ji(nC)) >= top_neigh(i,j,3*nC+2)) then
		  top_neigh(i,j,3*nC) = (ii(nC)*dx)-(dx/2) + (dx/2)*((top_neigh(i,j,3*nC+2)-ibm_ht_xstag(ii(nC),ji(nC))) &
						                  /(ibm_ht(ii(nC)+1,ji(nC))-ibm_ht_xstag(ii(nC),ji(nC))))
	       else
		  top_neigh(i,j,3*nC) = (ii(nC)*dx)-dx + (dx/2)*((top_neigh(i,j,3*nC+2)-ibm_ht(ii(nC),ji(nC))) &
							  /(ibm_ht_xstag(ii(nC),ji(nC))-ibm_ht(ii(nC),ji(nC))))
	       endif						  
	   elseif (stag == 2) then
	       !next y
	       top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy)
	       ! solve for x
	       if (ibm_ht_xstag(ii(nC)+1,ji(nC)) >= top_neigh(i,j,3*nC+2)) then
		  top_neigh(i,j,3*nC) = (ii(nC)*dx) + (dx/2)*((top_neigh(i,j,3*nC+2)-ibm_ht_xstag(ii(nC)+1,ji(nC))) &
						           /(ibm_ht(ii(nC)+1,ji(nC))-ibm_ht_xstag(ii(nC)+1,ji(nC))))
	       else
		  top_neigh(i,j,3*nC) = (ii(nC)*dx)-(dx/2) + (dx/2)*((top_neigh(i,j,3*nC+2)-ibm_ht(ii(nC),ji(nC))) &
						            /(ibm_ht_xstag(ii(nC)+1,ji(nC))-ibm_ht(ii(nC),ji(nC))))
	       endif
	   elseif (stag == 3) then
	       !next y
	       top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)
	       ! solve for x
	       if (ibm_ht_xstag(ii(nC)+1,ji(nC)) >= top_neigh(i,j,3*nC+2)) then
		  top_neigh(i,j,3*nC) = (ii(nC)*dx) + (dx/2)*((top_neigh(i,j,3*nC+2)-ibm_ht_xstag(ii(nC)+1,ji(nC))) &
						           /(ibm_ht(ii(nC)+1,ji(nC))-ibm_ht_xstag(ii(nC)+1,ji(nC))))
	       else
		  top_neigh(i,j,3*nC) = (ii(nC)*dx)-(dx/2) + (dx/2)*((top_neigh(i,j,3*nC+2)-ibm_ht(ii(nC),ji(nC))) &
						            /(ibm_ht_xstag(ii(nC)+1,ji(nC))-ibm_ht(ii(nC),ji(nC))))
	       endif
	   endif
	   ! neighbors 0,1,3,5,7 are computational nodes
	   nC = 7
	   top_neigh_i(i,j,3*nC) = ii(nC)
	   top_neigh_i(i,j,3*nC+1) = ji(nC)
	   top_neigh_i(i,j,3*nC+2) = ki(nC)		
	   if (stag ==1 ) then 			
	       top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx)
	       top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)
	   elseif (stag == 2) then
	       top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
	       top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy)	     
	   elseif (stag == 3) then
	       top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
	       top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)	     
	   endif
	   top_neigh(i,j,3*nC+2) = ht_p(top_neigh_i(i,j,3*nC),top_neigh_i(i,j,3*nC+2),top_neigh_i(i,j,3*nC+1))
    ELSEIF ((inside(ii(0),ki(0),ji(0)) == 0).AND. &
	   (inside(ii(1),ki(1),ji(1)) == 0).AND. &
	   (inside(ii(2),ki(2),ji(2)) == 1).AND. &
	   (inside(ii(3),ki(3),ji(3)) == 0).AND. &
	   (inside(ii(4),ki(4),ji(4)) == 1).AND. &
	   (inside(ii(5),ki(5),ji(5)) == 0).AND. &
	   (inside(ii(6),ki(6),ji(6)) == 1).AND. &
	   (inside(ii(7),ki(7),ji(7)) == 0)) THEN
	   ! neighbors 0,1,3,5,7 are computational nodes
	   do nC = 0,1
	      top_neigh_i(i,j,3*nC) = ii(nC)
	      top_neigh_i(i,j,3*nC+1) = ji(nC)
	      top_neigh_i(i,j,3*nC+2) = ki(nC)		
	      if (stag ==1 ) then 			
		  top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx)
		  top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)
	      elseif (stag == 2) then
		  top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
		  top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy)	     
	      elseif (stag == 3) then
		  top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
		  top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)	     
	      endif
	      top_neigh(i,j,3*nC+2) = ht_p(top_neigh_i(i,j,3*nC),top_neigh_i(i,j,3*nC+2),top_neigh_i(i,j,3*nC+1))  
	   enddo 
	   ! neighbor 2 on the boundary between 2 and 3
	   nC = 2
	   top_neigh_i(i,j,3*nC) = 0
	   top_neigh_i(i,j,3*nC+1) = ji(nC)
	   top_neigh_i(i,j,3*nC+2) = 0
	   ! first z
	   top_neigh(i,j,3*nC+2) = ht_p(ii(nC),ki(nC),ji(nC))
	   if (stag == 1) then
	       !next y
	       top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)
	       ! solve for x
	       if (ibm_ht_xstag(ii(nC),ji(nC)) >= top_neigh(i,j,3*nC+2)) then
		  top_neigh(i,j,3*nC) = (ii(nC)*dx)-(dx/2) + (dx/2)*((top_neigh(i,j,3*nC+2)-ibm_ht_xstag(ii(nC),ji(nC))) &
						                  /(ibm_ht(ii(nC)+1,ji(nC))-ibm_ht_xstag(ii(nC),ji(nC))))
	       else
		  top_neigh(i,j,3*nC) = (ii(nC)*dx)-dx + (dx/2)*((top_neigh(i,j,3*nC+2)-ibm_ht(ii(nC),ji(nC))) &
							  /(ibm_ht_xstag(ii(nC),ji(nC))-ibm_ht(ii(nC),ji(nC))))
	       endif						  
	   elseif (stag == 2) then
	       !next y
	       top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy)
	       ! solve for x
	       if (ibm_ht_xstag(ii(nC)+1,ji(nC)) >= top_neigh(i,j,3*nC+2)) then
		  top_neigh(i,j,3*nC) = (ii(nC)*dx) + (dx/2)*((top_neigh(i,j,3*nC+2)-ibm_ht_xstag(ii(nC)+1,ji(nC))) &
						           /(ibm_ht(ii(nC)+1,ji(nC))-ibm_ht_xstag(ii(nC)+1,ji(nC))))
	       else
		  top_neigh(i,j,3*nC) = (ii(nC)*dx)-(dx/2) + (dx/2)*((top_neigh(i,j,3*nC+2)-ibm_ht(ii(nC),ji(nC))) &
						            /(ibm_ht_xstag(ii(nC)+1,ji(nC))-ibm_ht(ii(nC),ji(nC))))
	       endif
	   elseif (stag == 3) then
	       !next y
	       top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)
	       ! solve for x
	       if (ibm_ht_xstag(ii(nC)+1,ji(nC)) >= top_neigh(i,j,3*nC+2)) then
		  top_neigh(i,j,3*nC) = (ii(nC)*dx) + (dx/2)*((top_neigh(i,j,3*nC+2)-ibm_ht_xstag(ii(nC)+1,ji(nC))) &
						           /(ibm_ht(ii(nC)+1,ji(nC))-ibm_ht_xstag(ii(nC)+1,ji(nC))))
	       else
		  top_neigh(i,j,3*nC) = (ii(nC)*dx)-(dx/2) + (dx/2)*((top_neigh(i,j,3*nC+2)-ibm_ht(ii(nC),ji(nC))) &
						            /(ibm_ht_xstag(ii(nC)+1,ji(nC))-ibm_ht(ii(nC),ji(nC))))
	       endif
	   endif
           ! neighbors 0,1,3,5,7 are computational nodes
	   nC = 3
	   top_neigh_i(i,j,3*nC) = ii(nC)
	   top_neigh_i(i,j,3*nC+1) = ji(nC)
	   top_neigh_i(i,j,3*nC+2) = ki(nC)		
	   if (stag ==1 ) then 			
	       top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx)
	       top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)
	   elseif (stag == 2) then
	       top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
	       top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy)	     
	   elseif (stag == 3) then
	       top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
	       top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)	     
	   endif
	   top_neigh(i,j,3*nC+2) = ht_p(top_neigh_i(i,j,3*nC),top_neigh_i(i,j,3*nC+2),top_neigh_i(i,j,3*nC+1)) 
	   ! neighbor 4 on the boundary between 4 and 5
	   nC = 4
	   top_neigh_i(i,j,3*nC) = 0
	   top_neigh_i(i,j,3*nC+1) = ji(nC)
	   top_neigh_i(i,j,3*nC+2) = 0
	   ! first z
	   top_neigh(i,j,3*nC+2) = ht_p(ii(nC),ki(nC),ji(nC))
	   if (stag == 1) then
	       !next y
	       top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)
	       ! solve for x
	       if (ibm_ht_xstag(ii(nC),ji(nC)) >= top_neigh(i,j,3*nC+2)) then
		  top_neigh(i,j,3*nC) = (ii(nC)*dx)-(dx/2) + (dx/2)*((top_neigh(i,j,3*nC+2)-ibm_ht_xstag(ii(nC),ji(nC))) &
						                  /(ibm_ht(ii(nC)+1,ji(nC))-ibm_ht_xstag(ii(nC),ji(nC))))
	       else
		  top_neigh(i,j,3*nC) = (ii(nC)*dx)-dx + (dx/2)*((top_neigh(i,j,3*nC+2)-ibm_ht(ii(nC),ji(nC))) &
							  /(ibm_ht_xstag(ii(nC),ji(nC))-ibm_ht(ii(nC),ji(nC))))
	       endif						  
	   elseif (stag == 2) then
	       !next y
	       top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy)
	       ! solve for x
	       if (ibm_ht_xstag(ii(nC)+1,ji(nC)) >= top_neigh(i,j,3*nC+2)) then
		  top_neigh(i,j,3*nC) = (ii(nC)*dx) + (dx/2)*((top_neigh(i,j,3*nC+2)-ibm_ht_xstag(ii(nC)+1,ji(nC))) &
						           /(ibm_ht(ii(nC)+1,ji(nC))-ibm_ht_xstag(ii(nC)+1,ji(nC))))
	       else
		  top_neigh(i,j,3*nC) = (ii(nC)*dx)-(dx/2) + (dx/2)*((top_neigh(i,j,3*nC+2)-ibm_ht(ii(nC),ji(nC))) &
						            /(ibm_ht_xstag(ii(nC)+1,ji(nC))-ibm_ht(ii(nC),ji(nC))))
	       endif
	   elseif (stag == 3) then
	       !next y
	       top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)
	       ! solve for x
	       if (ibm_ht_xstag(ii(nC)+1,ji(nC)) >= top_neigh(i,j,3*nC+2)) then
		  top_neigh(i,j,3*nC) = (ii(nC)*dx) + (dx/2)*((top_neigh(i,j,3*nC+2)-ibm_ht_xstag(ii(nC)+1,ji(nC))) &
						           /(ibm_ht(ii(nC)+1,ji(nC))-ibm_ht_xstag(ii(nC)+1,ji(nC))))
	       else
		  top_neigh(i,j,3*nC) = (ii(nC)*dx)-(dx/2) + (dx/2)*((top_neigh(i,j,3*nC+2)-ibm_ht(ii(nC),ji(nC))) &
						            /(ibm_ht_xstag(ii(nC)+1,ji(nC))-ibm_ht(ii(nC),ji(nC))))
	       endif
	   endif
	   ! neighbors 0,1,3,5,7 are computational nodes
	   nC = 5
	   top_neigh_i(i,j,3*nC) = ii(nC)
	   top_neigh_i(i,j,3*nC+1) = ji(nC)
	   top_neigh_i(i,j,3*nC+2) = ki(nC)		
	   if (stag ==1 ) then 			
	       top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx)
	       top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)
	   elseif (stag == 2) then
	       top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
	       top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy)	     
	   elseif (stag == 3) then
	       top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
	       top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)	     
	   endif
	   top_neigh(i,j,3*nC+2) = ht_p(top_neigh_i(i,j,3*nC),top_neigh_i(i,j,3*nC+2),top_neigh_i(i,j,3*nC+1))
	   ! neighbor 6 on the boundary between 6 and 7
	   nC = 6
	   top_neigh_i(i,j,3*nC) = 0
	   top_neigh_i(i,j,3*nC+1) = ji(nC)
	   top_neigh_i(i,j,3*nC+2) = 0
	   ! first z
	   top_neigh(i,j,3*nC+2) = ht_p(ii(nC),ki(nC),ji(nC))
	   if (stag == 1) then
	       !next y
	       top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)
	       ! solve for x
	       if (ibm_ht_xstag(ii(nC),ji(nC)) >= top_neigh(i,j,3*nC+2)) then
		  top_neigh(i,j,3*nC) = (ii(nC)*dx)-(dx/2) + (dx/2)*((top_neigh(i,j,3*nC+2)-ibm_ht_xstag(ii(nC),ji(nC))) &
						                  /(ibm_ht(ii(nC)+1,ji(nC))-ibm_ht_xstag(ii(nC),ji(nC))))
	       else
		  top_neigh(i,j,3*nC) = (ii(nC)*dx)-dx + (dx/2)*((top_neigh(i,j,3*nC+2)-ibm_ht(ii(nC),ji(nC))) &
							  /(ibm_ht_xstag(ii(nC),ji(nC))-ibm_ht(ii(nC),ji(nC))))
	       endif						  
	   elseif (stag == 2) then
	       !next y
	       top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy)
	       ! solve for x
	       if (ibm_ht_xstag(ii(nC)+1,ji(nC)) >= top_neigh(i,j,3*nC+2)) then
		  top_neigh(i,j,3*nC) = (ii(nC)*dx) + (dx/2)*((top_neigh(i,j,3*nC+2)-ibm_ht_xstag(ii(nC)+1,ji(nC))) &
						           /(ibm_ht(ii(nC)+1,ji(nC))-ibm_ht_xstag(ii(nC)+1,ji(nC))))
	       else
		  top_neigh(i,j,3*nC) = (ii(nC)*dx)-(dx/2) + (dx/2)*((top_neigh(i,j,3*nC+2)-ibm_ht(ii(nC),ji(nC))) &
						            /(ibm_ht_xstag(ii(nC)+1,ji(nC))-ibm_ht(ii(nC),ji(nC))))
	       endif
	   elseif (stag == 3) then
	       !next y
	       top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)
	       ! solve for x
	       if (ibm_ht_xstag(ii(nC)+1,ji(nC)) >= top_neigh(i,j,3*nC+2)) then
		  top_neigh(i,j,3*nC) = (ii(nC)*dx) + (dx/2)*((top_neigh(i,j,3*nC+2)-ibm_ht_xstag(ii(nC)+1,ji(nC))) &
						           /(ibm_ht(ii(nC)+1,ji(nC))-ibm_ht_xstag(ii(nC)+1,ji(nC))))
	       else
		  top_neigh(i,j,3*nC) = (ii(nC)*dx)-(dx/2) + (dx/2)*((top_neigh(i,j,3*nC+2)-ibm_ht(ii(nC),ji(nC))) &
						            /(ibm_ht_xstag(ii(nC)+1,ji(nC))-ibm_ht(ii(nC),ji(nC))))
	       endif
	   endif
	   ! neighbors 0,1,3,5,7 are computational nodes
	   nC = 7
	   top_neigh_i(i,j,3*nC) = ii(nC)
	   top_neigh_i(i,j,3*nC+1) = ji(nC)
	   top_neigh_i(i,j,3*nC+2) = ki(nC)		
	   if (stag ==1 ) then 			
	       top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx)
	       top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)
	   elseif (stag == 2) then
	       top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
	       top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy)	     
	   elseif (stag == 3) then
	       top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
	       top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)	     
	   endif
	   top_neigh(i,j,3*nC+2) = ht_p(top_neigh_i(i,j,3*nC),top_neigh_i(i,j,3*nC+2),top_neigh_i(i,j,3*nC+1))
    ELSEIF ((inside(ii(0),ki(0),ji(0)) == 0).AND. &
	   (inside(ii(1),ki(1),ji(1)) == 1).AND. &
	   (inside(ii(2),ki(2),ji(2)) == 0).AND. &
	   (inside(ii(3),ki(3),ji(3)) == 1).AND. &
	   (inside(ii(4),ki(4),ji(4)) == 0).AND. &
	   (inside(ii(5),ki(5),ji(5)) == 0).AND. &
	   (inside(ii(6),ki(6),ji(6)) == 0).AND. &
	   (inside(ii(7),ki(7),ji(7)) == 1)) THEN
	   ! neighbors 0,2,4,5,6 are the zero computational nodes
	   nC = 0
	   top_neigh_i(i,j,3*nC) = ii(nC)
	   top_neigh_i(i,j,3*nC+1) = ji(nC)
	   top_neigh_i(i,j,3*nC+2) = ki(nC)		
	   if (stag ==1 ) then 			
	       top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx)
	       top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)
	   elseif (stag == 2) then
	       top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
	       top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy)	     
	   elseif (stag == 3) then
	       top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
	       top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)	     
	   endif
	   top_neigh(i,j,3*nC+2) = ht_p(top_neigh_i(i,j,3*nC),top_neigh_i(i,j,3*nC+2),top_neigh_i(i,j,3*nC+1))  	
	   ! neighbor 1 on the boundary between 0 and 1
	   nC = 1 
	   top_neigh_i(i,j,3*nC) = 0
	   top_neigh_i(i,j,3*nC+1) = ji(nC)
	   top_neigh_i(i,j,3*nC+2) = 0
	   ! first z
	   top_neigh(i,j,3*nC+2) = ht_p(ii(nC),ki(nC),ji(nC))
	   if (stag == 1) then
	       !next y
	       top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)
	       ! solve for x
	       if (ibm_ht_xstag(ii(nC)-1,ji(nC)) >= top_neigh(i,j,3*nC+2)) then
		  top_neigh(i,j,3*nC) = ((ii(nC)-1)*dx)-dx + (dx/2)*((top_neigh(i,j,3*nC+2)-ibm_ht(ii(nC)-1,ji(nC))) &
						          /(ibm_ht_xstag(ii(nC)-1,ji(nC))-ibm_ht(ii(nC)-1,ji(nC))))
	       else
		  top_neigh(i,j,3*nC) = ((ii(nC)-1)*dx)-(dx/2) + (dx/2)*((top_neigh(i,j,3*nC+2)-ibm_ht_xstag(ii(nC)-1,ji(nC))) &
							              /(ibm_ht(ii(nC),ji(nC))-ibm_ht_xstag(ii(nC)-1,ji(nC))))
	       endif						  
	   elseif (stag == 2) then
	       !next y
	       top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy)
	       ! solve for x
	       if (ibm_ht_xstag(ii(nC),ji(nC)) >= top_neigh(i,j,3*nC+2)) then
		  top_neigh(i,j,3*nC) = ((ii(nC)-1)*dx)-(dx/2) + (dx/2)*((top_neigh(i,j,3*nC+2)-ibm_ht(ii(nC)-1,ji(nC))) &
						        	/(ibm_ht_xstag(ii(nC),ji(nC))-ibm_ht(ii(nC)-1,ji(nC))))
	       else
		  top_neigh(i,j,3*nC) = (ii(nC)*dx)-dx + (dx/2)*((top_neigh(i,j,3*nC+2)-ibm_ht_xstag(ii(nC),ji(nC))) &
						              /(ibm_ht(ii(nC),ji(nC))-ibm_ht_xstag(ii(nC),ji(nC))))
	       endif
	   elseif (stag == 3) then
	       !next y
	       top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)
	       ! solve for x
	       if (ibm_ht_xstag(ii(nC),ji(nC)) >= top_neigh(i,j,3*nC+2)) then
		  top_neigh(i,j,3*nC) = ((ii(nC)-1)*dx)-(dx/2) + (dx/2)*((top_neigh(i,j,3*nC+2)-ibm_ht(ii(nC)-1,ji(nC))) &
						        	/(ibm_ht_xstag(ii(nC),ji(nC))-ibm_ht(ii(nC)-1,ji(nC))))
	       else
		  top_neigh(i,j,3*nC) = (ii(nC)*dx)-dx + (dx/2)*((top_neigh(i,j,3*nC+2)-ibm_ht_xstag(ii(nC),ji(nC))) &
						              /(ibm_ht(ii(nC),ji(nC))-ibm_ht_xstag(ii(nC),ji(nC))))
	       endif
	   endif
	   ! neighbors 0,2,4,5,6 are the zero computational nodes
	   nC = 2
	   top_neigh_i(i,j,3*nC) = ii(nC)
	   top_neigh_i(i,j,3*nC+1) = ji(nC)
	   top_neigh_i(i,j,3*nC+2) = ki(nC)		
	   if (stag ==1 ) then 			
	       top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx)
	       top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)
	   elseif (stag == 2) then
	       top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
	       top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy)	     
	   elseif (stag == 3) then
	       top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
	       top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)	     
	   endif
	   top_neigh(i,j,3*nC+2) = ht_p(top_neigh_i(i,j,3*nC),top_neigh_i(i,j,3*nC+2),top_neigh_i(i,j,3*nC+1))
	   ! neighbor 3 on the boundary between 2 and 3
	   nC = 3
	   top_neigh_i(i,j,3*nC) = 0
	   top_neigh_i(i,j,3*nC+1) = ji(nC)
	   top_neigh_i(i,j,3*nC+2) = 0
	   ! first z
	   top_neigh(i,j,3*nC+2) = ht_p(ii(nC),ki(nC),ji(nC))
	   if (stag == 1) then
	       !next y
	       top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)
	       ! solve for x
	       if (ibm_ht_xstag(ii(nC)-1,ji(nC)) >= top_neigh(i,j,3*nC+2)) then
		  top_neigh(i,j,3*nC) = ((ii(nC)-1)*dx)-dx + (dx/2)*((top_neigh(i,j,3*nC+2)-ibm_ht(ii(nC)-1,ji(nC))) &
						          /(ibm_ht_xstag(ii(nC)-1,ji(nC))-ibm_ht(ii(nC)-1,ji(nC))))
	       else
		  top_neigh(i,j,3*nC) = ((ii(nC)-1)*dx)-(dx/2) + (dx/2)*((top_neigh(i,j,3*nC+2)-ibm_ht_xstag(ii(nC)-1,ji(nC))) &
							              /(ibm_ht(ii(nC),ji(nC))-ibm_ht_xstag(ii(nC)-1,ji(nC))))
	       endif						  
	   elseif (stag == 2) then
	       !next y
	       top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy)
	       ! solve for x
	       if (ibm_ht_xstag(ii(nC),ji(nC)) >= top_neigh(i,j,3*nC+2)) then
		  top_neigh(i,j,3*nC) = ((ii(nC)-1)*dx)-(dx/2) + (dx/2)*((top_neigh(i,j,3*nC+2)-ibm_ht(ii(nC)-1,ji(nC))) &
						        	/(ibm_ht_xstag(ii(nC),ji(nC))-ibm_ht(ii(nC)-1,ji(nC))))
	       else
		  top_neigh(i,j,3*nC) = (ii(nC)*dx)-dx + (dx/2)*((top_neigh(i,j,3*nC+2)-ibm_ht_xstag(ii(nC),ji(nC))) &
						              /(ibm_ht(ii(nC),ji(nC))-ibm_ht_xstag(ii(nC),ji(nC))))
	       endif
	   elseif (stag == 3) then
	       !next y
	       top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)
	       ! solve for x
	       if (ibm_ht_xstag(ii(nC),ji(nC)) >= top_neigh(i,j,3*nC+2)) then
		  top_neigh(i,j,3*nC) = ((ii(nC)-1)*dx)-(dx/2) + (dx/2)*((top_neigh(i,j,3*nC+2)-ibm_ht(ii(nC)-1,ji(nC))) &
						        	/(ibm_ht_xstag(ii(nC),ji(nC))-ibm_ht(ii(nC)-1,ji(nC))))
	       else
		  top_neigh(i,j,3*nC) = (ii(nC)*dx)-dx + (dx/2)*((top_neigh(i,j,3*nC+2)-ibm_ht_xstag(ii(nC),ji(nC))) &
						              /(ibm_ht(ii(nC),ji(nC))-ibm_ht_xstag(ii(nC),ji(nC))))
	       endif
	   endif
	   ! neighbors 0,2,4,5,6 are the zero computational nodes
	   do nC = 4,6
	      top_neigh_i(i,j,3*nC) = ii(nC)
	      top_neigh_i(i,j,3*nC+1) = ji(nC)
	      top_neigh_i(i,j,3*nC+2) = ki(nC)		
	      if (stag ==1 ) then 			
		  top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx)
		  top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)
	      elseif (stag == 2) then
		  top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
		  top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy)	     
	      elseif (stag == 3) then
		  top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
		  top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)	     
	      endif
	      top_neigh(i,j,3*nC+2) = ht_p(top_neigh_i(i,j,3*nC),top_neigh_i(i,j,3*nC+2),top_neigh_i(i,j,3*nC+1))  
	   enddo	   
	   ! neighbor 7 is on the boundary between 6 and 7 
	   nC = 7 
	   top_neigh_i(i,j,3*nC) = 0
	   top_neigh_i(i,j,3*nC+1) = ji(nC)
	   top_neigh_i(i,j,3*nC+2) = 0
	   ! first z
	   top_neigh(i,j,3*nC+2) = ht_p(ii(nC),ki(nC),ji(nC))
	   if (stag == 1) then
	       !next y
	       top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)
	       ! solve for x
	       if (ibm_ht_xstag(ii(nC)-1,ji(nC)) >= top_neigh(i,j,3*nC+2)) then
		  top_neigh(i,j,3*nC) = ((ii(nC)-1)*dx)-dx + (dx/2)*((top_neigh(i,j,3*nC+2)-ibm_ht(ii(nC)-1,ji(nC))) &
							    /(ibm_ht_xstag(ii(nC)-1,ji(nC))-ibm_ht(ii(nC)-1,ji(nC))))
	       else
		  top_neigh(i,j,3*nC) = ((ii(nC)-1)*dx)-(dx/2) + (dx/2)*((top_neigh(i,j,3*nC+2)-ibm_ht_xstag(ii(nC)-1,ji(nC))) &
									/(ibm_ht(ii(nC),ji(nC))-ibm_ht_xstag(ii(nC)-1,ji(nC))))
	       endif 						 
	   elseif (stag == 2) then
	       !next y
	       top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy)
	       ! solve for x
	       if (ibm_ht_xstag(ii(nC),ji(nC)) >= top_neigh(i,j,3*nC+2)) then
		  top_neigh(i,j,3*nC) = ((ii(nC)-1)*dx)-(dx/2) + (dx/2)*((top_neigh(i,j,3*nC+2)-ibm_ht(ii(nC)-1,ji(nC))) &
								  /(ibm_ht_xstag(ii(nC),ji(nC))-ibm_ht(ii(nC)-1,ji(nC))))
	       else
		  top_neigh(i,j,3*nC) = (ii(nC)*dx)-dx + (dx/2)*((top_neigh(i,j,3*nC+2)-ibm_ht_xstag(ii(nC),ji(nC))) &
								/(ibm_ht(ii(nC),ji(nC))-ibm_ht_xstag(ii(nC),ji(nC))))
	       endif
	   elseif (stag == 3) then
	       !next y
	       top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)
	       ! solve for x
	       if (ibm_ht_xstag(ii(nC),ji(nC)) >= top_neigh(i,j,3*nC+2)) then
		  top_neigh(i,j,3*nC) = ((ii(nC)-1)*dx)-(dx/2) + (dx/2)*((top_neigh(i,j,3*nC+2)-ibm_ht(ii(nC)-1,ji(nC))) &
								  /(ibm_ht_xstag(ii(nC),ji(nC))-ibm_ht(ii(nC)-1,ji(nC))))
	       else
		  top_neigh(i,j,3*nC) = (ii(nC)*dx)-dx + (dx/2)*((top_neigh(i,j,3*nC+2)-ibm_ht_xstag(ii(nC),ji(nC))) &
								 /(ibm_ht(ii(nC),ji(nC))-ibm_ht_xstag(ii(nC),ji(nC))))
	       endif
	   endif	   
    ELSEIF ((inside(ii(0),ki(0),ji(0)) == 0).AND. &
	    (inside(ii(1),ki(1),ji(1)) == 0).AND. &
	    (inside(ii(2),ki(2),ji(2)) == 0).AND. &
	    (inside(ii(3),ki(3),ji(3)) == 1).AND. &
	    (inside(ii(4),ki(4),ji(4)) == 0).AND. &
	    (inside(ii(5),ki(5),ji(5)) == 1).AND. &
	    (inside(ii(6),ki(6),ji(6)) == 0).AND. &
	    (inside(ii(7),ki(7),ji(7)) == 1)) THEN
	   ! neighbors 0,1,2,4,6 are the zero computational nodes
	   do nC = 0,2
	      top_neigh_i(i,j,3*nC) = ii(nC)
	      top_neigh_i(i,j,3*nC+1) = ji(nC)
	      top_neigh_i(i,j,3*nC+2) = ki(nC)		
	      if (stag ==1 ) then 			
		  top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx)
		  top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)
	      elseif (stag == 2) then
		  top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
		  top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy)	     
	      elseif (stag == 3) then
		  top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
		  top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)	     
	      endif
	      top_neigh(i,j,3*nC+2) = ht_p(top_neigh_i(i,j,3*nC),top_neigh_i(i,j,3*nC+2),top_neigh_i(i,j,3*nC+1))  
	   enddo
	   ! neighbor 3 is on the boundary between 2 and 3 
	   nC = 3
	   top_neigh_i(i,j,3*nC) = 0
	   top_neigh_i(i,j,3*nC+1) = ji(nC)
	   top_neigh_i(i,j,3*nC+2) = 0
	   ! first z
	   top_neigh(i,j,3*nC+2) = ht_p(ii(nC),ki(nC),ji(nC))
	   if (stag == 1) then
	       !next y
	       top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)
	       ! solve for x
	       if (ibm_ht_xstag(ii(nC)-1,ji(nC)) >= top_neigh(i,j,3*nC+2)) then
		  top_neigh(i,j,3*nC) = ((ii(nC)-1)*dx)-dx + (dx/2)*((top_neigh(i,j,3*nC+2)-ibm_ht(ii(nC)-1,ji(nC))) &
							    /(ibm_ht_xstag(ii(nC)-1,ji(nC))-ibm_ht(ii(nC)-1,ji(nC))))
	       else
		  top_neigh(i,j,3*nC) = ((ii(nC)-1)*dx)-(dx/2) + (dx/2)*((top_neigh(i,j,3*nC+2)-ibm_ht_xstag(ii(nC)-1,ji(nC))) &
									/(ibm_ht(ii(nC),ji(nC))-ibm_ht_xstag(ii(nC)-1,ji(nC))))
	       endif 						 
	   elseif (stag == 2) then
	       !next y
	       top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy)
	       ! solve for x
	       if (ibm_ht_xstag(ii(nC),ji(nC)) >= top_neigh(i,j,3*nC+2)) then
		  top_neigh(i,j,3*nC) = ((ii(nC)-1)*dx)-(dx/2) + (dx/2)*((top_neigh(i,j,3*nC+2)-ibm_ht(ii(nC)-1,ji(nC))) &
								  /(ibm_ht_xstag(ii(nC),ji(nC))-ibm_ht(ii(nC)-1,ji(nC))))
	       else
		  top_neigh(i,j,3*nC) = (ii(nC)*dx)-dx + (dx/2)*((top_neigh(i,j,3*nC+2)-ibm_ht_xstag(ii(nC),ji(nC))) &
								/(ibm_ht(ii(nC),ji(nC))-ibm_ht_xstag(ii(nC),ji(nC))))
	       endif
	   elseif (stag == 3) then
	       !next y
	       top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)
	       ! solve for x
	       if (ibm_ht_xstag(ii(nC),ji(nC)) >= top_neigh(i,j,3*nC+2)) then
		  top_neigh(i,j,3*nC) = ((ii(nC)-1)*dx)-(dx/2) + (dx/2)*((top_neigh(i,j,3*nC+2)-ibm_ht(ii(nC)-1,ji(nC))) &
								  /(ibm_ht_xstag(ii(nC),ji(nC))-ibm_ht(ii(nC)-1,ji(nC))))
	       else
		  top_neigh(i,j,3*nC) = (ii(nC)*dx)-dx + (dx/2)*((top_neigh(i,j,3*nC+2)-ibm_ht_xstag(ii(nC),ji(nC))) &
								 /(ibm_ht(ii(nC),ji(nC))-ibm_ht_xstag(ii(nC),ji(nC))))
	       endif
	   endif
	   ! neighbors 0,1,2,4,6 are the zero computational nodes
	   nC = 4
	   top_neigh_i(i,j,3*nC) = ii(nC)
	   top_neigh_i(i,j,3*nC+1) = ji(nC)
	   top_neigh_i(i,j,3*nC+2) = ki(nC)		
	   if (stag ==1 ) then 			
	       top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx)
	       top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)
	   elseif (stag == 2) then
	       top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
	       top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy)	     
	   elseif (stag == 3) then
	       top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
	       top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)	     
	   endif
	   top_neigh(i,j,3*nC+2) = ht_p(top_neigh_i(i,j,3*nC),top_neigh_i(i,j,3*nC+2),top_neigh_i(i,j,3*nC+1))
	   ! neighbor 5 is on the boundary between 4 and 5
	   nC = 5
	   top_neigh_i(i,j,3*nC) = 0
	   top_neigh_i(i,j,3*nC+1) = ji(nC)
	   top_neigh_i(i,j,3*nC+2) = 0
	   ! first z
	   top_neigh(i,j,3*nC+2) = ht_p(ii(nC),ki(nC),ji(nC))
	   if (stag == 1) then
	       !next y
	       top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)
	       ! solve for x
	       if (ibm_ht_xstag(ii(nC)-1,ji(nC)) >= top_neigh(i,j,3*nC+2)) then
		  top_neigh(i,j,3*nC) = ((ii(nC)-1)*dx)-dx + (dx/2)*((top_neigh(i,j,3*nC+2)-ibm_ht(ii(nC)-1,ji(nC))) &
							    /(ibm_ht_xstag(ii(nC)-1,ji(nC))-ibm_ht(ii(nC)-1,ji(nC))))
	       else
		  top_neigh(i,j,3*nC) = ((ii(nC)-1)*dx)-(dx/2) + (dx/2)*((top_neigh(i,j,3*nC+2)-ibm_ht_xstag(ii(nC)-1,ji(nC))) &
									/(ibm_ht(ii(nC),ji(nC))-ibm_ht_xstag(ii(nC)-1,ji(nC))))
	       endif 						 
	   elseif (stag == 2) then
	       !next y
	       top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy)
	       ! solve for x
	       if (ibm_ht_xstag(ii(nC),ji(nC)) >= top_neigh(i,j,3*nC+2)) then
		  top_neigh(i,j,3*nC) = ((ii(nC)-1)*dx)-(dx/2) + (dx/2)*((top_neigh(i,j,3*nC+2)-ibm_ht(ii(nC)-1,ji(nC))) &
								  /(ibm_ht_xstag(ii(nC),ji(nC))-ibm_ht(ii(nC)-1,ji(nC))))
	       else
		  top_neigh(i,j,3*nC) = (ii(nC)*dx)-dx + (dx/2)*((top_neigh(i,j,3*nC+2)-ibm_ht_xstag(ii(nC),ji(nC))) &
								/(ibm_ht(ii(nC),ji(nC))-ibm_ht_xstag(ii(nC),ji(nC))))
	       endif
	   elseif (stag == 3) then
	       !next y
	       top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)
	       ! solve for x
	       if (ibm_ht_xstag(ii(nC),ji(nC)) >= top_neigh(i,j,3*nC+2)) then
		  top_neigh(i,j,3*nC) = ((ii(nC)-1)*dx)-(dx/2) + (dx/2)*((top_neigh(i,j,3*nC+2)-ibm_ht(ii(nC)-1,ji(nC))) &
								  /(ibm_ht_xstag(ii(nC),ji(nC))-ibm_ht(ii(nC)-1,ji(nC))))
	       else
		  top_neigh(i,j,3*nC) = (ii(nC)*dx)-dx + (dx/2)*((top_neigh(i,j,3*nC+2)-ibm_ht_xstag(ii(nC),ji(nC))) &
								 /(ibm_ht(ii(nC),ji(nC))-ibm_ht_xstag(ii(nC),ji(nC))))
	       endif
	   endif
	   ! neighbors 0,1,2,4,6 are the zero computational nodes
	   nC = 6
	   top_neigh_i(i,j,3*nC) = ii(nC)
	   top_neigh_i(i,j,3*nC+1) = ji(nC)
	   top_neigh_i(i,j,3*nC+2) = ki(nC)		
	   if (stag ==1 ) then 			
	       top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx)
	       top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)
	   elseif (stag == 2) then
	       top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
	       top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy)	     
	   elseif (stag == 3) then
	       top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
	       top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)	     
	   endif
	   top_neigh(i,j,3*nC+2) = ht_p(top_neigh_i(i,j,3*nC),top_neigh_i(i,j,3*nC+2),top_neigh_i(i,j,3*nC+1))
	   ! neighbor 6 is on the boundary between 6 and 7
	   nC = 7
	   top_neigh_i(i,j,3*nC) = 0
	   top_neigh_i(i,j,3*nC+1) = ji(nC)
	   top_neigh_i(i,j,3*nC+2) = 0
	   ! first z
	   top_neigh(i,j,3*nC+2) = ht_p(ii(nC),ki(nC),ji(nC))
	   if (stag == 1) then
	       !next y
	       top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)
	       ! solve for x
	       if (ibm_ht_xstag(ii(nC)-1,ji(nC)) >= top_neigh(i,j,3*nC+2)) then
		  top_neigh(i,j,3*nC) = ((ii(nC)-1)*dx)-dx + (dx/2)*((top_neigh(i,j,3*nC+2)-ibm_ht(ii(nC)-1,ji(nC))) &
							    /(ibm_ht_xstag(ii(nC)-1,ji(nC))-ibm_ht(ii(nC)-1,ji(nC))))
	       else
		  top_neigh(i,j,3*nC) = ((ii(nC)-1)*dx)-(dx/2) + (dx/2)*((top_neigh(i,j,3*nC+2)-ibm_ht_xstag(ii(nC)-1,ji(nC))) &
									/(ibm_ht(ii(nC),ji(nC))-ibm_ht_xstag(ii(nC)-1,ji(nC))))
	       endif 						 
	   elseif (stag == 2) then
	       !next y
	       top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy)
	       ! solve for x
	       if (ibm_ht_xstag(ii(nC),ji(nC)) >= top_neigh(i,j,3*nC+2)) then
		  top_neigh(i,j,3*nC) = ((ii(nC)-1)*dx)-(dx/2) + (dx/2)*((top_neigh(i,j,3*nC+2)-ibm_ht(ii(nC)-1,ji(nC))) &
								  /(ibm_ht_xstag(ii(nC),ji(nC))-ibm_ht(ii(nC)-1,ji(nC))))
	       else
		  top_neigh(i,j,3*nC) = (ii(nC)*dx)-dx + (dx/2)*((top_neigh(i,j,3*nC+2)-ibm_ht_xstag(ii(nC),ji(nC))) &
								/(ibm_ht(ii(nC),ji(nC))-ibm_ht_xstag(ii(nC),ji(nC))))
	       endif
	   elseif (stag == 3) then
	       !next y
	       top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)
	       ! solve for x
	       if (ibm_ht_xstag(ii(nC),ji(nC)) >= top_neigh(i,j,3*nC+2)) then
		  top_neigh(i,j,3*nC) = ((ii(nC)-1)*dx)-(dx/2) + (dx/2)*((top_neigh(i,j,3*nC+2)-ibm_ht(ii(nC)-1,ji(nC))) &
								  /(ibm_ht_xstag(ii(nC),ji(nC))-ibm_ht(ii(nC)-1,ji(nC))))
	       else
		  top_neigh(i,j,3*nC) = (ii(nC)*dx)-dx + (dx/2)*((top_neigh(i,j,3*nC+2)-ibm_ht_xstag(ii(nC),ji(nC))) &
								 /(ibm_ht(ii(nC),ji(nC))-ibm_ht_xstag(ii(nC),ji(nC))))
	       endif
	   endif
    ELSEIF ((inside(ii(0),ki(0),ji(0)) == 0).AND. &
	    (inside(ii(1),ki(1),ji(1)) == 0).AND. &
	    (inside(ii(2),ki(2),ji(2)) == 0).AND. &
	    (inside(ii(3),ki(3),ji(3)) == 0).AND. &
	    (inside(ii(4),ki(4),ji(4)) == 1).AND. &
	    (inside(ii(5),ki(5),ji(5)) == 0).AND. &
	    (inside(ii(6),ki(6),ji(6)) == 1).AND. &
	    (inside(ii(7),ki(7),ji(7)) == 1)) THEN
	   ! neighbors 0,1,2,3,5 are the zero computational nodes
	   do nC = 0,3
	      top_neigh_i(i,j,3*nC) = ii(nC)
	      top_neigh_i(i,j,3*nC+1) = ji(nC)
	      top_neigh_i(i,j,3*nC+2) = ki(nC)		
	      if (stag ==1 ) then 			
		  top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx)
		  top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)
	      elseif (stag == 2) then
		  top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
		  top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy)	     
	      elseif (stag == 3) then
		  top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
		  top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)	     
	      endif
	      top_neigh(i,j,3*nC+2) = ht_p(top_neigh_i(i,j,3*nC),top_neigh_i(i,j,3*nC+2),top_neigh_i(i,j,3*nC+1))  
	   enddo	  
	   ! neighbor 4 on the boundary on the 0145 plane 
	   nC = 4 
	   top_neigh_i(i,j,3*nC) = 0
	   top_neigh_i(i,j,3*nC+1) = 0
	   top_neigh_i(i,j,3*nC+2) = 0
	   ! first z
	   top_neigh(i,j,3*nC+2) = ht_p(ii(nC),ki(nC),ji(nC))
	   if (stag == 1) then
	       ! solve for x
	       if (ibm_ht_xstag(ii(nC),ji(nC)) >= top_neigh(i,j,3*nC+2)) then
		  top_neigh(i,j,3*nC) = (ii(nC)*dx)-dx +(dx/4)+(dx/4)*((top_neigh(i,j,3*nC+2)-ibm_ht_xstag(ii(nC),ji(nC))) &
						                      /(ibm_ht(ii(nC)+1,ji(nC))-ibm_ht_xstag(ii(nC),ji(nC))))
	       else
		  top_neigh(i,j,3*nC) = (ii(nC)*dx)-dx + (dx/4)*((top_neigh(i,j,3*nC+2)-ibm_ht(ii(nC),ji(nC))) &
						          /(ibm_ht_xstag(ii(nC),ji(nC))-ibm_ht(ii(nC),ji(nC))))
	       endif						  
	       ! solve for y
	       if (ibm_ht_ystag(ii(nC),ji(nC)) >= top_neigh(i,j,3*nC+2)) then
		  top_neigh(i,j,3*nC+1) = ((ji(nC)-1)*dy) +(dy/4)*((top_neigh(i,j,3*nC+2)-ibm_ht(ii(nC),ji(nC)-1)) &
						            /(ibm_ht_ystag(ii(nC),ji(nC))-ibm_ht(ii(nC),ji(nC)-1)))
	       else
		  top_neigh(i,j,3*nC+1) = ((ji(nC)-1)*dy)-dy + (dy/4)+(dy/4)*((top_neigh(i,j,3*nC+2)-ibm_ht_ystag(ii(nC),ji(nC))) &
							                         /(ibm_ht(ii(nC),ji(nC))-ibm_ht_ystag(ii(nC),ji(nC))))
	       endif
	   elseif (stag == 2) then
	       ! solve for x
	       if (ibm_ht_xstag(ii(nC)+1,ji(nC)) >= top_neigh(i,j,3*nC+2)) then
		  top_neigh(i,j,3*nC) = (ii(nC)*dx)-(dx/2) + (dx/4)+(dx/4)*((top_neigh(i,j,3*nC+2)-ibm_ht_xstag(ii(nC)+1,ji(nC))) &
						                         /(ibm_ht(ii(nC)+1,ji(nC))-ibm_ht_xstag(ii(nC)+1,ji(nC))))
	       else
		  top_neigh(i,j,3*nC) = (ii(nC)*dx)-(dx/2) + (dx/4)*((top_neigh(i,j,3*nC+2)-ibm_ht(ii(nC),ji(nC))) &
						            /(ibm_ht_xstag(ii(nC)+1,ji(nC))-ibm_ht(ii(nC),ji(nC))))
	       endif
	       ! solve for y
	       if (ibm_ht_ystag(ii(nC),ji(nC)-1) >= top_neigh(i,j,3*nC+2)) then
		  top_neigh(i,j,3*nC+1) = ((ji(nC)-1)*dy)-dy + (dy/2)+(dy/4)*((top_neigh(i,j,3*nC+2)-ibm_ht(ii(nC),ji(nC)-1)) &
						                     /(ibm_ht_ystag(ii(nC),ji(nC)-1)-ibm_ht(ii(nC),ji(nC)-1)))
	       else
		  top_neigh(i,j,3*nC+1) = ((ji(nC)-1)*dy)-(dy/2) + (dy/4)+(dy/4)*((top_neigh(i,j,3*nC+2)-ibm_ht_ystag(ii(nC),ji(nC)-1)) &
						                                 /(ibm_ht(ii(nC),ji(nC))-ibm_ht_ystag(ii(nC),ji(nC)-1)))
	       endif
	   elseif (stag == 3) then
	       ! solve for x
	       if (ibm_ht_xstag(ii(nC)+1,ji(nC)) >= top_neigh(i,j,3*nC+2)) then
		  top_neigh(i,j,3*nC) = (ii(nC)*dx)-(dx/2) + (dx/4)+(dx/4)*((top_neigh(i,j,3*nC+2)-ibm_ht_xstag(ii(nC)+1,ji(nC))) &
						                         /(ibm_ht(ii(nC)+1,ji(nC))-ibm_ht_xstag(ii(nC)+1,ji(nC))))
	       else
		  top_neigh(i,j,3*nC) = (ii(nC)*dx)-(dx/2) + (dx/4)*((top_neigh(i,j,3*nC+2)-ibm_ht(ii(nC),ji(nC))) &
						            /(ibm_ht_xstag(ii(nC)+1,ji(nC))-ibm_ht(ii(nC),ji(nC))))
	       endif
	       ! solve for y
	       if (ibm_ht_ystag(ii(nC),ji(nC)) >= top_neigh(i,j,3*nC+2)) then
		  top_neigh(i,j,3*nC+1) = ((ji(nC)-1)*dy) + (dy/4)*((top_neigh(i,j,3*nC+2)-ibm_ht(ii(nC),ji(nC)-1)) &
						             /(ibm_ht_ystag(ii(nC),ji(nC))-ibm_ht(ii(nC),ji(nC)-1)))
	       else
		  top_neigh(i,j,3*nC+1) = ((ji(nC)-1)*dy) + (dy/4)+(dy/4)*((top_neigh(i,j,3*nC+2)-ibm_ht_ystag(ii(nC),ji(nC))) &
							                 /(ibm_ht(ii(nC),ji(nC))-ibm_ht_ystag(ii(nC),ji(nC))))
	       endif
	   endif
	   ! neighbors 0,1,2,3,5 are the zero computational nodes
	   nC = 5
	   top_neigh_i(i,j,3*nC) = ii(nC)
	   top_neigh_i(i,j,3*nC+1) = ji(nC)
	   top_neigh_i(i,j,3*nC+2) = ki(nC)		
	   if (stag ==1 ) then 			
	       top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx)
	       top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)
	   elseif (stag == 2) then
	       top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
	       top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy)	     
	   elseif (stag == 3) then
	       top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
	       top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)	     
	   endif
	   top_neigh(i,j,3*nC+2) = ht_p(top_neigh_i(i,j,3*nC),top_neigh_i(i,j,3*nC+2),top_neigh_i(i,j,3*nC+1))
	   ! neighbor 6 on the boundary on the 2367 plane 
	   nC = 6
	   top_neigh_i(i,j,3*nC) = 0
	   top_neigh_i(i,j,3*nC+1) = 0
	   top_neigh_i(i,j,3*nC+2) = 0
	   ! first z
	   top_neigh(i,j,3*nC+2) = ht_p(ii(nC),ki(nC),ji(nC))
	   if (stag == 1) then
	       ! solve for x
	       if (ibm_ht_xstag(ii(nC),ji(nC)) >= top_neigh(i,j,3*nC+2)) then
		  top_neigh(i,j,3*nC) = (ii(nC)*dx)-dx +(dx/4)+(dx/4)*((top_neigh(i,j,3*nC+2)-ibm_ht_xstag(ii(nC),ji(nC))) &
						                      /(ibm_ht(ii(nC)+1,ji(nC))-ibm_ht_xstag(ii(nC),ji(nC))))
	       else
		  top_neigh(i,j,3*nC) = (ii(nC)*dx)-dx + (dx/4)*((top_neigh(i,j,3*nC+2)-ibm_ht(ii(nC),ji(nC))) &
						          /(ibm_ht_xstag(ii(nC),ji(nC))-ibm_ht(ii(nC),ji(nC))))
	       endif						  
	       ! solve for y
	       if (ibm_ht_ystag(ii(nC),ji(nC)) >= top_neigh(i,j,3*nC+2)) then
		  top_neigh(i,j,3*nC+1) = ((ji(nC)-1)*dy) +(dy/4)*((top_neigh(i,j,3*nC+2)-ibm_ht(ii(nC),ji(nC)-1)) &
						            /(ibm_ht_ystag(ii(nC),ji(nC))-ibm_ht(ii(nC),ji(nC)-1)))
	       else
		  top_neigh(i,j,3*nC+1) = ((ji(nC)-1)*dy)-dy + (dy/4)+(dy/4)*((top_neigh(i,j,3*nC+2)-ibm_ht_ystag(ii(nC),ji(nC))) &
							                         /(ibm_ht(ii(nC),ji(nC))-ibm_ht_ystag(ii(nC),ji(nC))))
	       endif
	   elseif (stag == 2) then
	       ! solve for x
	       if (ibm_ht_xstag(ii(nC)+1,ji(nC)) >= top_neigh(i,j,3*nC+2)) then
		  top_neigh(i,j,3*nC) = (ii(nC)*dx)-(dx/2) + (dx/4)+(dx/4)*((top_neigh(i,j,3*nC+2)-ibm_ht_xstag(ii(nC)+1,ji(nC))) &
						                         /(ibm_ht(ii(nC)+1,ji(nC))-ibm_ht_xstag(ii(nC)+1,ji(nC))))
	       else
		  top_neigh(i,j,3*nC) = (ii(nC)*dx)-(dx/2) + (dx/4)*((top_neigh(i,j,3*nC+2)-ibm_ht(ii(nC),ji(nC))) &
						            /(ibm_ht_xstag(ii(nC)+1,ji(nC))-ibm_ht(ii(nC),ji(nC))))
	       endif
	       ! solve for y
	       if (ibm_ht_ystag(ii(nC),ji(nC)-1) >= top_neigh(i,j,3*nC+2)) then
		  top_neigh(i,j,3*nC+1) = ((ji(nC)-1)*dy)-dy + (dy/2)+(dy/4)*((top_neigh(i,j,3*nC+2)-ibm_ht(ii(nC),ji(nC)-1)) &
						                     /(ibm_ht_ystag(ii(nC),ji(nC)-1)-ibm_ht(ii(nC),ji(nC)-1)))
	       else
		  top_neigh(i,j,3*nC+1) = ((ji(nC)-1)*dy)-(dy/2) + (dy/4)+(dy/4)*((top_neigh(i,j,3*nC+2)-ibm_ht_ystag(ii(nC),ji(nC)-1)) &
						                                 /(ibm_ht(ii(nC),ji(nC))-ibm_ht_ystag(ii(nC),ji(nC)-1)))
	       endif
	   elseif (stag == 3) then
	       ! solve for x
	       if (ibm_ht_xstag(ii(nC)+1,ji(nC)) >= top_neigh(i,j,3*nC+2)) then
		  top_neigh(i,j,3*nC) = (ii(nC)*dx)-(dx/2) + (dx/4)+(dx/4)*((top_neigh(i,j,3*nC+2)-ibm_ht_xstag(ii(nC)+1,ji(nC))) &
						                         /(ibm_ht(ii(nC)+1,ji(nC))-ibm_ht_xstag(ii(nC)+1,ji(nC))))
	       else
		  top_neigh(i,j,3*nC) = (ii(nC)*dx)-(dx/2) + (dx/4)*((top_neigh(i,j,3*nC+2)-ibm_ht(ii(nC),ji(nC))) &
						            /(ibm_ht_xstag(ii(nC)+1,ji(nC))-ibm_ht(ii(nC),ji(nC))))
	       endif
	       ! solve for y
	       if (ibm_ht_ystag(ii(nC),ji(nC)) >= top_neigh(i,j,3*nC+2)) then
		  top_neigh(i,j,3*nC+1) = ((ji(nC)-1)*dy) + (dy/4)*((top_neigh(i,j,3*nC+2)-ibm_ht(ii(nC),ji(nC)-1)) &
						             /(ibm_ht_ystag(ii(nC),ji(nC))-ibm_ht(ii(nC),ji(nC)-1)))
	       else
		  top_neigh(i,j,3*nC+1) = ((ji(nC)-1)*dy) + (dy/4)+(dy/4)*((top_neigh(i,j,3*nC+2)-ibm_ht_ystag(ii(nC),ji(nC))) &
							                 /(ibm_ht(ii(nC),ji(nC))-ibm_ht_ystag(ii(nC),ji(nC))))
	       endif
	   endif
	   ! neighbor 7 is on the boundary at ibm_ht
	   nC = 7
	   top_neigh_i(i,j,3*nC) = ii(nC)
	   top_neigh_i(i,j,3*nC+1) = ji(nC)
	   top_neigh_i(i,j,3*nC+2) = 0		
	   if (stag ==1 ) then 			
	       top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx)
	       top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)
	   elseif (stag == 2) then
	       top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
	       top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy)	     
	   elseif (stag == 3) then
	       top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
	       top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)	     
	   endif
	   top_neigh(i,j,3*nC+2) = ibm_ht(top_neigh_i(i,j,3*nC),top_neigh_i(i,j,3*nC+1)) 
    ELSEIF ((inside(ii(0),ki(0),ji(0)) == 0).AND. &
	   (inside(ii(1),ki(1),ji(1)) == 1).AND. &
	   (inside(ii(2),ki(2),ji(2)) == 1).AND. &
	   (inside(ii(3),ki(3),ji(3)) == 1).AND. &
	   (inside(ii(4),ki(4),ji(4)) == 0).AND. &
	   (inside(ii(5),ki(5),ji(5)) == 0).AND. &
	   (inside(ii(6),ki(6),ji(6)) == 0).AND. &
	   (inside(ii(7),ki(7),ji(7)) == 0)) THEN
	   ! neighbors 0,4,5,6,7 are computational nodes
	   nC = 0
	   top_neigh_i(i,j,3*nC) = ii(nC)
	   top_neigh_i(i,j,3*nC+1) = ji(nC)
	   top_neigh_i(i,j,3*nC+2) = ki(nC)		
	   if (stag ==1 ) then 			
	       top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx)
	       top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)
	   elseif (stag == 2) then
	       top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
	       top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy)	     
	   elseif (stag == 3) then
	       top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
	       top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)	     
	   endif
	   top_neigh(i,j,3*nC+2) = ht_p(top_neigh_i(i,j,3*nC),top_neigh_i(i,j,3*nC+2),top_neigh_i(i,j,3*nC+1))
	   ! neighbor 1 on the boundary face that cuts the 0145 plane
	   nC = 1 
	   top_neigh_i(i,j,3*nC) = 0
	   top_neigh_i(i,j,3*nC+1) = 0
	   top_neigh_i(i,j,3*nC+2) = 0
	   ! first z
	   top_neigh(i,j,3*nC+2) = ht_p(ii(nC),ki(nC),ji(nC))
	   if (stag == 1) then
	       ! solve for x/2
	       if (ibm_ht_xstag(ii(nC)-1,ji(nC)) >= top_neigh(i,j,3*nC+2)) then
		  top_neigh(i,j,3*nC) = ((ii(nC)-1)*dx)-dx + (dx/2)+(dx/4)*((top_neigh(i,j,3*nC+2)-ibm_ht(ii(nC)-1,ji(nC))) &
						                   /(ibm_ht_xstag(ii(nC)-1,ji(nC))-ibm_ht(ii(nC)-1,ji(nC))))
	       else
		  top_neigh(i,j,3*nC) = ((ii(nC)-1)*dx)-(dx/2) +  (dx/4)+(dx/4)*((top_neigh(i,j,3*nC+2)-ibm_ht_xstag(ii(nC)-1,ji(nC))) &
							                        /(ibm_ht(ii(nC),ji(nC))-ibm_ht_xstag(ii(nC)-1,ji(nC))))
	       endif	
	       ! solve for y/2
	       if (ibm_ht_ystag(ii(nC),ji(nC)+1) >= top_neigh(i,j,3*nC+2)) then
		  top_neigh(i,j,3*nC+1) = (ji(nC)*dy)-(dy/2) + (dy/4)+(dy/4)*((top_neigh(i,j,3*nC+2)-ibm_ht_ystag(ii(nC),ji(nC)+1)) &
						                           /(ibm_ht(ii(nC),ji(nC)+1)-ibm_ht_ystag(ii(nC),ji(nC)+1)))
	       else 
		  top_neigh(i,j,3*nC+1) = (ji(nC)*dy)-(dy/2) + (dy/4)*((top_neigh(i,j,3*nC+2)-ibm_ht(ii(nC),ji(nC))) &
						              /(ibm_ht_ystag(ii(nC),ji(nC)+1)-ibm_ht(ii(nC),ji(nC))))
	       endif					  
	   elseif (stag == 2) then
	       ! solve for x/2
	       if (ibm_ht_xstag(ii(nC),ji(nC)) >= top_neigh(i,j,3*nC+2)) then
		  top_neigh(i,j,3*nC) = ((ii(nC)-1)*dx)-(dx/2) +  (dx/2)+(dx/4)*((top_neigh(i,j,3*nC+2)-ibm_ht(ii(nC)-1,ji(nC))) &
						                          /(ibm_ht_xstag(ii(nC),ji(nC))-ibm_ht(ii(nC)-1,ji(nC))))
	       else
		  top_neigh(i,j,3*nC) = (ii(nC)*dx)-dx +  (dx/4)+(dx/4)*((top_neigh(i,j,3*nC+2)-ibm_ht_xstag(ii(nC),ji(nC))) &
						                        /(ibm_ht(ii(nC),ji(nC))-ibm_ht_xstag(ii(nC),ji(nC))))
	       endif
	       ! solve for y/2
	       if (ibm_ht_ystag(ii(nC),ji(nC)) >= top_neigh(i,j,3*nC+2)) then
		  top_neigh(i,j,3*nC+1) = (ji(nC)*dy)-dy + (dy/4)+(dy/4)*((top_neigh(i,j,3*nC+2)-ibm_ht_ystag(ii(nC),ji(nC))) &
						                    /(ibm_ht(ii(nC),ji(nC)+1)-ibm_ht_ystag(ii(nC),ji(nC))))
	       else
		  top_neigh(i,j,3*nC+1) = (ji(nC)*dy)-dy + (dy/4)*((top_neigh(i,j,3*nC+2)-ibm_ht(ii(nC),ji(nC))) &
						            /(ibm_ht_ystag(ii(nC),ji(nC))-ibm_ht(ii(nC),ji(nC))))
	       endif
	   elseif (stag == 3) then
	       ! solve for x/2
	       if (ibm_ht_xstag(ii(nC),ji(nC)) >= top_neigh(i,j,3*nC+2)) then
		  top_neigh(i,j,3*nC) = ((ii(nC)-1)*dx)-(dx/2) +  (dx/2)+(dx/4)*((top_neigh(i,j,3*nC+2)-ibm_ht(ii(nC)-1,ji(nC))) &
						                          /(ibm_ht_xstag(ii(nC),ji(nC))-ibm_ht(ii(nC)-1,ji(nC))))
	       else
		  top_neigh(i,j,3*nC) = (ii(nC)*dx)-dx +  (dx/4)+(dx/4)*((top_neigh(i,j,3*nC+2)-ibm_ht_xstag(ii(nC),ji(nC))) &
						                        /(ibm_ht(ii(nC),ji(nC))-ibm_ht_xstag(ii(nC),ji(nC))))
	       endif
	       ! solve for y/2
	       if (ibm_ht_ystag(ii(nC),ji(nC)+1) >= top_neigh(i,j,3*nC+2)) then
		  top_neigh(i,j,3*nC+1) = (ji(nC)*dy)-(dy/2) + (dy/4)+(dy/4)*((top_neigh(i,j,3*nC+2)-ibm_ht_ystag(ii(nC),ji(nC)+1)) &
						                           /(ibm_ht(ii(nC),ji(nC)+1)-ibm_ht_ystag(ii(nC),ji(nC)+1)))
	       else
		  top_neigh(i,j,3*nC+1) = (ji(nC)*dy)-(dy/2) + (dy/4)*((top_neigh(i,j,3*nC+2)-ibm_ht(ii(nC),ji(nC))) &
							      /(ibm_ht_ystag(ii(nC),ji(nC)+1)-ibm_ht(ii(nC),ji(nC))))
	       endif
	   endif	   
	   ! neighbor 2 is on the boundary between 2 and 6
	   ! neighbor 3 is on the boundary between 3 and 7
	   do nC = 2,3
	      top_neigh_i(i,j,3*nC) = ii(nC)
	      top_neigh_i(i,j,3*nC+1) = 0
	      top_neigh_i(i,j,3*nC+2) = 0
	      ! first z
	      top_neigh(i,j,3*nC+2) = ht_p(ii(nC),ki(nC),ji(nC))
	      if (stag == 1) then
		  !next x
		  top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx)
		  ! solve for y
		  if (ibm_ht_ystag(ii(nC),ji(nC)+1) >= top_neigh(i,j,3*nC+2)) then
		     top_neigh(i,j,3*nC+1) = (ji(nC)*dy) + (dy/2)*((top_neigh(i,j,3*nC+2)-ibm_ht_ystag(ii(nC),ji(nC)+1)) &
						        	/(ibm_ht(ii(nC),ji(nC)+1)-ibm_ht_ystag(ii(nC),ji(nC)+1)))
		  else
		     top_neigh(i,j,3*nC+1) = (ji(nC)*dy)-(dy/2) + (dy/2)*((top_neigh(i,j,3*nC+2)-ibm_ht(ii(nC),ji(nC))) &
						                 /(ibm_ht_ystag(ii(nC),ji(nC)+1)-ibm_ht(ii(nC),ji(nC))))
		  endif						  
	      elseif (stag == 2) then
		  !next x
		  top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
		  ! solve for y
		  if (ibm_ht_ystag(ii(nC),ji(nC)) >= top_neigh(i,j,3*nC+2)) then
		     top_neigh(i,j,3*nC+1) = (ji(nC)*dy-(dy/2)) + (dy/2)*((top_neigh(i,j,3*nC+2)-ibm_ht_ystag(ii(nC),ji(nC))) &
						                       /(ibm_ht(ii(nC),ji(nC)+1)-ibm_ht_ystag(ii(nC),ji(nC))))
		  else
		     top_neigh(i,j,3*nC+1) = (ji(nC)*dy)-dy + (dy/2)*((top_neigh(i,j,3*nC+2)-ibm_ht(ii(nC),ji(nC))) &
						               /(ibm_ht_ystag(ii(nC),ji(nC))-ibm_ht(ii(nC),ji(nC))))
		  endif
	      elseif (stag == 3) then
		  !next x
		  top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
		  ! solve for y
		  if (ibm_ht_ystag(ii(nC),ji(nC)+1) >= top_neigh(i,j,3*nC+2)) then
		     top_neigh(i,j,3*nC+1) = (ji(nC)*dy) + (dy/2)*((top_neigh(i,j,3*nC+2)-ibm_ht_ystag(ii(nC),ji(nC)+1)) &
						        	/(ibm_ht(ii(nC),ji(nC)+1)-ibm_ht_ystag(ii(nC),ji(nC)+1)))
		  else
		     top_neigh(i,j,3*nC+1) = (ji(nC)*dy)-(dy/2) + (dy/2)*((top_neigh(i,j,3*nC+2)-ibm_ht(ii(nC),ji(nC))) &
							         /(ibm_ht_ystag(ii(nC),ji(nC)+1)-ibm_ht(ii(nC),ji(nC))))
		  endif	
	      endif
	    enddo
	   ! neighbors 0,4,5,6,7 are computational nodes
	   do nC = 4,7
	      top_neigh_i(i,j,3*nC) = ii(nC)
	      top_neigh_i(i,j,3*nC+1) = ji(nC)
	      top_neigh_i(i,j,3*nC+2) = ki(nC)		
	      if (stag ==1 ) then 			
		  top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx)
		  top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)
	      elseif (stag == 2) then
		  top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
		  top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy)	     
	      elseif (stag == 3) then
		  top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
		  top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)	     
	      endif
	      top_neigh(i,j,3*nC+2) = ht_p(top_neigh_i(i,j,3*nC),top_neigh_i(i,j,3*nC+2),top_neigh_i(i,j,3*nC+1))  
	   enddo
    ELSEIF ((inside(ii(0),ki(0),ji(0)) == 0).AND. &
	   (inside(ii(1),ki(1),ji(1)) == 0).AND. &
	   (inside(ii(2),ki(2),ji(2)) == 1).AND. &
	   (inside(ii(3),ki(3),ji(3)) == 1).AND. &
	   (inside(ii(4),ki(4),ji(4)) == 0).AND. &
	   (inside(ii(5),ki(5),ji(5)) == 0).AND. &
	   (inside(ii(6),ki(6),ji(6)) == 1).AND. &
	   (inside(ii(7),ki(7),ji(7)) == 1)) THEN
	  ! neighbors 0,1,4,5 on top are computational nodes (the zero nodes)
	  ! neighbors 2,3,6,7 are at (ii,jj,ibm_ht(ii,jj)) on the boundary 
	  do nC = 0,7
	     top_neigh_i(i,j,3*nC) = ii(nC)
	     top_neigh_i(i,j,3*nC+1) = ji(nC)		
	     if (stag ==1 ) then 			
		 top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx)
		 top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)
	     elseif (stag == 2) then
		 top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
		 top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy)	     
	     elseif (stag == 3) then
		 top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
		 top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)	     
	     endif
	  enddo
	  do nC = 0,1
	     top_neigh_i(i,j,3*nC+2) = ki(nC)	     
	     top_neigh(i,j,3*nC+2) = ht_p(top_neigh_i(i,j,3*nC),top_neigh_i(i,j,3*nC+2),top_neigh_i(i,j,3*nC+1))
	  enddo
	  do nC = 2,3
	     top_neigh_i(i,j,3*nC+2) = 0 	     
	     top_neigh(i,j,3*nC+2) = ibm_ht(top_neigh_i(i,j,3*nC),top_neigh_i(i,j,3*nC+1))
	  enddo   
	  do nC = 4,5
	     top_neigh_i(i,j,3*nC+2) = ki(nC)	     
	     top_neigh(i,j,3*nC+2) = ht_p(top_neigh_i(i,j,3*nC),top_neigh_i(i,j,3*nC+2),top_neigh_i(i,j,3*nC+1))
	  enddo
	  do nC = 6,7
	     top_neigh_i(i,j,3*nC+2) = 0 	     
	     top_neigh(i,j,3*nC+2) = ibm_ht(top_neigh_i(i,j,3*nC),top_neigh_i(i,j,3*nC+1))
	  enddo 
   ELSEIF ((inside(ii(0),ki(0),ji(0)) == 1).AND. &
	   (inside(ii(1),ki(1),ji(1)) == 0).AND. &
	   (inside(ii(2),ki(2),ji(2)) == 1).AND. &
	   (inside(ii(3),ki(3),ji(3)) == 0).AND. &
	   (inside(ii(4),ki(4),ji(4)) == 1).AND. &
	   (inside(ii(5),ki(5),ji(5)) == 0).AND. &
	   (inside(ii(6),ki(6),ji(6)) == 1).AND. &
	   (inside(ii(7),ki(7),ji(7)) == 0)) THEN
	   ! neighbor 0 on the boundary between 0 and 1
	   nC = 0 
	   top_neigh_i(i,j,3*nC) = 0
	   top_neigh_i(i,j,3*nC+1) = ji(nC)
	   top_neigh_i(i,j,3*nC+2) = 0
	   ! first z
	   top_neigh(i,j,3*nC+2) = ht_p(ii(nC),ki(nC),ji(nC))
	   if (stag == 1) then
	       !next y
	       top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)
	       ! solve for x
	       if (ibm_ht_xstag(ii(nC),ji(nC)) >= top_neigh(i,j,3*nC+2)) then
		  top_neigh(i,j,3*nC) = (ii(nC)*dx)-(dx/2) + (dx/2)*((top_neigh(i,j,3*nC+2)-ibm_ht_xstag(ii(nC),ji(nC))) &
						                  /(ibm_ht(ii(nC)+1,ji(nC))-ibm_ht_xstag(ii(nC),ji(nC))))
	       else
		  top_neigh(i,j,3*nC) = (ii(nC)*dx)-dx + (dx/2)*((top_neigh(i,j,3*nC+2)-ibm_ht(ii(nC),ji(nC))) &
							  /(ibm_ht_xstag(ii(nC),ji(nC))-ibm_ht(ii(nC),ji(nC))))
	       endif						  
	   elseif (stag == 2) then
	       !next y
	       top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy)
	       ! solve for x
	       if (ibm_ht_xstag(ii(nC)+1,ji(nC)) >= top_neigh(i,j,3*nC+2)) then
		  top_neigh(i,j,3*nC) = (ii(nC)*dx) + (dx/2)*((top_neigh(i,j,3*nC+2)-ibm_ht_xstag(ii(nC)+1,ji(nC))) &
						           /(ibm_ht(ii(nC)+1,ji(nC))-ibm_ht_xstag(ii(nC)+1,ji(nC))))
	       else
		  top_neigh(i,j,3*nC) = (ii(nC)*dx)-(dx/2) + (dx/2)*((top_neigh(i,j,3*nC+2)-ibm_ht(ii(nC),ji(nC))) &
						            /(ibm_ht_xstag(ii(nC)+1,ji(nC))-ibm_ht(ii(nC),ji(nC))))
	       endif
	   elseif (stag == 3) then
	       !next y
	       top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)
	       ! solve for x
	       if (ibm_ht_xstag(ii(nC)+1,ji(nC)) >= top_neigh(i,j,3*nC+2)) then
		  top_neigh(i,j,3*nC) = (ii(nC)*dx) + (dx/2)*((top_neigh(i,j,3*nC+2)-ibm_ht_xstag(ii(nC)+1,ji(nC))) &
						           /(ibm_ht(ii(nC)+1,ji(nC))-ibm_ht_xstag(ii(nC)+1,ji(nC))))
	       else
		  top_neigh(i,j,3*nC) = (ii(nC)*dx)-(dx/2) + (dx/2)*((top_neigh(i,j,3*nC+2)-ibm_ht(ii(nC),ji(nC))) &
						            /(ibm_ht_xstag(ii(nC)+1,ji(nC))-ibm_ht(ii(nC),ji(nC))))
	       endif
	   endif
	   ! neighbors 1,3,5,7 are zero computational node
	   nC = 1
	   top_neigh_i(i,j,3*nC) = ii(nC)
	   top_neigh_i(i,j,3*nC+1) = ji(nC)
	   top_neigh_i(i,j,3*nC+2) = ki(nC)		
	   if (stag ==1 ) then 			
	       top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx)
	       top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)
	   elseif (stag == 2) then
	       top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
	       top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy)	     
	   elseif (stag == 3) then
	       top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
	       top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)	     
	   endif
           top_neigh(i,j,3*nC+2) = ht_p(top_neigh_i(i,j,3*nC),top_neigh_i(i,j,3*nC+2),top_neigh_i(i,j,3*nC+1))	   
	   ! neighbor 2 on the boundary between 2 and 3
	   nC = 2
	   top_neigh_i(i,j,3*nC) = 0
	   top_neigh_i(i,j,3*nC+1) = ji(nC)
	   top_neigh_i(i,j,3*nC+2) = 0
	   ! first z
	   top_neigh(i,j,3*nC+2) = ht_p(ii(nC),ki(nC),ji(nC))
	   if (stag == 1) then
	       !next y
	       top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)
	       ! solve for x
	       if (ibm_ht_xstag(ii(nC),ji(nC)) >= top_neigh(i,j,3*nC+2)) then
		  top_neigh(i,j,3*nC) = (ii(nC)*dx)-(dx/2) + (dx/2)*((top_neigh(i,j,3*nC+2)-ibm_ht_xstag(ii(nC),ji(nC))) &
						                  /(ibm_ht(ii(nC)+1,ji(nC))-ibm_ht_xstag(ii(nC),ji(nC))))
	       else
		  top_neigh(i,j,3*nC) = (ii(nC)*dx)-dx + (dx/2)*((top_neigh(i,j,3*nC+2)-ibm_ht(ii(nC),ji(nC))) &
							  /(ibm_ht_xstag(ii(nC),ji(nC))-ibm_ht(ii(nC),ji(nC))))
	       endif						  
	   elseif (stag == 2) then
	       !next y
	       top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy)
	       ! solve for x
	       if (ibm_ht_xstag(ii(nC)+1,ji(nC)) >= top_neigh(i,j,3*nC+2)) then
		  top_neigh(i,j,3*nC) = (ii(nC)*dx) + (dx/2)*((top_neigh(i,j,3*nC+2)-ibm_ht_xstag(ii(nC)+1,ji(nC))) &
						           /(ibm_ht(ii(nC)+1,ji(nC))-ibm_ht_xstag(ii(nC)+1,ji(nC))))
	       else
		  top_neigh(i,j,3*nC) = (ii(nC)*dx)-(dx/2) + (dx/2)*((top_neigh(i,j,3*nC+2)-ibm_ht(ii(nC),ji(nC))) &
						            /(ibm_ht_xstag(ii(nC)+1,ji(nC))-ibm_ht(ii(nC),ji(nC))))
	       endif
	   elseif (stag == 3) then
	       !next y
	       top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)
	       ! solve for x
	       if (ibm_ht_xstag(ii(nC)+1,ji(nC)) >= top_neigh(i,j,3*nC+2)) then
		  top_neigh(i,j,3*nC) = (ii(nC)*dx) + (dx/2)*((top_neigh(i,j,3*nC+2)-ibm_ht_xstag(ii(nC)+1,ji(nC))) &
						           /(ibm_ht(ii(nC)+1,ji(nC))-ibm_ht_xstag(ii(nC)+1,ji(nC))))
	       else
		  top_neigh(i,j,3*nC) = (ii(nC)*dx)-(dx/2) + (dx/2)*((top_neigh(i,j,3*nC+2)-ibm_ht(ii(nC),ji(nC))) &
						            /(ibm_ht_xstag(ii(nC)+1,ji(nC))-ibm_ht(ii(nC),ji(nC))))
	       endif
	   endif
	   ! neighbors 1,3,5,7 are zero computational node
	   nC = 3
	   top_neigh_i(i,j,3*nC) = ii(nC)
	   top_neigh_i(i,j,3*nC+1) = ji(nC)
	   top_neigh_i(i,j,3*nC+2) = ki(nC)		
	   if (stag ==1 ) then 			
	       top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx)
	       top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)
	   elseif (stag == 2) then
	       top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
	       top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy)	     
	   elseif (stag == 3) then
	       top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
	       top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)	     
	   endif
	   top_neigh(i,j,3*nC+2) = ht_p(top_neigh_i(i,j,3*nC),top_neigh_i(i,j,3*nC+2),top_neigh_i(i,j,3*nC+1))
	   ! neighbor 4 on the boundary between 4 and 5
	   nC = 4
	   top_neigh_i(i,j,3*nC) = 0
	   top_neigh_i(i,j,3*nC+1) = ji(nC)
	   top_neigh_i(i,j,3*nC+2) = 0
	   ! first z
	   top_neigh(i,j,3*nC+2) = ht_p(ii(nC),ki(nC),ji(nC))
	   if (stag == 1) then
	       !next y
	       top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)
	       ! solve for x
	       if (ibm_ht_xstag(ii(nC),ji(nC)) >= top_neigh(i,j,3*nC+2)) then
		  top_neigh(i,j,3*nC) = (ii(nC)*dx)-(dx/2) + (dx/2)*((top_neigh(i,j,3*nC+2)-ibm_ht_xstag(ii(nC),ji(nC))) &
						                  /(ibm_ht(ii(nC)+1,ji(nC))-ibm_ht_xstag(ii(nC),ji(nC))))
	       else
		  top_neigh(i,j,3*nC) = (ii(nC)*dx)-dx + (dx/2)*((top_neigh(i,j,3*nC+2)-ibm_ht(ii(nC),ji(nC))) &
							  /(ibm_ht_xstag(ii(nC),ji(nC))-ibm_ht(ii(nC),ji(nC))))
	       endif						  
	   elseif (stag == 2) then
	       !next y
	       top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy)
	       ! solve for x
	       if (ibm_ht_xstag(ii(nC)+1,ji(nC)) >= top_neigh(i,j,3*nC+2)) then
		  top_neigh(i,j,3*nC) = (ii(nC)*dx) + (dx/2)*((top_neigh(i,j,3*nC+2)-ibm_ht_xstag(ii(nC)+1,ji(nC))) &
						           /(ibm_ht(ii(nC)+1,ji(nC))-ibm_ht_xstag(ii(nC)+1,ji(nC))))
	       else
		  top_neigh(i,j,3*nC) = (ii(nC)*dx)-(dx/2) + (dx/2)*((top_neigh(i,j,3*nC+2)-ibm_ht(ii(nC),ji(nC))) &
						            /(ibm_ht_xstag(ii(nC)+1,ji(nC))-ibm_ht(ii(nC),ji(nC))))
	       endif
	   elseif (stag == 3) then
	       !next y
	       top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)
	       ! solve for x
	       if (ibm_ht_xstag(ii(nC)+1,ji(nC)) >= top_neigh(i,j,3*nC+2)) then
		  top_neigh(i,j,3*nC) = (ii(nC)*dx) + (dx/2)*((top_neigh(i,j,3*nC+2)-ibm_ht_xstag(ii(nC)+1,ji(nC))) &
						           /(ibm_ht(ii(nC)+1,ji(nC))-ibm_ht_xstag(ii(nC)+1,ji(nC))))
	       else
		  top_neigh(i,j,3*nC) = (ii(nC)*dx)-(dx/2) + (dx/2)*((top_neigh(i,j,3*nC+2)-ibm_ht(ii(nC),ji(nC))) &
						            /(ibm_ht_xstag(ii(nC)+1,ji(nC))-ibm_ht(ii(nC),ji(nC))))
	       endif
	   endif
	   ! neighbors 1,3,5,7 are zero computational node
	   nC = 5
	   top_neigh_i(i,j,3*nC) = ii(nC)
	   top_neigh_i(i,j,3*nC+1) = ji(nC)
	   top_neigh_i(i,j,3*nC+2) = ki(nC)		
	   if (stag ==1 ) then 			
	       top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx)
	       top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)
	   elseif (stag == 2) then
	       top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
	       top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy)	     
	   elseif (stag == 3) then
	       top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
	       top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)	     
	   endif
	   top_neigh(i,j,3*nC+2) = ht_p(top_neigh_i(i,j,3*nC),top_neigh_i(i,j,3*nC+2),top_neigh_i(i,j,3*nC+1))
	   ! neighbor 6 on the boundary between 6 and 7
	   nC = 6
	   top_neigh_i(i,j,3*nC) = 0
	   top_neigh_i(i,j,3*nC+1) = ji(nC)
	   top_neigh_i(i,j,3*nC+2) = 0
	   ! first z
	   top_neigh(i,j,3*nC+2) = ht_p(ii(nC),ki(nC),ji(nC))
	   if (stag == 1) then
	       !next y
	       top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)
	       ! solve for x
	       if (ibm_ht_xstag(ii(nC),ji(nC)) >= top_neigh(i,j,3*nC+2)) then
		  top_neigh(i,j,3*nC) = (ii(nC)*dx)-(dx/2) + (dx/2)*((top_neigh(i,j,3*nC+2)-ibm_ht_xstag(ii(nC),ji(nC))) &
						                  /(ibm_ht(ii(nC)+1,ji(nC))-ibm_ht_xstag(ii(nC),ji(nC))))
	       else
		  top_neigh(i,j,3*nC) = (ii(nC)*dx)-dx + (dx/2)*((top_neigh(i,j,3*nC+2)-ibm_ht(ii(nC),ji(nC))) &
							  /(ibm_ht_xstag(ii(nC),ji(nC))-ibm_ht(ii(nC),ji(nC))))
	       endif						  
	   elseif (stag == 2) then
	       !next y
	       top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy)
	       ! solve for x
	       if (ibm_ht_xstag(ii(nC)+1,ji(nC)) >= top_neigh(i,j,3*nC+2)) then
		  top_neigh(i,j,3*nC) = (ii(nC)*dx) + (dx/2)*((top_neigh(i,j,3*nC+2)-ibm_ht_xstag(ii(nC)+1,ji(nC))) &
						           /(ibm_ht(ii(nC)+1,ji(nC))-ibm_ht_xstag(ii(nC)+1,ji(nC))))
	       else
		  top_neigh(i,j,3*nC) = (ii(nC)*dx)-(dx/2) + (dx/2)*((top_neigh(i,j,3*nC+2)-ibm_ht(ii(nC),ji(nC))) &
						            /(ibm_ht_xstag(ii(nC)+1,ji(nC))-ibm_ht(ii(nC),ji(nC))))
	       endif
	   elseif (stag == 3) then
	       !next y
	       top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)
	       ! solve for x
	       if (ibm_ht_xstag(ii(nC)+1,ji(nC)) >= top_neigh(i,j,3*nC+2)) then
		  top_neigh(i,j,3*nC) = (ii(nC)*dx) + (dx/2)*((top_neigh(i,j,3*nC+2)-ibm_ht_xstag(ii(nC)+1,ji(nC))) &
						           /(ibm_ht(ii(nC)+1,ji(nC))-ibm_ht_xstag(ii(nC)+1,ji(nC))))
	       else
		  top_neigh(i,j,3*nC) = (ii(nC)*dx)-(dx/2) + (dx/2)*((top_neigh(i,j,3*nC+2)-ibm_ht(ii(nC),ji(nC))) &
						            /(ibm_ht_xstag(ii(nC)+1,ji(nC))-ibm_ht(ii(nC),ji(nC))))
	       endif
	   endif
	   ! neighbors 1,3,5,7 are zero computational node
	   nC = 7
	   top_neigh_i(i,j,3*nC) = ii(nC)
	   top_neigh_i(i,j,3*nC+1) = ji(nC)
	   top_neigh_i(i,j,3*nC+2) = ki(nC)		
	   if (stag ==1 ) then 			
	       top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx)
	       top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)
	   elseif (stag == 2) then
	       top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
	       top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy)	     
	   elseif (stag == 3) then
	       top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
	       top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)	     
	   endif
	   top_neigh(i,j,3*nC+2) = ht_p(top_neigh_i(i,j,3*nC),top_neigh_i(i,j,3*nC+2),top_neigh_i(i,j,3*nC+1))	   
   ELSEIF ((inside(ii(0),ki(0),ji(0)) == 1).AND. &
	   (inside(ii(1),ki(1),ji(1)) == 1).AND. &
	   (inside(ii(2),ki(2),ji(2)) == 1).AND. &
	   (inside(ii(3),ki(3),ji(3)) == 1).AND. &
	   (inside(ii(4),ki(4),ji(4)) == 0).AND. &
	   (inside(ii(5),ki(5),ji(5)) == 0).AND. &
	   (inside(ii(6),ki(6),ji(6)) == 0).AND. &
	   (inside(ii(7),ki(7),ji(7)) == 0)) THEN
	  ! neighbor 0 is on the boundary between 0 and 4
	  ! neighbor 1 is on the boundary between 1 and 5 
	  ! neighbor 2 is on the boundary between 2 and 6
	  ! neighbor 3 is on the boundary between 3 and 7
	  do nC = 0,3
	     top_neigh_i(i,j,3*nC) = ii(nC)
	     top_neigh_i(i,j,3*nC+1) = 0
	     top_neigh_i(i,j,3*nC+2) = 0
	     ! first z
	     top_neigh(i,j,3*nC+2) = ht_p(ii(nC),ki(nC),ji(nC))
	     if (stag == 1) then
		 !next x
		 top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx)
		 ! solve for y
		 if (ibm_ht_ystag(ii(nC),ji(nC)+1) >= top_neigh(i,j,3*nC+2)) then
		    top_neigh(i,j,3*nC+1) = (ji(nC)*dy) + (dy/2)*((top_neigh(i,j,3*nC+2)-ibm_ht_ystag(ii(nC),ji(nC)+1)) &
						               /(ibm_ht(ii(nC),ji(nC)+1)-ibm_ht_ystag(ii(nC),ji(nC)+1)))
		 else
		    top_neigh(i,j,3*nC+1) = (ji(nC)*dy)-(dy/2) + (dy/2)*((top_neigh(i,j,3*nC+2)-ibm_ht(ii(nC),ji(nC))) &
						                /(ibm_ht_ystag(ii(nC),ji(nC)+1)-ibm_ht(ii(nC),ji(nC))))
		 endif						  
	     elseif (stag == 2) then
		 !next x
		 top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
		 ! solve for y
		 if (ibm_ht_ystag(ii(nC),ji(nC)) >= top_neigh(i,j,3*nC+2)) then
		    top_neigh(i,j,3*nC+1) = (ji(nC)*dy-(dy/2)) + (dy/2)*((top_neigh(i,j,3*nC+2)-ibm_ht_ystag(ii(nC),ji(nC))) &
						                      /(ibm_ht(ii(nC),ji(nC)+1)-ibm_ht_ystag(ii(nC),ji(nC))))
		 else
		    top_neigh(i,j,3*nC+1) = (ji(nC)*dy)-dy + (dy/2)*((top_neigh(i,j,3*nC+2)-ibm_ht(ii(nC),ji(nC))) &
						              /(ibm_ht_ystag(ii(nC),ji(nC))-ibm_ht(ii(nC),ji(nC))))
		 endif
	     elseif (stag == 3) then
		 !next x
		 top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
		 ! solve for y
		 if (ibm_ht_ystag(ii(nC),ji(nC)+1) >= top_neigh(i,j,3*nC+2)) then
		    top_neigh(i,j,3*nC+1) = (ji(nC)*dy) + (dy/2)*((top_neigh(i,j,3*nC+2)-ibm_ht_ystag(ii(nC),ji(nC)+1)) &
						               /(ibm_ht(ii(nC),ji(nC)+1)-ibm_ht_ystag(ii(nC),ji(nC)+1)))
		 else
		    top_neigh(i,j,3*nC+1) = (ji(nC)*dy)-(dy/2) + (dy/2)*((top_neigh(i,j,3*nC+2)-ibm_ht(ii(nC),ji(nC))) &
							        /(ibm_ht_ystag(ii(nC),ji(nC)+1)-ibm_ht(ii(nC),ji(nC))))
		 endif	
	     endif
	   enddo 
	   ! neighbors 4,5,6,7 are the zero computational nodes
	   do nC = 4,7
	      top_neigh_i(i,j,3*nC) = ii(nC)
	      top_neigh_i(i,j,3*nC+1) = ji(nC)
	      top_neigh_i(i,j,3*nC+2) = ki(nC)		
	      if (stag ==1 ) then 			
		  top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx)
		  top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)
	      elseif (stag == 2) then
		  top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
		  top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy)	     
	      elseif (stag == 3) then
		  top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
		  top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)	     
	      endif
	      top_neigh(i,j,3*nC+2) = ht_p(top_neigh_i(i,j,3*nC),top_neigh_i(i,j,3*nC+2),top_neigh_i(i,j,3*nC+1)) 
	   enddo
   ELSEIF ((inside(ii(0),ki(0),ji(0)) == 1).AND. &
	   (inside(ii(1),ki(1),ji(1)) == 0).AND. &
	   (inside(ii(2),ki(2),ji(2)) == 1).AND. &
	   (inside(ii(3),ki(3),ji(3)) == 1).AND. &
	   (inside(ii(4),ki(4),ji(4)) == 0).AND. &
	   (inside(ii(5),ki(5),ji(5)) == 0).AND. &
	   (inside(ii(6),ki(6),ji(6)) == 1).AND. &
	   (inside(ii(7),ki(7),ji(7)) == 1)) THEN	   	   
	   ! neighbor 1 is a zero computational node
	   nC = 1
	   top_neigh_i(i,j,3*nC) = ii(nC)
	   top_neigh_i(i,j,3*nC+1) = ji(nC)
	   top_neigh_i(i,j,3*nC+2) = ki(nC)		
	   if (stag ==1 ) then 			
	       top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx)
	       top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)
	   elseif (stag == 2) then
	       top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
	       top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy)	     
	   elseif (stag == 3) then
	       top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
	       top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)	     
	   endif
	   top_neigh(i,j,3*nC+2) = ht_p(top_neigh_i(i,j,3*nC),top_neigh_i(i,j,3*nC+2),top_neigh_i(i,j,3*nC+1))
	   ! neighbor 3 is at (ii,jj,ibm_ht(ii,jj)) on the boundary
	   nC = 3
	   top_neigh_i(i,j,3*nC) = ii(nC)
	   top_neigh_i(i,j,3*nC+1) = ji(nC)
	   top_neigh_i(i,j,3*nC+2) = 0		
	   if (stag ==1 ) then 			
	       top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx)
	       top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)
	   elseif (stag == 2) then
	       top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
	       top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy)	     
	   elseif (stag == 3) then
	       top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
	       top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)	     
	   endif
	   top_neigh(i,j,3*nC+2) = ibm_ht(top_neigh_i(i,j,3*nC),top_neigh_i(i,j,3*nC+1)) 
	   ! neighbors 4,5 are zero computational nodes
	   do nC = 4,5
	      top_neigh_i(i,j,3*nC) = ii(nC)
	      top_neigh_i(i,j,3*nC+1) = ji(nC)
	      top_neigh_i(i,j,3*nC+2) = ki(nC)		
	      if (stag ==1 ) then 			
		  top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx)
		  top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)
	      elseif (stag == 2) then
		  top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
		  top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy)	     
	      elseif (stag == 3) then
		  top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
		  top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)	     
	      endif
	      top_neigh(i,j,3*nC+2) = ht_p(top_neigh_i(i,j,3*nC),top_neigh_i(i,j,3*nC+2),top_neigh_i(i,j,3*nC+1)) 
	   enddo
	   ! neighbors 6,7 are at (ii,jj,ibm_ht(ii,jj)) on the boundary
	   do nC = 6,7
	      top_neigh_i(i,j,3*nC) = ii(nC)
	      top_neigh_i(i,j,3*nC+1) = ji(nC)
	      top_neigh_i(i,j,3*nC+2) = 0		
	      if (stag ==1 ) then 			
		  top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx)
		  top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)
	      elseif (stag == 2) then
		  top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
		  top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy)	     
	      elseif (stag == 3) then
		  top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
		  top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)	     
	      endif
	      top_neigh(i,j,3*nC+2) = ibm_ht(top_neigh_i(i,j,3*nC),top_neigh_i(i,j,3*nC+1)) 	   
	   enddo
	  ! neighbors 0,2 still need to be assigned
	  ! if 0 is a top ghost point, then the 0 neighbor is (ii(1),ji(1),ht(ki(1)+1) the node above it
	  ! and the 2 neighbor is ibm_ht(ii,jj) on the boundary
	  if (ki(0) == top(ii(0),ji(0))) then	  
	      nC = 0
	      top_neigh_i(i,j,3*nC) = ii(nC)
	      top_neigh_i(i,j,3*nC+1) = ji(nC)
	      top_neigh_i(i,j,3*nC+2) = ki(nC)+1		
	      if (stag ==1 ) then 			
		  top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx)
		  top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)
	      elseif (stag == 2) then
		  top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
		  top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy)	     
	      elseif (stag == 3) then
		  top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
		  top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)	     
	      endif
	      top_neigh(i,j,3*nC+2) = ht_p(top_neigh_i(i,j,3*nC),top_neigh_i(i,j,3*nC+2),top_neigh_i(i,j,3*nC+1))	   
	      nC = 2
	      top_neigh_i(i,j,3*nC) = ii(nC)
	      top_neigh_i(i,j,3*nC+1) = ji(nC)
	      top_neigh_i(i,j,3*nC+2) = 0		
	      if (stag ==1 ) then 			
		  top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx)
		  top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)
	      elseif (stag == 2) then
		  top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
		  top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy)	     
	      elseif (stag == 3) then
		  top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
		  top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)	     
	      endif
	      top_neigh(i,j,3*nC+2) = ibm_ht(top_neigh_i(i,j,3*nC),top_neigh_i(i,j,3*nC+1))	
	  else
	     ! the algorithm is more complicated
!	     ! neighbor 0 on the boundary
!	     ! either to the east between 0 and 1
!	     ! or to the north between 0 and 4
!	     nC = 0 
!	     if (staq == 1) then
!		 if (ibm_ht_xstag(ii(nC),ji(nC)) < ibm_ht_ystag(ii(nC),ji(nC)+1)) then ! look east
!		    top_neigh_i(i,j,3*nC) = 0
!		    top_neigh_i(i,j,3*nC+1) = ji(nC)
!		    top_neigh_i(i,j,3*nC+2) = 0
!		    ! first z
!		    top_neigh(i,j,3*nC+2) = ht_p(ii(nC),ki(nC),ji(nC))
!		    !next y
!		    top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)
!		    ! solve for x
!		    if (ibm_ht_xstag(ii(nC),ji(nC)) >= top_neigh(i,j,3*nC+2)) then
!		       top_neigh(i,j,3*nC) = (ii(nC)*dx)-(dx/2) + (dx/2)*((top_neigh(i,j,3*nC+2)-ibm_ht_xstag(ii(nC),ji(nC))) &
!								       /(ibm_ht(ii(nC)+1,ji(nC))-ibm_ht_xstag(ii(nC),ji(nC))))
!		    else
!		       top_neigh(i,j,3*nC) = (ii(nC)*dx)-dx + (dx/2)*((top_neigh(i,j,3*nC+2)-ibm_ht(ii(nC),ji(nC))) &
!							       /(ibm_ht_xstag(ii(nC),ji(nC))-ibm_ht(ii(nC),ji(nC))))
!		    endif					       
!		 else ! look north
!		    top_neigh_i(i,j,3*nC) = ii(nC)
!		    top_neigh_i(i,j,3*nC+1) = 0
!		    top_neigh_i(i,j,3*nC+2) = 0
!		    ! first z
!		    top_neigh(i,j,3*nC+2) = ht_p(ii(nC),ki(nC),ji(nC))
!		    !next x
!		    top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx)
!		    ! solve for y
!		    if (ibm_ht_ystag(ii(nC),ji(nC)+1) >= top_neigh(i,j,3*nC+2)) then
!		       top_neigh(i,j,3*nC+1) = (ji(nC)*dy) + (dy/2)*((top_neigh(i,j,3*nC+2)-ibm_ht_ystag(ii(nC),ji(nC)+1)) &
!								  /(ibm_ht(ii(nC),ji(nC)+1)-ibm_ht_ystag(ii(nC),ji(nC)+1)))
!		    else
!		       top_neigh(i,j,3*nC+1) = (ji(nC)*dy)-(dy/2) + (dy/2)*((top_neigh(i,j,3*nC+2)-ibm_ht(ii(nC),ji(nC))) &
!								   /(ibm_ht_ystag(ii(nC),ji(nC)+1)-ibm_ht(ii(nC),ji(nC))))
!		    endif
!		 endif
!	     elseif (stag == 2) then
!		 if (ibm_ht_xstag(ii(nC)+1,ji(nC)) < ibm_ht_ystag(ii(nC),ji(nC))) then ! look east
!		    top_neigh_i(i,j,3*nC) = 0
!		    top_neigh_i(i,j,3*nC+1) = ji(nC)
!		    top_neigh_i(i,j,3*nC+2) = 0
!		    ! first z
!		    top_neigh(i,j,3*nC+2) = ht_p(ii(nC),ki(nC),ji(nC))
!		    !next y
!		    top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy)
!		    ! solve for x
!		    if (ibm_ht_xstag(ii(nC)+1,ji(nC)) >= top_neigh(i,j,3*nC+2)) then
!		       top_neigh(i,j,3*nC) = (ii(nC)*dx) + (dx/2)*((top_neigh(i,j,3*nC+2)-ibm_ht_xstag(ii(nC)+1,ji(nC))) &
!								/(ibm_ht(ii(nC)+1,ji(nC))-ibm_ht_xstag(ii(nC)+1,ji(nC))))
!		    else
!		       top_neigh(i,j,3*nC) = (ii(nC)*dx)-(dx/2) + (dx/2)*((top_neigh(i,j,3*nC+2)-ibm_ht(ii(nC),ji(nC))) &
!								 /(ibm_ht_xstag(ii(nC)+1,ji(nC))-ibm_ht(ii(nC),ji(nC))))
!		    endif
!		 else ! look north
!		    top_neigh_i(i,j,3*nC) = ii(nC)
!		    top_neigh_i(i,j,3*nC+1) = 0
!		    top_neigh_i(i,j,3*nC+2) = 0
!		    ! first z
!		    top_neigh(i,j,3*nC+2) = ht_p(ii(nC),ki(nC),ji(nC))
!		    !next x
!		    top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
!		    ! solve for y
!		    if (ibm_ht_ystag(ii(nC),ji(nC)) >= top_neigh(i,j,3*nC+2)) then
!		       top_neigh(i,j,3*nC+1) = (ji(nC)*dy-(dy/2)) + (dy/2)*((top_neigh(i,j,3*nC+2)-ibm_ht_ystag(ii(nC),ji(nC))) &
!									 /(ibm_ht(ii(nC),ji(nC)+1)-ibm_ht_ystag(ii(nC),ji(nC))))
!		    else
!		       top_neigh(i,j,3*nC+1) = (ji(nC)*dy)-dy + (dy/2)*((top_neigh(i,j,3*nC+2)-ibm_ht(ii(nC),ji(nC))) &
!								 /(ibm_ht_ystag(ii(nC),ji(nC))-ibm_ht(ii(nC),ji(nC))))
!		    endif
!		 endif
!	     elseif (stag == 3) then
!		 if (ibm_ht_xstag(ii(nC)+1,ji(nC)) < ibm_ht_ystag(ii(nC),ji(nC)+1)) then ! look east
!		    top_neigh_i(i,j,3*nC) = 0
!		    top_neigh_i(i,j,3*nC+1) = ji(nC)
!		    top_neigh_i(i,j,3*nC+2) = 0
!		    ! first z
!		    top_neigh(i,j,3*nC+2) = ht_p(ii(nC),ki(nC),ji(nC))
!		    !next y
!		    top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)
!		    ! solve for x
!		    if (ibm_ht_xstag(ii(nC)+1,ji(nC)) >= top_neigh(i,j,3*nC+2)) then
!		       top_neigh(i,j,3*nC) = (ii(nC)*dx) + (dx/2)*((top_neigh(i,j,3*nC+2)-ibm_ht_xstag(ii(nC)+1,ji(nC))) &
!								/(ibm_ht(ii(nC)+1,ji(nC))-ibm_ht_xstag(ii(nC)+1,ji(nC))))
!		    else
!		       top_neigh(i,j,3*nC) = (ii(nC)*dx)-(dx/2) + (dx/2)*((top_neigh(i,j,3*nC+2)-ibm_ht(ii(nC),ji(nC))) &
!								 /(ibm_ht_xstag(ii(nC)+1,ji(nC))-ibm_ht(ii(nC),ji(nC))))
!		    endif
!		 else ! look north
!		    top_neigh_i(i,j,3*nC) = ii(nC)
!		    top_neigh_i(i,j,3*nC+1) = 0
!		    top_neigh_i(i,j,3*nC+2) = 0
!		    ! first z
!		    top_neigh(i,j,3*nC+2) = ht_p(ii(nC),ki(nC),ji(nC))
!		    !next x
!		    top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
!		    ! solve for y
!		    if (ibm_ht_ystag(ii(nC),ji(nC)+1) >= top_neigh(i,j,3*nC+2)) then
!		       top_neigh(i,j,3*nC+1) = (ji(nC)*dy) + (dy/2)*((top_neigh(i,j,3*nC+2)-ibm_ht_ystag(ii(nC),ji(nC)+1)) &
!								  /(ibm_ht(ii(nC),ji(nC)+1)-ibm_ht_ystag(ii(nC),ji(nC)+1)))
!		    else
!		       top_neigh(i,j,3*nC+1) = (ji(nC)*dy)-(dy/2) + (dy/2)*((top_neigh(i,j,3*nC+2)-ibm_ht(ii(nC),ji(nC))) &
!								   /(ibm_ht_ystag(ii(nC),ji(nC)+1)-ibm_ht(ii(nC),ji(nC))))
!		    endif  
!		 endif
!	     endif
             ! assign neighbor 0
             ! for a dirchlet boundary condition, there can be 5 neighbors on the boundary 
	     ! for neumann boundary condition, there can be a maximum of 4 neighbors on the boundary
	     nC = 0
	     if (bc_type == 1) then
		! neighbor 0 on the boundary on the 0145 plane
		top_neigh_i(i,j,3*nC) = 0
		top_neigh_i(i,j,3*nC+1) = 0
		top_neigh_i(i,j,3*nC+2) = 0
		! first z
		top_neigh(i,j,3*nC+2) = ht_p(ii(nC),ki(nC),ji(nC))
		if (stag == 1) then
		    ! solve for x
		    if (ibm_ht_xstag(ii(nC),ji(nC)) >= top_neigh(i,j,3*nC+2)) then
		       top_neigh(i,j,3*nC) = (ii(nC)*dx)-dx + (dx/4)+(dx/4)*((top_neigh(i,j,3*nC+2)-ibm_ht_xstag(ii(nC),ji(nC))) &
						                	  /(ibm_ht(ii(nC)+1,ji(nC))-ibm_ht_xstag(ii(nC),ji(nC))))
		    else
		       top_neigh(i,j,3*nC) = (ii(nC)*dx)-dx + (dx/4)*((top_neigh(i,j,3*nC+2)-ibm_ht(ii(nC),ji(nC))) &
							       /(ibm_ht_xstag(ii(nC),ji(nC))-ibm_ht(ii(nC),ji(nC))))
		    endif						  
	       	    ! solve for y
		    if (ibm_ht_ystag(ii(nC),ji(nC)+1) >= top_neigh(i,j,3*nC+2)) then
		       top_neigh(i,j,3*nC+1) = (ji(nC)*dy)-(dy/2) + (dy/4)+(dy/4)*((top_neigh(i,j,3*nC+2)-ibm_ht_ystag(ii(nC),ji(nC)+1)) &
						                        	/(ibm_ht(ii(nC),ji(nC)+1)-ibm_ht_ystag(ii(nC),ji(nC)+1)))
		    else
		       top_neigh(i,j,3*nC+1) = (ji(nC)*dy)-(dy/2) + (dy/4)*((top_neigh(i,j,3*nC+2)-ibm_ht(ii(nC),ji(nC))) &
								   /(ibm_ht_ystag(ii(nC),ji(nC)+1)-ibm_ht(ii(nC),ji(nC))))
		    endif
		elseif (stag == 2) then
		    ! solve for x
		    if (ibm_ht_xstag(ii(nC)+1,ji(nC)) >= top_neigh(i,j,3*nC+2)) then
		       top_neigh(i,j,3*nC) = (ii(nC)*dx)-(dx/2) + (dx/4)+(dx/4)*((top_neigh(i,j,3*nC+2)-ibm_ht_xstag(ii(nC)+1,ji(nC))) &
						                              /(ibm_ht(ii(nC)+1,ji(nC))-ibm_ht_xstag(ii(nC)+1,ji(nC))))
		    else
		       top_neigh(i,j,3*nC) = (ii(nC)*dx)-(dx/2) + (dx/4)*((top_neigh(i,j,3*nC+2)-ibm_ht(ii(nC),ji(nC))) &
						        	 /(ibm_ht_xstag(ii(nC)+1,ji(nC))-ibm_ht(ii(nC),ji(nC))))
		    endif
		    ! solve for y
		    if (ibm_ht_ystag(ii(nC),ji(nC)) >= top_neigh(i,j,3*nC+2)) then
		       top_neigh(i,j,3*nC+1) = (ji(nC)*dy)-dy + (dy/4)+(dy/4)*((top_neigh(i,j,3*nC+2)-ibm_ht_ystag(ii(nC),ji(nC))) &
						                            /(ibm_ht(ii(nC),ji(nC)+1)-ibm_ht_ystag(ii(nC),ji(nC))))
		    else
		       top_neigh(i,j,3*nC+1) = (ji(nC)*dy)-dy + (dy/4)*((top_neigh(i,j,3*nC+2)-ibm_ht(ii(nC),ji(nC))) &
						        	 /(ibm_ht_ystag(ii(nC),ji(nC))-ibm_ht(ii(nC),ji(nC))))
		    endif
	       elseif (stag == 3) then
		    ! solve for x
		    if (ibm_ht_xstag(ii(nC)+1,ji(nC)) >= top_neigh(i,j,3*nC+2)) then
		       top_neigh(i,j,3*nC) = (ii(nC)*dx)-(dx/2) + (dx/4)+(dx/4)*((top_neigh(i,j,3*nC+2)-ibm_ht_xstag(ii(nC)+1,ji(nC))) &
						                              /(ibm_ht(ii(nC)+1,ji(nC))-ibm_ht_xstag(ii(nC)+1,ji(nC))))
		    else
		       top_neigh(i,j,3*nC) = (ii(nC)*dx)-(dx/2) + (dx/4)*((top_neigh(i,j,3*nC+2)-ibm_ht(ii(nC),ji(nC))) &
						        	 /(ibm_ht_xstag(ii(nC)+1,ji(nC))-ibm_ht(ii(nC),ji(nC))))
		    endif
		    ! solve for y
		    if (ibm_ht_ystag(ii(nC),ji(nC)+1) >= top_neigh(i,j,3*nC+2)) then
		       top_neigh(i,j,3*nC+1) = (ji(nC)*dy)-(dy/2) + (dy/4)+(dy/4)*((top_neigh(i,j,3*nC+2)-ibm_ht_ystag(ii(nC),ji(nC)+1)) &
						                        	 /(ibm_ht(ii(nC),ji(nC)+1)-ibm_ht_ystag(ii(nC),ji(nC)+1)))
		    else
		       top_neigh(i,j,3*nC+1) = (ji(nC)*dy)-(dy/2) + (dy/4)*((top_neigh(i,j,3*nC+2)-ibm_ht(ii(nC),ji(nC))) &
								   /(ibm_ht_ystag(ii(nC),ji(nC)+1)-ibm_ht(ii(nC),ji(nC))))
		    endif
	       endif
	     elseif (bc_type == 2) then ! if neumann, start looking for a computational node
	        ! for neighbor 0 look at the computational node at ii+2,ji+2
	        if (ki(nC) > top(ii(nC)+2,ji(nC)+2)) then
		   top_neigh_i(i,j,3*nC) = ii(nC)+2
		   top_neigh_i(i,j,3*nC+1) = ji(nC)+2
		   top_neigh_i(i,j,3*nC+2) = ki(nC)	
		   if (stag ==1 ) then 			
		       top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx)
		       top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)
		   elseif (stag == 2) then
		       top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
		       top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy)	     
		   elseif (stag == 3) then
		       top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
		       top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)	     
		   endif
		   top_neigh(i,j,3*nC+2) = ht_p(top_neigh_i(i,j,3*nC),top_neigh_i(i,j,3*nC+2),top_neigh_i(i,j,3*nC+1))
	        elseif (ki(nC)+1 > top(ii(nC)+2,ji(nC)+2)) then
		   top_neigh_i(i,j,3*nC) = ii(nC)+2
		   top_neigh_i(i,j,3*nC+1) = ji(nC)+2
		   top_neigh_i(i,j,3*nC+2) = ki(nC)+1	
		   if (stag ==1 ) then 			
		       top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx)
		       top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)
		   elseif (stag == 2) then
		       top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
		       top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy)	     
		   elseif (stag == 3) then
		       top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
		       top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)	     
		   endif
		   top_neigh(i,j,3*nC+2) = ht_p(top_neigh_i(i,j,3*nC),top_neigh_i(i,j,3*nC+2),top_neigh_i(i,j,3*nC+1))
		else
		   write(*,*)  'neighbors not assigned for Neumann 10110011 at ',i,j
		endif
	     endif ! end of dirichlet or neumann
	    ! neighbor 2 on the boundary on a plane at the height of the image point 
	    nC = 2
	    top_neigh_i(i,j,3*nC) = 0
	    top_neigh_i(i,j,3*nC+1) = 0
	    top_neigh_i(i,j,3*nC+2) = 0
	    ! first z
	    top_neigh(i,j,3*nC+2) = top_img(i,j,6)
	    if (stag == 1) then
		! solve for x
		if (ibm_ht_xstag(ii(nC),ji(nC)) >= top_neigh(i,j,3*nC+2)) then
		   top_neigh(i,j,3*nC) = (ii(nC)*dx)-dx + (dx/4)+(dx/4)*((top_neigh(i,j,3*nC+2)-ibm_ht_xstag(ii(nC),ji(nC))) &
						                      /(ibm_ht(ii(nC)+1,ji(nC))-ibm_ht_xstag(ii(nC),ji(nC))))
		else
		   top_neigh(i,j,3*nC) = (ii(nC)*dx)-dx + (dx/4)*((top_neigh(i,j,3*nC+2)-ibm_ht(ii(nC),ji(nC))) &
							   /(ibm_ht_xstag(ii(nC),ji(nC))-ibm_ht(ii(nC),ji(nC))))
		endif						  
	       	! solve for y
		if (ibm_ht_ystag(ii(nC),ji(nC)+1) >= top_neigh(i,j,3*nC+2)) then
		   top_neigh(i,j,3*nC+1) = (ji(nC)*dy)-(dy/2) + (dy/4)+(dy/4)*((top_neigh(i,j,3*nC+2)-ibm_ht_ystag(ii(nC),ji(nC)+1)) &
						                            /(ibm_ht(ii(nC),ji(nC)+1)-ibm_ht_ystag(ii(nC),ji(nC)+1)))
		else
		   top_neigh(i,j,3*nC+1) = (ji(nC)*dy)-(dy/2) + (dy/4)*((top_neigh(i,j,3*nC+2)-ibm_ht(ii(nC),ji(nC))) &
							       /(ibm_ht_ystag(ii(nC),ji(nC)+1)-ibm_ht(ii(nC),ji(nC))))
		endif
	    elseif (stag == 2) then
		! solve for x
		if (ibm_ht_xstag(ii(nC)+1,ji(nC)) >= top_neigh(i,j,3*nC+2)) then
		   top_neigh(i,j,3*nC) = (ii(nC)*dx)-(dx/2) + (dx/4)+(dx/4)*((top_neigh(i,j,3*nC+2)-ibm_ht_xstag(ii(nC)+1,ji(nC))) &
						                          /(ibm_ht(ii(nC)+1,ji(nC))-ibm_ht_xstag(ii(nC)+1,ji(nC))))
		else
		   top_neigh(i,j,3*nC) = (ii(nC)*dx)-(dx/2) + (dx/4)*((top_neigh(i,j,3*nC+2)-ibm_ht(ii(nC),ji(nC))) &
						             /(ibm_ht_xstag(ii(nC)+1,ji(nC))-ibm_ht(ii(nC),ji(nC))))
		endif
		! solve for y
		if (ibm_ht_ystag(ii(nC),ji(nC)) >= top_neigh(i,j,3*nC+2)) then
		   top_neigh(i,j,3*nC+1) = (ji(nC)*dy)-dy + (dy/4)+(dy/4)*((top_neigh(i,j,3*nC+2)-ibm_ht_ystag(ii(nC),ji(nC))) &
						                        /(ibm_ht(ii(nC),ji(nC)+1)-ibm_ht_ystag(ii(nC),ji(nC))))
		else
		   top_neigh(i,j,3*nC+1) = (ji(nC)*dy)-dy + (dy/4)*((top_neigh(i,j,3*nC+2)-ibm_ht(ii(nC),ji(nC))) &
						             /(ibm_ht_ystag(ii(nC),ji(nC))-ibm_ht(ii(nC),ji(nC))))
		endif
	   elseif (stag == 3) then
		! solve for x
		if (ibm_ht_xstag(ii(nC)+1,ji(nC)) >= top_neigh(i,j,3*nC+2)) then
		   top_neigh(i,j,3*nC) = (ii(nC)*dx)-(dx/2) + (dx/4)+(dx/4)*((top_neigh(i,j,3*nC+2)-ibm_ht_xstag(ii(nC)+1,ji(nC))) &
						                          /(ibm_ht(ii(nC)+1,ji(nC))-ibm_ht_xstag(ii(nC)+1,ji(nC))))
		else
		   top_neigh(i,j,3*nC) = (ii(nC)*dx)-(dx/2) + (dx/4)*((top_neigh(i,j,3*nC+2)-ibm_ht(ii(nC),ji(nC))) &
						             /(ibm_ht_xstag(ii(nC)+1,ji(nC))-ibm_ht(ii(nC),ji(nC))))
		endif
		! solve for y
		if (ibm_ht_ystag(ii(nC),ji(nC)+1) >= top_neigh(i,j,3*nC+2)) then
		   top_neigh(i,j,3*nC+1) = (ji(nC)*dy)-(dy/2) + (dy/4)+(dy/4)*((top_neigh(i,j,3*nC+2)-ibm_ht_ystag(ii(nC),ji(nC)+1)) &
						                             /(ibm_ht(ii(nC),ji(nC)+1)-ibm_ht_ystag(ii(nC),ji(nC)+1)))
		else
		   top_neigh(i,j,3*nC+1) = (ji(nC)*dy)-(dy/2) + (dy/4)*((top_neigh(i,j,3*nC+2)-ibm_ht(ii(nC),ji(nC))) &
							       /(ibm_ht_ystag(ii(nC),ji(nC)+1)-ibm_ht(ii(nC),ji(nC))))
		endif
	   endif
	endif ! end of if 0 is a top point or not
   ELSEIF ((inside(ii(0),ki(0),ji(0)) == 0).AND. &
	   (inside(ii(1),ki(1),ji(1)) == 0).AND. &
	   (inside(ii(2),ki(2),ji(2)) == 1).AND. &
	   (inside(ii(3),ki(3),ji(3)) == 1).AND. &
	   (inside(ii(4),ki(4),ji(4)) == 1).AND. &
	   (inside(ii(5),ki(5),ji(5)) == 0).AND. &
	   (inside(ii(6),ki(6),ji(6)) == 1).AND. &
	   (inside(ii(7),ki(7),ji(7)) == 1)) THEN
	   ! neighbors 0,1,5 are the zero computational nodes
	   ! neighbors 2,3,7 are at (ii,jj,ibm_ht(ii,jj)) on the boundary
	   do nC = 0,1
	      top_neigh_i(i,j,3*nC) = ii(nC)
	      top_neigh_i(i,j,3*nC+1) = ji(nC)
	      top_neigh_i(i,j,3*nC+2) = ki(nC)		
	      if (stag ==1 ) then 			
		  top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx)
		  top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)
	      elseif (stag == 2) then
		  top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
		  top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy)	     
	      elseif (stag == 3) then
		  top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
		  top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)	     
	      endif
	      top_neigh(i,j,3*nC+2) = ht_p(top_neigh_i(i,j,3*nC),top_neigh_i(i,j,3*nC+2),top_neigh_i(i,j,3*nC+1))  
	   enddo 
	   do nC = 2,3
	      top_neigh_i(i,j,3*nC) = ii(nC)
	      top_neigh_i(i,j,3*nC+1) = ji(nC)
	      top_neigh_i(i,j,3*nC+2) = 0		
	      if (stag ==1 ) then 			
		  top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx)
		  top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)
	      elseif (stag == 2) then
		  top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
		  top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy)	     
	      elseif (stag == 3) then
		  top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
		  top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)	     
	      endif
	      top_neigh(i,j,3*nC+2) = ibm_ht(top_neigh_i(i,j,3*nC),top_neigh_i(i,j,3*nC+1))
	   enddo	   	  
	   nC = 5
	   top_neigh_i(i,j,3*nC) = ii(nC)
	   top_neigh_i(i,j,3*nC+1) = ji(nC)
	   top_neigh_i(i,j,3*nC+2) = ki(nC)		
	   if (stag ==1 ) then 			
	       top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx)
	       top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)
	   elseif (stag == 2) then
	       top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
	       top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy)	     
	   elseif (stag == 3) then
	       top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
	       top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)	     
	   endif
	   top_neigh(i,j,3*nC+2) = ht_p(top_neigh_i(i,j,3*nC),top_neigh_i(i,j,3*nC+2),top_neigh_i(i,j,3*nC+1))
	   nC = 7
	   top_neigh_i(i,j,3*nC) = ii(nC)
	   top_neigh_i(i,j,3*nC+1) = ji(nC)
	   top_neigh_i(i,j,3*nC+2) = 0		
	   if (stag ==1 ) then 			
	       top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx)
	       top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)
	   elseif (stag == 2) then
	       top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
	       top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy)	     
	   elseif (stag == 3) then
	       top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
	       top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)	     
	   endif
	   top_neigh(i,j,3*nC+2) = ibm_ht(top_neigh_i(i,j,3*nC),top_neigh_i(i,j,3*nC+1))
	   ! neighbors 4,6 still need to be assigned
	   ! if 4 is a top ghost point, then the 4 neighbor is (ii,ji,ht(ki+1)) the node above it
	   ! and the 6 neighbor is ibm_ht(ii,jj) on the boundary
	   if (ki(4) == top(ii(4),ji(4))) then
	       nC = 4
	       top_neigh_i(i,j,3*nC) = ii(nC)
	       top_neigh_i(i,j,3*nC+1) = ji(nC)
	       top_neigh_i(i,j,3*nC+2) = ki(nC)+1		
	       if (stag ==1 ) then 			
		   top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx)
		   top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)
	       elseif (stag == 2) then
		   top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
		   top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy)	     
	       elseif (stag == 3) then
		   top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
		   top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)	     
	       endif
	       top_neigh(i,j,3*nC+2) = ht_p(top_neigh_i(i,j,3*nC),top_neigh_i(i,j,3*nC+2),top_neigh_i(i,j,3*nC+1))	   
	       nC = 6
	       top_neigh_i(i,j,3*nC) = ii(nC)
	       top_neigh_i(i,j,3*nC+1) = ji(nC)
	       top_neigh_i(i,j,3*nC+2) = 0		
	       if (stag ==1 ) then 			
		   top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx)
		   top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)
	       elseif (stag == 2) then
		   top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
		   top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy)	     
	       elseif (stag == 3) then
		   top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
		   top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)	     
	       endif
	       top_neigh(i,j,3*nC+2) = ibm_ht(top_neigh_i(i,j,3*nC),top_neigh_i(i,j,3*nC+1))	
	   else ! if neigbor 4 is not a top point, then the algoritm is more compilcated
	     ! assign neighbor 4
             ! for a dirchlet boundary condition, there can be 5 neighbors on the boundary 
	     ! for neumann boundary condition, there can be a maximum of 4 neighbors on the boundary
	     nC = 4
	     if (bc_type == 1) then
		! neighbor 4 on the boundary on the 0145 plane 
		top_neigh_i(i,j,3*nC) = 0
		top_neigh_i(i,j,3*nC+1) = 0
		top_neigh_i(i,j,3*nC+2) = 0
		! first z
		top_neigh(i,j,3*nC+2) = ht_p(ii(nC),ki(nC),ji(nC))
		if (stag == 1) then
		    ! solve for x
		    if (ibm_ht_xstag(ii(nC),ji(nC)) >= top_neigh(i,j,3*nC+2)) then
		       top_neigh(i,j,3*nC) = (ii(nC)*dx)-dx +(dx/4)+(dx/4)*((top_neigh(i,j,3*nC+2)-ibm_ht_xstag(ii(nC),ji(nC))) &
						                	   /(ibm_ht(ii(nC)+1,ji(nC))-ibm_ht_xstag(ii(nC),ji(nC))))
		    else
		       top_neigh(i,j,3*nC) = (ii(nC)*dx)-dx + (dx/4)*((top_neigh(i,j,3*nC+2)-ibm_ht(ii(nC),ji(nC))) &
						               /(ibm_ht_xstag(ii(nC),ji(nC))-ibm_ht(ii(nC),ji(nC))))
		    endif						  
		    ! solve for y
		    if (ibm_ht_ystag(ii(nC),ji(nC)) >= top_neigh(i,j,3*nC+2)) then
		       top_neigh(i,j,3*nC+1) = ((ji(nC)-1)*dy) +(dy/4)*((top_neigh(i,j,3*nC+2)-ibm_ht(ii(nC),ji(nC)-1)) &
						        	 /(ibm_ht_ystag(ii(nC),ji(nC))-ibm_ht(ii(nC),ji(nC)-1)))
		    else
		       top_neigh(i,j,3*nC+1) = ((ji(nC)-1)*dy)-dy + (dy/4)+(dy/4)*((top_neigh(i,j,3*nC+2)-ibm_ht_ystag(ii(nC),ji(nC))) &
							                              /(ibm_ht(ii(nC),ji(nC))-ibm_ht_ystag(ii(nC),ji(nC))))
		    endif
		elseif (stag == 2) then
		    ! solve for x
		    if (ibm_ht_xstag(ii(nC)+1,ji(nC)) >= top_neigh(i,j,3*nC+2)) then
		       top_neigh(i,j,3*nC) = (ii(nC)*dx)-(dx/2) + (dx/4)+(dx/4)*((top_neigh(i,j,3*nC+2)-ibm_ht_xstag(ii(nC)+1,ji(nC))) &
						                              /(ibm_ht(ii(nC)+1,ji(nC))-ibm_ht_xstag(ii(nC)+1,ji(nC))))
		    else
		       top_neigh(i,j,3*nC) = (ii(nC)*dx)-(dx/2) + (dx/4)*((top_neigh(i,j,3*nC+2)-ibm_ht(ii(nC),ji(nC))) &
						        	 /(ibm_ht_xstag(ii(nC)+1,ji(nC))-ibm_ht(ii(nC),ji(nC))))
		    endif
		    ! solve for y
		    if (ibm_ht_ystag(ii(nC),ji(nC)-1) >= top_neigh(i,j,3*nC+2)) then
		       top_neigh(i,j,3*nC+1) = ((ji(nC)-1)*dy)-dy + (dy/2)+(dy/4)*((top_neigh(i,j,3*nC+2)-ibm_ht(ii(nC),ji(nC)-1)) &
						                	  /(ibm_ht_ystag(ii(nC),ji(nC)-1)-ibm_ht(ii(nC),ji(nC)-1)))
		    else
		       top_neigh(i,j,3*nC+1) = ((ji(nC)-1)*dy)-(dy/2) + (dy/4)+(dy/4)*((top_neigh(i,j,3*nC+2)-ibm_ht_ystag(ii(nC),ji(nC)-1)) &
						                                      /(ibm_ht(ii(nC),ji(nC))-ibm_ht_ystag(ii(nC),ji(nC)-1)))
		    endif
		elseif (stag == 3) then
		    ! solve for x
		    if (ibm_ht_xstag(ii(nC)+1,ji(nC)) >= top_neigh(i,j,3*nC+2)) then
		       top_neigh(i,j,3*nC) = (ii(nC)*dx)-(dx/2) + (dx/4)+(dx/4)*((top_neigh(i,j,3*nC+2)-ibm_ht_xstag(ii(nC)+1,ji(nC))) &
						                              /(ibm_ht(ii(nC)+1,ji(nC))-ibm_ht_xstag(ii(nC)+1,ji(nC))))
		    else
		       top_neigh(i,j,3*nC) = (ii(nC)*dx)-(dx/2) + (dx/4)*((top_neigh(i,j,3*nC+2)-ibm_ht(ii(nC),ji(nC))) &
						        	 /(ibm_ht_xstag(ii(nC)+1,ji(nC))-ibm_ht(ii(nC),ji(nC))))
		    endif
		    ! solve for y
		    if (ibm_ht_ystag(ii(nC),ji(nC)) >= top_neigh(i,j,3*nC+2)) then
		       top_neigh(i,j,3*nC+1) = ((ji(nC)-1)*dy) + (dy/4)*((top_neigh(i,j,3*nC+2)-ibm_ht(ii(nC),ji(nC)-1)) &
						        	  /(ibm_ht_ystag(ii(nC),ji(nC))-ibm_ht(ii(nC),ji(nC)-1)))
		    else
		       top_neigh(i,j,3*nC+1) = ((ji(nC)-1)*dy) + (dy/4)+(dy/4)*((top_neigh(i,j,3*nC+2)-ibm_ht_ystag(ii(nC),ji(nC))) &
							                      /(ibm_ht(ii(nC),ji(nC))-ibm_ht_ystag(ii(nC),ji(nC))))
		    endif
		endif
	     elseif (bc_type == 2) then ! if neumann, start looking for a computational node
	        ! for neighbor 4 look at the computational node at ii+2,ji-2
	        if (ki(nC) > top(ii(nC)+2,ji(nC)-2)) then
		   top_neigh_i(i,j,3*nC) = ii(nC)+2
		   top_neigh_i(i,j,3*nC+1) = ji(nC)-2
		   top_neigh_i(i,j,3*nC+2) = ki(nC)	
		   if (stag ==1 ) then 			
		       top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx)
		       top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)
		   elseif (stag == 2) then
		       top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
		       top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy)	     
		   elseif (stag == 3) then
		       top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
		       top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)	     
		   endif
		   top_neigh(i,j,3*nC+2) = ht_p(top_neigh_i(i,j,3*nC),top_neigh_i(i,j,3*nC+2),top_neigh_i(i,j,3*nC+1))
	        elseif (ki(nC)+1 > top(ii(nC)+2,ji(nC)-2)) then
		   top_neigh_i(i,j,3*nC) = ii(nC)+2
		   top_neigh_i(i,j,3*nC+1) = ji(nC)-2
		   top_neigh_i(i,j,3*nC+2) = ki(nC)+1	
		   if (stag ==1 ) then 			
		       top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx)
		       top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)
		   elseif (stag == 2) then
		       top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
		       top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy)	     
		   elseif (stag == 3) then
		       top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
		       top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)	     
		   endif
		   top_neigh(i,j,3*nC+2) = ht_p(top_neigh_i(i,j,3*nC),top_neigh_i(i,j,3*nC+2),top_neigh_i(i,j,3*nC+1))
		else
		   write(*,*)  'neighbors not assigned for Neumann 00111011 at ',i,j
		endif
	     endif ! end of dirichlet or neumann
	     ! neighbor 6 on the boundary on a plane at the height of the image point 
	     nC = 6
	     top_neigh_i(i,j,3*nC) = 0
	     top_neigh_i(i,j,3*nC+1) = 0
	     top_neigh_i(i,j,3*nC+2) = 0
	     ! first z
	     top_neigh(i,j,3*nC+2) = top_img(i,j,6)
	     if (stag == 1) then
		 ! solve for x
		 if (ibm_ht_xstag(ii(nC),ji(nC)) >= top_neigh(i,j,3*nC+2)) then
		    top_neigh(i,j,3*nC) = (ii(nC)*dx)-dx +(dx/4)+(dx/4)*((top_neigh(i,j,3*nC+2)-ibm_ht_xstag(ii(nC),ji(nC))) &
						                	/(ibm_ht(ii(nC)+1,ji(nC))-ibm_ht_xstag(ii(nC),ji(nC))))
		 else
		    top_neigh(i,j,3*nC) = (ii(nC)*dx)-dx + (dx/4)*((top_neigh(i,j,3*nC+2)-ibm_ht(ii(nC),ji(nC))) &
						            /(ibm_ht_xstag(ii(nC),ji(nC))-ibm_ht(ii(nC),ji(nC))))
		 endif						  
		 ! solve for y
		 if (ibm_ht_ystag(ii(nC),ji(nC)) >= top_neigh(i,j,3*nC+2)) then
		    top_neigh(i,j,3*nC+1) = ((ji(nC)-1)*dy) +(dy/4)*((top_neigh(i,j,3*nC+2)-ibm_ht(ii(nC),ji(nC)-1)) &
						              /(ibm_ht_ystag(ii(nC),ji(nC))-ibm_ht(ii(nC),ji(nC)-1)))
		 else
		    top_neigh(i,j,3*nC+1) = ((ji(nC)-1)*dy)-dy + (dy/4)+(dy/4)*((top_neigh(i,j,3*nC+2)-ibm_ht_ystag(ii(nC),ji(nC))) &
							                           /(ibm_ht(ii(nC),ji(nC))-ibm_ht_ystag(ii(nC),ji(nC))))
		 endif
	     elseif (stag == 2) then
		 ! solve for x
		 if (ibm_ht_xstag(ii(nC)+1,ji(nC)) >= top_neigh(i,j,3*nC+2)) then
		    top_neigh(i,j,3*nC) = (ii(nC)*dx)-(dx/2) + (dx/4)+(dx/4)*((top_neigh(i,j,3*nC+2)-ibm_ht_xstag(ii(nC)+1,ji(nC))) &
						                           /(ibm_ht(ii(nC)+1,ji(nC))-ibm_ht_xstag(ii(nC)+1,ji(nC))))
		 else
		    top_neigh(i,j,3*nC) = (ii(nC)*dx)-(dx/2) + (dx/4)*((top_neigh(i,j,3*nC+2)-ibm_ht(ii(nC),ji(nC))) &
						              /(ibm_ht_xstag(ii(nC)+1,ji(nC))-ibm_ht(ii(nC),ji(nC))))
		 endif
		 ! solve for y
		 if (ibm_ht_ystag(ii(nC),ji(nC)-1) >= top_neigh(i,j,3*nC+2)) then
		    top_neigh(i,j,3*nC+1) = ((ji(nC)-1)*dy)-dy + (dy/2)+(dy/4)*((top_neigh(i,j,3*nC+2)-ibm_ht(ii(nC),ji(nC)-1)) &
						                       /(ibm_ht_ystag(ii(nC),ji(nC)-1)-ibm_ht(ii(nC),ji(nC)-1)))
		 else
		    top_neigh(i,j,3*nC+1) = ((ji(nC)-1)*dy)-(dy/2) + (dy/4)+(dy/4)*((top_neigh(i,j,3*nC+2)-ibm_ht_ystag(ii(nC),ji(nC)-1)) &
						                                   /(ibm_ht(ii(nC),ji(nC))-ibm_ht_ystag(ii(nC),ji(nC)-1)))
		 endif
	     elseif (stag == 3) then
		 ! solve for x
		 if (ibm_ht_xstag(ii(nC)+1,ji(nC)) >= top_neigh(i,j,3*nC+2)) then
		    top_neigh(i,j,3*nC) = (ii(nC)*dx)-(dx/2) + (dx/4)+(dx/4)*((top_neigh(i,j,3*nC+2)-ibm_ht_xstag(ii(nC)+1,ji(nC))) &
						                           /(ibm_ht(ii(nC)+1,ji(nC))-ibm_ht_xstag(ii(nC)+1,ji(nC))))
		 else
		    top_neigh(i,j,3*nC) = (ii(nC)*dx)-(dx/2) + (dx/4)*((top_neigh(i,j,3*nC+2)-ibm_ht(ii(nC),ji(nC))) &
						              /(ibm_ht_xstag(ii(nC)+1,ji(nC))-ibm_ht(ii(nC),ji(nC))))
		 endif
		 ! solve for y
		 if (ibm_ht_ystag(ii(nC),ji(nC)) >= top_neigh(i,j,3*nC+2)) then
		    top_neigh(i,j,3*nC+1) = ((ji(nC)-1)*dy) + (dy/4)*((top_neigh(i,j,3*nC+2)-ibm_ht(ii(nC),ji(nC)-1)) &
						               /(ibm_ht_ystag(ii(nC),ji(nC))-ibm_ht(ii(nC),ji(nC)-1)))
		 else
		    top_neigh(i,j,3*nC+1) = ((ji(nC)-1)*dy) + (dy/4)+(dy/4)*((top_neigh(i,j,3*nC+2)-ibm_ht_ystag(ii(nC),ji(nC))) &
							                   /(ibm_ht(ii(nC),ji(nC))-ibm_ht_ystag(ii(nC),ji(nC))))
		 endif
	      endif
	   endif ! end of if neighbor 4 is a top point or not
   ELSEIF ((inside(ii(0),ki(0),ji(0)) == 0).AND. &
	   (inside(ii(1),ki(1),ji(1)) == 0).AND. &
	   (inside(ii(2),ki(2),ji(2)) == 1).AND. &
	   (inside(ii(3),ki(3),ji(3)) == 1).AND. &
	   (inside(ii(4),ki(4),ji(4)) == 0).AND. &
	   (inside(ii(5),ki(5),ji(5)) == 1).AND. &
	   (inside(ii(6),ki(6),ji(6)) == 1).AND. &
	   (inside(ii(7),ki(7),ji(7)) == 1)) THEN 
	   ! neighbors 0,1,4 are the zero computational nodes
	   ! neighbors 2,3,6 are at (ii,jj,ibm_ht(ii,jj)) on the boundary
	   do nC = 0,1
	      top_neigh_i(i,j,3*nC) = ii(nC)
	      top_neigh_i(i,j,3*nC+1) = ji(nC)
	      top_neigh_i(i,j,3*nC+2) = ki(nC)		
	      if (stag ==1 ) then 			
		  top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx)
		  top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)
	      elseif (stag == 2) then
		  top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
		  top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy)	     
	      elseif (stag == 3) then
		  top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
		  top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)	     
	      endif
	      top_neigh(i,j,3*nC+2) = ht_p(top_neigh_i(i,j,3*nC),top_neigh_i(i,j,3*nC+2),top_neigh_i(i,j,3*nC+1))
	   enddo  
	   do nC = 2,3
	      top_neigh_i(i,j,3*nC) = ii(nC)
	      top_neigh_i(i,j,3*nC+1) = ji(nC)
	      top_neigh_i(i,j,3*nC+2) = 0		
	      if (stag ==1 ) then 			
		  top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx)
		  top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)
	      elseif (stag == 2) then
		  top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
		  top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy)	     
	      elseif (stag == 3) then
		  top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
		  top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)	     
	      endif
	      top_neigh(i,j,3*nC+2) = ibm_ht(top_neigh_i(i,j,3*nC),top_neigh_i(i,j,3*nC+1))
	   enddo   
	   nC = 4
	   top_neigh_i(i,j,3*nC) = ii(nC)
	   top_neigh_i(i,j,3*nC+1) = ji(nC)
	   top_neigh_i(i,j,3*nC+2) = ki(nC)		
	   if (stag ==1 ) then 			
	       top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx)
	       top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)
	   elseif (stag == 2) then
	       top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
	       top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy)	     
	   elseif (stag == 3) then
	       top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
	       top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)	     
	   endif
	   top_neigh(i,j,3*nC+2) = ht_p(top_neigh_i(i,j,3*nC),top_neigh_i(i,j,3*nC+2),top_neigh_i(i,j,3*nC+1)) 	   
	   nC = 6
	   top_neigh_i(i,j,3*nC) = ii(nC)
	   top_neigh_i(i,j,3*nC+1) = ji(nC)
	   top_neigh_i(i,j,3*nC+2) = 0		
	   if (stag ==1 ) then 			
	       top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx)
	       top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)
	   elseif (stag == 2) then
	       top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
	       top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy)	     
	   elseif (stag == 3) then
	       top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
	       top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)	     
	   endif
	   top_neigh(i,j,3*nC+2) = ibm_ht(top_neigh_i(i,j,3*nC),top_neigh_i(i,j,3*nC+1))
	   ! neighbors 5,7 still need to be assigned
	   ! if 5 is a top ghost point, then the 5 neighbor is (ii(1),ji(1),ht(ki(1)+1) the node above it
	   ! and the 7 neighbor is ibm_ht(ii,jj) on the boundary
	   if (ki(5) == top(ii(5),ji(5))) then
	       nC = 5	  
	       top_neigh_i(i,j,3*nC) = ii(nC)
	       top_neigh_i(i,j,3*nC+1) = ji(nC)
	       top_neigh_i(i,j,3*nC+2) = ki(nC)+1		
	       if (stag ==1 ) then 			
		   top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx)
		   top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)
	       elseif (stag == 2) then
		   top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
		   top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy)	     
	       elseif (stag == 3) then
		   top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
		   top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)	     
	       endif
	       top_neigh(i,j,3*nC+2) = ht_p(top_neigh_i(i,j,3*nC),top_neigh_i(i,j,3*nC+2),top_neigh_i(i,j,3*nC+1))	   
	       nC = 7
	       top_neigh_i(i,j,3*nC) = ii(nC)
	       top_neigh_i(i,j,3*nC+1) = ji(nC)
	       top_neigh_i(i,j,3*nC+2) = 0		
	       if (stag ==1 ) then 			
		   top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx)
		   top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)
	       elseif (stag == 2) then
		   top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
		   top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy)	     
	       elseif (stag == 3) then
		   top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
		   top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)	     
	       endif
	       top_neigh(i,j,3*nC+2) = ibm_ht(top_neigh_i(i,j,3*nC),top_neigh_i(i,j,3*nC+1))	
	   else ! if neighbor 5 is not a top point, then the algorithm is more complicated
               ! assign neighbor 5
               ! for a dirchlet boundary condition, there can be 5 neighbors on the boundary 
	       ! for neumann boundary condition, there can be a maximum of 4 neighbors on the boundary
	       nC = 5
	       if (bc_type == 1) then
		  ! neighbor 5 on the boundary on the 0145 plane 
		  top_neigh_i(i,j,3*nC) = 0
		  top_neigh_i(i,j,3*nC+1) = 0
		  top_neigh_i(i,j,3*nC+2) = 0
		  ! first z
		  top_neigh(i,j,3*nC+2) = ht_p(ii(nC),ki(nC),ji(nC))
 		  if (stag == 1) then
 		      ! solve for x
 		      if (ibm_ht_xstag(ii(nC)-1,ji(nC)) >= top_neigh(i,j,3*nC+2)) then
 			 top_neigh(i,j,3*nC) = ((ii(nC)-1)*dx)-dx + (dx/2)+(dx/4)*((top_neigh(i,j,3*nC+2)-ibm_ht(ii(nC)-1,ji(nC))) &
 									  /(ibm_ht_xstag(ii(nC)-1,ji(nC))-ibm_ht(ii(nC)-1,ji(nC))))
 		      else
 			 top_neigh(i,j,3*nC) = ((ii(nC)-1)*dx)-(dx/2) + (dx/4)+(dx/4)*((top_neigh(i,j,3*nC+2)-ibm_ht_xstag(ii(nC)-1,ji(nC))) &
 									              /(ibm_ht(ii(nC),ji(nC))-ibm_ht_xstag(ii(nC)-1,ji(nC))))
 		      endif						  
 		      ! solve for y
 		      if (ibm_ht_ystag(ii(nC),ji(nC)) >= top_neigh(i,j,3*nC+2)) then
 			 top_neigh(i,j,3*nC+1) = ((ji(nC)-1)*dy)-(dy/2) + (dy/2)+(dy/4)*((top_neigh(i,j,3*nC+2)-ibm_ht(ii(nC),ji(nC)-1)) &
 										  /(ibm_ht_ystag(ii(nC),ji(nC))-ibm_ht(ii(nC),ji(nC)-1)))
 		      else
 			 top_neigh(i,j,3*nC+1) = (ji(nC)*dy)-dy + (dy/4)+(dy/4)*((top_neigh(i,j,3*nC+2)-ibm_ht_ystag(ii(nC),ji(nC))) &
 										/(ibm_ht(ii(nC),ji(nC))-ibm_ht_ystag(ii(nC),ji(nC))))
 		      endif
 		  elseif (stag == 2) then
 		      ! solve for x
 		      if (ibm_ht_xstag(ii(nC),ji(nC)) >= top_neigh(i,j,3*nC+2)) then
 			 top_neigh(i,j,3*nC) = ((ii(nC)-1)*dx)-(dx/2) + (dx/2)+(dx/4)*((top_neigh(i,j,3*nC+2)-ibm_ht(ii(nC)-1,ji(nC))) &
 								              /(ibm_ht_xstag(ii(nC)+1,ji(nC))-ibm_ht(ii(nC)-1,ji(nC))))
 		      else
 			 top_neigh(i,j,3*nC) = (ii(nC)*dx)-dx + (dx/4)+(dx/4)*((top_neigh(i,j,3*nC+2)-ibm_ht_xstag(ii(nC),ji(nC))) &
 								              /(ibm_ht(ii(nC),ji(nC))-ibm_ht_xstag(ii(nC),ji(nC))))
 		      endif
 		      ! solve for y
 		      if (ibm_ht_ystag(ii(nC),ji(nC)-1) >= top_neigh(i,j,3*nC+2)) then
 			 top_neigh(i,j,3*nC+1) = ((ji(nC)-1)*dy)-dy + (dy/2)+(dy/4)*((top_neigh(i,j,3*nC+2)-ibm_ht(ii(nC),ji(nC)-1)) &
 									    /(ibm_ht_ystag(ii(nC),ji(nC)-1)-ibm_ht(ii(nC),ji(nC)-1)))
 		      else
 			 top_neigh(i,j,3*nC+1) = ((ji(nC)-1)*dy)-(dy/2) + (dy/4)+(dy/4)*((top_neigh(i,j,3*nC+2)-ibm_ht_ystag(ii(nC),ji(nC)-1)) &
 									    		/(ibm_ht(ii(nC),ji(nC))-ibm_ht_ystag(ii(nC),ji(nC)-1)))
 		      endif
 		  elseif (stag == 3) then
 		      ! solve for x
 		      if (ibm_ht_xstag(ii(nC),ji(nC)) >= top_neigh(i,j,3*nC+2)) then
 			 top_neigh(i,j,3*nC) = ((ii(nC)-1)*dx)-(dx/2) + (dx/2)+(dx/4)*((top_neigh(i,j,3*nC+2)-ibm_ht(ii(nC)-1,ji(nC))) &
 										/(ibm_ht_xstag(ii(nC),ji(nC))-ibm_ht(ii(nC)-1,ji(nC))))
 		      else
 			 top_neigh(i,j,3*nC) = (ii(nC)*dx)-dx + (dx/4)+(dx/4)*((top_neigh(i,j,3*nC+2)-ibm_ht_xstag(ii(nC),ji(nC))) &
 								              /(ibm_ht(ii(nC),ji(nC))-ibm_ht_xstag(ii(nC),ji(nC))))
 		      endif
 		      ! solve for y
 		      if (ibm_ht_ystag(ii(nC),ji(nC)) >= top_neigh(i,j,3*nC+2)) then
 			 top_neigh(i,j,3*nC+1) = ((ji(nC)-1)*dy)-(dy/2) + (dy/2)+(dy/4)*((top_neigh(i,j,3*nC+2)-ibm_ht(ii(nC),ji(nC)-1)) &
 										  /(ibm_ht_ystag(ii(nC),ji(nC))-ibm_ht(ii(nC),ji(nC)-1)))
 		      else
 			 top_neigh(i,j,3*nC+1) = (ji(nC)*dy)-dy + (dy/4)+(dy/4)*((top_neigh(i,j,3*nC+2)-ibm_ht_ystag(ii(nC),ji(nC))) &
 									      /(ibm_ht(ii(nC),ji(nC))-ibm_ht_ystag(ii(nC),ji(nC))))
 		      endif
 		  endif
	       elseif (bc_type == 2) then ! if neumann, start looking for a computational node
	          ! for neighbor 5 look at the computational node at ii-2,ji-2
	          if (ki(nC) > top(ii(nC)-2,ji(nC)-2)) then
		     top_neigh_i(i,j,3*nC) = ii(nC)-2
		     top_neigh_i(i,j,3*nC+1) = ji(nC)-2
		     top_neigh_i(i,j,3*nC+2) = ki(nC)	
		     if (stag ==1 ) then 			
			 top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx)
			 top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)
		     elseif (stag == 2) then
			 top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
			 top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy)	     
		     elseif (stag == 3) then
			 top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
			 top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)	     
		     endif
		     top_neigh(i,j,3*nC+2) = ht_p(top_neigh_i(i,j,3*nC),top_neigh_i(i,j,3*nC+2),top_neigh_i(i,j,3*nC+1))
	          elseif (ki(nC)+1 > top(ii(nC)-2,ji(nC)-2)) then
		     top_neigh_i(i,j,3*nC) = ii(nC)-2
		     top_neigh_i(i,j,3*nC+1) = ji(nC)-2
		     top_neigh_i(i,j,3*nC+2) = ki(nC)+1	
		     if (stag ==1 ) then 			
			 top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx)
			 top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)
		     elseif (stag == 2) then
			 top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
			 top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy)	     
		     elseif (stag == 3) then
			 top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
			 top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)	     
		     endif
		     top_neigh(i,j,3*nC+2) = ht_p(top_neigh_i(i,j,3*nC),top_neigh_i(i,j,3*nC+2),top_neigh_i(i,j,3*nC+1))
		  else
		     write(*,*)  'neighbors not assigned for Neumann 00110111 at ',i,j
		  endif
	       endif ! end of dirichlet or neumann
	       ! neighbor 7 on the boundary on a plane at the height of the image point 
	       nC = 7
	       top_neigh_i(i,j,3*nC) = 0
	       top_neigh_i(i,j,3*nC+1) = 0
	       top_neigh_i(i,j,3*nC+2) = 0
	       ! first z
	       top_neigh(i,j,3*nC+2) = top_img(i,j,6)
 	       if (stag == 1) then
 		   ! solve for x
 		   if (ibm_ht_xstag(ii(nC)-1,ji(nC)) >= top_neigh(i,j,3*nC+2)) then
 		      top_neigh(i,j,3*nC) = ((ii(nC)-1)*dx)-dx + (dx/2)+(dx/4)*((top_neigh(i,j,3*nC+2)-ibm_ht(ii(nC)-1,ji(nC))) &
 								       /(ibm_ht_xstag(ii(nC)-1,ji(nC))-ibm_ht(ii(nC)-1,ji(nC))))
 		   else
 		      top_neigh(i,j,3*nC) = ((ii(nC)-1)*dx)-(dx/2) + (dx/4)+(dx/4)*((top_neigh(i,j,3*nC+2)-ibm_ht_xstag(ii(nC)-1,ji(nC))) &
 									           /(ibm_ht(ii(nC),ji(nC))-ibm_ht_xstag(ii(nC)-1,ji(nC))))
 		   endif						  
 		   ! solve for y
 		   if (ibm_ht_ystag(ii(nC),ji(nC)) >= top_neigh(i,j,3*nC+2)) then
 		      top_neigh(i,j,3*nC+1) = ((ji(nC)-1)*dy)-(dy/2) + (dy/2)+(dy/4)*((top_neigh(i,j,3*nC+2)-ibm_ht(ii(nC),ji(nC)-1)) &
 									       /(ibm_ht_ystag(ii(nC),ji(nC))-ibm_ht(ii(nC),ji(nC)-1)))
 		   else
 		      top_neigh(i,j,3*nC+1) = (ji(nC)*dy)-dy + (dy/4)+(dy/4)*((top_neigh(i,j,3*nC+2)-ibm_ht_ystag(ii(nC),ji(nC))) &
 									     /(ibm_ht(ii(nC),ji(nC))-ibm_ht_ystag(ii(nC),ji(nC))))
 		   endif
 	       elseif (stag == 2) then
 		   ! solve for x
 		   if (ibm_ht_xstag(ii(nC),ji(nC)) >= top_neigh(i,j,3*nC+2)) then
 		      top_neigh(i,j,3*nC) = ((ii(nC)-1)*dx)-(dx/2) + (dx/2)+(dx/4)*((top_neigh(i,j,3*nC+2)-ibm_ht(ii(nC)-1,ji(nC))) &
 								           /(ibm_ht_xstag(ii(nC)+1,ji(nC))-ibm_ht(ii(nC)-1,ji(nC))))
 		   else
 		      top_neigh(i,j,3*nC) = (ii(nC)*dx)-dx + (dx/4)+(dx/4)*((top_neigh(i,j,3*nC+2)-ibm_ht_xstag(ii(nC),ji(nC))) &
 								           /(ibm_ht(ii(nC),ji(nC))-ibm_ht_xstag(ii(nC),ji(nC))))
 		   endif
 		   ! solve for y
 		   if (ibm_ht_ystag(ii(nC),ji(nC)-1) >= top_neigh(i,j,3*nC+2)) then
 		      top_neigh(i,j,3*nC+1) = ((ji(nC)-1)*dy)-dy + (dy/2)+(dy/4)*((top_neigh(i,j,3*nC+2)-ibm_ht(ii(nC),ji(nC)-1)) &
 									 /(ibm_ht_ystag(ii(nC),ji(nC)-1)-ibm_ht(ii(nC),ji(nC)-1)))
 		   else
 		      top_neigh(i,j,3*nC+1) = ((ji(nC)-1)*dy)-(dy/2) + (dy/4)+(dy/4)*((top_neigh(i,j,3*nC+2)-ibm_ht_ystag(ii(nC),ji(nC)-1)) &
 									    	     /(ibm_ht(ii(nC),ji(nC))-ibm_ht_ystag(ii(nC),ji(nC)-1)))
 		   endif
 	       elseif (stag == 3) then
 		   ! solve for x
 		   if (ibm_ht_xstag(ii(nC),ji(nC)) >= top_neigh(i,j,3*nC+2)) then
 		      top_neigh(i,j,3*nC) = ((ii(nC)-1)*dx)-(dx/2) + (dx/2)+(dx/4)*((top_neigh(i,j,3*nC+2)-ibm_ht(ii(nC)-1,ji(nC))) &
 									     /(ibm_ht_xstag(ii(nC),ji(nC))-ibm_ht(ii(nC)-1,ji(nC))))
 		   else
 		      top_neigh(i,j,3*nC) = (ii(nC)*dx)-dx + (dx/4)+(dx/4)*((top_neigh(i,j,3*nC+2)-ibm_ht_xstag(ii(nC),ji(nC))) &
 								           /(ibm_ht(ii(nC),ji(nC))-ibm_ht_xstag(ii(nC),ji(nC))))
 		   endif
 		   ! solve for y
 		   if (ibm_ht_ystag(ii(nC),ji(nC)) >= top_neigh(i,j,3*nC+2)) then
 		      top_neigh(i,j,3*nC+1) = ((ji(nC)-1)*dy)-(dy/2) + (dy/2)+(dy/4)*((top_neigh(i,j,3*nC+2)-ibm_ht(ii(nC),ji(nC)-1)) &
 									       /(ibm_ht_ystag(ii(nC),ji(nC))-ibm_ht(ii(nC),ji(nC)-1)))
 		   else
 		      top_neigh(i,j,3*nC+1) = (ji(nC)*dy)-dy + (dy/4)+(dy/4)*((top_neigh(i,j,3*nC+2)-ibm_ht_ystag(ii(nC),ji(nC))) &
 									   /(ibm_ht(ii(nC),ji(nC))-ibm_ht_ystag(ii(nC),ji(nC))))
 		   endif
 	       endif	   
	   endif ! end of if neighbor 5 is a top point or not 	   
   ELSEIF ((inside(ii(0),ki(0),ji(0)) == 0).AND. &
	   (inside(ii(1),ki(1),ji(1)) == 1).AND. &
	   (inside(ii(2),ki(2),ji(2)) == 1).AND. &
	   (inside(ii(3),ki(3),ji(3)) == 1).AND. &
	   (inside(ii(4),ki(4),ji(4)) == 0).AND. &
	   (inside(ii(5),ki(5),ji(5)) == 0).AND. &
	   (inside(ii(6),ki(6),ji(6)) == 1).AND. &
	   (inside(ii(7),ki(7),ji(7)) == 1)) THEN
	   ! neighbors 0,4,5 are the zero computational nodes
	   ! neighbors 2,6,7 are at (ii,jj,ibm_ht(ii,jj)) on the boundary
	   nC = 0
	   top_neigh_i(i,j,3*nC) = ii(nC)
	   top_neigh_i(i,j,3*nC+1) = ji(nC)
	   top_neigh_i(i,j,3*nC+2) = ki(nC)		
	   if (stag ==1 ) then 			
	       top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx)
	       top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)
	   elseif (stag == 2) then
	       top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
	       top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy)	     
	   elseif (stag == 3) then
	       top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
	       top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)	     
	   endif
	   top_neigh(i,j,3*nC+2) = ht_p(top_neigh_i(i,j,3*nC),top_neigh_i(i,j,3*nC+2),top_neigh_i(i,j,3*nC+1))   
	   nC = 2
	   top_neigh_i(i,j,3*nC) = ii(nC)
	   top_neigh_i(i,j,3*nC+1) = ji(nC)
	   top_neigh_i(i,j,3*nC+2) = 0		
	   if (stag ==1 ) then 			
	       top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx)
	       top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)
	   elseif (stag == 2) then
	       top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
	       top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy)	     
	   elseif (stag == 3) then
	       top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
	       top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)	     
	   endif
	   top_neigh(i,j,3*nC+2) = ibm_ht(top_neigh_i(i,j,3*nC),top_neigh_i(i,j,3*nC+1))	   	  
	   do nC = 4,5
	      top_neigh_i(i,j,3*nC) = ii(nC)
	      top_neigh_i(i,j,3*nC+1) = ji(nC)
	      top_neigh_i(i,j,3*nC+2) = ki(nC)		
	      if (stag ==1 ) then 			
		  top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx)
		  top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)
	      elseif (stag == 2) then
		  top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
		  top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy)	     
	      elseif (stag == 3) then
		  top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
		  top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)	     
	      endif
	      top_neigh(i,j,3*nC+2) = ht_p(top_neigh_i(i,j,3*nC),top_neigh_i(i,j,3*nC+2),top_neigh_i(i,j,3*nC+1))
	   enddo	
	   do nC = 6,7
	      top_neigh_i(i,j,3*nC) = ii(nC)
	      top_neigh_i(i,j,3*nC+1) = ji(nC)
	      top_neigh_i(i,j,3*nC+2) = 0		
	      if (stag ==1 ) then 			
		  top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx)
		  top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)
	      elseif (stag == 2) then
		  top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
		  top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy)	     
	      elseif (stag == 3) then
		  top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
		  top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)	     
	      endif
	      top_neigh(i,j,3*nC+2) = ibm_ht(top_neigh_i(i,j,3*nC),top_neigh_i(i,j,3*nC+1))
	   enddo	
	   ! neighbors 1,3 still need to be assigned
	   ! if 1 is a top ghost point, then the 1 neighbor is (ii(1),ji(1),ht(ki(1)+1) the node above it
	   ! and the 3 neighbor is ibm_ht(ii,jj) on the boundary
	   if (ki(1) == top(ii(1),ji(1))) then	
	       nC = 1  
	       top_neigh_i(i,j,3*nC) = ii(nC)
	       top_neigh_i(i,j,3*nC+1) = ji(nC)
	       top_neigh_i(i,j,3*nC+2) = ki(nC)+1		
	       if (stag ==1 ) then 			
		   top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx)
		   top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)
	       elseif (stag == 2) then
		   top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
		   top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy)	     
	       elseif (stag == 3) then
		   top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
		   top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)	     
	       endif
	       top_neigh(i,j,3*nC+2) = ht_p(top_neigh_i(i,j,3*nC),top_neigh_i(i,j,3*nC+2),top_neigh_i(i,j,3*nC+1))	   
	       nC = 3
	       top_neigh_i(i,j,3*nC) = ii(nC)
	       top_neigh_i(i,j,3*nC+1) = ji(nC)
	       top_neigh_i(i,j,3*nC+2) = 0		
	       if (stag ==1 ) then 			
		   top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx)
		   top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)
	       elseif (stag == 2) then
		   top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
		   top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy)	     
	       elseif (stag == 3) then
		   top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
		   top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)	     
	       endif
	       top_neigh(i,j,3*nC+2) = ibm_ht(top_neigh_i(i,j,3*nC),top_neigh_i(i,j,3*nC+1))	
	   else ! if neighbor 1 is not a top point, then the algorithm is more complicated
              ! assign neighbor 1
              ! for a dirchlet boundary condition, there can be 5 neighbors on the boundary 
	      ! for neumann boundary condition, there can be a maximum of 4 neighbors on the boundary
	      nC = 1
	      if (bc_type == 1) then
		 ! neighbor 1 on the boundary face that cuts the 0145 plane
		 top_neigh_i(i,j,3*nC) = 0
		 top_neigh_i(i,j,3*nC+1) = 0
		 top_neigh_i(i,j,3*nC+2) = 0
		 ! first z
		 top_neigh(i,j,3*nC+2) = ht_p(ii(nC),ki(nC),ji(nC))
		 if (stag == 1) then
		     ! solve for x/2
		     if (ibm_ht_xstag(ii(nC)-1,ji(nC)) >= top_neigh(i,j,3*nC+2)) then
			top_neigh(i,j,3*nC) = ((ii(nC)-1)*dx)-dx + (dx/2)+(dx/4)*((top_neigh(i,j,3*nC+2)-ibm_ht(ii(nC)-1,ji(nC))) &
						                	 /(ibm_ht_xstag(ii(nC)-1,ji(nC))-ibm_ht(ii(nC)-1,ji(nC))))
		     else
			top_neigh(i,j,3*nC) = ((ii(nC)-1)*dx)-(dx/2) +  (dx/4)+(dx/4)*((top_neigh(i,j,3*nC+2)-ibm_ht_xstag(ii(nC)-1,ji(nC))) &
							                              /(ibm_ht(ii(nC),ji(nC))-ibm_ht_xstag(ii(nC)-1,ji(nC))))
		     endif	
		     ! solve for y/2
		     if (ibm_ht_ystag(ii(nC),ji(nC)+1) >= top_neigh(i,j,3*nC+2)) then
			top_neigh(i,j,3*nC+1) = (ji(nC)*dy)-(dy/2) + (dy/4)+(dy/4)*((top_neigh(i,j,3*nC+2)-ibm_ht_ystag(ii(nC),ji(nC)+1)) &
						                        	 /(ibm_ht(ii(nC),ji(nC)+1)-ibm_ht_ystag(ii(nC),ji(nC)+1)))
		     else 
			top_neigh(i,j,3*nC+1) = (ji(nC)*dy)-(dy/2) + (dy/4)*((top_neigh(i,j,3*nC+2)-ibm_ht(ii(nC),ji(nC))) &
						        	    /(ibm_ht_ystag(ii(nC),ji(nC)+1)-ibm_ht(ii(nC),ji(nC))))
		     endif					  
		 elseif (stag == 2) then
		     ! solve for x/2
		     if (ibm_ht_xstag(ii(nC),ji(nC)) >= top_neigh(i,j,3*nC+2)) then
			top_neigh(i,j,3*nC) = ((ii(nC)-1)*dx)-(dx/2) +  (dx/2)+(dx/4)*((top_neigh(i,j,3*nC+2)-ibm_ht(ii(nC)-1,ji(nC))) &
						                        	/(ibm_ht_xstag(ii(nC),ji(nC))-ibm_ht(ii(nC)-1,ji(nC))))
		     else
			top_neigh(i,j,3*nC) = (ii(nC)*dx)-dx +  (dx/4)+(dx/4)*((top_neigh(i,j,3*nC+2)-ibm_ht_xstag(ii(nC),ji(nC))) &
						                              /(ibm_ht(ii(nC),ji(nC))-ibm_ht_xstag(ii(nC),ji(nC))))
		     endif
		     ! solve for y/2
		     if (ibm_ht_ystag(ii(nC),ji(nC)) >= top_neigh(i,j,3*nC+2)) then
			top_neigh(i,j,3*nC+1) = (ji(nC)*dy)-dy + (dy/4)+(dy/4)*((top_neigh(i,j,3*nC+2)-ibm_ht_ystag(ii(nC),ji(nC))) &
						                	  /(ibm_ht(ii(nC),ji(nC)+1)-ibm_ht_ystag(ii(nC),ji(nC))))
		     else
			top_neigh(i,j,3*nC+1) = (ji(nC)*dy)-dy + (dy/4)*((top_neigh(i,j,3*nC+2)-ibm_ht(ii(nC),ji(nC))) &
						        	  /(ibm_ht_ystag(ii(nC),ji(nC))-ibm_ht(ii(nC),ji(nC))))
		     endif
		 elseif (stag == 3) then
		     ! solve for x/2
		     if (ibm_ht_xstag(ii(nC),ji(nC)) >= top_neigh(i,j,3*nC+2)) then
			top_neigh(i,j,3*nC) = ((ii(nC)-1)*dx)-(dx/2) +  (dx/2)+(dx/4)*((top_neigh(i,j,3*nC+2)-ibm_ht(ii(nC)-1,ji(nC))) &
						                        	/(ibm_ht_xstag(ii(nC),ji(nC))-ibm_ht(ii(nC)-1,ji(nC))))
		     else
			top_neigh(i,j,3*nC) = (ii(nC)*dx)-dx +  (dx/4)+(dx/4)*((top_neigh(i,j,3*nC+2)-ibm_ht_xstag(ii(nC),ji(nC))) &
						                              /(ibm_ht(ii(nC),ji(nC))-ibm_ht_xstag(ii(nC),ji(nC))))
		     endif
		     ! solve for y/2
		     if (ibm_ht_ystag(ii(nC),ji(nC)+1) >= top_neigh(i,j,3*nC+2)) then
			top_neigh(i,j,3*nC+1) = (ji(nC)*dy)-(dy/2) + (dy/4)+(dy/4)*((top_neigh(i,j,3*nC+2)-ibm_ht_ystag(ii(nC),ji(nC)+1)) &
						                        	 /(ibm_ht(ii(nC),ji(nC)+1)-ibm_ht_ystag(ii(nC),ji(nC)+1)))
		     else
			top_neigh(i,j,3*nC+1) = (ji(nC)*dy)-(dy/2) + (dy/4)*((top_neigh(i,j,3*nC+2)-ibm_ht(ii(nC),ji(nC))) &
								    /(ibm_ht_ystag(ii(nC),ji(nC)+1)-ibm_ht(ii(nC),ji(nC))))
		     endif
		 endif
	     elseif (bc_type == 2) then ! if neumann, start looking for a computational node
	        ! for neighbor 1 look at the computational node at ii-2,ji+2
	        if (ki(nC) > top(ii(nC)-2,ji(nC)+2)) then
		   top_neigh_i(i,j,3*nC) = ii(nC)-2
		   top_neigh_i(i,j,3*nC+1) = ji(nC)+2
		   top_neigh_i(i,j,3*nC+2) = ki(nC)	
		   if (stag ==1 ) then 			
		       top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx)
		       top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)
		   elseif (stag == 2) then
		       top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
		       top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy)	     
		   elseif (stag == 3) then
		       top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
		       top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)	     
		   endif
		   top_neigh(i,j,3*nC+2) = ht_p(top_neigh_i(i,j,3*nC),top_neigh_i(i,j,3*nC+2),top_neigh_i(i,j,3*nC+1))
		elseif (ki(nC)+1 > top(ii(nC)-2,ji(nC)+2)) then
	           top_neigh_i(i,j,3*nC) = ii(nC)-2
		   top_neigh_i(i,j,3*nC+1) = ji(nC)+2
		   top_neigh_i(i,j,3*nC+2) = ki(nC)+1	
		   if (stag ==1 ) then 			
		       top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx)
		       top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)
		   elseif (stag == 2) then
		       top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
		       top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy)	     
		   elseif (stag == 3) then
		       top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
		       top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)	     
		   endif
		   top_neigh(i,j,3*nC+2) = ht_p(top_neigh_i(i,j,3*nC),top_neigh_i(i,j,3*nC+2),top_neigh_i(i,j,3*nC+1))
		else
		   write(*,*)  'neighbors not assigned for Neumann 01110011 at ',i,j
		endif
	     endif ! end of dirichlet or neumann
	     ! neighbor 3 on the boundary on a plane at the height of the image point 
	     nC = 3
	     top_neigh_i(i,j,3*nC) = 0
	     top_neigh_i(i,j,3*nC+1) = 0
	     top_neigh_i(i,j,3*nC+2) = 0
	     ! first z
	     top_neigh(i,j,3*nC+2) = top_img(i,j,6)
	     if (stag == 1) then
		 ! solve for x/2
		 if (ibm_ht_xstag(ii(nC)-1,ji(nC)) >= top_neigh(i,j,3*nC+2)) then
		    top_neigh(i,j,3*nC) = ((ii(nC)-1)*dx)-dx + (dx/2)+(dx/4)*((top_neigh(i,j,3*nC+2)-ibm_ht(ii(nC)-1,ji(nC))) &
						                     /(ibm_ht_xstag(ii(nC)-1,ji(nC))-ibm_ht(ii(nC)-1,ji(nC))))
		 else
		    top_neigh(i,j,3*nC) = ((ii(nC)-1)*dx)-(dx/2) +  (dx/4)+(dx/4)*((top_neigh(i,j,3*nC+2)-ibm_ht_xstag(ii(nC)-1,ji(nC))) &
							                          /(ibm_ht(ii(nC),ji(nC))-ibm_ht_xstag(ii(nC)-1,ji(nC))))
		 endif	
		 ! solve for y/2
		 if (ibm_ht_ystag(ii(nC),ji(nC)+1) >= top_neigh(i,j,3*nC+2)) then
		    top_neigh(i,j,3*nC+1) = (ji(nC)*dy)-(dy/2) + (dy/4)+(dy/4)*((top_neigh(i,j,3*nC+2)-ibm_ht_ystag(ii(nC),ji(nC)+1)) &
						                             /(ibm_ht(ii(nC),ji(nC)+1)-ibm_ht_ystag(ii(nC),ji(nC)+1)))
		 else 
		    top_neigh(i,j,3*nC+1) = (ji(nC)*dy)-(dy/2) + (dy/4)*((top_neigh(i,j,3*nC+2)-ibm_ht(ii(nC),ji(nC))) &
						        	/(ibm_ht_ystag(ii(nC),ji(nC)+1)-ibm_ht(ii(nC),ji(nC))))
		 endif					  
	     elseif (stag == 2) then
		 ! solve for x/2
		 if (ibm_ht_xstag(ii(nC),ji(nC)) >= top_neigh(i,j,3*nC+2)) then
		    top_neigh(i,j,3*nC) = ((ii(nC)-1)*dx)-(dx/2) +  (dx/2)+(dx/4)*((top_neigh(i,j,3*nC+2)-ibm_ht(ii(nC)-1,ji(nC))) &
						                            /(ibm_ht_xstag(ii(nC),ji(nC))-ibm_ht(ii(nC)-1,ji(nC))))
		 else
		    top_neigh(i,j,3*nC) = (ii(nC)*dx)-dx +  (dx/4)+(dx/4)*((top_neigh(i,j,3*nC+2)-ibm_ht_xstag(ii(nC),ji(nC))) &
						                          /(ibm_ht(ii(nC),ji(nC))-ibm_ht_xstag(ii(nC),ji(nC))))
		 endif
		 ! solve for y/2
		 if (ibm_ht_ystag(ii(nC),ji(nC)) >= top_neigh(i,j,3*nC+2)) then
		    top_neigh(i,j,3*nC+1) = (ji(nC)*dy)-dy + (dy/4)+(dy/4)*((top_neigh(i,j,3*nC+2)-ibm_ht_ystag(ii(nC),ji(nC))) &
						                      /(ibm_ht(ii(nC),ji(nC)+1)-ibm_ht_ystag(ii(nC),ji(nC))))
		 else
		    top_neigh(i,j,3*nC+1) = (ji(nC)*dy)-dy + (dy/4)*((top_neigh(i,j,3*nC+2)-ibm_ht(ii(nC),ji(nC))) &
						              /(ibm_ht_ystag(ii(nC),ji(nC))-ibm_ht(ii(nC),ji(nC))))
		 endif
	     elseif (stag == 3) then
		 ! solve for x/2
		 if (ibm_ht_xstag(ii(nC),ji(nC)) >= top_neigh(i,j,3*nC+2)) then
		    top_neigh(i,j,3*nC) = ((ii(nC)-1)*dx)-(dx/2) +  (dx/2)+(dx/4)*((top_neigh(i,j,3*nC+2)-ibm_ht(ii(nC)-1,ji(nC))) &
						                            /(ibm_ht_xstag(ii(nC),ji(nC))-ibm_ht(ii(nC)-1,ji(nC))))
		 else
		    top_neigh(i,j,3*nC) = (ii(nC)*dx)-dx +  (dx/4)+(dx/4)*((top_neigh(i,j,3*nC+2)-ibm_ht_xstag(ii(nC),ji(nC))) &
						                          /(ibm_ht(ii(nC),ji(nC))-ibm_ht_xstag(ii(nC),ji(nC))))
		 endif
		 ! solve for y/2
		 if (ibm_ht_ystag(ii(nC),ji(nC)+1) >= top_neigh(i,j,3*nC+2)) then
		    top_neigh(i,j,3*nC+1) = (ji(nC)*dy)-(dy/2) + (dy/4)+(dy/4)*((top_neigh(i,j,3*nC+2)-ibm_ht_ystag(ii(nC),ji(nC)+1)) &
						                             /(ibm_ht(ii(nC),ji(nC)+1)-ibm_ht_ystag(ii(nC),ji(nC)+1)))
		 else
		    top_neigh(i,j,3*nC+1) = (ji(nC)*dy)-(dy/2) + (dy/4)*((top_neigh(i,j,3*nC+2)-ibm_ht(ii(nC),ji(nC))) &
								/(ibm_ht_ystag(ii(nC),ji(nC)+1)-ibm_ht(ii(nC),ji(nC))))
		 endif
	     endif
	   endif ! end of if neighbor 1 is a top point or not 	    
  ELSEIF ((inside(ii(0),ki(0),ji(0)) == 1).AND. &
	   (inside(ii(1),ki(1),ji(1)) == 1).AND. &
	   (inside(ii(2),ki(2),ji(2)) == 1).AND. &
	   (inside(ii(3),ki(3),ji(3)) == 1).AND. &
	   (inside(ii(4),ki(4),ji(4)) == 0).AND. &
	   (inside(ii(5),ki(5),ji(5)) == 0).AND. &
	   (inside(ii(6),ki(6),ji(6)) == 1).AND. &
	   (inside(ii(7),ki(7),ji(7)) == 0)) THEN 
	   if (bc_type == 1) then
	      ! neighbor 0 is on the boundary between 0 and 4
	      ! neighbor 1 is on the boundary between 1 and 5
	      do nC = 0,1
		 top_neigh_i(i,j,3*nC) = ii(nC)
		 top_neigh_i(i,j,3*nC+1) = 0
		 top_neigh_i(i,j,3*nC+2) = 0
		 ! first z
		 top_neigh(i,j,3*nC+2) = ht_p(ii(nC),ki(nC),ji(nC))
		 if (stag == 1) then
		     !next x
		     top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx)
		     ! solve for y
		     if (ibm_ht_ystag(ii(nC),ji(nC)+1) >= top_neigh(i,j,3*nC+2)) then
			top_neigh(i,j,3*nC+1) = (ji(nC)*dy) + (dy/2)*((top_neigh(i,j,3*nC+2)-ibm_ht_ystag(ii(nC),ji(nC)+1)) &
						        	   /(ibm_ht(ii(nC),ji(nC)+1)-ibm_ht_ystag(ii(nC),ji(nC)+1)))
		     else
			top_neigh(i,j,3*nC+1) = (ji(nC)*dy)-(dy/2) + (dy/2)*((top_neigh(i,j,3*nC+2)-ibm_ht(ii(nC),ji(nC))) &
						                    /(ibm_ht_ystag(ii(nC),ji(nC)+1)-ibm_ht(ii(nC),ji(nC))))
		     endif						  
		 elseif (stag == 2) then
		     !next x
		     top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
		     ! solve for y
		     if (ibm_ht_ystag(ii(nC),ji(nC)) >= top_neigh(i,j,3*nC+2)) then
			top_neigh(i,j,3*nC+1) = (ji(nC)*dy-(dy/2)) + (dy/2)*((top_neigh(i,j,3*nC+2)-ibm_ht_ystag(ii(nC),ji(nC))) &
						                	  /(ibm_ht(ii(nC),ji(nC)+1)-ibm_ht_ystag(ii(nC),ji(nC))))
		     else
			top_neigh(i,j,3*nC+1) = (ji(nC)*dy)-dy + (dy/2)*((top_neigh(i,j,3*nC+2)-ibm_ht(ii(nC),ji(nC))) &
						        	  /(ibm_ht_ystag(ii(nC),ji(nC))-ibm_ht(ii(nC),ji(nC))))
		     endif
		 elseif (stag == 3) then
		     !next x
		     top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
		     ! solve for y
		     if (ibm_ht_ystag(ii(nC),ji(nC)+1) >= top_neigh(i,j,3*nC+2)) then
			top_neigh(i,j,3*nC+1) = (ji(nC)*dy) + (dy/2)*((top_neigh(i,j,3*nC+2)-ibm_ht_ystag(ii(nC),ji(nC)+1)) &
						        	   /(ibm_ht(ii(nC),ji(nC)+1)-ibm_ht_ystag(ii(nC),ji(nC)+1)))
		     else
			top_neigh(i,j,3*nC+1) = (ji(nC)*dy)-(dy/2) + (dy/2)*((top_neigh(i,j,3*nC+2)-ibm_ht(ii(nC),ji(nC))) &
							            /(ibm_ht_ystag(ii(nC),ji(nC)+1)-ibm_ht(ii(nC),ji(nC))))
		     endif	
		 endif
	       enddo	   
	       ! neighbor 2 on the boundary on the 2367 plane
	       nC = 2
	       top_neigh_i(i,j,3*nC) = 0
	       top_neigh_i(i,j,3*nC+1) = 0
	       top_neigh_i(i,j,3*nC+2) = 0
	       ! first z
	       top_neigh(i,j,3*nC+2) = ht_p(ii(nC),ki(nC),ji(nC))
	       if (stag == 1) then
		   ! solve for x
		   if (ibm_ht_xstag(ii(nC),ji(nC)) >= top_neigh(i,j,3*nC+2)) then
		      top_neigh(i,j,3*nC) = (ii(nC)*dx)-dx + (dx/4)+(dx/4)*((top_neigh(i,j,3*nC+2)-ibm_ht_xstag(ii(nC),ji(nC))) &
						                	 /(ibm_ht(ii(nC)+1,ji(nC))-ibm_ht_xstag(ii(nC),ji(nC))))
		   else
		      top_neigh(i,j,3*nC) = (ii(nC)*dx)-dx + (dx/4)*((top_neigh(i,j,3*nC+2)-ibm_ht(ii(nC),ji(nC))) &
							      /(ibm_ht_xstag(ii(nC),ji(nC))-ibm_ht(ii(nC),ji(nC))))
		   endif						  
	       	   ! solve for y
		   if (ibm_ht_ystag(ii(nC),ji(nC)+1) >= top_neigh(i,j,3*nC+2)) then
		      top_neigh(i,j,3*nC+1) = (ji(nC)*dy)-(dy/2) + (dy/4)+(dy/4)*((top_neigh(i,j,3*nC+2)-ibm_ht_ystag(ii(nC),ji(nC)+1)) &
						                               /(ibm_ht(ii(nC),ji(nC)+1)-ibm_ht_ystag(ii(nC),ji(nC)+1)))
		   else
		      top_neigh(i,j,3*nC+1) = (ji(nC)*dy)-(dy/2) + (dy/4)*((top_neigh(i,j,3*nC+2)-ibm_ht(ii(nC),ji(nC))) &
								  /(ibm_ht_ystag(ii(nC),ji(nC)+1)-ibm_ht(ii(nC),ji(nC))))
		   endif
	       elseif (stag == 2) then
		   ! solve for x
		   if (ibm_ht_xstag(ii(nC)+1,ji(nC)) >= top_neigh(i,j,3*nC+2)) then
		      top_neigh(i,j,3*nC) = (ii(nC)*dx)-(dx/2) + (dx/4)+(dx/4)*((top_neigh(i,j,3*nC+2)-ibm_ht_xstag(ii(nC)+1,ji(nC))) &
						                             /(ibm_ht(ii(nC)+1,ji(nC))-ibm_ht_xstag(ii(nC)+1,ji(nC))))
		   else
		      top_neigh(i,j,3*nC) = (ii(nC)*dx)-(dx/2) + (dx/4)*((top_neigh(i,j,3*nC+2)-ibm_ht(ii(nC),ji(nC))) &
						        	/(ibm_ht_xstag(ii(nC)+1,ji(nC))-ibm_ht(ii(nC),ji(nC))))
		   endif
		   ! solve for y
		   if (ibm_ht_ystag(ii(nC),ji(nC)) >= top_neigh(i,j,3*nC+2)) then
		      top_neigh(i,j,3*nC+1) = (ji(nC)*dy)-dy + (dy/4)+(dy/4)*((top_neigh(i,j,3*nC+2)-ibm_ht_ystag(ii(nC),ji(nC))) &
						                           /(ibm_ht(ii(nC),ji(nC)+1)-ibm_ht_ystag(ii(nC),ji(nC))))
		   else
		      top_neigh(i,j,3*nC+1) = (ji(nC)*dy)-dy + (dy/4)*((top_neigh(i,j,3*nC+2)-ibm_ht(ii(nC),ji(nC))) &
						        	/(ibm_ht_ystag(ii(nC),ji(nC))-ibm_ht(ii(nC),ji(nC))))
		   endif
	      elseif (stag == 3) then
		   ! solve for x
		   if (ibm_ht_xstag(ii(nC)+1,ji(nC)) >= top_neigh(i,j,3*nC+2)) then
		      top_neigh(i,j,3*nC) = (ii(nC)*dx)-(dx/2) + (dx/4)+(dx/4)*((top_neigh(i,j,3*nC+2)-ibm_ht_xstag(ii(nC)+1,ji(nC))) &
						                             /(ibm_ht(ii(nC)+1,ji(nC))-ibm_ht_xstag(ii(nC)+1,ji(nC))))
		   else
		      top_neigh(i,j,3*nC) = (ii(nC)*dx)-(dx/2) + (dx/4)*((top_neigh(i,j,3*nC+2)-ibm_ht(ii(nC),ji(nC))) &
						        	/(ibm_ht_xstag(ii(nC)+1,ji(nC))-ibm_ht(ii(nC),ji(nC))))
		   endif
		   ! solve for y
		   if (ibm_ht_ystag(ii(nC),ji(nC)+1) >= top_neigh(i,j,3*nC+2)) then
		      top_neigh(i,j,3*nC+1) = (ji(nC)*dy)-(dy/2) + (dy/4)+(dy/4)*((top_neigh(i,j,3*nC+2)-ibm_ht_ystag(ii(nC),ji(nC)+1)) &
						                        	/(ibm_ht(ii(nC),ji(nC)+1)-ibm_ht_ystag(ii(nC),ji(nC)+1)))
		   else
		      top_neigh(i,j,3*nC+1) = (ji(nC)*dy)-(dy/2) + (dy/4)*((top_neigh(i,j,3*nC+2)-ibm_ht(ii(nC),ji(nC))) &
								  /(ibm_ht_ystag(ii(nC),ji(nC)+1)-ibm_ht(ii(nC),ji(nC))))
		   endif
	      endif
	      ! neighbor 3 is on the boundary between 3 and 7
	      nC = 3
	      top_neigh_i(i,j,3*nC) = ii(nC)
	      top_neigh_i(i,j,3*nC+1) = 0
	      top_neigh_i(i,j,3*nC+2) = 0
	      ! first z
	      top_neigh(i,j,3*nC+2) = ht_p(ii(nC),ki(nC),ji(nC))
	      if (stag == 1) then
		  !next x
		  top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx)
		  ! solve for y
		  if (ibm_ht_ystag(ii(nC),ji(nC)+1) >= top_neigh(i,j,3*nC+2)) then
		     top_neigh(i,j,3*nC+1) = (ji(nC)*dy) + (dy/2)*((top_neigh(i,j,3*nC+2)-ibm_ht_ystag(ii(nC),ji(nC)+1)) &
						        	/(ibm_ht(ii(nC),ji(nC)+1)-ibm_ht_ystag(ii(nC),ji(nC)+1)))
		  else
		     top_neigh(i,j,3*nC+1) = (ji(nC)*dy)-(dy/2) + (dy/2)*((top_neigh(i,j,3*nC+2)-ibm_ht(ii(nC),ji(nC))) &
						        	 /(ibm_ht_ystag(ii(nC),ji(nC)+1)-ibm_ht(ii(nC),ji(nC))))
		  endif						  
	      elseif (stag == 2) then
		  !next x
		  top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
		  ! solve for y
		  if (ibm_ht_ystag(ii(nC),ji(nC)) >= top_neigh(i,j,3*nC+2)) then
		     top_neigh(i,j,3*nC+1) = (ji(nC)*dy-(dy/2)) + (dy/2)*((top_neigh(i,j,3*nC+2)-ibm_ht_ystag(ii(nC),ji(nC))) &
						                       /(ibm_ht(ii(nC),ji(nC)+1)-ibm_ht_ystag(ii(nC),ji(nC))))
		  else
		     top_neigh(i,j,3*nC+1) = (ji(nC)*dy)-dy + (dy/2)*((top_neigh(i,j,3*nC+2)-ibm_ht(ii(nC),ji(nC))) &
						               /(ibm_ht_ystag(ii(nC),ji(nC))-ibm_ht(ii(nC),ji(nC))))
		  endif
	      elseif (stag == 3) then
		  !next x
		  top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
		  ! solve for y
		  if (ibm_ht_ystag(ii(nC),ji(nC)+1) >= top_neigh(i,j,3*nC+2)) then
		     top_neigh(i,j,3*nC+1) = (ji(nC)*dy) + (dy/2)*((top_neigh(i,j,3*nC+2)-ibm_ht_ystag(ii(nC),ji(nC)+1)) &
						        	/(ibm_ht(ii(nC),ji(nC)+1)-ibm_ht_ystag(ii(nC),ji(nC)+1)))
		  else
		     top_neigh(i,j,3*nC+1) = (ji(nC)*dy)-(dy/2) + (dy/2)*((top_neigh(i,j,3*nC+2)-ibm_ht(ii(nC),ji(nC))) &
								 /(ibm_ht_ystag(ii(nC),ji(nC)+1)-ibm_ht(ii(nC),ji(nC))))
		  endif	
	      endif
 	      ! neighbor 4,5,7 are the zero computational nodes
 	      do nC = 4,5
 		 top_neigh_i(i,j,3*nC) = ii(nC)
 		 top_neigh_i(i,j,3*nC+1) = ji(nC)
 		 top_neigh_i(i,j,3*nC+2) = ki(nC)		
 		 if (stag ==1 ) then  		
 		     top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx)
 		     top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)
 		 elseif (stag == 2) then
 		     top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
 		     top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy)	     
 		 elseif (stag == 3) then
 		     top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
 		     top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)	     
 		 endif
 		 top_neigh(i,j,3*nC+2) = ht_p(top_neigh_i(i,j,3*nC),top_neigh_i(i,j,3*nC+2),top_neigh_i(i,j,3*nC+1))
	      enddo	   	   
	      ! neighbor 6 on the boundary between 6 and 7
	      nC = 6
	      top_neigh_i(i,j,3*nC) = 0
	      top_neigh_i(i,j,3*nC+1) = ji(nC)
	      top_neigh_i(i,j,3*nC+2) = 0
	      ! first z
	      top_neigh(i,j,3*nC+2) = ht_p(ii(nC),ki(nC),ji(nC))
	      if (stag == 1) then
		  !next y
		  top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)
		  ! solve for x
		  if (ibm_ht_xstag(ii(nC),ji(nC)) >= top_neigh(i,j,3*nC+2)) then
		     top_neigh(i,j,3*nC) = (ii(nC)*dx)-(dx/2) + (dx/2)*((top_neigh(i,j,3*nC+2)-ibm_ht_xstag(ii(nC),ji(nC))) &
						                     /(ibm_ht(ii(nC)+1,ji(nC))-ibm_ht_xstag(ii(nC),ji(nC))))
		  else
		     top_neigh(i,j,3*nC) = (ii(nC)*dx)-dx + (dx/2)*((top_neigh(i,j,3*nC+2)-ibm_ht(ii(nC),ji(nC))) &
							     /(ibm_ht_xstag(ii(nC),ji(nC))-ibm_ht(ii(nC),ji(nC))))
		  endif						  
	      elseif (stag == 2) then
		  !next y
		  top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy)
		  ! solve for x
		  if (ibm_ht_xstag(ii(nC)+1,ji(nC)) >= top_neigh(i,j,3*nC+2)) then
		     top_neigh(i,j,3*nC) = (ii(nC)*dx) + (dx/2)*((top_neigh(i,j,3*nC+2)-ibm_ht_xstag(ii(nC)+1,ji(nC))) &
						              /(ibm_ht(ii(nC)+1,ji(nC))-ibm_ht_xstag(ii(nC)+1,ji(nC))))
		  else
		     top_neigh(i,j,3*nC) = (ii(nC)*dx)-(dx/2) + (dx/2)*((top_neigh(i,j,3*nC+2)-ibm_ht(ii(nC),ji(nC))) &
						               /(ibm_ht_xstag(ii(nC)+1,ji(nC))-ibm_ht(ii(nC),ji(nC))))
		  endif
	      elseif (stag == 3) then
		  !next y
		  top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)
		  ! solve for x
		  if (ibm_ht_xstag(ii(nC)+1,ji(nC)) >= top_neigh(i,j,3*nC+2)) then
		     top_neigh(i,j,3*nC) = (ii(nC)*dx) + (dx/2)*((top_neigh(i,j,3*nC+2)-ibm_ht_xstag(ii(nC)+1,ji(nC))) &
						              /(ibm_ht(ii(nC)+1,ji(nC))-ibm_ht_xstag(ii(nC)+1,ji(nC))))
		  else
		     top_neigh(i,j,3*nC) = (ii(nC)*dx)-(dx/2) + (dx/2)*((top_neigh(i,j,3*nC+2)-ibm_ht(ii(nC),ji(nC))) &
						               /(ibm_ht_xstag(ii(nC)+1,ji(nC))-ibm_ht(ii(nC),ji(nC))))
		  endif
	      endif
 	      ! neighbor 4,5,7 are the zero computational nodes
 	      nC = 7
 	      top_neigh_i(i,j,3*nC) = ii(nC)
 	      top_neigh_i(i,j,3*nC+1) = ji(nC)
 	      top_neigh_i(i,j,3*nC+2) = ki(nC)		
 	      if (stag ==1 ) then  		
 		  top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx)
 		  top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)
 	      elseif (stag == 2) then
 		  top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
 		  top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy)	     
 	      elseif (stag == 3) then
 		  top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
 		  top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)	     
 	      endif
 	      top_neigh(i,j,3*nC+2) = ht_p(top_neigh_i(i,j,3*nC),top_neigh_i(i,j,3*nC+2),top_neigh_i(i,j,3*nC+1))		   
	   elseif (bc_type == 2) then
	      ! if 0  and 1 are top ghost points, then the 0,1 neighbor is (ii(1),ji(1),ht(ki(1)+1) the node above it
	      ! and the 2,3 neighbor is ibm_ht(ii,jj) on the boundary	   
	      if ((ki(0)==top(ii(0),ji(0))).AND.(ki(1)==top(ii(1),ji(1)))) then
		 do nC = 0,1
		    top_neigh_i(i,j,3*nC) = ii(nC)
		    top_neigh_i(i,j,3*nC+1) = ji(nC)
		    top_neigh_i(i,j,3*nC+2) = ki(nC)+1		
		    if (stag ==1 ) then 			
			top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx)
			top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)
		    elseif (stag == 2) then
			top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
			top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy)	     
		    elseif (stag == 3) then
			top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
			top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)	     
		    endif
		    top_neigh(i,j,3*nC+2) = ht_p(top_neigh_i(i,j,3*nC),top_neigh_i(i,j,3*nC+2),top_neigh_i(i,j,3*nC+1))	   
		 enddo
		 do nC = 2,3
		    top_neigh_i(i,j,3*nC) = ii(nC)
		    top_neigh_i(i,j,3*nC+1) = ji(nC)
		    top_neigh_i(i,j,3*nC+2) = 0		
		    if (stag ==1 ) then 			
			top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx)
			top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)
		    elseif (stag == 2) then
			top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
			top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy)	     
		    elseif (stag == 3) then
			top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
			top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)	     
		    endif
		    top_neigh(i,j,3*nC+2) = ibm_ht(top_neigh_i(i,j,3*nC),top_neigh_i(i,j,3*nC+1))		 
		 enddo 
		 ! neighbors 4,5,7 are zero computational nodes
		 do nC = 4,5
		    top_neigh_i(i,j,3*nC) = ii(nC)
		    top_neigh_i(i,j,3*nC+1) = ji(nC)
		    top_neigh_i(i,j,3*nC+2) = ki(nC)		
		    if (stag ==1 ) then 			
			top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx)
			top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)
		    elseif (stag == 2) then
			top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
			top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy)	     
		    elseif (stag == 3) then
			top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
			top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)	     
		    endif
		    top_neigh(i,j,3*nC+2) = ht_p(top_neigh_i(i,j,3*nC),top_neigh_i(i,j,3*nC+2),top_neigh_i(i,j,3*nC+1)) 
		 enddo
		 ! neighbor 6 is at (ii,jj,ibm_ht(ii,jj)) on the boundary
		 nC = 6
		 top_neigh_i(i,j,3*nC) = ii(nC)
		 top_neigh_i(i,j,3*nC+1) = ji(nC)
		 top_neigh_i(i,j,3*nC+2) = 0		
		 if (stag ==1 ) then 			
		     top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx)
		     top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)
		 elseif (stag == 2) then
		     top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
		     top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy)	     
		 elseif (stag == 3) then
		     top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
		     top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)	     
		 endif
		 top_neigh(i,j,3*nC+2) = ibm_ht(top_neigh_i(i,j,3*nC),top_neigh_i(i,j,3*nC+1)) 
		 ! neighbors 4,5,7 are zero computational nodes
		 nC = 7
		 top_neigh_i(i,j,3*nC) = ii(nC)
		 top_neigh_i(i,j,3*nC+1) = ji(nC)
		 top_neigh_i(i,j,3*nC+2) = ki(nC)		
		 if (stag ==1 ) then 			
		     top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx)
		     top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)
		 elseif (stag == 2) then
		     top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
		     top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy)	     
		 elseif (stag == 3) then
		     top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
		     top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)	     
		 endif
		 top_neigh(i,j,3*nC+2) = ht_p(top_neigh_i(i,j,3*nC),top_neigh_i(i,j,3*nC+2),top_neigh_i(i,j,3*nC+1))
	      else ! if 0,1 are not top neighbors
		 ! neighbor 0 is on the boundary between 0 and 4
		 ! neighbor 1 is on the boundary between 1 and 5
		 do nC = 0,1
		    top_neigh_i(i,j,3*nC) = ii(nC)
		    top_neigh_i(i,j,3*nC+1) = 0
		    top_neigh_i(i,j,3*nC+2) = 0
		    ! first z
		    top_neigh(i,j,3*nC+2) = ht_p(ii(nC),ki(nC),ji(nC))
		    if (stag == 1) then
			!next x
			top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx)
			! solve for y
			if (ibm_ht_ystag(ii(nC),ji(nC)+1) >= top_neigh(i,j,3*nC+2)) then
			   top_neigh(i,j,3*nC+1) = (ji(nC)*dy) + (dy/2)*((top_neigh(i,j,3*nC+2)-ibm_ht_ystag(ii(nC),ji(nC)+1)) &
						        	      /(ibm_ht(ii(nC),ji(nC)+1)-ibm_ht_ystag(ii(nC),ji(nC)+1)))
			else
			   top_neigh(i,j,3*nC+1) = (ji(nC)*dy)-(dy/2) + (dy/2)*((top_neigh(i,j,3*nC+2)-ibm_ht(ii(nC),ji(nC))) &
						                       /(ibm_ht_ystag(ii(nC),ji(nC)+1)-ibm_ht(ii(nC),ji(nC))))
			endif						  
		    elseif (stag == 2) then
			!next x
			top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
			! solve for y
			if (ibm_ht_ystag(ii(nC),ji(nC)) >= top_neigh(i,j,3*nC+2)) then
			   top_neigh(i,j,3*nC+1) = (ji(nC)*dy-(dy/2)) + (dy/2)*((top_neigh(i,j,3*nC+2)-ibm_ht_ystag(ii(nC),ji(nC))) &
						                	     /(ibm_ht(ii(nC),ji(nC)+1)-ibm_ht_ystag(ii(nC),ji(nC))))
			else
			   top_neigh(i,j,3*nC+1) = (ji(nC)*dy)-dy + (dy/2)*((top_neigh(i,j,3*nC+2)-ibm_ht(ii(nC),ji(nC))) &
						        	     /(ibm_ht_ystag(ii(nC),ji(nC))-ibm_ht(ii(nC),ji(nC))))
			endif
		    elseif (stag == 3) then
			!next x
			top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
			! solve for y
			if (ibm_ht_ystag(ii(nC),ji(nC)+1) >= top_neigh(i,j,3*nC+2)) then
			   top_neigh(i,j,3*nC+1) = (ji(nC)*dy) + (dy/2)*((top_neigh(i,j,3*nC+2)-ibm_ht_ystag(ii(nC),ji(nC)+1)) &
						        	      /(ibm_ht(ii(nC),ji(nC)+1)-ibm_ht_ystag(ii(nC),ji(nC)+1)))
			else
			   top_neigh(i,j,3*nC+1) = (ji(nC)*dy)-(dy/2) + (dy/2)*((top_neigh(i,j,3*nC+2)-ibm_ht(ii(nC),ji(nC))) &
							               /(ibm_ht_ystag(ii(nC),ji(nC)+1)-ibm_ht(ii(nC),ji(nC))))
			endif	
		    endif
		  enddo	   
		 ! neighbor 3 is on the boundary between 3 and 7
		 nC = 3
		 top_neigh_i(i,j,3*nC) = ii(nC)
		 top_neigh_i(i,j,3*nC+1) = 0
		 top_neigh_i(i,j,3*nC+2) = 0
		 ! first z
		 top_neigh(i,j,3*nC+2) = ht_p(ii(nC),ki(nC),ji(nC))
		 if (stag == 1) then
		     !next x
		     top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx)
		     ! solve for y
		     if (ibm_ht_ystag(ii(nC),ji(nC)+1) >= top_neigh(i,j,3*nC+2)) then
			top_neigh(i,j,3*nC+1) = (ji(nC)*dy) + (dy/2)*((top_neigh(i,j,3*nC+2)-ibm_ht_ystag(ii(nC),ji(nC)+1)) &
						        	   /(ibm_ht(ii(nC),ji(nC)+1)-ibm_ht_ystag(ii(nC),ji(nC)+1)))
		     else
			top_neigh(i,j,3*nC+1) = (ji(nC)*dy)-(dy/2) + (dy/2)*((top_neigh(i,j,3*nC+2)-ibm_ht(ii(nC),ji(nC))) &
						        	    /(ibm_ht_ystag(ii(nC),ji(nC)+1)-ibm_ht(ii(nC),ji(nC))))
		     endif						  
		 elseif (stag == 2) then
		     !next x
		     top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
		     ! solve for y
		     if (ibm_ht_ystag(ii(nC),ji(nC)) >= top_neigh(i,j,3*nC+2)) then
			top_neigh(i,j,3*nC+1) = (ji(nC)*dy-(dy/2)) + (dy/2)*((top_neigh(i,j,3*nC+2)-ibm_ht_ystag(ii(nC),ji(nC))) &
						                	  /(ibm_ht(ii(nC),ji(nC)+1)-ibm_ht_ystag(ii(nC),ji(nC))))
		     else
			top_neigh(i,j,3*nC+1) = (ji(nC)*dy)-dy + (dy/2)*((top_neigh(i,j,3*nC+2)-ibm_ht(ii(nC),ji(nC))) &
						        	  /(ibm_ht_ystag(ii(nC),ji(nC))-ibm_ht(ii(nC),ji(nC))))
		     endif
		 elseif (stag == 3) then
		     !next x
		     top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
		     ! solve for y
		     if (ibm_ht_ystag(ii(nC),ji(nC)+1) >= top_neigh(i,j,3*nC+2)) then
			top_neigh(i,j,3*nC+1) = (ji(nC)*dy) + (dy/2)*((top_neigh(i,j,3*nC+2)-ibm_ht_ystag(ii(nC),ji(nC)+1)) &
						        	   /(ibm_ht(ii(nC),ji(nC)+1)-ibm_ht_ystag(ii(nC),ji(nC)+1)))
		     else
			top_neigh(i,j,3*nC+1) = (ji(nC)*dy)-(dy/2) + (dy/2)*((top_neigh(i,j,3*nC+2)-ibm_ht(ii(nC),ji(nC))) &
								    /(ibm_ht_ystag(ii(nC),ji(nC)+1)-ibm_ht(ii(nC),ji(nC))))
		     endif	
		 endif
 		 ! neighbor 4,5,7 are the zero computational nodes
 		 do nC = 4,5
 		    top_neigh_i(i,j,3*nC) = ii(nC)
 		    top_neigh_i(i,j,3*nC+1) = ji(nC)
 		    top_neigh_i(i,j,3*nC+2) = ki(nC)		
 		    if (stag ==1 ) then  		
 			top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx)
 			top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)
 		    elseif (stag == 2) then
 			top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
 			top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy)	     
 		    elseif (stag == 3) then
 			top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
 			top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)	     
 		    endif
 		    top_neigh(i,j,3*nC+2) = ht_p(top_neigh_i(i,j,3*nC),top_neigh_i(i,j,3*nC+2),top_neigh_i(i,j,3*nC+1))
		 enddo	   	   
		 ! neighbor 6 on the boundary between 6 and 7
		 nC = 6
		 top_neigh_i(i,j,3*nC) = 0
		 top_neigh_i(i,j,3*nC+1) = ji(nC)
		 top_neigh_i(i,j,3*nC+2) = 0
		 ! first z
		 top_neigh(i,j,3*nC+2) = ht_p(ii(nC),ki(nC),ji(nC))
		 if (stag == 1) then
		     !next y
		     top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)
		     ! solve for x
		     if (ibm_ht_xstag(ii(nC),ji(nC)) >= top_neigh(i,j,3*nC+2)) then
			top_neigh(i,j,3*nC) = (ii(nC)*dx)-(dx/2) + (dx/2)*((top_neigh(i,j,3*nC+2)-ibm_ht_xstag(ii(nC),ji(nC))) &
						                	/(ibm_ht(ii(nC)+1,ji(nC))-ibm_ht_xstag(ii(nC),ji(nC))))
		     else
			top_neigh(i,j,3*nC) = (ii(nC)*dx)-dx + (dx/2)*((top_neigh(i,j,3*nC+2)-ibm_ht(ii(nC),ji(nC))) &
								/(ibm_ht_xstag(ii(nC),ji(nC))-ibm_ht(ii(nC),ji(nC))))
		     endif						  
		 elseif (stag == 2) then
		     !next y
		     top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy)
		     ! solve for x
		     if (ibm_ht_xstag(ii(nC)+1,ji(nC)) >= top_neigh(i,j,3*nC+2)) then
			top_neigh(i,j,3*nC) = (ii(nC)*dx) + (dx/2)*((top_neigh(i,j,3*nC+2)-ibm_ht_xstag(ii(nC)+1,ji(nC))) &
						        	 /(ibm_ht(ii(nC)+1,ji(nC))-ibm_ht_xstag(ii(nC)+1,ji(nC))))
		     else
			top_neigh(i,j,3*nC) = (ii(nC)*dx)-(dx/2) + (dx/2)*((top_neigh(i,j,3*nC+2)-ibm_ht(ii(nC),ji(nC))) &
						        	  /(ibm_ht_xstag(ii(nC)+1,ji(nC))-ibm_ht(ii(nC),ji(nC))))
		     endif
		 elseif (stag == 3) then
		     !next y
		     top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)
		     ! solve for x
		     if (ibm_ht_xstag(ii(nC)+1,ji(nC)) >= top_neigh(i,j,3*nC+2)) then
			top_neigh(i,j,3*nC) = (ii(nC)*dx) + (dx/2)*((top_neigh(i,j,3*nC+2)-ibm_ht_xstag(ii(nC)+1,ji(nC))) &
						        	 /(ibm_ht(ii(nC)+1,ji(nC))-ibm_ht_xstag(ii(nC)+1,ji(nC))))
		     else
			top_neigh(i,j,3*nC) = (ii(nC)*dx)-(dx/2) + (dx/2)*((top_neigh(i,j,3*nC+2)-ibm_ht(ii(nC),ji(nC))) &
						        	  /(ibm_ht_xstag(ii(nC)+1,ji(nC))-ibm_ht(ii(nC),ji(nC))))
		     endif
		 endif
 		 ! neighbor 4,5,7 are the zero computational nodes
 		 nC = 7
 		 top_neigh_i(i,j,3*nC) = ii(nC)
 		 top_neigh_i(i,j,3*nC+1) = ji(nC)
 		 top_neigh_i(i,j,3*nC+2) = ki(nC)		
 		 if (stag ==1 ) then  		
 		     top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx)
 		     top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)
 		 elseif (stag == 2) then
 		     top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
 		     top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy)	     
 		 elseif (stag == 3) then
 		     top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
 		     top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)	     
 		 endif
 		 top_neigh(i,j,3*nC+2) = ht_p(top_neigh_i(i,j,3*nC),top_neigh_i(i,j,3*nC+2),top_neigh_i(i,j,3*nC+1))	
		 ! neighbor 2 is still not assigned, start looking around for a computational node 
	         ! for neighbor 2 look at the computational node at ii+2,ji+2
		 nC = 2
	         if (ki(nC) > top(ii(nC)+2,ji(nC)+2)) then
		    top_neigh_i(i,j,3*nC) = ii(nC)+2
		    top_neigh_i(i,j,3*nC+1) = ji(nC)+2
		    top_neigh_i(i,j,3*nC+2) = ki(nC)	
		    if (stag ==1 ) then 			
			top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx)
			top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)
		    elseif (stag == 2) then
			top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
			top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy)	     
		    elseif (stag == 3) then
			top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
			top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)	     
		    endif
		    top_neigh(i,j,3*nC+2) = ht_p(top_neigh_i(i,j,3*nC),top_neigh_i(i,j,3*nC+2),top_neigh_i(i,j,3*nC+1))
                 else
                    write(*,*)  'neighbors not assigned for Neumann 11110010 at ',i,j
		 endif
	      endif ! if 0,1 are / are not top neighbors
	   endif ! end if bc_type == 1 or 2 
  ELSEIF ((inside(ii(0),ki(0),ji(0)) == 1).AND. &
	   (inside(ii(1),ki(1),ji(1)) == 1).AND. &
	   (inside(ii(2),ki(2),ji(2)) == 1).AND. &
	   (inside(ii(3),ki(3),ji(3)) == 1).AND. &
	   (inside(ii(4),ki(4),ji(4)) == 0).AND. &
	   (inside(ii(5),ki(5),ji(5)) == 0).AND. &
	   (inside(ii(6),ki(6),ji(6)) == 0).AND. &
	   (inside(ii(7),ki(7),ji(7)) == 1)) THEN 
           if (bc_type == 1) then
	     ! neighbor 0 is on the boundary between 0 and 4
	     ! neighbor 1 is on the boundary between 1 and 5 
	     ! neighbor 2 is on the boundary between 2 and 6
	     do nC = 0,2
		top_neigh_i(i,j,3*nC) = ii(nC)
		top_neigh_i(i,j,3*nC+1) = 0
		top_neigh_i(i,j,3*nC+2) = 0
		! first z
		top_neigh(i,j,3*nC+2) = ht_p(ii(nC),ki(nC),ji(nC))
		if (stag == 1) then
		    !next x
		    top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx)
		    ! solve for y
		    if (ibm_ht_ystag(ii(nC),ji(nC)+1) >= top_neigh(i,j,3*nC+2)) then
		       top_neigh(i,j,3*nC+1) = (ji(nC)*dy) + (dy/2)*((top_neigh(i,j,3*nC+2)-ibm_ht_ystag(ii(nC),ji(nC)+1)) &
						        	  /(ibm_ht(ii(nC),ji(nC)+1)-ibm_ht_ystag(ii(nC),ji(nC)+1)))
		    else
		       top_neigh(i,j,3*nC+1) = (ji(nC)*dy)-(dy/2) + (dy/2)*((top_neigh(i,j,3*nC+2)-ibm_ht(ii(nC),ji(nC))) &
						                   /(ibm_ht_ystag(ii(nC),ji(nC)+1)-ibm_ht(ii(nC),ji(nC))))
		    endif						  
		elseif (stag == 2) then
		    !next x
		    top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
		    ! solve for y
		    if (ibm_ht_ystag(ii(nC),ji(nC)) >= top_neigh(i,j,3*nC+2)) then
		       top_neigh(i,j,3*nC+1) = (ji(nC)*dy-(dy/2)) + (dy/2)*((top_neigh(i,j,3*nC+2)-ibm_ht_ystag(ii(nC),ji(nC))) &
						                	 /(ibm_ht(ii(nC),ji(nC)+1)-ibm_ht_ystag(ii(nC),ji(nC))))
		    else
		       top_neigh(i,j,3*nC+1) = (ji(nC)*dy)-dy + (dy/2)*((top_neigh(i,j,3*nC+2)-ibm_ht(ii(nC),ji(nC))) &
						        	 /(ibm_ht_ystag(ii(nC),ji(nC))-ibm_ht(ii(nC),ji(nC))))
		    endif
		elseif (stag == 3) then
		    !next x
		    top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
		    ! solve for y
		    if (ibm_ht_ystag(ii(nC),ji(nC)+1) >= top_neigh(i,j,3*nC+2)) then
		       top_neigh(i,j,3*nC+1) = (ji(nC)*dy) + (dy/2)*((top_neigh(i,j,3*nC+2)-ibm_ht_ystag(ii(nC),ji(nC)+1)) &
						        	  /(ibm_ht(ii(nC),ji(nC)+1)-ibm_ht_ystag(ii(nC),ji(nC)+1)))
		    else
		       top_neigh(i,j,3*nC+1) = (ji(nC)*dy)-(dy/2) + (dy/2)*((top_neigh(i,j,3*nC+2)-ibm_ht(ii(nC),ji(nC))) &
							           /(ibm_ht_ystag(ii(nC),ji(nC)+1)-ibm_ht(ii(nC),ji(nC))))
		    endif	
		endif
	      enddo
	      ! neighbor 3 on the boundary face that cuts the 2367 plane
	      nC = 3
	      top_neigh_i(i,j,3*nC) = 0
	      top_neigh_i(i,j,3*nC+1) = 0
	      top_neigh_i(i,j,3*nC+2) = 0
	      ! first z
	      top_neigh(i,j,3*nC+2) = ht_p(ii(nC),ki(nC),ji(nC))
	      if (stag == 1) then
		  ! solve for x/2
		  if (ibm_ht_xstag(ii(nC)-1,ji(nC)) >= top_neigh(i,j,3*nC+2)) then
		     top_neigh(i,j,3*nC) = ((ii(nC)-1)*dx)-dx + (dx/2)+(dx/4)*((top_neigh(i,j,3*nC+2)-ibm_ht(ii(nC)-1,ji(nC))) &
						                      /(ibm_ht_xstag(ii(nC)-1,ji(nC))-ibm_ht(ii(nC)-1,ji(nC))))
		  else
		     top_neigh(i,j,3*nC) = ((ii(nC)-1)*dx)-(dx/2) +  (dx/4)+(dx/4)*((top_neigh(i,j,3*nC+2)-ibm_ht_xstag(ii(nC)-1,ji(nC))) &
							                           /(ibm_ht(ii(nC),ji(nC))-ibm_ht_xstag(ii(nC)-1,ji(nC))))
		  endif	
		  ! solve for y/2
		  if (ibm_ht_ystag(ii(nC),ji(nC)+1) >= top_neigh(i,j,3*nC+2)) then
		     top_neigh(i,j,3*nC+1) = (ji(nC)*dy)-(dy/2) + (dy/4)+(dy/4)*((top_neigh(i,j,3*nC+2)-ibm_ht_ystag(ii(nC),ji(nC)+1)) &
						                              /(ibm_ht(ii(nC),ji(nC)+1)-ibm_ht_ystag(ii(nC),ji(nC)+1)))
		  else 
		     top_neigh(i,j,3*nC+1) = (ji(nC)*dy)-(dy/2) + (dy/4)*((top_neigh(i,j,3*nC+2)-ibm_ht(ii(nC),ji(nC))) &
						        	 /(ibm_ht_ystag(ii(nC),ji(nC)+1)-ibm_ht(ii(nC),ji(nC))))
		  endif					  
	      elseif (stag == 2) then
		  ! solve for x/2
		  if (ibm_ht_xstag(ii(nC),ji(nC)) >= top_neigh(i,j,3*nC+2)) then
		     top_neigh(i,j,3*nC) = ((ii(nC)-1)*dx)-(dx/2) +  (dx/2)+(dx/4)*((top_neigh(i,j,3*nC+2)-ibm_ht(ii(nC)-1,ji(nC))) &
						                             /(ibm_ht_xstag(ii(nC),ji(nC))-ibm_ht(ii(nC)-1,ji(nC))))
		  else
		     top_neigh(i,j,3*nC) = (ii(nC)*dx)-dx +  (dx/4)+(dx/4)*((top_neigh(i,j,3*nC+2)-ibm_ht_xstag(ii(nC),ji(nC))) &
						                           /(ibm_ht(ii(nC),ji(nC))-ibm_ht_xstag(ii(nC),ji(nC))))
		  endif
		  ! solve for y/2
		  if (ibm_ht_ystag(ii(nC),ji(nC)) >= top_neigh(i,j,3*nC+2)) then
		     top_neigh(i,j,3*nC+1) = (ji(nC)*dy)-dy + (dy/4)+(dy/4)*((top_neigh(i,j,3*nC+2)-ibm_ht_ystag(ii(nC),ji(nC))) &
						                       /(ibm_ht(ii(nC),ji(nC)+1)-ibm_ht_ystag(ii(nC),ji(nC))))
		  else
		     top_neigh(i,j,3*nC+1) = (ji(nC)*dy)-dy + (dy/4)*((top_neigh(i,j,3*nC+2)-ibm_ht(ii(nC),ji(nC))) &
						               /(ibm_ht_ystag(ii(nC),ji(nC))-ibm_ht(ii(nC),ji(nC))))
		  endif
	      elseif (stag == 3) then
		  ! solve for x/2
		  if (ibm_ht_xstag(ii(nC),ji(nC)) >= top_neigh(i,j,3*nC+2)) then
		     top_neigh(i,j,3*nC) = ((ii(nC)-1)*dx)-(dx/2) +  (dx/2)+(dx/4)*((top_neigh(i,j,3*nC+2)-ibm_ht(ii(nC)-1,ji(nC))) &
						                             /(ibm_ht_xstag(ii(nC),ji(nC))-ibm_ht(ii(nC)-1,ji(nC))))
		  else
		     top_neigh(i,j,3*nC) = (ii(nC)*dx)-dx +  (dx/4)+(dx/4)*((top_neigh(i,j,3*nC+2)-ibm_ht_xstag(ii(nC),ji(nC))) &
						                           /(ibm_ht(ii(nC),ji(nC))-ibm_ht_xstag(ii(nC),ji(nC))))
		  endif
		  ! solve for y/2
		  if (ibm_ht_ystag(ii(nC),ji(nC)+1) >= top_neigh(i,j,3*nC+2)) then
		     top_neigh(i,j,3*nC+1) = (ji(nC)*dy)-(dy/2) + (dy/4)+(dy/4)*((top_neigh(i,j,3*nC+2)-ibm_ht_ystag(ii(nC),ji(nC)+1)) &
						                              /(ibm_ht(ii(nC),ji(nC)+1)-ibm_ht_ystag(ii(nC),ji(nC)+1)))
		  else
		     top_neigh(i,j,3*nC+1) = (ji(nC)*dy)-(dy/2) + (dy/4)*((top_neigh(i,j,3*nC+2)-ibm_ht(ii(nC),ji(nC))) &
								 /(ibm_ht_ystag(ii(nC),ji(nC)+1)-ibm_ht(ii(nC),ji(nC))))
		  endif
	      endif	   
 	      ! neighbor 4,5,6 are the zero computational nodes
 	      do nC = 4,6
 		 top_neigh_i(i,j,3*nC) = ii(nC)
 		 top_neigh_i(i,j,3*nC+1) = ji(nC)
 		 top_neigh_i(i,j,3*nC+2) = ki(nC)		
 		 if (stag ==1 ) then  		
 		     top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx)
 		     top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)
 		 elseif (stag == 2) then
 		     top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
 		     top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy)	     
 		 elseif (stag == 3) then
 		     top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
 		     top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)	     
 		 endif
 		 top_neigh(i,j,3*nC+2) = ht_p(top_neigh_i(i,j,3*nC),top_neigh_i(i,j,3*nC+2),top_neigh_i(i,j,3*nC+1))
	      enddo	   
	      ! neighbor 7 is on the boundary between 6 and 7 
	      nC = 7
	      top_neigh_i(i,j,3*nC) = 0
	      top_neigh_i(i,j,3*nC+1) = ji(nC)
	      top_neigh_i(i,j,3*nC+2) = 0
	      ! first z
	      top_neigh(i,j,3*nC+2) = ht_p(ii(nC),ki(nC),ji(nC))
	      if (stag == 1) then
		  !next y
		  top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)
		  ! solve for x
		  if (ibm_ht_xstag(ii(nC)-1,ji(nC)) >= top_neigh(i,j,3*nC+2)) then
		     top_neigh(i,j,3*nC) = ((ii(nC)-1)*dx)-dx + (dx/2)*((top_neigh(i,j,3*nC+2)-ibm_ht(ii(nC)-1,ji(nC))) &
							       /(ibm_ht_xstag(ii(nC)-1,ji(nC))-ibm_ht(ii(nC)-1,ji(nC))))
		  else
		     top_neigh(i,j,3*nC) = ((ii(nC)-1)*dx)-(dx/2) + (dx/2)*((top_neigh(i,j,3*nC+2)-ibm_ht_xstag(ii(nC)-1,ji(nC))) &
									   /(ibm_ht(ii(nC),ji(nC))-ibm_ht_xstag(ii(nC)-1,ji(nC))))
		  endif 						 
	      elseif (stag == 2) then
		  !next y
		  top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy)
		  ! solve for x
		  if (ibm_ht_xstag(ii(nC),ji(nC)) >= top_neigh(i,j,3*nC+2)) then
		     top_neigh(i,j,3*nC) = ((ii(nC)-1)*dx)-(dx/2) + (dx/2)*((top_neigh(i,j,3*nC+2)-ibm_ht(ii(nC)-1,ji(nC))) &
								     /(ibm_ht_xstag(ii(nC),ji(nC))-ibm_ht(ii(nC)-1,ji(nC))))
		  else
		     top_neigh(i,j,3*nC) = (ii(nC)*dx)-dx + (dx/2)*((top_neigh(i,j,3*nC+2)-ibm_ht_xstag(ii(nC),ji(nC))) &
								   /(ibm_ht(ii(nC),ji(nC))-ibm_ht_xstag(ii(nC),ji(nC))))
		  endif
	      elseif (stag == 3) then
		  !next y
		  top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)
		  ! solve for x
		  if (ibm_ht_xstag(ii(nC),ji(nC)) >= top_neigh(i,j,3*nC+2)) then
		     top_neigh(i,j,3*nC) = ((ii(nC)-1)*dx)-(dx/2) + (dx/2)*((top_neigh(i,j,3*nC+2)-ibm_ht(ii(nC)-1,ji(nC))) &
								     /(ibm_ht_xstag(ii(nC),ji(nC))-ibm_ht(ii(nC)-1,ji(nC))))
		  else
		     top_neigh(i,j,3*nC) = (ii(nC)*dx)-dx + (dx/2)*((top_neigh(i,j,3*nC+2)-ibm_ht_xstag(ii(nC),ji(nC))) &
								    /(ibm_ht(ii(nC),ji(nC))-ibm_ht_xstag(ii(nC),ji(nC))))
		  endif
	      endif
	   elseif (bc_type == 2) then
	      ! if 0  and 1 are top ghost points, then the 0,1 neighbor is (ii(1),ji(1),ht(ki(1)+1) the node above it
	      ! and the 2,3 neighbor is ibm_ht(ii,jj) on the boundary
	      if ((ki(0)==top(ii(0),ji(0))).AND.(ki(1)==top(ii(1),ji(1)))) then
		 do nC = 0,1
		    top_neigh_i(i,j,3*nC) = ii(nC)
		    top_neigh_i(i,j,3*nC+1) = ji(nC)
		    top_neigh_i(i,j,3*nC+2) = ki(nC)+1		
		    if (stag ==1 ) then 			
			top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx)
			top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)
		    elseif (stag == 2) then
			top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
			top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy)	     
		    elseif (stag == 3) then
			top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
			top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)	     
		    endif
		    top_neigh(i,j,3*nC+2) = ht_p(top_neigh_i(i,j,3*nC),top_neigh_i(i,j,3*nC+2),top_neigh_i(i,j,3*nC+1))	   
		 enddo
		 do nC = 2,3
		    top_neigh_i(i,j,3*nC) = ii(nC)
		    top_neigh_i(i,j,3*nC+1) = ji(nC)
		    top_neigh_i(i,j,3*nC+2) = 0		
		    if (stag ==1 ) then 			
			top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx)
			top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)
		    elseif (stag == 2) then
			top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
			top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy)	     
		    elseif (stag == 3) then
			top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
			top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)	     
		    endif
		    top_neigh(i,j,3*nC+2) = ibm_ht(top_neigh_i(i,j,3*nC),top_neigh_i(i,j,3*nC+1))		 
		 enddo 
		 ! neighbors 4,5,6 are zero computational nodes
		 do nC = 4,6
		    top_neigh_i(i,j,3*nC) = ii(nC)
		    top_neigh_i(i,j,3*nC+1) = ji(nC)
		    top_neigh_i(i,j,3*nC+2) = ki(nC)		
		    if (stag ==1 ) then 			
			top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx)
			top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)
		    elseif (stag == 2) then
			top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
			top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy)	     
		    elseif (stag == 3) then
			top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
			top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)	     
		    endif
		    top_neigh(i,j,3*nC+2) = ht_p(top_neigh_i(i,j,3*nC),top_neigh_i(i,j,3*nC+2),top_neigh_i(i,j,3*nC+1)) 
		 enddo
		 ! neighbor 7 is at (ii,jj,ibm_ht(ii,jj)) on the boundary
		 nC = 7
		 top_neigh_i(i,j,3*nC) = ii(nC)
		 top_neigh_i(i,j,3*nC+1) = ji(nC)
		 top_neigh_i(i,j,3*nC+2) = 0		
		 if (stag ==1 ) then 			
		     top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx)
		     top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)
		 elseif (stag == 2) then
		     top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
		     top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy)	     
		 elseif (stag == 3) then
		     top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
		     top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)	     
		 endif
		 top_neigh(i,j,3*nC+2) = ibm_ht(top_neigh_i(i,j,3*nC),top_neigh_i(i,j,3*nC+1)) 
	      else ! if 0,1 are not top neighbors
		! neighbor 0 is on the boundary between 0 and 4
		! neighbor 1 is on the boundary between 1 and 5 
		! neighbor 2 is on the boundary between 2 and 6
		do nC = 0,2
		   top_neigh_i(i,j,3*nC) = ii(nC)
		   top_neigh_i(i,j,3*nC+1) = 0
		   top_neigh_i(i,j,3*nC+2) = 0
		   ! first z
		   top_neigh(i,j,3*nC+2) = ht_p(ii(nC),ki(nC),ji(nC))
		   if (stag == 1) then
		       !next x
		       top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx)
		       ! solve for y
		       if (ibm_ht_ystag(ii(nC),ji(nC)+1) >= top_neigh(i,j,3*nC+2)) then
			  top_neigh(i,j,3*nC+1) = (ji(nC)*dy) + (dy/2)*((top_neigh(i,j,3*nC+2)-ibm_ht_ystag(ii(nC),ji(nC)+1)) &
						        	     /(ibm_ht(ii(nC),ji(nC)+1)-ibm_ht_ystag(ii(nC),ji(nC)+1)))
		       else
			  top_neigh(i,j,3*nC+1) = (ji(nC)*dy)-(dy/2) + (dy/2)*((top_neigh(i,j,3*nC+2)-ibm_ht(ii(nC),ji(nC))) &
						                      /(ibm_ht_ystag(ii(nC),ji(nC)+1)-ibm_ht(ii(nC),ji(nC))))
		       endif						  
		   elseif (stag == 2) then
		       !next x
		       top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
		       ! solve for y
		       if (ibm_ht_ystag(ii(nC),ji(nC)) >= top_neigh(i,j,3*nC+2)) then
			  top_neigh(i,j,3*nC+1) = (ji(nC)*dy-(dy/2)) + (dy/2)*((top_neigh(i,j,3*nC+2)-ibm_ht_ystag(ii(nC),ji(nC))) &
						                	    /(ibm_ht(ii(nC),ji(nC)+1)-ibm_ht_ystag(ii(nC),ji(nC))))
		       else
			  top_neigh(i,j,3*nC+1) = (ji(nC)*dy)-dy + (dy/2)*((top_neigh(i,j,3*nC+2)-ibm_ht(ii(nC),ji(nC))) &
						        	    /(ibm_ht_ystag(ii(nC),ji(nC))-ibm_ht(ii(nC),ji(nC))))
		       endif
		   elseif (stag == 3) then
		       !next x
		       top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
		       ! solve for y
		       if (ibm_ht_ystag(ii(nC),ji(nC)+1) >= top_neigh(i,j,3*nC+2)) then
			  top_neigh(i,j,3*nC+1) = (ji(nC)*dy) + (dy/2)*((top_neigh(i,j,3*nC+2)-ibm_ht_ystag(ii(nC),ji(nC)+1)) &
						        	     /(ibm_ht(ii(nC),ji(nC)+1)-ibm_ht_ystag(ii(nC),ji(nC)+1)))
		       else
			  top_neigh(i,j,3*nC+1) = (ji(nC)*dy)-(dy/2) + (dy/2)*((top_neigh(i,j,3*nC+2)-ibm_ht(ii(nC),ji(nC))) &
							              /(ibm_ht_ystag(ii(nC),ji(nC)+1)-ibm_ht(ii(nC),ji(nC))))
		       endif	
		   endif
		 enddo
 		 ! neighbor 4,5,6 are the zero computational nodes
 		 do nC = 4,6
 		    top_neigh_i(i,j,3*nC) = ii(nC)
 		    top_neigh_i(i,j,3*nC+1) = ji(nC)
 		    top_neigh_i(i,j,3*nC+2) = ki(nC)		
 		    if (stag ==1 ) then  		
 			top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx)
 			top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)
 		    elseif (stag == 2) then
 			top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
 			top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy)	     
 		    elseif (stag == 3) then
 			top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
 			top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)	     
 		    endif
 		    top_neigh(i,j,3*nC+2) = ht_p(top_neigh_i(i,j,3*nC),top_neigh_i(i,j,3*nC+2),top_neigh_i(i,j,3*nC+1))
		 enddo	   
		 ! neighbor 7 is on the boundary between 6 and 7 
		 nC = 7
		 top_neigh_i(i,j,3*nC) = 0
		 top_neigh_i(i,j,3*nC+1) = ji(nC)
		 top_neigh_i(i,j,3*nC+2) = 0
		 ! first z
		 top_neigh(i,j,3*nC+2) = ht_p(ii(nC),ki(nC),ji(nC))
		 if (stag == 1) then
		     !next y
		     top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)
		     ! solve for x
		     if (ibm_ht_xstag(ii(nC)-1,ji(nC)) >= top_neigh(i,j,3*nC+2)) then
			top_neigh(i,j,3*nC) = ((ii(nC)-1)*dx)-dx + (dx/2)*((top_neigh(i,j,3*nC+2)-ibm_ht(ii(nC)-1,ji(nC))) &
								  /(ibm_ht_xstag(ii(nC)-1,ji(nC))-ibm_ht(ii(nC)-1,ji(nC))))
		     else
			top_neigh(i,j,3*nC) = ((ii(nC)-1)*dx)-(dx/2) + (dx/2)*((top_neigh(i,j,3*nC+2)-ibm_ht_xstag(ii(nC)-1,ji(nC))) &
									      /(ibm_ht(ii(nC),ji(nC))-ibm_ht_xstag(ii(nC)-1,ji(nC))))
		     endif 						 
		 elseif (stag == 2) then
		     !next y
		     top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy)
		     ! solve for x
		     if (ibm_ht_xstag(ii(nC),ji(nC)) >= top_neigh(i,j,3*nC+2)) then
			top_neigh(i,j,3*nC) = ((ii(nC)-1)*dx)-(dx/2) + (dx/2)*((top_neigh(i,j,3*nC+2)-ibm_ht(ii(nC)-1,ji(nC))) &
									/(ibm_ht_xstag(ii(nC),ji(nC))-ibm_ht(ii(nC)-1,ji(nC))))
		     else
			top_neigh(i,j,3*nC) = (ii(nC)*dx)-dx + (dx/2)*((top_neigh(i,j,3*nC+2)-ibm_ht_xstag(ii(nC),ji(nC))) &
								      /(ibm_ht(ii(nC),ji(nC))-ibm_ht_xstag(ii(nC),ji(nC))))
		     endif
		 elseif (stag == 3) then
		     !next y
		     top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)
		     ! solve for x
		     if (ibm_ht_xstag(ii(nC),ji(nC)) >= top_neigh(i,j,3*nC+2)) then
			top_neigh(i,j,3*nC) = ((ii(nC)-1)*dx)-(dx/2) + (dx/2)*((top_neigh(i,j,3*nC+2)-ibm_ht(ii(nC)-1,ji(nC))) &
									/(ibm_ht_xstag(ii(nC),ji(nC))-ibm_ht(ii(nC)-1,ji(nC))))
		     else
			top_neigh(i,j,3*nC) = (ii(nC)*dx)-dx + (dx/2)*((top_neigh(i,j,3*nC+2)-ibm_ht_xstag(ii(nC),ji(nC))) &
								       /(ibm_ht(ii(nC),ji(nC))-ibm_ht_xstag(ii(nC),ji(nC))))
		     endif
		 endif	      
                 ! neighbor 3 is still not assigned, start looking around for a computational node 
	         ! for neighbor 3 look at the computational node at ii-2,ji+2
		 nC = 3
	         if (ki(nC) > top(ii(nC)-2,ji(nC)+2)) then
		    top_neigh_i(i,j,3*nC) = ii(nC)-2
		    top_neigh_i(i,j,3*nC+1) = ji(nC)+2
		    top_neigh_i(i,j,3*nC+2) = ki(nC)	
		    if (stag ==1 ) then 			
			top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx)
			top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)
		    elseif (stag == 2) then
			top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
			top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy)	     
		    elseif (stag == 3) then
			top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
			top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)	     
		    endif
		    top_neigh(i,j,3*nC+2) = ht_p(top_neigh_i(i,j,3*nC),top_neigh_i(i,j,3*nC+2),top_neigh_i(i,j,3*nC+1))
                 else
                    write(*,*)  'neighbors not assigned for Neumann 11110001 at ',i,j
		 endif
	      endif ! if 0,1 are / are not top neighbors
	   endif ! end of if bc_type = 1 or 2
   ELSEIF ((inside(ii(0),ki(0),ji(0)) == 1).AND. &
	   (inside(ii(1),ki(1),ji(1)) == 0).AND. &
	   (inside(ii(2),ki(2),ji(2)) == 1).AND. &
	   (inside(ii(3),ki(3),ji(3)) == 0).AND. &
	   (inside(ii(4),ki(4),ji(4)) == 1).AND. &
	   (inside(ii(5),ki(5),ji(5)) == 0).AND. &
	   (inside(ii(6),ki(6),ji(6)) == 1).AND. &
	   (inside(ii(7),ki(7),ji(7)) == 1)) THEN
	   if (bc_type == 1) then
	      ! neighbor 0 on the boundary between 0 and 1
	      nC = 0 
	      top_neigh_i(i,j,3*nC) = 0
	      top_neigh_i(i,j,3*nC+1) = ji(nC)
	      top_neigh_i(i,j,3*nC+2) = 0
	      ! first z
	      top_neigh(i,j,3*nC+2) = ht_p(ii(nC),ki(nC),ji(nC))
	      if (stag == 1) then
		  !next y
		  top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)
		  ! solve for x
		  if (ibm_ht_xstag(ii(nC),ji(nC)) >= top_neigh(i,j,3*nC+2)) then
		     top_neigh(i,j,3*nC) = (ii(nC)*dx)-(dx/2) + (dx/2)*((top_neigh(i,j,3*nC+2)-ibm_ht_xstag(ii(nC),ji(nC))) &
						                     /(ibm_ht(ii(nC)+1,ji(nC))-ibm_ht_xstag(ii(nC),ji(nC))))
		  else
		     top_neigh(i,j,3*nC) = (ii(nC)*dx)-dx + (dx/2)*((top_neigh(i,j,3*nC+2)-ibm_ht(ii(nC),ji(nC))) &
							     /(ibm_ht_xstag(ii(nC),ji(nC))-ibm_ht(ii(nC),ji(nC))))
		  endif						  
	      elseif (stag == 2) then
		  !next y
		  top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy)
		  ! solve for x
		  if (ibm_ht_xstag(ii(nC)+1,ji(nC)) >= top_neigh(i,j,3*nC+2)) then
		     top_neigh(i,j,3*nC) = (ii(nC)*dx) + (dx/2)*((top_neigh(i,j,3*nC+2)-ibm_ht_xstag(ii(nC)+1,ji(nC))) &
						              /(ibm_ht(ii(nC)+1,ji(nC))-ibm_ht_xstag(ii(nC)+1,ji(nC))))
		  else
		     top_neigh(i,j,3*nC) = (ii(nC)*dx)-(dx/2) + (dx/2)*((top_neigh(i,j,3*nC+2)-ibm_ht(ii(nC),ji(nC))) &
						               /(ibm_ht_xstag(ii(nC)+1,ji(nC))-ibm_ht(ii(nC),ji(nC))))
		  endif
	      elseif (stag == 3) then
		  !next y
		  top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)
		  ! solve for x
		  if (ibm_ht_xstag(ii(nC)+1,ji(nC)) >= top_neigh(i,j,3*nC+2)) then
		     top_neigh(i,j,3*nC) = (ii(nC)*dx) + (dx/2)*((top_neigh(i,j,3*nC+2)-ibm_ht_xstag(ii(nC)+1,ji(nC))) &
						              /(ibm_ht(ii(nC)+1,ji(nC))-ibm_ht_xstag(ii(nC)+1,ji(nC))))
		  else
		     top_neigh(i,j,3*nC) = (ii(nC)*dx)-(dx/2) + (dx/2)*((top_neigh(i,j,3*nC+2)-ibm_ht(ii(nC),ji(nC))) &
						               /(ibm_ht_xstag(ii(nC)+1,ji(nC))-ibm_ht(ii(nC),ji(nC))))
		  endif
	      endif
	      ! neighbors 1,3,5 are zero computational node
	      nC = 1
	      top_neigh_i(i,j,3*nC) = ii(nC)
	      top_neigh_i(i,j,3*nC+1) = ji(nC)
	      top_neigh_i(i,j,3*nC+2) = ki(nC)		
	      if (stag ==1 ) then 			
		  top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx)
		  top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)
	      elseif (stag == 2) then
		  top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
		  top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy)	     
	      elseif (stag == 3) then
		  top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
		  top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)	     
	      endif
              top_neigh(i,j,3*nC+2) = ht_p(top_neigh_i(i,j,3*nC),top_neigh_i(i,j,3*nC+2),top_neigh_i(i,j,3*nC+1))	   
	      ! neighbor 2 on the boundary between 2 and 3
	      nC = 2
	      top_neigh_i(i,j,3*nC) = 0
	      top_neigh_i(i,j,3*nC+1) = ji(nC)
	      top_neigh_i(i,j,3*nC+2) = 0
	      ! first z
	      top_neigh(i,j,3*nC+2) = ht_p(ii(nC),ki(nC),ji(nC))
	      if (stag == 1) then
		  !next y
		  top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)
		  ! solve for x
		  if (ibm_ht_xstag(ii(nC),ji(nC)) >= top_neigh(i,j,3*nC+2)) then
		     top_neigh(i,j,3*nC) = (ii(nC)*dx)-(dx/2) + (dx/2)*((top_neigh(i,j,3*nC+2)-ibm_ht_xstag(ii(nC),ji(nC))) &
						                     /(ibm_ht(ii(nC)+1,ji(nC))-ibm_ht_xstag(ii(nC),ji(nC))))
		  else
		     top_neigh(i,j,3*nC) = (ii(nC)*dx)-dx + (dx/2)*((top_neigh(i,j,3*nC+2)-ibm_ht(ii(nC),ji(nC))) &
							     /(ibm_ht_xstag(ii(nC),ji(nC))-ibm_ht(ii(nC),ji(nC))))
		  endif						  
	      elseif (stag == 2) then
		  !next y
		  top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy)
		  ! solve for x
		  if (ibm_ht_xstag(ii(nC)+1,ji(nC)) >= top_neigh(i,j,3*nC+2)) then
		     top_neigh(i,j,3*nC) = (ii(nC)*dx) + (dx/2)*((top_neigh(i,j,3*nC+2)-ibm_ht_xstag(ii(nC)+1,ji(nC))) &
						              /(ibm_ht(ii(nC)+1,ji(nC))-ibm_ht_xstag(ii(nC)+1,ji(nC))))
		  else
		     top_neigh(i,j,3*nC) = (ii(nC)*dx)-(dx/2) + (dx/2)*((top_neigh(i,j,3*nC+2)-ibm_ht(ii(nC),ji(nC))) &
						               /(ibm_ht_xstag(ii(nC)+1,ji(nC))-ibm_ht(ii(nC),ji(nC))))
		  endif
	      elseif (stag == 3) then
		  !next y
		  top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)
		  ! solve for x
		  if (ibm_ht_xstag(ii(nC)+1,ji(nC)) >= top_neigh(i,j,3*nC+2)) then
		     top_neigh(i,j,3*nC) = (ii(nC)*dx) + (dx/2)*((top_neigh(i,j,3*nC+2)-ibm_ht_xstag(ii(nC)+1,ji(nC))) &
						              /(ibm_ht(ii(nC)+1,ji(nC))-ibm_ht_xstag(ii(nC)+1,ji(nC))))
		  else
		     top_neigh(i,j,3*nC) = (ii(nC)*dx)-(dx/2) + (dx/2)*((top_neigh(i,j,3*nC+2)-ibm_ht(ii(nC),ji(nC))) &
						               /(ibm_ht_xstag(ii(nC)+1,ji(nC))-ibm_ht(ii(nC),ji(nC))))
		  endif
	      endif
	      ! neighbors 1,3,5 are zero computational node
	      nC = 3
	      top_neigh_i(i,j,3*nC) = ii(nC)
	      top_neigh_i(i,j,3*nC+1) = ji(nC)
	      top_neigh_i(i,j,3*nC+2) = ki(nC)		
	      if (stag ==1 ) then 			
		  top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx)
		  top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)
	      elseif (stag == 2) then
		  top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
		  top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy)	     
	      elseif (stag == 3) then
		  top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
		  top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)	     
	      endif
	      top_neigh(i,j,3*nC+2) = ht_p(top_neigh_i(i,j,3*nC),top_neigh_i(i,j,3*nC+2),top_neigh_i(i,j,3*nC+1))
	      ! neighbor 4 on the boundary between 4 and 5
	      nC = 4
	      top_neigh_i(i,j,3*nC) = 0
	      top_neigh_i(i,j,3*nC+1) = ji(nC)
	      top_neigh_i(i,j,3*nC+2) = 0
	      ! first z
	      top_neigh(i,j,3*nC+2) = ht_p(ii(nC),ki(nC),ji(nC))
	      if (stag == 1) then
		  !next y
		  top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)
		  ! solve for x
		  if (ibm_ht_xstag(ii(nC),ji(nC)) >= top_neigh(i,j,3*nC+2)) then
		     top_neigh(i,j,3*nC) = (ii(nC)*dx)-(dx/2) + (dx/2)*((top_neigh(i,j,3*nC+2)-ibm_ht_xstag(ii(nC),ji(nC))) &
						                     /(ibm_ht(ii(nC)+1,ji(nC))-ibm_ht_xstag(ii(nC),ji(nC))))
		  else
		     top_neigh(i,j,3*nC) = (ii(nC)*dx)-dx + (dx/2)*((top_neigh(i,j,3*nC+2)-ibm_ht(ii(nC),ji(nC))) &
							     /(ibm_ht_xstag(ii(nC),ji(nC))-ibm_ht(ii(nC),ji(nC))))
		  endif						  
	      elseif (stag == 2) then
		  !next y
		  top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy)
		  ! solve for x
		  if (ibm_ht_xstag(ii(nC)+1,ji(nC)) >= top_neigh(i,j,3*nC+2)) then
		     top_neigh(i,j,3*nC) = (ii(nC)*dx) + (dx/2)*((top_neigh(i,j,3*nC+2)-ibm_ht_xstag(ii(nC)+1,ji(nC))) &
						              /(ibm_ht(ii(nC)+1,ji(nC))-ibm_ht_xstag(ii(nC)+1,ji(nC))))
		  else
		     top_neigh(i,j,3*nC) = (ii(nC)*dx)-(dx/2) + (dx/2)*((top_neigh(i,j,3*nC+2)-ibm_ht(ii(nC),ji(nC))) &
						               /(ibm_ht_xstag(ii(nC)+1,ji(nC))-ibm_ht(ii(nC),ji(nC))))
		  endif
	      elseif (stag == 3) then
		  !next y
		  top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)
		  ! solve for x
		  if (ibm_ht_xstag(ii(nC)+1,ji(nC)) >= top_neigh(i,j,3*nC+2)) then
		     top_neigh(i,j,3*nC) = (ii(nC)*dx) + (dx/2)*((top_neigh(i,j,3*nC+2)-ibm_ht_xstag(ii(nC)+1,ji(nC))) &
						              /(ibm_ht(ii(nC)+1,ji(nC))-ibm_ht_xstag(ii(nC)+1,ji(nC))))
		  else
		     top_neigh(i,j,3*nC) = (ii(nC)*dx)-(dx/2) + (dx/2)*((top_neigh(i,j,3*nC+2)-ibm_ht(ii(nC),ji(nC))) &
						               /(ibm_ht_xstag(ii(nC)+1,ji(nC))-ibm_ht(ii(nC),ji(nC))))
		  endif
	      endif	   
	      ! neighbors 1,3,5 are zero computational node
	      nC = 5
	      top_neigh_i(i,j,3*nC) = ii(nC)
	      top_neigh_i(i,j,3*nC+1) = ji(nC)
	      top_neigh_i(i,j,3*nC+2) = ki(nC)		
	      if (stag ==1 ) then 			
		  top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx)
		  top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)
	      elseif (stag == 2) then
		  top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
		  top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy)	     
	      elseif (stag == 3) then
		  top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
		  top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)	     
	      endif
	      top_neigh(i,j,3*nC+2) = ht_p(top_neigh_i(i,j,3*nC),top_neigh_i(i,j,3*nC+2),top_neigh_i(i,j,3*nC+1)) 
	      ! neighbor 6 on the boundary on the 2367 plane 
	      nC = 6
	      top_neigh_i(i,j,3*nC) = 0
	      top_neigh_i(i,j,3*nC+1) = 0
	      top_neigh_i(i,j,3*nC+2) = 0
	      ! first z
	      top_neigh(i,j,3*nC+2) = ht_p(ii(nC),ki(nC),ji(nC))
	      if (stag == 1) then
		  ! solve for x
		  if (ibm_ht_xstag(ii(nC),ji(nC)) >= top_neigh(i,j,3*nC+2)) then
		     top_neigh(i,j,3*nC) = (ii(nC)*dx)-dx +(dx/4)+(dx/4)*((top_neigh(i,j,3*nC+2)-ibm_ht_xstag(ii(nC),ji(nC))) &
						                	 /(ibm_ht(ii(nC)+1,ji(nC))-ibm_ht_xstag(ii(nC),ji(nC))))
		  else
		     top_neigh(i,j,3*nC) = (ii(nC)*dx)-dx + (dx/4)*((top_neigh(i,j,3*nC+2)-ibm_ht(ii(nC),ji(nC))) &
						             /(ibm_ht_xstag(ii(nC),ji(nC))-ibm_ht(ii(nC),ji(nC))))
		  endif						  
		  ! solve for y
		  if (ibm_ht_ystag(ii(nC),ji(nC)) >= top_neigh(i,j,3*nC+2)) then
		     top_neigh(i,j,3*nC+1) = ((ji(nC)-1)*dy) +(dy/4)*((top_neigh(i,j,3*nC+2)-ibm_ht(ii(nC),ji(nC)-1)) &
						               /(ibm_ht_ystag(ii(nC),ji(nC))-ibm_ht(ii(nC),ji(nC)-1)))
		  else
		     top_neigh(i,j,3*nC+1) = ((ji(nC)-1)*dy)-dy + (dy/4)+(dy/4)*((top_neigh(i,j,3*nC+2)-ibm_ht_ystag(ii(nC),ji(nC))) &
							                            /(ibm_ht(ii(nC),ji(nC))-ibm_ht_ystag(ii(nC),ji(nC))))
		  endif
	      elseif (stag == 2) then
		  ! solve for x
		  if (ibm_ht_xstag(ii(nC)+1,ji(nC)) >= top_neigh(i,j,3*nC+2)) then
		     top_neigh(i,j,3*nC) = (ii(nC)*dx)-(dx/2) + (dx/4)+(dx/4)*((top_neigh(i,j,3*nC+2)-ibm_ht_xstag(ii(nC)+1,ji(nC))) &
						                            /(ibm_ht(ii(nC)+1,ji(nC))-ibm_ht_xstag(ii(nC)+1,ji(nC))))
		  else
		     top_neigh(i,j,3*nC) = (ii(nC)*dx)-(dx/2) + (dx/4)*((top_neigh(i,j,3*nC+2)-ibm_ht(ii(nC),ji(nC))) &
						               /(ibm_ht_xstag(ii(nC)+1,ji(nC))-ibm_ht(ii(nC),ji(nC))))
		  endif
		  ! solve for y
		  if (ibm_ht_ystag(ii(nC),ji(nC)-1) >= top_neigh(i,j,3*nC+2)) then
		     top_neigh(i,j,3*nC+1) = ((ji(nC)-1)*dy)-dy + (dy/2)+(dy/4)*((top_neigh(i,j,3*nC+2)-ibm_ht(ii(nC),ji(nC)-1)) &
						                	/(ibm_ht_ystag(ii(nC),ji(nC)-1)-ibm_ht(ii(nC),ji(nC)-1)))
		  else
		     top_neigh(i,j,3*nC+1) = ((ji(nC)-1)*dy)-(dy/2) + (dy/4)+(dy/4)*((top_neigh(i,j,3*nC+2)-ibm_ht_ystag(ii(nC),ji(nC)-1)) &
						                                    /(ibm_ht(ii(nC),ji(nC))-ibm_ht_ystag(ii(nC),ji(nC)-1)))
		  endif
	      elseif (stag == 3) then
		  ! solve for x
		  if (ibm_ht_xstag(ii(nC)+1,ji(nC)) >= top_neigh(i,j,3*nC+2)) then
		     top_neigh(i,j,3*nC) = (ii(nC)*dx)-(dx/2) + (dx/4)+(dx/4)*((top_neigh(i,j,3*nC+2)-ibm_ht_xstag(ii(nC)+1,ji(nC))) &
						                            /(ibm_ht(ii(nC)+1,ji(nC))-ibm_ht_xstag(ii(nC)+1,ji(nC))))
		  else
		     top_neigh(i,j,3*nC) = (ii(nC)*dx)-(dx/2) + (dx/4)*((top_neigh(i,j,3*nC+2)-ibm_ht(ii(nC),ji(nC))) &
						               /(ibm_ht_xstag(ii(nC)+1,ji(nC))-ibm_ht(ii(nC),ji(nC))))
		  endif
		  ! solve for y
		  if (ibm_ht_ystag(ii(nC),ji(nC)) >= top_neigh(i,j,3*nC+2)) then
		     top_neigh(i,j,3*nC+1) = ((ji(nC)-1)*dy) + (dy/4)*((top_neigh(i,j,3*nC+2)-ibm_ht(ii(nC),ji(nC)-1)) &
						        	/(ibm_ht_ystag(ii(nC),ji(nC))-ibm_ht(ii(nC),ji(nC)-1)))
		  else
		     top_neigh(i,j,3*nC+1) = ((ji(nC)-1)*dy) + (dy/4)+(dy/4)*((top_neigh(i,j,3*nC+2)-ibm_ht_ystag(ii(nC),ji(nC))) &
							                    /(ibm_ht(ii(nC),ji(nC))-ibm_ht_ystag(ii(nC),ji(nC))))
		  endif
	      endif
	      ! neighbor 7 is on the boundary between 7 and 3 
	      nC = 7
	      top_neigh_i(i,j,3*nC) = ii(nC)
	      top_neigh_i(i,j,3*nC+1) = 0
	      top_neigh_i(i,j,3*nC+2) = 0
	      ! first z
	      top_neigh(i,j,3*nC+2) = ht_p(ii(nC),ki(nC),ji(nC))
	      if (stag == 1) then
		  !next x
		  top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx)
		  ! solve for y
		  if (ibm_ht_ystag(ii(nC),ji(nC)) >= top_neigh(i,j,3*nC+2)) then
		     top_neigh(i,j,3*nC+1) = ((ji(nC)-1)*dy)-(dy/2) + (dy/2)*((top_neigh(i,j,3*nC+2)-ibm_ht(ii(nC),ji(nC)-1)) &
								       /(ibm_ht_ystag(ii(nC),ji(nC))-ibm_ht(ii(nC),ji(nC)-1)))
		  else
		     top_neigh(i,j,3*nC+1) = (ji(nC)*dy)-dy + (dy/2)*((top_neigh(i,j,3*nC+2)-ibm_ht_ystag(ii(nC),ji(nC))) &
								     /(ibm_ht(ii(nC),ji(nC))-ibm_ht_ystag(ii(nC),ji(nC))))
		  endif						 
	      elseif (stag == 2) then
		  !next x
		  top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
		  ! solve for y
		  if (ibm_ht_ystag(ii(nC),ji(nC)-1) >= top_neigh(i,j,3*nC+2)) then
		     top_neigh(i,j,3*nC+1) = ((ji(nC)-1)*dy)-dy + (dy/2)*((top_neigh(i,j,3*nC+2)-ibm_ht(ii(nC),ji(nC)-1)) &
								 /(ibm_ht_ystag(ii(nC),ji(nC)-1)-ibm_ht(ii(nC),ji(nC)-1)))
		  else
		     top_neigh(i,j,3*nC+1) = ((ji(nC)-1)*dy)-(dy/2) + (dy/2)*((top_neigh(i,j,3*nC+2)-ibm_ht_ystag(ii(nC),ji(nC)-1)) &
									     /(ibm_ht(ii(nC),ji(nC))-ibm_ht_ystag(ii(nC),ji(nC)-1)))
		  endif
	      elseif (stag == 3) then
		  !next x
		  top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
		  ! solve for y
		  if (ibm_ht_ystag(ii(nC),ji(nC)) >= top_neigh(i,j,3*nC+2)) then
		     top_neigh(i,j,3*nC+1) = ((ji(nC)-1)*dy)-(dy/2) + (dy/2)*((top_neigh(i,j,3*nC+2)-ibm_ht(ii(nC),ji(nC)-1)) &
								       /(ibm_ht_ystag(ii(nC),ji(nC))-ibm_ht(ii(nC),ji(nC)-1)))
		  else
		     top_neigh(i,j,3*nC+1) = (ji(nC)*dy)-dy + (dy/2)*((top_neigh(i,j,3*nC+2)-ibm_ht_ystag(ii(nC),ji(nC))) &
								     /(ibm_ht(ii(nC),ji(nC))-ibm_ht_ystag(ii(nC),ji(nC))))
		  endif
	      endif
	   elseif (bc_type ==2) then
	      ! if 0  and 4 are top ghost points, then the 0,4 neighbor is (ii(1),ji(1),ht(ki(1)+1) the node above it
	      ! and the 2,6 neighbor is ibm_ht(ii,jj) on the boundary
	      if ((ki(0)==top(ii(0),ji(0))).AND.(ki(4)==top(ii(4),ji(4)))) then
		 nC = 0
		 top_neigh_i(i,j,3*nC) = ii(nC)
		 top_neigh_i(i,j,3*nC+1) = ji(nC)
		 top_neigh_i(i,j,3*nC+2) = ki(nC)+1		
		 if (stag ==1 ) then 			
		     top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx)
		     top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)
		 elseif (stag == 2) then
		     top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
		     top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy)	     
		 elseif (stag == 3) then
		     top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
		     top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)	     
		 endif
		 top_neigh(i,j,3*nC+2) = ht_p(top_neigh_i(i,j,3*nC),top_neigh_i(i,j,3*nC+2),top_neigh_i(i,j,3*nC+1))	   
		 ! neighbors 1,3,5 are zero computational nodes
		 nC = 1
		 top_neigh_i(i,j,3*nC) = ii(nC)
		 top_neigh_i(i,j,3*nC+1) = ji(nC)
		 top_neigh_i(i,j,3*nC+2) = ki(nC)		
		 if (stag ==1 ) then 			
		     top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx)
		     top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)
		 elseif (stag == 2) then
		     top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
		     top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy)	     
		 elseif (stag == 3) then
		     top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
		     top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)	     
		 endif
		 top_neigh(i,j,3*nC+2) = ht_p(top_neigh_i(i,j,3*nC),top_neigh_i(i,j,3*nC+2),top_neigh_i(i,j,3*nC+1))
		 ! neighbor 2 is at (ii,jj,ibm_ht(ii,jj)) on the boundary
		 nC = 2
		 top_neigh_i(i,j,3*nC) = ii(nC)
		 top_neigh_i(i,j,3*nC+1) = ji(nC)
		 top_neigh_i(i,j,3*nC+2) = 0		
		 if (stag ==1 ) then 			
		     top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx)
		     top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)
		 elseif (stag == 2) then
		     top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
		     top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy)	     
		 elseif (stag == 3) then
		     top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
		     top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)	     
		 endif
		 top_neigh(i,j,3*nC+2) = ibm_ht(top_neigh_i(i,j,3*nC),top_neigh_i(i,j,3*nC+1))
		 ! neighbors 1,3,5 are zero computational nodes
		 nC = 3
		 top_neigh_i(i,j,3*nC) = ii(nC)
		 top_neigh_i(i,j,3*nC+1) = ji(nC)
		 top_neigh_i(i,j,3*nC+2) = ki(nC)		
		 if (stag ==1 ) then 			
		     top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx)
		     top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)
		 elseif (stag == 2) then
		     top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
		     top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy)	     
		 elseif (stag == 3) then
		     top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
		     top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)	     
		 endif
		 top_neigh(i,j,3*nC+2) = ht_p(top_neigh_i(i,j,3*nC),top_neigh_i(i,j,3*nC+2),top_neigh_i(i,j,3*nC+1))
		 nC = 4
		 top_neigh_i(i,j,3*nC) = ii(nC)
		 top_neigh_i(i,j,3*nC+1) = ji(nC)
		 top_neigh_i(i,j,3*nC+2) = ki(nC)+1		
		 if (stag ==1 ) then 			
		     top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx)
		     top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)
		 elseif (stag == 2) then
		     top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
		     top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy)	     
		 elseif (stag == 3) then
		     top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
		     top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)	     
		 endif
		 top_neigh(i,j,3*nC+2) = ht_p(top_neigh_i(i,j,3*nC),top_neigh_i(i,j,3*nC+2),top_neigh_i(i,j,3*nC+1))
		 ! neighbors 1,3,5 are zero computational nodes
		 nC = 5
		 top_neigh_i(i,j,3*nC) = ii(nC)
		 top_neigh_i(i,j,3*nC+1) = ji(nC)
		 top_neigh_i(i,j,3*nC+2) = ki(nC)		
		 if (stag ==1 ) then 			
		     top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx)
		     top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)
		 elseif (stag == 2) then
		     top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
		     top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy)	     
		 elseif (stag == 3) then
		     top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
		     top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)	     
		 endif
		 top_neigh(i,j,3*nC+2) = ht_p(top_neigh_i(i,j,3*nC),top_neigh_i(i,j,3*nC+2),top_neigh_i(i,j,3*nC+1))
		 ! neighbor 6,7 is at (ii,jj,ibm_ht(ii,jj)) on the boundary
		 do nC = 6,7
		    top_neigh_i(i,j,3*nC) = ii(nC)
		    top_neigh_i(i,j,3*nC+1) = ji(nC)
		    top_neigh_i(i,j,3*nC+2) = 0		
		    if (stag ==1 ) then 			
			top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx)
			top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)
		    elseif (stag == 2) then
			top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
			top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy)	     
		    elseif (stag == 3) then
			top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
			top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)	     
		    endif
		    top_neigh(i,j,3*nC+2) = ibm_ht(top_neigh_i(i,j,3*nC),top_neigh_i(i,j,3*nC+1)) 
		 enddo
	      else ! if 0,4 are not top neighbors
	         ! neighbor 0 on the boundary between 0 and 1
		 nC = 0 
		 top_neigh_i(i,j,3*nC) = 0
		 top_neigh_i(i,j,3*nC+1) = ji(nC)
		 top_neigh_i(i,j,3*nC+2) = 0
		 ! first z
		 top_neigh(i,j,3*nC+2) = ht_p(ii(nC),ki(nC),ji(nC))
		 if (stag == 1) then
		     !next y
		     top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)
		     ! solve for x
		     if (ibm_ht_xstag(ii(nC),ji(nC)) >= top_neigh(i,j,3*nC+2)) then
			top_neigh(i,j,3*nC) = (ii(nC)*dx)-(dx/2) + (dx/2)*((top_neigh(i,j,3*nC+2)-ibm_ht_xstag(ii(nC),ji(nC))) &
						                	/(ibm_ht(ii(nC)+1,ji(nC))-ibm_ht_xstag(ii(nC),ji(nC))))
		     else
			top_neigh(i,j,3*nC) = (ii(nC)*dx)-dx + (dx/2)*((top_neigh(i,j,3*nC+2)-ibm_ht(ii(nC),ji(nC))) &
								/(ibm_ht_xstag(ii(nC),ji(nC))-ibm_ht(ii(nC),ji(nC))))
		     endif						  
		 elseif (stag == 2) then
		     !next y
		     top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy)
		     ! solve for x
		     if (ibm_ht_xstag(ii(nC)+1,ji(nC)) >= top_neigh(i,j,3*nC+2)) then
			top_neigh(i,j,3*nC) = (ii(nC)*dx) + (dx/2)*((top_neigh(i,j,3*nC+2)-ibm_ht_xstag(ii(nC)+1,ji(nC))) &
						        	 /(ibm_ht(ii(nC)+1,ji(nC))-ibm_ht_xstag(ii(nC)+1,ji(nC))))
		     else
			top_neigh(i,j,3*nC) = (ii(nC)*dx)-(dx/2) + (dx/2)*((top_neigh(i,j,3*nC+2)-ibm_ht(ii(nC),ji(nC))) &
						        	  /(ibm_ht_xstag(ii(nC)+1,ji(nC))-ibm_ht(ii(nC),ji(nC))))
		     endif
		 elseif (stag == 3) then
		     !next y
		     top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)
		     ! solve for x
		     if (ibm_ht_xstag(ii(nC)+1,ji(nC)) >= top_neigh(i,j,3*nC+2)) then
			top_neigh(i,j,3*nC) = (ii(nC)*dx) + (dx/2)*((top_neigh(i,j,3*nC+2)-ibm_ht_xstag(ii(nC)+1,ji(nC))) &
						        	 /(ibm_ht(ii(nC)+1,ji(nC))-ibm_ht_xstag(ii(nC)+1,ji(nC))))
		     else
			top_neigh(i,j,3*nC) = (ii(nC)*dx)-(dx/2) + (dx/2)*((top_neigh(i,j,3*nC+2)-ibm_ht(ii(nC),ji(nC))) &
						        	  /(ibm_ht_xstag(ii(nC)+1,ji(nC))-ibm_ht(ii(nC),ji(nC))))
		     endif
		 endif
		 ! neighbors 1,3,5 are zero computational node
		 nC = 1
		 top_neigh_i(i,j,3*nC) = ii(nC)
		 top_neigh_i(i,j,3*nC+1) = ji(nC)
		 top_neigh_i(i,j,3*nC+2) = ki(nC)		
		 if (stag ==1 ) then 			
		     top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx)
		     top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)
		 elseif (stag == 2) then
		     top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
		     top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy)	     
		 elseif (stag == 3) then
		     top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
		     top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)	     
		 endif
        	 top_neigh(i,j,3*nC+2) = ht_p(top_neigh_i(i,j,3*nC),top_neigh_i(i,j,3*nC+2),top_neigh_i(i,j,3*nC+1))	   
		 ! neighbor 2 on the boundary between 2 and 3
		 nC = 2
		 top_neigh_i(i,j,3*nC) = 0
		 top_neigh_i(i,j,3*nC+1) = ji(nC)
		 top_neigh_i(i,j,3*nC+2) = 0
		 ! first z
		 top_neigh(i,j,3*nC+2) = ht_p(ii(nC),ki(nC),ji(nC))
		 if (stag == 1) then
		     !next y
		     top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)
		     ! solve for x
		     if (ibm_ht_xstag(ii(nC),ji(nC)) >= top_neigh(i,j,3*nC+2)) then
			top_neigh(i,j,3*nC) = (ii(nC)*dx)-(dx/2) + (dx/2)*((top_neigh(i,j,3*nC+2)-ibm_ht_xstag(ii(nC),ji(nC))) &
						                	/(ibm_ht(ii(nC)+1,ji(nC))-ibm_ht_xstag(ii(nC),ji(nC))))
		     else
			top_neigh(i,j,3*nC) = (ii(nC)*dx)-dx + (dx/2)*((top_neigh(i,j,3*nC+2)-ibm_ht(ii(nC),ji(nC))) &
								/(ibm_ht_xstag(ii(nC),ji(nC))-ibm_ht(ii(nC),ji(nC))))
		     endif						  
		 elseif (stag == 2) then
		     !next y
		     top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy)
		     ! solve for x
		     if (ibm_ht_xstag(ii(nC)+1,ji(nC)) >= top_neigh(i,j,3*nC+2)) then
			top_neigh(i,j,3*nC) = (ii(nC)*dx) + (dx/2)*((top_neigh(i,j,3*nC+2)-ibm_ht_xstag(ii(nC)+1,ji(nC))) &
						        	 /(ibm_ht(ii(nC)+1,ji(nC))-ibm_ht_xstag(ii(nC)+1,ji(nC))))
		     else
			top_neigh(i,j,3*nC) = (ii(nC)*dx)-(dx/2) + (dx/2)*((top_neigh(i,j,3*nC+2)-ibm_ht(ii(nC),ji(nC))) &
						        	  /(ibm_ht_xstag(ii(nC)+1,ji(nC))-ibm_ht(ii(nC),ji(nC))))
		     endif
		 elseif (stag == 3) then
		     !next y
		     top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)
		     ! solve for x
		     if (ibm_ht_xstag(ii(nC)+1,ji(nC)) >= top_neigh(i,j,3*nC+2)) then
			top_neigh(i,j,3*nC) = (ii(nC)*dx) + (dx/2)*((top_neigh(i,j,3*nC+2)-ibm_ht_xstag(ii(nC)+1,ji(nC))) &
						        	 /(ibm_ht(ii(nC)+1,ji(nC))-ibm_ht_xstag(ii(nC)+1,ji(nC))))
		     else
			top_neigh(i,j,3*nC) = (ii(nC)*dx)-(dx/2) + (dx/2)*((top_neigh(i,j,3*nC+2)-ibm_ht(ii(nC),ji(nC))) &
						        	  /(ibm_ht_xstag(ii(nC)+1,ji(nC))-ibm_ht(ii(nC),ji(nC))))
		     endif
		 endif
		 ! neighbors 1,3,5 are zero computational node
		 nC = 3
		 top_neigh_i(i,j,3*nC) = ii(nC)
		 top_neigh_i(i,j,3*nC+1) = ji(nC)
		 top_neigh_i(i,j,3*nC+2) = ki(nC)		
		 if (stag ==1 ) then 			
		     top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx)
		     top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)
		 elseif (stag == 2) then
		     top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
		     top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy)	     
		 elseif (stag == 3) then
		     top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
		     top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)	     
		 endif
		 top_neigh(i,j,3*nC+2) = ht_p(top_neigh_i(i,j,3*nC),top_neigh_i(i,j,3*nC+2),top_neigh_i(i,j,3*nC+1))
		 ! neighbor 4 on the boundary between 4 and 5
		 nC = 4
		 top_neigh_i(i,j,3*nC) = 0
		 top_neigh_i(i,j,3*nC+1) = ji(nC)
		 top_neigh_i(i,j,3*nC+2) = 0
		 ! first z
		 top_neigh(i,j,3*nC+2) = ht_p(ii(nC),ki(nC),ji(nC))
		 if (stag == 1) then
		     !next y
		     top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)
		     ! solve for x
		     if (ibm_ht_xstag(ii(nC),ji(nC)) >= top_neigh(i,j,3*nC+2)) then
			top_neigh(i,j,3*nC) = (ii(nC)*dx)-(dx/2) + (dx/2)*((top_neigh(i,j,3*nC+2)-ibm_ht_xstag(ii(nC),ji(nC))) &
						                	/(ibm_ht(ii(nC)+1,ji(nC))-ibm_ht_xstag(ii(nC),ji(nC))))
		     else
			top_neigh(i,j,3*nC) = (ii(nC)*dx)-dx + (dx/2)*((top_neigh(i,j,3*nC+2)-ibm_ht(ii(nC),ji(nC))) &
								/(ibm_ht_xstag(ii(nC),ji(nC))-ibm_ht(ii(nC),ji(nC))))
		     endif						  
		 elseif (stag == 2) then
		     !next y
		     top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy)
		     ! solve for x
		     if (ibm_ht_xstag(ii(nC)+1,ji(nC)) >= top_neigh(i,j,3*nC+2)) then
			top_neigh(i,j,3*nC) = (ii(nC)*dx) + (dx/2)*((top_neigh(i,j,3*nC+2)-ibm_ht_xstag(ii(nC)+1,ji(nC))) &
						        	 /(ibm_ht(ii(nC)+1,ji(nC))-ibm_ht_xstag(ii(nC)+1,ji(nC))))
		     else
			top_neigh(i,j,3*nC) = (ii(nC)*dx)-(dx/2) + (dx/2)*((top_neigh(i,j,3*nC+2)-ibm_ht(ii(nC),ji(nC))) &
						        	  /(ibm_ht_xstag(ii(nC)+1,ji(nC))-ibm_ht(ii(nC),ji(nC))))
		     endif
		 elseif (stag == 3) then
		     !next y
		     top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)
		     ! solve for x
		     if (ibm_ht_xstag(ii(nC)+1,ji(nC)) >= top_neigh(i,j,3*nC+2)) then
			top_neigh(i,j,3*nC) = (ii(nC)*dx) + (dx/2)*((top_neigh(i,j,3*nC+2)-ibm_ht_xstag(ii(nC)+1,ji(nC))) &
						        	 /(ibm_ht(ii(nC)+1,ji(nC))-ibm_ht_xstag(ii(nC)+1,ji(nC))))
		     else
			top_neigh(i,j,3*nC) = (ii(nC)*dx)-(dx/2) + (dx/2)*((top_neigh(i,j,3*nC+2)-ibm_ht(ii(nC),ji(nC))) &
						        	  /(ibm_ht_xstag(ii(nC)+1,ji(nC))-ibm_ht(ii(nC),ji(nC))))
		     endif
		 endif	   
		 ! neighbors 1,3,5 are zero computational node
		 nC = 5
		 top_neigh_i(i,j,3*nC) = ii(nC)
		 top_neigh_i(i,j,3*nC+1) = ji(nC)
		 top_neigh_i(i,j,3*nC+2) = ki(nC)		
		 if (stag ==1 ) then 			
		     top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx)
		     top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)
		 elseif (stag == 2) then
		     top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
		     top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy)	     
		 elseif (stag == 3) then
		     top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
		     top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)	     
		 endif
		 top_neigh(i,j,3*nC+2) = ht_p(top_neigh_i(i,j,3*nC),top_neigh_i(i,j,3*nC+2),top_neigh_i(i,j,3*nC+1)) 
		 ! neighbor 7 is on the boundary between 7 and 3 
		 nC = 7
		 top_neigh_i(i,j,3*nC) = ii(nC)
		 top_neigh_i(i,j,3*nC+1) = 0
		 top_neigh_i(i,j,3*nC+2) = 0
		 ! first z
		 top_neigh(i,j,3*nC+2) = ht_p(ii(nC),ki(nC),ji(nC))
		 if (stag == 1) then
		     !next x
		     top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx)
		     ! solve for y
		     if (ibm_ht_ystag(ii(nC),ji(nC)) >= top_neigh(i,j,3*nC+2)) then
			top_neigh(i,j,3*nC+1) = ((ji(nC)-1)*dy)-(dy/2) + (dy/2)*((top_neigh(i,j,3*nC+2)-ibm_ht(ii(nC),ji(nC)-1)) &
									  /(ibm_ht_ystag(ii(nC),ji(nC))-ibm_ht(ii(nC),ji(nC)-1)))
		     else
			top_neigh(i,j,3*nC+1) = (ji(nC)*dy)-dy + (dy/2)*((top_neigh(i,j,3*nC+2)-ibm_ht_ystag(ii(nC),ji(nC))) &
									/(ibm_ht(ii(nC),ji(nC))-ibm_ht_ystag(ii(nC),ji(nC))))
		     endif						 
		 elseif (stag == 2) then
		     !next x
		     top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
		     ! solve for y
		     if (ibm_ht_ystag(ii(nC),ji(nC)-1) >= top_neigh(i,j,3*nC+2)) then
			top_neigh(i,j,3*nC+1) = ((ji(nC)-1)*dy)-dy + (dy/2)*((top_neigh(i,j,3*nC+2)-ibm_ht(ii(nC),ji(nC)-1)) &
								    /(ibm_ht_ystag(ii(nC),ji(nC)-1)-ibm_ht(ii(nC),ji(nC)-1)))
		     else
			top_neigh(i,j,3*nC+1) = ((ji(nC)-1)*dy)-(dy/2) + (dy/2)*((top_neigh(i,j,3*nC+2)-ibm_ht_ystag(ii(nC),ji(nC)-1)) &
										/(ibm_ht(ii(nC),ji(nC))-ibm_ht_ystag(ii(nC),ji(nC)-1)))
		     endif
		 elseif (stag == 3) then
		     !next x
		     top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
		     ! solve for y
		     if (ibm_ht_ystag(ii(nC),ji(nC)) >= top_neigh(i,j,3*nC+2)) then
			top_neigh(i,j,3*nC+1) = ((ji(nC)-1)*dy)-(dy/2) + (dy/2)*((top_neigh(i,j,3*nC+2)-ibm_ht(ii(nC),ji(nC)-1)) &
									  /(ibm_ht_ystag(ii(nC),ji(nC))-ibm_ht(ii(nC),ji(nC)-1)))
		     else
			top_neigh(i,j,3*nC+1) = (ji(nC)*dy)-dy + (dy/2)*((top_neigh(i,j,3*nC+2)-ibm_ht_ystag(ii(nC),ji(nC))) &
									/(ibm_ht(ii(nC),ji(nC))-ibm_ht_ystag(ii(nC),ji(nC))))
		     endif
		 endif
		 ! neighbor 6 is still not assigned, start looking around for a computational node 
	         ! for neighbor 6 look at the computational node at ii+2,ji-2
		 nC = 6
	         if (ki(nC) > top(ii(nC)+2,ji(nC)-2)) then
		    top_neigh_i(i,j,3*nC) = ii(nC)+2
		    top_neigh_i(i,j,3*nC+1) = ji(nC)-2
		    top_neigh_i(i,j,3*nC+2) = ki(nC)	
		    if (stag ==1 ) then 			
			top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx)
			top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)
		    elseif (stag == 2) then
			top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
			top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy)	     
		    elseif (stag == 3) then
			top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
			top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)	     
		    endif
		    top_neigh(i,j,3*nC+2) = ht_p(top_neigh_i(i,j,3*nC),top_neigh_i(i,j,3*nC+2),top_neigh_i(i,j,3*nC+1))
                  else
                    write(*,*)  'neighbors not assigned for Neumann 10101011 at ',i,j
		  endif
	      endif ! if 0,4 are / are not top neighbors	   
	   endif ! end of if bc_type = 1 or 2
   ELSEIF ((inside(ii(0),ki(0),ji(0)) == 1).AND. &
	   (inside(ii(1),ki(1),ji(1)) == 0).AND. &
	   (inside(ii(2),ki(2),ji(2)) == 1).AND. &
	   (inside(ii(3),ki(3),ji(3)) == 1).AND. &
	   (inside(ii(4),ki(4),ji(4)) == 1).AND. &
	   (inside(ii(5),ki(5),ji(5)) == 0).AND. &
	   (inside(ii(6),ki(6),ji(6)) == 1).AND. &
	   (inside(ii(7),ki(7),ji(7)) == 1)) THEN
	   if ((ki(0)==top(ii(0),ji(0))).AND.(ki(4)==top(ii(4),ji(4)))) then
	      ! if neighbors 0 and 4 are top nodes then
	      ! then move ki(0,4) up one regardless of boundary condition, 
	      ! so now it is 00110011
 	      ! neighbor 0,1,4,5 are the zero computational nodes
 	      do nC = 0,1
 		 top_neigh_i(i,j,3*nC) = ii(nC)
 		 top_neigh_i(i,j,3*nC+1) = ji(nC)
 		 top_neigh_i(i,j,3*nC+2) = ki(nC)		
 		 if (stag ==1 ) then  		
 		     top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx)
 		     top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)
 		 elseif (stag == 2) then
 		     top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
 		     top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy)	     
 		 elseif (stag == 3) then
 		     top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
 		     top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)	     
 		 endif
 		 top_neigh(i,j,3*nC+2) = ht_p(top_neigh_i(i,j,3*nC),top_neigh_i(i,j,3*nC+2),top_neigh_i(i,j,3*nC+1))  
	      enddo    
 	      ! neighbors 2,3,6,7 are at (ii,jj,ibm_ht(ii,jj)) on the boundary
 	      do nC = 2,3
 		 top_neigh_i(i,j,3*nC) = ii(nC)
 		 top_neigh_i(i,j,3*nC+1) = ji(nC)
 		 top_neigh_i(i,j,3*nC+2) = 0  	
 		 if (stag ==1 ) then  		
 		     top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx)
 		     top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)
 		 elseif (stag == 2) then
 		     top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
 		     top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy)	     
 		 elseif (stag == 3) then
 		     top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
 		     top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)	     
 		 endif
 		 top_neigh(i,j,3*nC+2) = ibm_ht(top_neigh_i(i,j,3*nC),top_neigh_i(i,j,3*nC+1))
	      enddo
	      ! neighbor 0,1,4,5 are the zero computational nodes
 	      do nC = 4,5
 		 top_neigh_i(i,j,3*nC) = ii(nC)
 		 top_neigh_i(i,j,3*nC+1) = ji(nC)
 		 top_neigh_i(i,j,3*nC+2) = ki(nC)		
 		 if (stag ==1 ) then  		
 		     top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx)
 		     top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)
 		 elseif (stag == 2) then
 		     top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
 		     top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy)	     
 		 elseif (stag == 3) then
 		     top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
 		     top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)	     
 		 endif
 		 top_neigh(i,j,3*nC+2) = ht_p(top_neigh_i(i,j,3*nC),top_neigh_i(i,j,3*nC+2),top_neigh_i(i,j,3*nC+1))
	      enddo
 	      ! neighbors 2,3,6,7 are at (ii,jj,ibm_ht(ii,jj)) on the boundary
 	      do nC = 6,7
 		 top_neigh_i(i,j,3*nC) = ii(nC)
 		 top_neigh_i(i,j,3*nC+1) = ji(nC)
 		 top_neigh_i(i,j,3*nC+2) = 0  	
 		 if (stag ==1 ) then  		
 		     top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx)
 		     top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)
 		 elseif (stag == 2) then
 		     top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
 		     top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy)	     
 		 elseif (stag == 3) then
 		     top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
 		     top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)	     
 		 endif
 		 top_neigh(i,j,3*nC+2) = ibm_ht(top_neigh_i(i,j,3*nC),top_neigh_i(i,j,3*nC+1))
	      enddo
           else ! if 0,4 are not top nodes
	      if (bc_type == 1) then
		 ! neighbor 0 is on the boundary between 0 and 1 
 		 nC = 0 
 		 top_neigh_i(i,j,3*nC) = 0
 		 top_neigh_i(i,j,3*nC+1) = ji(nC)
 		 top_neigh_i(i,j,3*nC+2) = 0
 		 ! first z
 		 top_neigh(i,j,3*nC+2) = ht_p(ii(nC),ki(nC),ji(nC))
 		 if (stag == 1) then
 		     !next y
 		     top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)
 		     ! solve for x
 		     if (ibm_ht_xstag(ii(nC),ji(nC)) >= top_neigh(i,j,3*nC+2)) then
 			top_neigh(i,j,3*nC) = (ii(nC)*dx)-(dx/2) + (dx/2)*((top_neigh(i,j,3*nC+2)-ibm_ht_xstag(ii(nC),ji(nC))) &
 									/(ibm_ht(ii(nC)+1,ji(nC))-ibm_ht_xstag(ii(nC),ji(nC))))
 		     else
 			top_neigh(i,j,3*nC) = (ii(nC)*dx)-dx + (dx/2)*((top_neigh(i,j,3*nC+2)-ibm_ht(ii(nC),ji(nC))) &
 								/(ibm_ht_xstag(ii(nC),ji(nC))-ibm_ht(ii(nC),ji(nC))))
 		     endif						  
 		 elseif (stag == 2) then
 		     !next y
 		     top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy)
 		     ! solve for x
 		     if (ibm_ht_xstag(ii(nC)+1,ji(nC)) >= top_neigh(i,j,3*nC+2)) then
 			top_neigh(i,j,3*nC) = (ii(nC)*dx) + (dx/2)*((top_neigh(i,j,3*nC+2)-ibm_ht_xstag(ii(nC)+1,ji(nC))) &
 								 /(ibm_ht(ii(nC)+1,ji(nC))-ibm_ht_xstag(ii(nC)+1,ji(nC))))
 		     else
 			top_neigh(i,j,3*nC) = (ii(nC)*dx)-(dx/2) + (dx/2)*((top_neigh(i,j,3*nC+2)-ibm_ht(ii(nC),ji(nC))) &
 								  /(ibm_ht_xstag(ii(nC)+1,ji(nC))-ibm_ht(ii(nC),ji(nC))))
 		     endif
 		 elseif (stag == 3) then
 		     !next y
 		     top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)
 		     ! solve for x
 		     if (ibm_ht_xstag(ii(nC)+1,ji(nC)) >= top_neigh(i,j,3*nC+2)) then
 			top_neigh(i,j,3*nC) = (ii(nC)*dx) + (dx/2)*((top_neigh(i,j,3*nC+2)-ibm_ht_xstag(ii(nC)+1,ji(nC))) &
 								 /(ibm_ht(ii(nC)+1,ji(nC))-ibm_ht_xstag(ii(nC)+1,ji(nC))))
 		     else
 			top_neigh(i,j,3*nC) = (ii(nC)*dx)-(dx/2) + (dx/2)*((top_neigh(i,j,3*nC+2)-ibm_ht(ii(nC),ji(nC))) &
 								  /(ibm_ht_xstag(ii(nC)+1,ji(nC))-ibm_ht(ii(nC),ji(nC))))
 		     endif
 		 endif
 		 ! neighbor 1,5 are the zero computational nodes
 		 nC = 1
 		 top_neigh_i(i,j,3*nC) = ii(nC)
 		 top_neigh_i(i,j,3*nC+1) = ji(nC)
 		 top_neigh_i(i,j,3*nC+2) = ki(nC)		
 		 if (stag ==1 ) then  		
 		     top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx)
 		     top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)
 		 elseif (stag == 2) then
 		     top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
 		     top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy)	     
 		 elseif (stag == 3) then
 		     top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
 		     top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)	     
 		 endif
 		 top_neigh(i,j,3*nC+2) = ht_p(top_neigh_i(i,j,3*nC),top_neigh_i(i,j,3*nC+2),top_neigh_i(i,j,3*nC+1))
		 ! assign neighbor 2 to the midpoint of the cut on the 0123 plane or the ibm_ht_stag
 		 nC = 2
 		 top_neigh_i(i,j,3*nC) = 0
 		 top_neigh_i(i,j,3*nC+1) = ji(nC)
 		 top_neigh_i(i,j,3*nC+2) = 0
 		 if (stag == 1) then
 		     ! y
 		     top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)
 		     if (ibm_ht_xstag(ii(nC),ji(nC)) >= ht_p(ii(nC),ki(nC)+1,ji(nC))) then
			! solve for x/2
 			top_neigh(i,j,3*nC) = (ii(nC)*dx)-(dx/2) + (dx/4)+(dx/4)*((top_neigh(i,j,3*nC+2)-ibm_ht_xstag(ii(nC),ji(nC))) &
 								               /(ibm_ht(ii(nC)+1,ji(nC))-ibm_ht_xstag(ii(nC),ji(nC))))
			! solve for z
	        	top_neigh(i,j,3*nC+2) = (ht_p(ii(nC)+1,ki(nC)+1,ji(nC))+ibm_ht(ii(nC)+1,ji(nC)))/2.  							    
 		     else
			top_neigh(i,j,3*nC) = (ii(nC)*dx)-(dx/2)
			top_neigh(i,j,3*nC+2)=ibm_ht_xstag(ii(nC),ji(nC))
 		     endif						  
 		 elseif (stag == 2) then
 		     ! y
 		     top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy)
 		     if (ibm_ht_xstag(ii(nC)+1,ji(nC)) >= ht_p(ii(nC),ki(nC)+1,ji(nC))) then
			! solve for x/2
 			top_neigh(i,j,3*nC) = (ii(nC)*dx) + (dx/4)+(dx/4)*((top_neigh(i,j,3*nC+2)-ibm_ht_xstag(ii(nC)+1,ji(nC))) &
 							        	/(ibm_ht(ii(nC)+1,ji(nC))-ibm_ht_xstag(ii(nC)+1,ji(nC))))
			! solve for z
	        	top_neigh(i,j,3*nC+2) = (ht_p(ii(nC)+1,ki(nC)+1,ji(nC))+ibm_ht(ii(nC)+1,ji(nC)))/2.  						     
 		     else
 			top_neigh(i,j,3*nC) = ii(nC)*dx
			top_neigh(i,j,3*nC+2)=ibm_ht_xstag(ii(nC)+1,ji(nC))
 		     endif
 		 elseif (stag == 3) then
 		     ! y
 		     top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)
 		     if (ibm_ht_xstag(ii(nC)+1,ji(nC)) >= ht_p(ii(nC),ki(nC)+1,ji(nC))) then
			! solve for x/2
 			top_neigh(i,j,3*nC) = (ii(nC)*dx) + (dx/4)+(dx/2)*((top_neigh(i,j,3*nC+2)-ibm_ht_xstag(ii(nC)+1,ji(nC))) &
 							        	/(ibm_ht(ii(nC)+1,ji(nC))-ibm_ht_xstag(ii(nC)+1,ji(nC))))
			! solve for z
	        	top_neigh(i,j,3*nC+2) = (ht_p(ii(nC)+1,ki(nC)+1,ji(nC))+ibm_ht(ii(nC)+1,ji(nC)))/2.  
 		     else
			top_neigh(i,j,3*nC) = ii(nC)*dx
			top_neigh(i,j,3*nC+2)=ibm_ht_xstag(ii(nC)+1,ji(nC))
 		     endif
 		 endif
 		 ! neighbors 3,7 are at (ii,jj,ibm_ht(ii,jj)) on the boundary
 		 nC = 3
 		 top_neigh_i(i,j,3*nC) = ii(nC)
 		 top_neigh_i(i,j,3*nC+1) = ji(nC)
 		 top_neigh_i(i,j,3*nC+2) = 0  	
 		 if (stag ==1 ) then  		
 		     top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx)
 		     top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)
 		 elseif (stag == 2) then
 		     top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
 		     top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy)	     
 		 elseif (stag == 3) then
 		     top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
 		     top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)	     
 		 endif
 		 top_neigh(i,j,3*nC+2) = ibm_ht(top_neigh_i(i,j,3*nC),top_neigh_i(i,j,3*nC+1))		 
		 ! neighbor 4 is on the boundary between 4 and 5
 		 nC = 4
 		 top_neigh_i(i,j,3*nC) = 0
 		 top_neigh_i(i,j,3*nC+1) = ji(nC)
 		 top_neigh_i(i,j,3*nC+2) = 0
 		 ! first z
 		 top_neigh(i,j,3*nC+2) = ht_p(ii(nC),ki(nC),ji(nC))
 		 if (stag == 1) then
 		     !next y
 		     top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)
 		     ! solve for x
 		     if (ibm_ht_xstag(ii(nC),ji(nC)) >= top_neigh(i,j,3*nC+2)) then
 			top_neigh(i,j,3*nC) = (ii(nC)*dx)-(dx/2) + (dx/2)*((top_neigh(i,j,3*nC+2)-ibm_ht_xstag(ii(nC),ji(nC))) &
 									/(ibm_ht(ii(nC)+1,ji(nC))-ibm_ht_xstag(ii(nC),ji(nC))))
 		     else
 			top_neigh(i,j,3*nC) = (ii(nC)*dx)-dx + (dx/2)*((top_neigh(i,j,3*nC+2)-ibm_ht(ii(nC),ji(nC))) &
 								/(ibm_ht_xstag(ii(nC),ji(nC))-ibm_ht(ii(nC),ji(nC))))
 		     endif						  
 		 elseif (stag == 2) then
 		     !next y
 		     top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy)
 		     ! solve for x
 		     if (ibm_ht_xstag(ii(nC)+1,ji(nC)) >= top_neigh(i,j,3*nC+2)) then
 			top_neigh(i,j,3*nC) = (ii(nC)*dx) + (dx/2)*((top_neigh(i,j,3*nC+2)-ibm_ht_xstag(ii(nC)+1,ji(nC))) &
 								 /(ibm_ht(ii(nC)+1,ji(nC))-ibm_ht_xstag(ii(nC)+1,ji(nC))))
 		     else
 			top_neigh(i,j,3*nC) = (ii(nC)*dx)-(dx/2) + (dx/2)*((top_neigh(i,j,3*nC+2)-ibm_ht(ii(nC),ji(nC))) &
 								  /(ibm_ht_xstag(ii(nC)+1,ji(nC))-ibm_ht(ii(nC),ji(nC))))
 		     endif
 		 elseif (stag == 3) then
 		     !next y
 		     top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)
 		     ! solve for x
 		     if (ibm_ht_xstag(ii(nC)+1,ji(nC)) >= top_neigh(i,j,3*nC+2)) then
 			top_neigh(i,j,3*nC) = (ii(nC)*dx) + (dx/2)*((top_neigh(i,j,3*nC+2)-ibm_ht_xstag(ii(nC)+1,ji(nC))) &
 								 /(ibm_ht(ii(nC)+1,ji(nC))-ibm_ht_xstag(ii(nC)+1,ji(nC))))
 		     else
 			top_neigh(i,j,3*nC) = (ii(nC)*dx)-(dx/2) + (dx/2)*((top_neigh(i,j,3*nC+2)-ibm_ht(ii(nC),ji(nC))) &
 								  /(ibm_ht_xstag(ii(nC)+1,ji(nC))-ibm_ht(ii(nC),ji(nC))))
 		     endif
 		 endif
		 ! neighbor 1,5 are the zero computational nodes
 		 nC = 5
 		 top_neigh_i(i,j,3*nC) = ii(nC)
 		 top_neigh_i(i,j,3*nC+1) = ji(nC)
 		 top_neigh_i(i,j,3*nC+2) = ki(nC)		
 		 if (stag ==1 ) then  		
 		     top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx)
 		     top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)
 		 elseif (stag == 2) then
 		     top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
 		     top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy)	     
 		 elseif (stag == 3) then
 		     top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
 		     top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)	     
 		 endif
 		 top_neigh(i,j,3*nC+2) = ht_p(top_neigh_i(i,j,3*nC),top_neigh_i(i,j,3*nC+2),top_neigh_i(i,j,3*nC+1))  
		 ! assign neighbor 6 to the midpoint of the cut on the 4567 plane or the ibm_ht_stag
 		 nC = 6
 		 top_neigh_i(i,j,3*nC) = 0
 		 top_neigh_i(i,j,3*nC+1) = ji(nC)
 		 top_neigh_i(i,j,3*nC+2) = 0    
 		 if (stag == 1) then
 		     ! y
 		     top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)
 		     if (ibm_ht_xstag(ii(nC),ji(nC)) >= ht_p(ii(nC),ki(nC)+1,ji(nC))) then
			! solve for x/2
 			top_neigh(i,j,3*nC) = (ii(nC)*dx)-(dx/2) + (dx/4)+(dx/4)*((top_neigh(i,j,3*nC+2)-ibm_ht_xstag(ii(nC),ji(nC))) &
 								               /(ibm_ht(ii(nC)+1,ji(nC))-ibm_ht_xstag(ii(nC),ji(nC))))
			! solve for z
	        	top_neigh(i,j,3*nC+2) = (ht_p(ii(nC)+1,ki(nC)+1,ji(nC))+ibm_ht(ii(nC)+1,ji(nC)))/2.  							    
 		     else
			top_neigh(i,j,3*nC) = (ii(nC)*dx)-(dx/2)
			top_neigh(i,j,3*nC+2)=ibm_ht_xstag(ii(nC),ji(nC))
 		     endif						  
 		 elseif (stag == 2) then
 		     ! y
 		     top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy)
 		     if (ibm_ht_xstag(ii(nC)+1,ji(nC)) >= ht_p(ii(nC),ki(nC)+1,ji(nC))) then
			! solve for x/2
 			top_neigh(i,j,3*nC) = (ii(nC)*dx) + (dx/4)+(dx/4)*((top_neigh(i,j,3*nC+2)-ibm_ht_xstag(ii(nC)+1,ji(nC))) &
 							        	/(ibm_ht(ii(nC)+1,ji(nC))-ibm_ht_xstag(ii(nC)+1,ji(nC))))
			! solve for z
	        	top_neigh(i,j,3*nC+2) = (ht_p(ii(nC)+1,ki(nC)+1,ji(nC))+ibm_ht(ii(nC)+1,ji(nC)))/2.  						     
 		     else
 			top_neigh(i,j,3*nC) = ii(nC)*dx
			top_neigh(i,j,3*nC+2)=ibm_ht_xstag(ii(nC)+1,ji(nC))
 		     endif
 		 elseif (stag == 3) then
 		     ! y
 		     top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)
 		     if (ibm_ht_xstag(ii(nC)+1,ji(nC)) >= ht_p(ii(nC),ki(nC)+1,ji(nC))) then
			! solve for x/2
 			top_neigh(i,j,3*nC) = (ii(nC)*dx) + (dx/4)+(dx/2)*((top_neigh(i,j,3*nC+2)-ibm_ht_xstag(ii(nC)+1,ji(nC))) &
 							        	/(ibm_ht(ii(nC)+1,ji(nC))-ibm_ht_xstag(ii(nC)+1,ji(nC))))
			! solve for z
	        	top_neigh(i,j,3*nC+2) = (ht_p(ii(nC)+1,ki(nC)+1,ji(nC))+ibm_ht(ii(nC)+1,ji(nC)))/2.  
 		     else
			top_neigh(i,j,3*nC) = ii(nC)*dx
			top_neigh(i,j,3*nC+2)=ibm_ht_xstag(ii(nC)+1,ji(nC))
 		     endif
 		 endif
		 ! neighbors 3,7 are at (ii,jj,ibm_ht(ii,jj)) on the boundary
 		 nC = 7
 		 top_neigh_i(i,j,3*nC) = ii(nC)
 		 top_neigh_i(i,j,3*nC+1) = ji(nC)
 		 top_neigh_i(i,j,3*nC+2) = 0  	
 		 if (stag ==1 ) then  		
 		     top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx)
 		     top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)
 		 elseif (stag == 2) then
 		     top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
 		     top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy)	     
 		 elseif (stag == 3) then
 		     top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
 		     top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)	     
 		 endif
 		 top_neigh(i,j,3*nC+2) = ibm_ht(top_neigh_i(i,j,3*nC),top_neigh_i(i,j,3*nC+1))
	      elseif (bc_type == 2) then
	         !print  '((A),1i5,(A),1i5,(A),2i5)','stag =',stag,' bc type =', bc_type,' moving ',i,j
	         ii=ii+1
		 go to 200
	      endif
	   endif ! end of if 0,4 are top
   ELSEIF ((inside(ii(0),ki(0),ji(0)) == 0).AND. &
 	   (inside(ii(1),ki(1),ji(1)) == 0).AND. &
 	   (inside(ii(2),ki(2),ji(2)) == 1).AND. &
 	   (inside(ii(3),ki(3),ji(3)) == 1).AND. &
 	   (inside(ii(4),ki(4),ji(4)) == 1).AND. &
 	   (inside(ii(5),ki(5),ji(5)) == 1).AND. &
 	   (inside(ii(6),ki(6),ji(6)) == 1).AND. &
 	   (inside(ii(7),ki(7),ji(7)) == 1)) THEN
	   if ((ki(4)==top(ii(4),ji(4))).AND.(ki(5)==top(ii(5),ji(5)))) then
	      ! if neighbors 4 and 5 are top nodes then
	      ! then move ki(4,5) up one regardless of boundary condition, 
	      ! so now it is 00110011
 	      ! neighbor 0,1,4,5 are the zero computational nodes
 	      do nC = 0,1
 		 top_neigh_i(i,j,3*nC) = ii(nC)
 		 top_neigh_i(i,j,3*nC+1) = ji(nC)
 		 top_neigh_i(i,j,3*nC+2) = ki(nC)		
 		 if (stag ==1 ) then  		
 		     top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx)
 		     top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)
 		 elseif (stag == 2) then
 		     top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
 		     top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy)	     
 		 elseif (stag == 3) then
 		     top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
 		     top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)	     
 		 endif
 		 top_neigh(i,j,3*nC+2) = ht_p(top_neigh_i(i,j,3*nC),top_neigh_i(i,j,3*nC+2),top_neigh_i(i,j,3*nC+1))  
	      enddo    
 	      ! neighbors 2,3,6,7 are at (ii,jj,ibm_ht(ii,jj)) on the boundary
 	      do nC = 2,3
 		 top_neigh_i(i,j,3*nC) = ii(nC)
 		 top_neigh_i(i,j,3*nC+1) = ji(nC)
 		 top_neigh_i(i,j,3*nC+2) = 0  	
 		 if (stag ==1 ) then  		
 		     top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx)
 		     top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)
 		 elseif (stag == 2) then
 		     top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
 		     top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy)	     
 		 elseif (stag == 3) then
 		     top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
 		     top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)	     
 		 endif
 		 top_neigh(i,j,3*nC+2) = ibm_ht(top_neigh_i(i,j,3*nC),top_neigh_i(i,j,3*nC+1))
	      enddo
	      ! neighbor 0,1,4,5 are the zero computational nodes
 	      do nC = 4,5
 		 top_neigh_i(i,j,3*nC) = ii(nC)
 		 top_neigh_i(i,j,3*nC+1) = ji(nC)
 		 top_neigh_i(i,j,3*nC+2) = ki(nC)		
 		 if (stag ==1 ) then  		
 		     top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx)
 		     top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)
 		 elseif (stag == 2) then
 		     top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
 		     top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy)	     
 		 elseif (stag == 3) then
 		     top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
 		     top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)	     
 		 endif
 		 top_neigh(i,j,3*nC+2) = ht_p(top_neigh_i(i,j,3*nC),top_neigh_i(i,j,3*nC+2),top_neigh_i(i,j,3*nC+1))
	      enddo
 	      ! neighbors 2,3,6,7 are at (ii,jj,ibm_ht(ii,jj)) on the boundary
 	      do nC = 6,7
 		 top_neigh_i(i,j,3*nC) = ii(nC)
 		 top_neigh_i(i,j,3*nC+1) = ji(nC)
 		 top_neigh_i(i,j,3*nC+2) = 0  	
 		 if (stag ==1 ) then  		
 		     top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx)
 		     top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)
 		 elseif (stag == 2) then
 		     top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
 		     top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy)	     
 		 elseif (stag == 3) then
 		     top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
 		     top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)	     
 		 endif
 		 top_neigh(i,j,3*nC+2) = ibm_ht(top_neigh_i(i,j,3*nC),top_neigh_i(i,j,3*nC+1))
	      enddo
	   else ! 4,5 are not top nodes
	      if (bc_type == 1) then
	         ! neighbor 0,1 are the zero computational nodes
 		 do nC = 0,1
 		    top_neigh_i(i,j,3*nC) = ii(nC)
 		    top_neigh_i(i,j,3*nC+1) = ji(nC)
 		    top_neigh_i(i,j,3*nC+2) = ki(nC)		
 		    if (stag ==1 ) then  		
 			top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx)
 			top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)
 		    elseif (stag == 2) then
 			top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
 			top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy)	     
 		    elseif (stag == 3) then
 			top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
 			top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)	     
 		    endif
 		    top_neigh(i,j,3*nC+2) = ht_p(top_neigh_i(i,j,3*nC),top_neigh_i(i,j,3*nC+2),top_neigh_i(i,j,3*nC+1))
		 enddo	      
 		 ! neighbors 2,3 are at (ii,jj,ibm_ht(ii,jj)) on the boundary
 		 do nC = 2,3
 		    top_neigh_i(i,j,3*nC) = ii(nC)
 		    top_neigh_i(i,j,3*nC+1) = ji(nC)
 		    top_neigh_i(i,j,3*nC+2) = 0  	
 		    if (stag ==1 ) then  		
 			top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx)
 			top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)
 		    elseif (stag == 2) then
 			top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
 			top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy)	     
 		    elseif (stag == 3) then
 			top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
 			top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)	     
 		    endif
 		    top_neigh(i,j,3*nC+2) = ibm_ht(top_neigh_i(i,j,3*nC),top_neigh_i(i,j,3*nC+1))
		 enddo		      
		 ! neighbor 4 is on the boundary between 4 and 0
		 ! neighbor 5 is on the boundary between 5 and 1	 
		 do nC = 4,5
		    top_neigh_i(i,j,3*nC) = ii(nC)
		    top_neigh_i(i,j,3*nC+1) = 0
		    top_neigh_i(i,j,3*nC+2) = 0
		    ! first z
		    top_neigh(i,j,3*nC+2) = ht_p(ii(nC),ki(nC),ji(nC))
		    if (stag == 1) then
			!next x
			top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx)
			! solve for y
			if (ibm_ht_ystag(ii(nC),ji(nC)) >= top_neigh(i,j,3*nC+2)) then
			   top_neigh(i,j,3*nC+1) = ((ji(nC)-1)*dy)-(dy/2) + (dy/2)*((top_neigh(i,j,3*nC+2)-ibm_ht(ii(nC),ji(nC)-1)) &
						                	     /(ibm_ht_ystag(ii(nC),ji(nC))-ibm_ht(ii(nC),ji(nC)-1)))
			else
			   top_neigh(i,j,3*nC+1) = (ji(nC)*dy)-dy + (dy/2)*((top_neigh(i,j,3*nC+2)-ibm_ht_ystag(ii(nC),ji(nC))) &
							        	   /(ibm_ht(ii(nC),ji(nC))-ibm_ht_ystag(ii(nC),ji(nC))))
			endif						  
		    elseif (stag == 2) then
			!next x
			top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
			! solve for y
			if (ibm_ht_ystag(ii(nC),ji(nC)-1) >= top_neigh(i,j,3*nC+2)) then
			   top_neigh(i,j,3*nC+1) = ((ji(nC)-1)*dy)-dy + (dy/2)*((top_neigh(i,j,3*nC+2)-ibm_ht(ii(nC),ji(nC)-1)) &
						        	       /(ibm_ht_ystag(ii(nC),ji(nC)-1)-ibm_ht(ii(nC),ji(nC)-1)))
			else
			   top_neigh(i,j,3*nC+1) = ((ji(nC)-1)*dy)-(dy/2) + (dy/2)*((top_neigh(i,j,3*nC+2)-ibm_ht_ystag(ii(nC),ji(nC)-1)) &
						                          	   /(ibm_ht(ii(nC),ji(nC))-ibm_ht_ystag(ii(nC),ji(nC)-1)))
			endif
		    elseif (stag == 3) then
			!next x
			top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
			! solve for y
			if (ibm_ht_ystag(ii(nC),ji(nC)) >= top_neigh(i,j,3*nC+2)) then
			   top_neigh(i,j,3*nC+1) = ((ji(nC)-1)*dy)-(dy/2) + (dy/2)*((top_neigh(i,j,3*nC+2)-ibm_ht(ii(nC),ji(nC)-1)) &
						                	     /(ibm_ht_ystag(ii(nC),ji(nC))-ibm_ht(ii(nC),ji(nC)-1)))
			else
			   top_neigh(i,j,3*nC+1) = (ji(nC)*dy)-dy + (dy/2)*((top_neigh(i,j,3*nC+2)-ibm_ht_ystag(ii(nC),ji(nC))) &
							        	   /(ibm_ht(ii(nC),ji(nC))-ibm_ht_ystag(ii(nC),ji(nC))))
			endif
		    endif
		 enddo	 
		 ! assign neighbor 6 to the midpoint of the cut on the 0246 plane or to ibm_ht_stag
		 ! assign neighbor 7 to the midpoint of the cut on the 1357 plane or to ibm_ht_stag	      
                 do nC = 6,7
		    top_neigh_i(i,j,3*nC) = ii(nC)
		    top_neigh_i(i,j,3*nC+1) = 0
		    top_neigh_i(i,j,3*nC+2) = 0
		    ! first z
		    top_neigh(i,j,3*nC+2) = ht_p(ii(nC),ki(nC),ji(nC))
		    if (stag == 1) then
		        ! x
			top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx)		  
			! solve for y/2
			if (ibm_ht_ystag(ii(nC),ji(nC)) >= ht_p(ii(nC),ki(nC)+1,ji(nC))) then
			   top_neigh(i,j,3*nC+1) = ((ji(nC)-1)*dy) +(dy/4)*((top_neigh(i,j,3*nC+2)-ibm_ht(ii(nC),ji(nC)-1)) &
						        	     /(ibm_ht_ystag(ii(nC),ji(nC))-ibm_ht(ii(nC),ji(nC)-1)))
			   ! solve for z
	        	   top_neigh(i,j,3*nC+2) = (ht_p(ii(nC)+1,ki(nC)+1,ji(nC))+ibm_ht(ii(nC),ji(nC)-1))/2.
			else
			  top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-dy
			  top_neigh(i,j,3*nC+2)=ibm_ht_ystag(ii(nC),ji(nC))
			endif
		    elseif (stag == 2) then
		        ! x
                        top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
			! solve for y/2
			if (ibm_ht_ystag(ii(nC),ji(nC)-1) >= ht_p(ii(nC),ki(nC)+1,ji(nC))) then
			   top_neigh(i,j,3*nC+1) = ((ji(nC)-1)*dy)-dy + (dy/2)+(dy/4)*((top_neigh(i,j,3*nC+2)-ibm_ht(ii(nC),ji(nC)-1)) &
						                	      /(ibm_ht_ystag(ii(nC),ji(nC)-1)-ibm_ht(ii(nC),ji(nC)-1)))
			   ! solve for z
	        	   top_neigh(i,j,3*nC+2) = (ht_p(ii(nC)+1,ki(nC)+1,ji(nC))+ibm_ht(ii(nC),ji(nC)-1))/2.  
			else
			    top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(3*dy/2)           
		            top_neigh(i,j,3*nC+2)=ibm_ht_ystag(ii(nC),ji(nC)-1)       
			endif
		    elseif (stag == 3) then
		        ! x
                        top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
			! solve for y/2
			if (ibm_ht_ystag(ii(nC),ji(nC)) >= ht_p(ii(nC),ki(nC)+1,ji(nC))) then
			   top_neigh(i,j,3*nC+1) = ((ji(nC)-1)*dy) + (dy/4)*((top_neigh(i,j,3*nC+2)-ibm_ht(ii(nC),ji(nC)-1)) &
						        	      /(ibm_ht_ystag(ii(nC),ji(nC))-ibm_ht(ii(nC),ji(nC)-1)))
			   ! solve for z
	        	   top_neigh(i,j,3*nC+2) = (ht_p(ii(nC)+1,ki(nC)+1,ji(nC))+ibm_ht(ii(nC),ji(nC)-1))/2.
			else
                           top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-dy
                           top_neigh(i,j,3*nC+2)=ibm_ht_ystag(ii(nC),ji(nC))
			endif
		    endif
		 enddo
	      elseif (bc_type == 2) then
	         !print  '((A),1i5,(A),1i5,(A),2i5)','stag =',stag,' bc type =', bc_type,' moving ',i,j
	         ii=ii-1
		 go to 200	      
	      endif ! end of bc_type = 1 or 2
	   endif ! end of if 4,5 are top nodes or not
   ELSEIF ((inside(ii(0),ki(0),ji(0)) == 0).AND. &
 	   (inside(ii(1),ki(1),ji(1)) == 1).AND. &
 	   (inside(ii(2),ki(2),ji(2)) == 1).AND. &
 	   (inside(ii(3),ki(3),ji(3)) == 1).AND. &
 	   (inside(ii(4),ki(4),ji(4)) == 0).AND. &
 	   (inside(ii(5),ki(5),ji(5)) == 1).AND. &
 	   (inside(ii(6),ki(6),ji(6)) == 1).AND. &
 	   (inside(ii(7),ki(7),ji(7)) == 1)) THEN
 	   if ((ki(1)==top(ii(1),ji(1))).AND.(ki(5)==top(ii(5),ji(5)))) then
 	      ! then move ki(1,5) up one regardless of boundary condition, 
 	      ! so now it is 00110011
 	      ! neighbors 0,1,4,5 on top are computational nodes (the zero nodes)
 	      ! neighbors 2,3,6,7 are at (ii,jj,ibm_ht(ii,jj)) on the boundary 
 	      do nC = 0,7
 		 top_neigh_i(i,j,3*nC) = ii(nC)
 		 top_neigh_i(i,j,3*nC+1) = ji(nC)		
 		 if (stag ==1 ) then			
 		     top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx)
 		     top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)
 		 elseif (stag == 2) then
 		     top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
 		     top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy)       
 		 elseif (stag == 3) then
 		     top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
 		     top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)	     
 		 endif
 	      enddo
 	      nC = 0
 	      top_neigh_i(i,j,3*nC+2) = ki(nC)    
 	      top_neigh(i,j,3*nC+2) = ht_p(top_neigh_i(i,j,3*nC),top_neigh_i(i,j,3*nC+2),top_neigh_i(i,j,3*nC+1))
 	      nC = 1
 	      top_neigh_i(i,j,3*nC+2) = ki(nC)+1   
 	      top_neigh(i,j,3*nC+2) = ht_p(top_neigh_i(i,j,3*nC),top_neigh_i(i,j,3*nC+2),top_neigh_i(i,j,3*nC+1))	      
 	      do nC = 2,3	      
 		 top_neigh_i(i,j,3*nC+2) = 0	     
 		 top_neigh(i,j,3*nC+2) = ibm_ht(top_neigh_i(i,j,3*nC),top_neigh_i(i,j,3*nC+1))
 	      enddo   
 	      nC = 4
 	      top_neigh_i(i,j,3*nC+2) = ki(nC)    
 	      top_neigh(i,j,3*nC+2) = ht_p(top_neigh_i(i,j,3*nC),top_neigh_i(i,j,3*nC+2),top_neigh_i(i,j,3*nC+1))
 	      nC = 5
 	      top_neigh_i(i,j,3*nC+2) = ki(nC)+1   
 	      top_neigh(i,j,3*nC+2) = ht_p(top_neigh_i(i,j,3*nC),top_neigh_i(i,j,3*nC+2),top_neigh_i(i,j,3*nC+1))
 	      do nC = 6,7
 		 top_neigh_i(i,j,3*nC+2) = 0	     
 		 top_neigh(i,j,3*nC+2) = ibm_ht(top_neigh_i(i,j,3*nC),top_neigh_i(i,j,3*nC+1))
 	      enddo	      
 	   else
 		print  '((A),1i5,(A),1i5,(A),2i5)','stag =',stag,' bc type =', bc_type,'problem with 01110111',i,j
 	   endif	   
  ELSEIF ((inside(ii(0),ki(0),ji(0)) == 1).AND. &
	   (inside(ii(1),ki(1),ji(1)) == 1).AND. &
	   (inside(ii(2),ki(2),ji(2)) == 1).AND. &
	   (inside(ii(3),ki(3),ji(3)) == 1).AND. &
	   (inside(ii(4),ki(4),ji(4)) == 0).AND. &
	   (inside(ii(5),ki(5),ji(5)) == 0).AND. &
	   (inside(ii(6),ki(6),ji(6)) == 1).AND. &
	   (inside(ii(7),ki(7),ji(7)) == 1)) THEN
	   if ((ki(0)==top(ii(0),ji(0))).AND.(ki(1)==top(ii(1),ji(1)))) then
	      ! if neighbors 0 and 1 are top nodes then
	      ! then move ki(0,1) up one regardless of boundary condition, 
	      ! so now it is 00110011
 	      ! neighbor 0,1 are the zero computational nodes
 	      do nC = 0,1
 		 top_neigh_i(i,j,3*nC) = ii(nC)
 		 top_neigh_i(i,j,3*nC+1) = ji(nC)
 		 top_neigh_i(i,j,3*nC+2) = ki(nC)		
 		 if (stag ==1 ) then  		
 		     top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx)
 		     top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)
 		 elseif (stag == 2) then
 		     top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
 		     top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy)	     
 		 elseif (stag == 3) then
 		     top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
 		     top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)	     
 		 endif
 		 top_neigh(i,j,3*nC+2) = ht_p(top_neigh_i(i,j,3*nC),top_neigh_i(i,j,3*nC+2),top_neigh_i(i,j,3*nC+1))
	      enddo   
 	      ! neighbors 2,3 are at (ii,jj,ibm_ht(ii,jj)) on the boundary
 	      do nC = 2,3
 		 top_neigh_i(i,j,3*nC) = ii(nC)
 		 top_neigh_i(i,j,3*nC+1) = ji(nC)
 		 top_neigh_i(i,j,3*nC+2) = 0  	
 		 if (stag ==1 ) then  		
 		     top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx)
 		     top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)
 		 elseif (stag == 2) then
 		     top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
 		     top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy)	     
 		 elseif (stag == 3) then
 		     top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
 		     top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)	     
 		 endif
 		 top_neigh(i,j,3*nC+2) = ibm_ht(top_neigh_i(i,j,3*nC),top_neigh_i(i,j,3*nC+1))
	      enddo	   	   
 	      ! neighbor 4,5 are the zero computational nodes
 	      do nC = 4,5
 		 top_neigh_i(i,j,3*nC) = ii(nC)
 		 top_neigh_i(i,j,3*nC+1) = ji(nC)
 		 top_neigh_i(i,j,3*nC+2) = ki(nC)		
 		 if (stag ==1 ) then  		
 		     top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx)
 		     top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)
 		 elseif (stag == 2) then
 		     top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
 		     top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy)	     
 		 elseif (stag == 3) then
 		     top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
 		     top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)	     
 		 endif
 		 top_neigh(i,j,3*nC+2) = ht_p(top_neigh_i(i,j,3*nC),top_neigh_i(i,j,3*nC+2),top_neigh_i(i,j,3*nC+1))
	      enddo   
 	      ! neighbors 6,7 are at (ii,jj,ibm_ht(ii,jj)) on the boundary
 	      do nC = 6,7
 		 top_neigh_i(i,j,3*nC) = ii(nC)
 		 top_neigh_i(i,j,3*nC+1) = ji(nC)
 		 top_neigh_i(i,j,3*nC+2) = 0  	
 		 if (stag ==1 ) then  		
 		     top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx)
 		     top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)
 		 elseif (stag == 2) then
 		     top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
 		     top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy)	     
 		 elseif (stag == 3) then
 		     top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
 		     top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)	     
 		 endif
 		 top_neigh(i,j,3*nC+2) = ibm_ht(top_neigh_i(i,j,3*nC),top_neigh_i(i,j,3*nC+1))
	      enddo
           else ! if 0,1 are not top nodes
	      if (bc_type == 1) then	   
		 ! neighbor 0 is on the boundary between 0 and 4
		 ! neighbor 1 is on the boundary between 1 and 5 
		 do nC = 0,1
		      top_neigh_i(i,j,3*nC) = ii(nC)
		      top_neigh_i(i,j,3*nC+1) = 0
		      top_neigh_i(i,j,3*nC+2) = 0
		      ! first z
		      top_neigh(i,j,3*nC+2) = ht_p(ii(nC),ki(nC),ji(nC))
		      if (stag == 1) then
			  !next x
			  top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx)
			  ! solve for y
			  if (ibm_ht_ystag(ii(nC),ji(nC)+1) >= top_neigh(i,j,3*nC+2)) then
			     top_neigh(i,j,3*nC+1) = (ji(nC)*dy) + (dy/2)*((top_neigh(i,j,3*nC+2)-ibm_ht_ystag(ii(nC),ji(nC)+1)) &
									/(ibm_ht(ii(nC),ji(nC)+1)-ibm_ht_ystag(ii(nC),ji(nC)+1)))
			  else
			     top_neigh(i,j,3*nC+1) = (ji(nC)*dy)-(dy/2) + (dy/2)*((top_neigh(i,j,3*nC+2)-ibm_ht(ii(nC),ji(nC))) &
									 /(ibm_ht_ystag(ii(nC),ji(nC)+1)-ibm_ht(ii(nC),ji(nC))))
			  endif						 
		      elseif (stag == 2) then
			  !next x
			  top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
			  ! solve for y
			  if (ibm_ht_ystag(ii(nC),ji(nC)) >= top_neigh(i,j,3*nC+2)) then
			     top_neigh(i,j,3*nC+1) = (ji(nC)*dy-(dy/2)) + (dy/2)*((top_neigh(i,j,3*nC+2)-ibm_ht_ystag(ii(nC),ji(nC))) &
									       /(ibm_ht(ii(nC),ji(nC)+1)-ibm_ht_ystag(ii(nC),ji(nC))))
			  else
			     top_neigh(i,j,3*nC+1) = (ji(nC)*dy)-dy + (dy/2)*((top_neigh(i,j,3*nC+2)-ibm_ht(ii(nC),ji(nC))) &
								       /(ibm_ht_ystag(ii(nC),ji(nC))-ibm_ht(ii(nC),ji(nC))))
			  endif
		      elseif (stag == 3) then
			  !next x
			  top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
			  ! solve for y
			  if (ibm_ht_ystag(ii(nC),ji(nC)+1) >= top_neigh(i,j,3*nC+2)) then
			     top_neigh(i,j,3*nC+1) = (ji(nC)*dy) + (dy/2)*((top_neigh(i,j,3*nC+2)-ibm_ht_ystag(ii(nC),ji(nC)+1)) &
									/(ibm_ht(ii(nC),ji(nC)+1)-ibm_ht_ystag(ii(nC),ji(nC)+1)))
			  else
			     top_neigh(i,j,3*nC+1) = (ji(nC)*dy)-(dy/2) + (dy/2)*((top_neigh(i,j,3*nC+2)-ibm_ht(ii(nC),ji(nC))) &
									 /(ibm_ht_ystag(ii(nC),ji(nC)+1)-ibm_ht(ii(nC),ji(nC))))
			  endif       
		      endif
		  enddo 
        	 ! neighbors 2 and 3 still need to be assigned
		 ! assign neighbor 2 to the midpoint of the cut on the 0246 plane or the ibm_ht_ystag
		 ! assign neighbor 3 to the midpoint of the cut on the 1357 plane or the ibm_ht_ystag
 		 do nC = 2,3
 		    top_neigh_i(i,j,3*nC) = ii(nC)
 		    top_neigh_i(i,j,3*nC+1) = 0
 		    top_neigh_i(i,j,3*nC+2) = 0
 		    if (stag == 1) then
 			! x
 			top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx)
 			if (ibm_ht_ystag(ii(nC),ji(nC)+1) >= ht_p(ii(nC),ki(nC)+1,ji(nC))) then
			   ! solve for y/2
			   top_neigh(i,j,3*nC+1) = (ji(nC)*dy) + (dy/4)+(dy/4)*((top_neigh(i,j,3*nC+2)-ibm_ht_ystag(ii(nC),ji(nC)+1)) &
								             /(ibm_ht(ii(nC),ji(nC)+1)-ibm_ht_ystag(ii(nC),ji(nC)+1)))
			   ! solve for z
	        	   top_neigh(i,j,3*nC+2) = (ht_p(ii(nC),ki(nC)+1,ji(nC)+1)+ibm_ht(ii(nC),ji(nC)+1))/2.  							    
 			else
			   top_neigh(i,j,3*nC+1) = ji(nC)*dy
			   top_neigh(i,j,3*nC+2)=ibm_ht_ystag(ii(nC),ji(nC)+1)
 			endif						  
 		    elseif (stag == 2) then
 			! x
 			top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
 			if (ibm_ht_ystag(ii(nC),ji(nC)) >= ht_p(ii(nC),ki(nC)+1,ji(nC))) then
			   ! solve for y/2
			   top_neigh(i,j,3*nC+1) = (ji(nC)*dy)-(dy/2) + (dy/4)+(dy/4)*((top_neigh(i,j,3*nC+2)-ibm_ht_ystag(ii(nC),ji(nC))) &
									            /(ibm_ht(ii(nC),ji(nC)+1)-ibm_ht_ystag(ii(nC),ji(nC))))
			   ! solve for z
	        	   top_neigh(i,j,3*nC+2) = (ht_p(ii(nC),ki(nC)+1,ji(nC)+1)+ibm_ht(ii(nC),ji(nC)+1))/2.  					     
 			else
 			   top_neigh(i,j,3*nC+1) = (ji(nC)*dy)-(dy/2)
			   top_neigh(i,j,3*nC+2)=ibm_ht_ystag(ii(nC),ji(nC))
 			endif
 		    elseif (stag == 3) then
 			! x
 			top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
 			if (ibm_ht_ystag(ii(nC),ji(nC)+1) >= ht_p(ii(nC),ki(nC)+1,ji(nC))) then
			   ! solve for y/2
			   top_neigh(i,j,3*nC+1) = (ji(nC)*dy) + (dy/4)+(dy/4)*((top_neigh(i,j,3*nC+2)-ibm_ht_ystag(ii(nC),ji(nC)+1)) &
								             /(ibm_ht(ii(nC),ji(nC)+1)-ibm_ht_ystag(ii(nC),ji(nC)+1)))
			   ! solve for z
	        	   top_neigh(i,j,3*nC+2) = (ht_p(ii(nC),ki(nC)+1,ji(nC)+1)+ibm_ht(ii(nC),ji(nC)+1))/2.  
 			else
			   top_neigh(i,j,3*nC+1) = ji(nC)*dy
			   top_neigh(i,j,3*nC+2)=ibm_ht_ystag(ii(nC),ji(nC)+1)
 			endif
 		    endif
		 enddo
		 ! neighbor 4,5 are the zero computational nodes
 		 do nC = 4,5
 		    top_neigh_i(i,j,3*nC) = ii(nC)
 		    top_neigh_i(i,j,3*nC+1) = ji(nC)
 		    top_neigh_i(i,j,3*nC+2) = ki(nC)		
 		    if (stag ==1 ) then  		
 			top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx)
 			top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)
 		    elseif (stag == 2) then
 			top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
 			top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy)	     
 		    elseif (stag == 3) then
 			top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
 			top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)	     
 		    endif
 		    top_neigh(i,j,3*nC+2) = ht_p(top_neigh_i(i,j,3*nC),top_neigh_i(i,j,3*nC+2),top_neigh_i(i,j,3*nC+1))
		 enddo   
 		 ! neighbors 6,7 are at (ii,jj,ibm_ht(ii,jj)) on the boundary
 		 do nC = 6,7
 		    top_neigh_i(i,j,3*nC) = ii(nC)
 		    top_neigh_i(i,j,3*nC+1) = ji(nC)
 		    top_neigh_i(i,j,3*nC+2) = 0  	
 		    if (stag ==1 ) then  		
 			top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx)
 			top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)
 		    elseif (stag == 2) then
 			top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
 			top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy)	     
 		    elseif (stag == 3) then
 			top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
 			top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)	     
 		    endif
 		    top_neigh(i,j,3*nC+2) = ibm_ht(top_neigh_i(i,j,3*nC),top_neigh_i(i,j,3*nC+1))
		 enddo
	      elseif (bc_type == 2) then
	         !print  '((A),1i5,(A),1i5,(A),2i5)','stag =',stag,' bc type =', bc_type,' moving ',i,j
	         ji=ji+1
		 go to 200
	      endif
	   endif ! end of if 0,1 are top
!  ELSEIF ((inside(ii(0),ki(0),ji(0)) == 0).AND. &
!	   (inside(ii(1),ki(1),ji(1)) == 1).AND. &
!	   (inside(ii(2),ki(2),ji(2)) == 1).AND. &
!	   (inside(ii(3),ki(3),ji(3)) == 1).AND. &
!	   (inside(ii(4),ki(4),ji(4)) == 1).AND. &
!	   (inside(ii(5),ki(5),ji(5)) == 0).AND. &
!	   (inside(ii(6),ki(6),ji(6)) == 1).AND. &
!	   (inside(ii(7),ki(7),ji(7)) == 1)) THEN
!	   if ((ki(1)==top(ii(1),ji(1))).AND.(ki(4)==top(ii(4),ji(4)))) then
!	      ! then move ki(1,4) up one regardless of boundary condition, 
!	      ! so now it is 00110011
!	      ! neighbors 0,1,4,5 on top are computational nodes (the zero nodes)
!	      ! neighbors 2,3,6,7 are at (ii,jj,ibm_ht(ii,jj)) on the boundary 
!	      do nC = 0,7
!		 top_neigh_i(i,j,3*nC) = ii(nC)
!		 top_neigh_i(i,j,3*nC+1) = ji(nC)		
!		 if (stag ==1 ) then			
!		     top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx)
!		     top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)
!		 elseif (stag == 2) then
!		     top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
!		     top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy)       
!		 elseif (stag == 3) then
!		     top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
!		     top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)	     
!		 endif
!	      enddo
!	      nC = 0
!	      top_neigh_i(i,j,3*nC+2) = ki(nC)    
!	      top_neigh(i,j,3*nC+2) = ht_p(top_neigh_i(i,j,3*nC),top_neigh_i(i,j,3*nC+2),top_neigh_i(i,j,3*nC+1))
!	      nC = 1
!	      top_neigh_i(i,j,3*nC+2) = ki(nC)+1   
!	      top_neigh(i,j,3*nC+2) = ht_p(top_neigh_i(i,j,3*nC),top_neigh_i(i,j,3*nC+2),top_neigh_i(i,j,3*nC+1))	      
!	      do nC = 2,3	      
!		 top_neigh_i(i,j,3*nC+2) = 0	     
!		 top_neigh(i,j,3*nC+2) = ibm_ht(top_neigh_i(i,j,3*nC),top_neigh_i(i,j,3*nC+1))
!	      enddo   
!	      nC = 4
!	      top_neigh_i(i,j,3*nC+2) = ki(nC)+1    
!	      top_neigh(i,j,3*nC+2) = ht_p(top_neigh_i(i,j,3*nC),top_neigh_i(i,j,3*nC+2),top_neigh_i(i,j,3*nC+1))
!	      nC = 5
!	      top_neigh_i(i,j,3*nC+2) = ki(nC)  
!	      top_neigh(i,j,3*nC+2) = ht_p(top_neigh_i(i,j,3*nC),top_neigh_i(i,j,3*nC+2),top_neigh_i(i,j,3*nC+1))
!	      do nC = 6,7
!		 top_neigh_i(i,j,3*nC+2) = 0	     
!		 top_neigh(i,j,3*nC+2) = ibm_ht(top_neigh_i(i,j,3*nC),top_neigh_i(i,j,3*nC+1))
!	      enddo	      
!	   else
!		print  '((A),1i5,(A),1i5,(A),2i5)','stag =',stag,' bc type =', bc_type,'problem with 01111011',i,j
!	   endif
   ELSEIF ((inside(ii(0),ki(0),ji(0)) == 0).AND. &
 	   (inside(ii(1),ki(1),ji(1)) == 1).AND. &
 	   (inside(ii(2),ki(2),ji(2)) == 1).AND. &
 	   (inside(ii(3),ki(3),ji(3)) == 1).AND. &
 	   (inside(ii(4),ki(4),ji(4)) == 1).AND. &
 	   (inside(ii(5),ki(5),ji(5)) == 1).AND. &
 	   (inside(ii(6),ki(6),ji(6)) == 1).AND. &
 	   (inside(ii(7),ki(7),ji(7)) == 1)) THEN
 	   if ((ki(1)==top(ii(1),ji(1))).AND.(ki(4)==top(ii(4),ji(4))).AND.(ki(5)==top(ii(5),ji(5)))) then
 	      ! then move ki(1,4,5) up one regardless of boundary condition, 
 	      ! so now it is 00110011
 	      ! neighbors 0,1,4,5 on top are computational nodes (the zero nodes)
 	      ! neighbors 2,3,6,7 are at (ii,jj,ibm_ht(ii,jj)) on the boundary 
 	      do nC = 0,7
 		 top_neigh_i(i,j,3*nC) = ii(nC)
 		 top_neigh_i(i,j,3*nC+1) = ji(nC)		
 		 if (stag ==1 ) then			
 		     top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx)
 		     top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)
 		 elseif (stag == 2) then
 		     top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
 		     top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy)       
 		 elseif (stag == 3) then
 		     top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
 		     top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)	     
 		 endif
 	      enddo
 	      nC = 0
 	      top_neigh_i(i,j,3*nC+2) = ki(nC)    
 	      top_neigh(i,j,3*nC+2) = ht_p(top_neigh_i(i,j,3*nC),top_neigh_i(i,j,3*nC+2),top_neigh_i(i,j,3*nC+1))
 	      nC = 1
 	      top_neigh_i(i,j,3*nC+2) = ki(nC)+1   
 	      top_neigh(i,j,3*nC+2) = ht_p(top_neigh_i(i,j,3*nC),top_neigh_i(i,j,3*nC+2),top_neigh_i(i,j,3*nC+1))	      
 	      do nC = 2,3	      
 		 top_neigh_i(i,j,3*nC+2) = 0	     
 		 top_neigh(i,j,3*nC+2) = ibm_ht(top_neigh_i(i,j,3*nC),top_neigh_i(i,j,3*nC+1))
 	      enddo   
 	      do nC = 4,5
 		 top_neigh_i(i,j,3*nC+2) = ki(nC)+1	     
 		 top_neigh(i,j,3*nC+2) = ht_p(top_neigh_i(i,j,3*nC),top_neigh_i(i,j,3*nC+2),top_neigh_i(i,j,3*nC+1))
 	      enddo
 	      do nC = 6,7
 		 top_neigh_i(i,j,3*nC+2) = 0	     
 		 top_neigh(i,j,3*nC+2) = ibm_ht(top_neigh_i(i,j,3*nC),top_neigh_i(i,j,3*nC+1))
 	      enddo	      
 	   else
 		print  '((A),1i5,(A),1i5,(A),2i5)','stag =',stag,' bc type =', bc_type,'problem with 01111111',i,j
 	   endif		   
   ELSEIF ((inside(ii(0),ki(0),ji(0)) == 1).AND. &
 	   (inside(ii(1),ki(1),ji(1)) == 0).AND. &
 	   (inside(ii(2),ki(2),ji(2)) == 1).AND. &
 	   (inside(ii(3),ki(3),ji(3)) == 1).AND. &
 	   (inside(ii(4),ki(4),ji(4)) == 1).AND. &
 	   (inside(ii(5),ki(5),ji(5)) == 1).AND. &
 	   (inside(ii(6),ki(6),ji(6)) == 1).AND. &
 	   (inside(ii(7),ki(7),ji(7)) == 1)) THEN
 	   if ((ki(0)==top(ii(0),ji(0))).AND.(ki(4)==top(ii(4),ji(4))).AND.(ki(5)==top(ii(5),ji(5)))) then
 	      ! then move ki(0,4,5) up one regardless of boundary condition, 
 	      ! so now it is 00110011
 	      ! neighbors 0,1,4,5 on top are computational nodes (the zero nodes)
 	      ! neighbors 2,3,6,7 are at (ii,jj,ibm_ht(ii,jj)) on the boundary 
 	      do nC = 0,7
 		 top_neigh_i(i,j,3*nC) = ii(nC)
 		 top_neigh_i(i,j,3*nC+1) = ji(nC)		
 		 if (stag ==1 ) then			
 		     top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx)
 		     top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)
 		 elseif (stag == 2) then
 		     top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
 		     top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy)       
 		 elseif (stag == 3) then
 		     top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
 		     top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)	     
 		 endif
 	      enddo
 	      nC = 0
 	      top_neigh_i(i,j,3*nC+2) = ki(nC)+1    
 	      top_neigh(i,j,3*nC+2) = ht_p(top_neigh_i(i,j,3*nC),top_neigh_i(i,j,3*nC+2),top_neigh_i(i,j,3*nC+1))
 	      nC = 1
 	      top_neigh_i(i,j,3*nC+2) = ki(nC)   
 	      top_neigh(i,j,3*nC+2) = ht_p(top_neigh_i(i,j,3*nC),top_neigh_i(i,j,3*nC+2),top_neigh_i(i,j,3*nC+1))	      
 	      do nC = 2,3	      
 		 top_neigh_i(i,j,3*nC+2) = 0	     
 		 top_neigh(i,j,3*nC+2) = ibm_ht(top_neigh_i(i,j,3*nC),top_neigh_i(i,j,3*nC+1))
 	      enddo   
 	      do nC = 4,5
 		 top_neigh_i(i,j,3*nC+2) = ki(nC)+1	     
 		 top_neigh(i,j,3*nC+2) = ht_p(top_neigh_i(i,j,3*nC),top_neigh_i(i,j,3*nC+2),top_neigh_i(i,j,3*nC+1))
 	      enddo
 	      do nC = 6,7
 		 top_neigh_i(i,j,3*nC+2) = 0	     
 		 top_neigh(i,j,3*nC+2) = ibm_ht(top_neigh_i(i,j,3*nC),top_neigh_i(i,j,3*nC+1))
 	      enddo	      
 	   else
 		print  '((A),1i5,(A),1i5,(A),2i5)','stag =',stag,' bc type =', bc_type,'problem with 10111111',i,j
 	   endif
   ELSEIF ((inside(ii(0),ki(0),ji(0)) == 1).AND. &
	    (inside(ii(1),ki(1),ji(1)) == 1).AND. &
	    (inside(ii(2),ki(2),ji(2)) == 1).AND. &
	    (inside(ii(3),ki(3),ji(3)) == 1).AND. &
	    (inside(ii(4),ki(4),ji(4)) == 1).AND. &
	    (inside(ii(5),ki(5),ji(5)) == 0).AND. &
	    (inside(ii(6),ki(6),ji(6)) == 1).AND. &
	    (inside(ii(7),ki(7),ji(7)) == 1)) THEN
 	    if ((ki(0)==top(ii(0),ji(0))).AND.(ki(1)==top(ii(1),ji(1))).AND.(ki(4)==top(ii(4),ji(4)))) then
	      ! then move ki(0,1,4) up one regardless of boundary condition, 
	      ! so now it is 00110011
	      ! neighbors 0,1,4,5 on top are computational nodes (the zero nodes)
	      ! neighbors 2,3,6,7 are at (ii,jj,ibm_ht(ii,jj)) on the boundary 
	      do nC = 0,7
		 top_neigh_i(i,j,3*nC) = ii(nC)
		 top_neigh_i(i,j,3*nC+1) = ji(nC)		
		 if (stag ==1 ) then			
		     top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx)
		     top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)
		 elseif (stag == 2) then
		     top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
		     top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy)       
		 elseif (stag == 3) then
		     top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
		     top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)	     
		 endif
	      enddo
	      do nC = 0,1
		 top_neigh_i(i,j,3*nC+2) = ki(nC)+1  
		 top_neigh(i,j,3*nC+2) = ht_p(top_neigh_i(i,j,3*nC),top_neigh_i(i,j,3*nC+2),top_neigh_i(i,j,3*nC+1))
              enddo 	      
	      do nC = 2,3	      
		 top_neigh_i(i,j,3*nC+2) = 0	     
		 top_neigh(i,j,3*nC+2) = ibm_ht(top_neigh_i(i,j,3*nC),top_neigh_i(i,j,3*nC+1))
	      enddo   
	      nC = 4
	      top_neigh_i(i,j,3*nC+2) = ki(nC)+1	     
	      top_neigh(i,j,3*nC+2) = ht_p(top_neigh_i(i,j,3*nC),top_neigh_i(i,j,3*nC+2),top_neigh_i(i,j,3*nC+1))
	      nC = 5
	      top_neigh_i(i,j,3*nC+2) = ki(nC)	     
	      top_neigh(i,j,3*nC+2) = ht_p(top_neigh_i(i,j,3*nC),top_neigh_i(i,j,3*nC+2),top_neigh_i(i,j,3*nC+1))
	      do nC = 6,7
		 top_neigh_i(i,j,3*nC+2) = 0	     
		 top_neigh(i,j,3*nC+2) = ibm_ht(top_neigh_i(i,j,3*nC),top_neigh_i(i,j,3*nC+1))
	      enddo	      
	   else
		!print  '((A),1i5,(A),1i5,(A),2i5)','stag =',stag,' bc type =', bc_type,' moving ',i,j
                ii=ii+1
		ji=ji+1
		go to 200
	   endif
   ELSEIF ((inside(ii(0),ki(0),ji(0)) == 1).AND. &
	   (inside(ii(1),ki(1),ji(1)) == 1).AND. &
	   (inside(ii(2),ki(2),ji(2)) == 1).AND. &
	   (inside(ii(3),ki(3),ji(3)) == 1).AND. &
	   (inside(ii(4),ki(4),ji(4)) == 0).AND. &
	   (inside(ii(5),ki(5),ji(5)) == 1).AND. &
	   (inside(ii(6),ki(6),ji(6)) == 1).AND. &
	   (inside(ii(7),ki(7),ji(7)) == 1)) THEN
	   if ((ki(0)==top(ii(0),ji(0))).AND.(ki(1)==top(ii(1),ji(1))).AND.(ki(5)==top(ii(5),ji(5)))) then
	      ! then move ki(0,1,5) up one regardless of boundary condition, 
	      ! so now it is 00110011
	      ! neighbors 0,1,4,5 on top are computational nodes (the zero nodes)
	      ! neighbors 2,3,6,7 are at (ii,jj,ibm_ht(ii,jj)) on the boundary 
	      do nC = 0,7
		 top_neigh_i(i,j,3*nC) = ii(nC)
		 top_neigh_i(i,j,3*nC+1) = ji(nC)		
		 if (stag ==1 ) then			
		     top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx)
		     top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)
		 elseif (stag == 2) then
		     top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
		     top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy)       
		 elseif (stag == 3) then
		     top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
		     top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)	     
		 endif
	      enddo
	      do nC = 0,1
		 top_neigh_i(i,j,3*nC+2) = ki(nC)+1    
		 top_neigh(i,j,3*nC+2) = ht_p(top_neigh_i(i,j,3*nC),top_neigh_i(i,j,3*nC+2),top_neigh_i(i,j,3*nC+1))
	      enddo	      
	      do nC = 2,3	      
		 top_neigh_i(i,j,3*nC+2) = 0	     
		 top_neigh(i,j,3*nC+2) = ibm_ht(top_neigh_i(i,j,3*nC),top_neigh_i(i,j,3*nC+1))
	      enddo   
	      nC = 4
	      top_neigh_i(i,j,3*nC+2) = ki(nC)       
	      top_neigh(i,j,3*nC+2) = ht_p(top_neigh_i(i,j,3*nC),top_neigh_i(i,j,3*nC+2),top_neigh_i(i,j,3*nC+1))
	      nC = 5
	      top_neigh_i(i,j,3*nC+2) = ki(nC)+1	     
	      top_neigh(i,j,3*nC+2) = ht_p(top_neigh_i(i,j,3*nC),top_neigh_i(i,j,3*nC+2),top_neigh_i(i,j,3*nC+1))
	      do nC = 6,7
		 top_neigh_i(i,j,3*nC+2) = 0	     
		 top_neigh(i,j,3*nC+2) = ibm_ht(top_neigh_i(i,j,3*nC),top_neigh_i(i,j,3*nC+1))
	      enddo	      
	   else
		print  '((A),1i5,(A),1i5,(A),2i5)','stag =',stag,' bc type =', bc_type,'problem with 11110111',i,j
	   endif
      ELSE      
           ! store the neighbors
	   DO nC=0,n-1
	      top_neigh_i(i,j,3*nC) = ii(nC)
	      top_neigh_i(i,j,3*nC+1) = ji(nC)
	      top_neigh_i(i,j,3*nC+2) = ki(nC)
	      if (stag ==1 ) then			
		 top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx)
		 top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)
	      elseif (stag == 2) then
		 top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
		 top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy)       
	      elseif (stag == 3) then
		 top_neigh(i,j,3*nC) = (top_neigh_i(i,j,3*nC)*dx)-(dx/2)
		 top_neigh(i,j,3*nC+1) = (top_neigh_i(i,j,3*nC+1)*dy)-(dy/2)	     
	      endif
	      top_neigh(i,j,3*nC+2) = ht_p(top_neigh_i(i,j,3*nC),top_neigh_i(i,j,3*nC+2),top_neigh_i(i,j,3*nC+1))
	   ENDDO
	   write(*,*), 'not found'
           write(*,'((A),1i5,(A),1i5,(A),1i5,(A),9i4)') 'i=',i,' j=',j,' for stag =',stag, ' bc type =', bc_type,                  &
	                                                                      inside(ii(0),ki(0),ji(0)),inside(ii(1),ki(1),ji(1)), &
                                                                              inside(ii(2),ki(2),ji(2)),inside(ii(3),ki(3),ji(3)), &
								              inside(ii(4),ki(4),ji(4)),inside(ii(5),ki(5),ji(5)), &
     								              inside(ii(6),ki(6),ji(6)),inside(ii(7),ki(7),ji(7))
      ENDIF
 ENDDO
 ENDDO
 
  !make the image coord the origin (x,y,z,)=(0,0,0)
  DO i=its,ite
  DO j=jts,jte
  DO nC=0,n-1
     top_neigh(i,j,3*nC) = top_neigh(i,j,3*nC)-top_img(i,j,4)
     top_neigh(i,j,3*nC+1) = top_neigh(i,j,3*nC+1)-top_img(i,j,5)
     top_neigh(i,j,3*nC+2) = top_neigh(i,j,3*nC+2)-top_img(i,j,6)	
  ENDDO
  ENDDO
  ENDDO  

  ! make the ghost point coord the origin (x,y,z,)=(0,0,0)
  !DO i=its,ite
  !DO j=jts,jte
  !DO nC=0,n-1
  !   top_neigh(i,j,3*nC) = top_neigh(i,j,3*nC)-top_img(i,j,1)
  !   top_neigh(i,j,3*nC+1) = top_neigh(i,j,3*nC+1)-top_img(i,j,2)
  !   top_neigh(i,j,3*nC+2) = top_neigh(i,j,3*nC+2)-top_img(i,j,3)     
  !ENDDO
  !ENDDO
  !ENDDO   

 END SUBROUTINE get_top_pts_3d
!--------------------------------------------------------------------------------

 SUBROUTINE get_side_pts_3d ( stag, bc_type,                &
                              dx, dy, ibm_ht,               &
                              ibm_ht_xstag, ibm_ht_ystag,   &
                              ht_p,                         &
			      inside,                       &
			      side, side_img, side_bound,   &
			      side_neigh, side_neigh_i,     &
			      n, np,                        &
			      ids, ide, jds, jde, kds, kde, &
                              ims, ime, jms, jme, kms, kme, &
                              its, ite, jts, jte, kts, kte)
  IMPLICIT NONE
 ! input data 
  INTEGER, INTENT(IN   )                                    :: stag,       &
                                                               bc_type 
  REAL, INTENT(IN   )                                       :: dx,dy
  REAL, DIMENSION(ims:ime,jms:jme), INTENT(IN   )           :: ibm_ht,     &
                                                               ibm_ht_xstag,&
							       ibm_ht_ystag
  REAL, DIMENSION(ims:ime,kms:kme,jms:jme), INTENT(IN   )   :: ht_p  			     
  INTEGER, DIMENSION(ims:ime,kms:kme,jms:jme), INTENT(IN  ) :: inside          ! one if the pt is inside boundary, zero if it is outside
  INTEGER, DIMENSION(3,np), INTENT(IN   )                   :: side            !'side boundary' ghost points							      
  REAL, DIMENSION(6,np), INTENT(IN   )                      :: side_img        ! (x,y,z) location of ghost point and image point of the 'side boundary' ghost points 
  REAL, DIMENSION(3,np), INTENT(IN   )                      :: side_bound      ! (x,y,z) location of the boundary for side points
  REAL, DIMENSION(0:3*n-1,np), INTENT(  OUT)                :: side_neigh      ! (x,y,z) location of neighbors
  INTEGER, DIMENSION(0:3*n-1,np), INTENT(  OUT)             :: side_neigh_i    ! (i,j,k) location of neighbors
  INTEGER, INTENT(IN   )                                    :: n,           &  ! desired number of nearest neighbors
                                                               np              ! number of side ghost points
  INTEGER, INTENT(IN   )                   :: ids, ide, jds, jde, kds, kde, &  ! d: domain m:memory p:patch t:tile
                                              ims, ime, jms, jme, kms, kme, &
                                              its, ite, jts, jte, kts, kte		   

 !local data
  INTEGER                                                   :: S,nC,        &
                                                               test_k
  INTEGER, DIMENSION(0:n-1)                                 :: ii,ji,ki	
  REAL                                                      :: ht_stag, dist						       

!-----------------------------------------------------------------------------------
! the executable begins here
! this subroutine stores the (i,j,k) index and (x,y,z) location of the eight
! neighbors of a side image point.
! numbering order is 01   45
!                    23   67
 CALL wrf_debug(100,'dyn_em/module_ibm.F/subroutine get_side_pts_3d')
!------------------------------------------------------------------------------------			   
! dist is the percent of dz that the grid must vary by in order to start choosing
! neighbors that are not rectangular
dist = 0.10

! initalize the arrays
side_neigh = 0.
side_neigh_i = 0

 DO S=1,np
!    IF (bc_type == 1) THEN
       ! find neighbors of the image point
       ! get i indicies
       if (stag == 1) then
          do nC = 0,6,2
	     ii(nC) = ceiling(side_img(4,S)/dx)
	  enddo
	  do nC = 1,7,2
	     ii(nC) = ceiling(side_img(4,S)/dx)+1
	  enddo
	  if ((MOD(side_img(4,S),dx)==0).AND.(ibm_ht_xstag(side(1,S)-1,side(2,S))>ibm_ht_xstag(side(1,S),side(2,S)))) then
             ii = ii+1
	  endif	  
       elseif ((stag == 2).OR.(stag == 3)) then
          do nC = 0,6,2
	     ii(nC) = ceiling((side_img(4,S)-(dx/2))/dx)
	  enddo
	  do nC = 1,7,2
	     ii(nC) = ceiling((side_img(4,S)-(dx/2))/dx)+1
	  enddo
	  if ((MOD(side_img(4,S)-(dx/2),dx)==0).AND.(ibm_ht_xstag(side(1,S),side(2,S))>ibm_ht_xstag(side(1,S)+1,side(2,S)))) then
	      ii = ii+1
	  endif
       endif
       ! get j indicies
       if (stag == 2) then
          do nC = 0,3
	     ji(nC) = ceiling(side_img(5,S)/dy)
	  enddo
	  do nC = 4,7
	     ji(nC) = ceiling(side_img(5,S)/dy)+1
	  enddo
	  if ((MOD(side_img(5,S),dy)==0).AND.(ibm_ht_ystag(side(1,S),side(2,S)-1)>ibm_ht_ystag(side(1,S),side(2,S)))) then
	      ji = ji+1
	  endif 
       elseif ((stag == 1).OR.(stag == 3)) then
	   do nC = 0,3
	      ji(nC) = ceiling((side_img(5,S)-(dy/2))/dy)
	   enddo 
	   do nC = 4,7
	      ji(nC) = ceiling((side_img(5,S)-(dy/2))/dy)+1
	   enddo 
	   if ((MOD(side_img(5,S),dy)==0).AND.(ibm_ht_ystag(side(1,S),side(2,S))>ibm_ht_ystag(side(1,S),side(2,S)+1))) then
	      ji = ji+1
	  endif   
       endif       
!   ELSEIF (bc_type == 2) THEN
!      ! find neighbors of the boundary point
!      ! get i indicies
!      if (stag == 1) then
!	  do nC = 0,6,2
!	     ii(nC) = ceiling(side_bound(1,S)/dx)
!	  enddo
!	  do nC = 1,7,2
!	     ii(nC) = ceiling(side_bound(1,S)/dx)+1
!	  enddo
!	  if ((MOD(side_bound(1,S),dx)==0).AND.(ibm_ht_xstag(side(1,S)-1,side(2,S))>ibm_ht_xstag(side(1,S),side(2,S)))) then
!	     ii = ii+1
!	  endif   
!      elseif ((stag == 2).OR.(stag == 3)) then
!	  do nC = 0,6,2
!	     ii(nC) = ceiling((side_bound(1,S)-(dx/2))/dx)
!	  enddo
!	  do nC = 1,7,2
!	     ii(nC) = ceiling((side_bound(1,S)-(dx/2))/dx)+1
!	  enddo
!	  if ((MOD(side_bound(1,S)-(dx/2),dx)==0).AND.(ibm_ht_xstag(side(1,S),side(2,S))>ibm_ht_xstag(side(1,S)+1,side(2,S)))) then
!	      ii = ii+1
!	  endif
!      endif
!      ! get j indicies
!      if (stag == 2) then
!	  do nC = 0,3
!	     ji(nC) = ceiling(side_bound(2,S)/dy)
!	  enddo
!	  do nC = 4,7
!	     ji(nC) = ceiling(side_bound(2,S)/dy)+1
!	  enddo
!	  if ((MOD(side_bound(2,S),dy)==0).AND.(ibm_ht_ystag(side(1,S),side(2,S)-1)>ibm_ht_ystag(side(1,S),side(2,S)))) then
!	      ji = ji+1
!	  endif 
!      elseif ((stag == 1).OR.(stag == 3)) then
!	   do nC = 0,3
!	      ji(nC) = ceiling((side_bound(2,S)-(dy/2))/dy)
!	   enddo 
!	   do nC = 4,7
!	      ji(nC) = ceiling((side_bound(2,S)-(dy/2))/dy)+1
!	   enddo 
!	   if ((MOD(side_bound(2,S),dy)==0).AND.(ibm_ht_ystag(side(1,S),side(2,S))>ibm_ht_ystag(side(1,S),side(2,S)+1))) then
!	      ji = ji+1
!	  endif   
!      endif	   
!   ENDIF ! end of bc_type equals 1 or 2
    ! get k inicies
    test_k = side(3,S)-1 
    ki = side(3,S)-1
!    IF (bc_type == 1) THEN
        do while (side_img(6,S) >= ht_p(side(1,S),test_k,side(2,S)))
	     test_k=test_k+1
        enddo
	do nC = 0,1
	   do while (side_img(6,S) >= ht_p(ii(nC),ki(nC),ji(nC)))
	     ki(nC)=ki(nC)+1
	   enddo  
	   !if (ki(nC)<test_k) write(*,'(5i5,1f20.8)') stag,S,nC,ki(nC),test_k,(ht_p(ii(nC),ki(nC),ji(nC))-side_img(6,S))/(ht_p(ii(nC),ki(nC),ji(nC))-ht_p(ii(nC),ki(nC)-1,ji(nC)))
	   if ((ki(nC)<test_k).AND.((ht_p(ii(nC),ki(nC),ji(nC))-side_img(6,S))/(ht_p(ii(nC),ki(nC),ji(nC))-ht_p(ii(nC),ki(nC)-1,ji(nC)))<dist)) ki(nC)=ki(nC)+1
	   ki(nC+2) = ki(nC)-1
	enddo	 
	do nC = 4,5
	   do while (side_img(6,S) >= ht_p(ii(nC),ki(nC),ji(nC)))
	     ki(nC)=ki(nC)+1
	   enddo  
	   !if (ki(nC)<test_k) write(*,'(5i5,1f20.8)') stag,S,nC,ki(nC),test_k,(ht_p(ii(nC),ki(nC),ji(nC))-side_img(6,S))/(ht_p(ii(nC),ki(nC),ji(nC))-ht_p(ii(nC),ki(nC)-1,ji(nC)))
	   if ((ki(nC)<test_k).AND.((ht_p(ii(nC),ki(nC),ji(nC))-side_img(6,S))/(ht_p(ii(nC),ki(nC),ji(nC))-ht_p(ii(nC),ki(nC)-1,ji(nC)))<dist)) ki(nC)=ki(nC)+1
  	   ki(nC+2) = ki(nC)-1
	enddo   
!   ELSEIF (bc_type == 2) THEN
!	do while (side_bound(3,S) >= ht_p(side(1,S),test_k,side(2,S)))
!	     test_k=test_k+1
!	enddo
!	do nC = 0,1
!	   do while (side_bound(3,S) >= ht_p(ii(nC),ki(nC),ji(nC)))
!	     ki(nC)=ki(nC)+1
!	   enddo 
!	   !if (ki(nC)<test_k) write(*,'(5i5,1f20.8)') stag,S,nC,ki(nC),test_k,(ht_p(ii(nC),ki(nC),ji(nC))-side_bound(3,S))/(ht_p(ii(nC),ki(nC),ji(nC))-ht_p(ii(nC),ki(nC)-1,ji(nC)))
!	   if ((ki(nC)<test_k).AND.((ht_p(ii(nC),ki(nC),ji(nC))-side_bound(3,S))/(ht_p(ii(nC),ki(nC),ji(nC))-ht_p(ii(nC),ki(nC)-1,ji(nC)))<dist)) ki(nC)=ki(nC)+1 
!	   ki(nC+2) = ki(nC)-1
!	enddo	 
!	do nC = 4,5
!	   do while (side_bound(3,S) >= ht_p(ii(nC),ki(nC),ji(nC)))
!	     ki(nC)=ki(nC)+1
!	   enddo 
!	   !if (ki(nC)<test_k) write(*,'(5i5,1f20.8)') stag,S,nC,ki(nC),test_k,(ht_p(ii(nC),ki(nC),ji(nC))-side_bound(3,S))/(ht_p(ii(nC),ki(nC),ji(nC))-ht_p(ii(nC),ki(nC)-1,ji(nC)))
!	   if ((ki(nC)<test_k).AND.((ht_p(ii(nC),ki(nC),ji(nC))-side_bound(3,S))/(ht_p(ii(nC),ki(nC),ji(nC))-ht_p(ii(nC),ki(nC)-1,ji(nC)))<dist)) ki(nC)=ki(nC)+1  
!	   ki(nC+2) = ki(nC)-1
!	enddo
!   ENDIF  
    IF ((inside(ii(0),ki(0),ji(0)) == 0).AND. &
	(inside(ii(1),ki(1),ji(1)) == 0).AND. &
	(inside(ii(2),ki(2),ji(2)) == 0).AND. &
	(inside(ii(3),ki(3),ji(3)) == 0).AND. &
	(inside(ii(4),ki(4),ji(4)) == 0).AND. &
	(inside(ii(5),ki(5),ji(5)) == 0).AND. &
	(inside(ii(6),ki(6),ji(6)) == 0).AND. &
	(inside(ii(7),ki(7),ji(7)) == 0)) THEN
	 ! neighbors 0,1,2,3,4,4,6,7 are the zero computational nodes
	 do nC = 0,7
	    side_neigh_i(3*nC,S) = ii(nC)
	    side_neigh_i(3*nC+1,S) = ji(nC)
	    side_neigh_i(3*nC+2,S) = ki(nC)		
	    if (stag ==1 ) then 			
		side_neigh(3*nC,S) = (side_neigh_i(3*nC,S)*dx)-(dx)
		side_neigh(3*nC+1,S) = (side_neigh_i(3*nC+1,S)*dy)-(dy/2)
	    elseif (stag == 2) then
		side_neigh(3*nC,S) = (side_neigh_i(3*nC,S)*dx)-(dx/2)
		side_neigh(3*nC+1,S) = (side_neigh_i(3*nC+1,S)*dy)-(dy)	     
	    elseif (stag == 3) then
		side_neigh(3*nC,S) = (side_neigh_i(3*nC,S)*dx)-(dx/2)
		side_neigh(3*nC+1,S) = (side_neigh_i(3*nC+1,S)*dy)-(dy/2)	     
	    endif
	    side_neigh(3*nC+2,S) = ht_p(side_neigh_i(3*nC,S),side_neigh_i(3*nC+2,S),side_neigh_i(3*nC+1,S))  
	 enddo	
    ELSEIF ((inside(ii(0),ki(0),ji(0)) == 1).AND. &
 	(inside(ii(1),ki(1),ji(1)) == 0).AND. &
 	(inside(ii(2),ki(2),ji(2)) == 1).AND. &
 	(inside(ii(3),ki(3),ji(3)) == 0).AND. &
 	(inside(ii(4),ki(4),ji(4)) == 0).AND. &
 	(inside(ii(5),ki(5),ji(5)) == 0).AND. &
 	(inside(ii(6),ki(6),ji(6)) == 0).AND. &
 	(inside(ii(7),ki(7),ji(7)) == 0)) THEN
 	 ! neighbor 0 on the boundary on the 0145 plane
 	 nC = 0 
 	 side_neigh_i(3*nC,S) = 0
 	 side_neigh_i(3*nC+1,S) = 0
 	 side_neigh_i(3*nC+2,S) = 0
 	 ! first z
 	 side_neigh(3*nC+2,S) = ht_p(ii(nC),ki(nC),ji(nC))
 	 if (stag == 1) then
 	     ! solve for x
 	     if (ibm_ht_xstag(ii(nC),ji(nC)) >= side_neigh(3*nC+2,S)) then
 		side_neigh(3*nC,S) = (ii(nC)*dx)-dx + (dx/4)+(dx/4)*((side_neigh(3*nC+2,S)-ibm_ht_xstag(ii(nC),ji(nC))) &
 							         /(ibm_ht(ii(nC)+1,ji(nC))-ibm_ht_xstag(ii(nC),ji(nC))))
 	     else
 		side_neigh(3*nC,S) = (ii(nC)*dx)-dx + (dx/4)*((side_neigh(3*nC+2,S)-ibm_ht(ii(nC),ji(nC))) &
 						      /(ibm_ht_xstag(ii(nC),ji(nC))-ibm_ht(ii(nC),ji(nC))))
 	     endif						  
 	     ! solve for y
 	     if (ibm_ht_ystag(ii(nC),ji(nC)+1) >= side_neigh(3*nC+2,S)) then
 		side_neigh(3*nC+1,S) = (ji(nC)*dy)-(dy/2) + (dy/4)+(dy/4)*((side_neigh(3*nC+2,S)-ibm_ht_ystag(ii(nC),ji(nC)+1)) &
 						   	               /(ibm_ht(ii(nC),ji(nC)+1)-ibm_ht_ystag(ii(nC),ji(nC)+1)))
 	     else
 		side_neigh(3*nC+1,S) = (ji(nC)*dy)-(dy/2) + (dy/4)*((side_neigh(3*nC+2,S)-ibm_ht(ii(nC),ji(nC))) &
 							  /(ibm_ht_ystag(ii(nC),ji(nC)+1)-ibm_ht(ii(nC),ji(nC))))
 	     endif
 	 elseif (stag == 2) then
 	     ! solve for x
 	     if (ibm_ht_xstag(ii(nC)+1,ji(nC)) >= side_neigh(3*nC+2,S)) then
 		side_neigh(3*nC,S) = (ii(nC)*dx)-(dx/2) + (dx/4)+(dx/4)*((side_neigh(3*nC+2,S)-ibm_ht_xstag(ii(nC)+1,ji(nC))) &
 						                     /(ibm_ht(ii(nC)+1,ji(nC))-ibm_ht_xstag(ii(nC)+1,ji(nC))))
 	     else
 		side_neigh(3*nC,S) = (ii(nC)*dx)-(dx/2) + (dx/4)*((side_neigh(3*nC+2,S)-ibm_ht(ii(nC),ji(nC))) &
 							/(ibm_ht_xstag(ii(nC)+1,ji(nC))-ibm_ht(ii(nC),ji(nC))))
 	     endif
 	     ! solve for y
 	     if (ibm_ht_ystag(ii(nC),ji(nC)) >= side_neigh(3*nC+2,S)) then
 		side_neigh(3*nC+1,S) = (ji(nC)*dy)-dy + (dy/4)+(dy/4)*((side_neigh(3*nC+2,S)-ibm_ht_ystag(ii(nC),ji(nC))) &
 							  	   /(ibm_ht(ii(nC),ji(nC)+1)-ibm_ht_ystag(ii(nC),ji(nC))))
 	     else
 		side_neigh(3*nC+1,S) = (ji(nC)*dy)-dy + (dy/4)*((side_neigh(3*nC+2,S)-ibm_ht(ii(nC),ji(nC))) &
 							/(ibm_ht_ystag(ii(nC),ji(nC))-ibm_ht(ii(nC),ji(nC))))
 	     endif
 	elseif (stag == 3) then
 	     ! solve for x
 	     if (ibm_ht_xstag(ii(nC)+1,ji(nC)) >= side_neigh(3*nC+2,S)) then
 		side_neigh(3*nC,S) = (ii(nC)*dx)-(dx/2) + (dx/4)+(dx/4)*((side_neigh(3*nC+2,S)-ibm_ht_xstag(ii(nC)+1,ji(nC))) &
 						                     /(ibm_ht(ii(nC)+1,ji(nC))-ibm_ht_xstag(ii(nC)+1,ji(nC))))
 	     else
 		side_neigh(3*nC,S) = (ii(nC)*dx)-(dx/2) + (dx/4)*((side_neigh(3*nC+2,S)-ibm_ht(ii(nC),ji(nC))) &
 							/(ibm_ht_xstag(ii(nC)+1,ji(nC))-ibm_ht(ii(nC),ji(nC))))
 	     endif
 	     ! solve for y
 	     if (ibm_ht_ystag(ii(nC),ji(nC)+1) >= side_neigh(3*nC+2,S)) then
 		side_neigh(3*nC+1,S) = (ji(nC)*dy)-(dy/2) + (dy/4)+(dy/4)*((side_neigh(3*nC+2,S)-ibm_ht_ystag(ii(nC),ji(nC)+1)) &
 							               /(ibm_ht(ii(nC),ji(nC)+1)-ibm_ht_ystag(ii(nC),ji(nC)+1)))
 	     else
 		side_neigh(3*nC+1,S) = (ji(nC)*dy)-(dy/2) + (dy/4)*((side_neigh(3*nC+2,S)-ibm_ht(ii(nC),ji(nC))) &
 							  /(ibm_ht_ystag(ii(nC),ji(nC)+1)-ibm_ht(ii(nC),ji(nC))))
 	     endif
 	endif
 	! neighbors 1,3,4,5,6,7 are the zero computational nodes
 	nC = 1
 	side_neigh_i(3*nC,S) = ii(nC)
 	side_neigh_i(3*nC+1,S) = ji(nC)
 	side_neigh_i(3*nC+2,S) = ki(nC) 	
 	if (stag ==1 ) then			
 	    side_neigh(3*nC,S) = (side_neigh_i(3*nC,S)*dx)-(dx)
 	    side_neigh(3*nC+1,S) = (side_neigh_i(3*nC+1,S)*dy)-(dy/2)
 	elseif (stag == 2) then
 	    side_neigh(3*nC,S) = (side_neigh_i(3*nC,S)*dx)-(dx/2)
 	    side_neigh(3*nC+1,S) = (side_neigh_i(3*nC+1,S)*dy)-(dy)	     
 	elseif (stag == 3) then
 	    side_neigh(3*nC,S) = (side_neigh_i(3*nC,S)*dx)-(dx/2)
 	    side_neigh(3*nC+1,S) = (side_neigh_i(3*nC+1,S)*dy)-(dy/2)	     
 	endif
 	side_neigh(3*nC+2,S) = ht_p(side_neigh_i(3*nC,S),side_neigh_i(3*nC+2,S),side_neigh_i(3*nC+1,S))
 	! neighbor 2 on the boundary on the 2367 plane
 	nC = 2
 	side_neigh_i(3*nC,S) = 0
 	side_neigh_i(3*nC+1,S) = 0
 	side_neigh_i(3*nC+2,S) = 0
 	! first z
 	side_neigh(3*nC+2,S) = ht_p(ii(nC),ki(nC),ji(nC))
 	if (stag == 1) then
  	     ! solve for x
 	     if (ibm_ht_xstag(ii(nC),ji(nC)) >= side_neigh(3*nC+2,S)) then
 		side_neigh(3*nC,S) = (ii(nC)*dx)-dx + (dx/4)+(dx/4)*((side_neigh(3*nC+2,S)-ibm_ht_xstag(ii(nC),ji(nC))) &
 							         /(ibm_ht(ii(nC)+1,ji(nC))-ibm_ht_xstag(ii(nC),ji(nC))))
 	     else
 		side_neigh(3*nC,S) = (ii(nC)*dx)-dx + (dx/4)*((side_neigh(3*nC+2,S)-ibm_ht(ii(nC),ji(nC))) &
 						      /(ibm_ht_xstag(ii(nC),ji(nC))-ibm_ht(ii(nC),ji(nC))))
 	     endif						  
 	     ! solve for y
 	     if (ibm_ht_ystag(ii(nC),ji(nC)+1) >= side_neigh(3*nC+2,S)) then
 		side_neigh(3*nC+1,S) = (ji(nC)*dy)-(dy/2) + (dy/4)+(dy/4)*((side_neigh(3*nC+2,S)-ibm_ht_ystag(ii(nC),ji(nC)+1)) &
 						   	               /(ibm_ht(ii(nC),ji(nC)+1)-ibm_ht_ystag(ii(nC),ji(nC)+1)))
 	     else
 		side_neigh(3*nC+1,S) = (ji(nC)*dy)-(dy/2) + (dy/4)*((side_neigh(3*nC+2,S)-ibm_ht(ii(nC),ji(nC))) &
 							  /(ibm_ht_ystag(ii(nC),ji(nC)+1)-ibm_ht(ii(nC),ji(nC))))
 	     endif
 	elseif (stag == 2) then
 	     ! solve for x
 	     if (ibm_ht_xstag(ii(nC)+1,ji(nC)) >= side_neigh(3*nC+2,S)) then
 		side_neigh(3*nC,S) = (ii(nC)*dx)-(dx/2) + (dx/4)+(dx/4)*((side_neigh(3*nC+2,S)-ibm_ht_xstag(ii(nC)+1,ji(nC))) &
 						                     /(ibm_ht(ii(nC)+1,ji(nC))-ibm_ht_xstag(ii(nC)+1,ji(nC))))
 	     else
 		side_neigh(3*nC,S) = (ii(nC)*dx)-(dx/2) + (dx/4)*((side_neigh(3*nC+2,S)-ibm_ht(ii(nC),ji(nC))) &
 							/(ibm_ht_xstag(ii(nC)+1,ji(nC))-ibm_ht(ii(nC),ji(nC))))
 	     endif
 	     ! solve for y
 	     if (ibm_ht_ystag(ii(nC),ji(nC)) >= side_neigh(3*nC+2,S)) then
 		side_neigh(3*nC+1,S) = (ji(nC)*dy)-dy + (dy/4)+(dy/4)*((side_neigh(3*nC+2,S)-ibm_ht_ystag(ii(nC),ji(nC))) &
 							  	   /(ibm_ht(ii(nC),ji(nC)+1)-ibm_ht_ystag(ii(nC),ji(nC))))
 	     else
 		side_neigh(3*nC+1,S) = (ji(nC)*dy)-dy + (dy/4)*((side_neigh(3*nC+2,S)-ibm_ht(ii(nC),ji(nC))) &
 							/(ibm_ht_ystag(ii(nC),ji(nC))-ibm_ht(ii(nC),ji(nC))))
 	     endif
       elseif (stag == 3) then
  	     ! solve for x
 	     if (ibm_ht_xstag(ii(nC)+1,ji(nC)) >= side_neigh(3*nC+2,S)) then
 		side_neigh(3*nC,S) = (ii(nC)*dx)-(dx/2) + (dx/4)+(dx/4)*((side_neigh(3*nC+2,S)-ibm_ht_xstag(ii(nC)+1,ji(nC))) &
 						                     /(ibm_ht(ii(nC)+1,ji(nC))-ibm_ht_xstag(ii(nC)+1,ji(nC))))
 	     else
 		side_neigh(3*nC,S) = (ii(nC)*dx)-(dx/2) + (dx/4)*((side_neigh(3*nC+2,S)-ibm_ht(ii(nC),ji(nC))) &
 							/(ibm_ht_xstag(ii(nC)+1,ji(nC))-ibm_ht(ii(nC),ji(nC))))
 	     endif
 	     ! solve for y
 	     if (ibm_ht_ystag(ii(nC),ji(nC)+1) >= side_neigh(3*nC+2,S)) then
 		side_neigh(3*nC+1,S) = (ji(nC)*dy)-(dy/2) + (dy/4)+(dy/4)*((side_neigh(3*nC+2,S)-ibm_ht_ystag(ii(nC),ji(nC)+1)) &
 							               /(ibm_ht(ii(nC),ji(nC)+1)-ibm_ht_ystag(ii(nC),ji(nC)+1)))
 	     else
 		side_neigh(3*nC+1,S) = (ji(nC)*dy)-(dy/2) + (dy/4)*((side_neigh(3*nC+2,S)-ibm_ht(ii(nC),ji(nC))) &
 							  /(ibm_ht_ystag(ii(nC),ji(nC)+1)-ibm_ht(ii(nC),ji(nC))))
 	     endif
       endif
       ! neighbors 1,3,4,5,6,7 are the zero computational nodes
       do nC = 3,7
 	  side_neigh_i(3*nC,S) = ii(nC)
 	  side_neigh_i(3*nC+1,S) = ji(nC)
 	  side_neigh_i(3*nC+2,S) = ki(nC)		
 	  if (stag ==1 ) then			
 	      side_neigh(3*nC,S) = (side_neigh_i(3*nC,S)*dx)-(dx)
 	      side_neigh(3*nC+1,S) = (side_neigh_i(3*nC+1,S)*dy)-(dy/2)
 	  elseif (stag == 2) then
 	      side_neigh(3*nC,S) = (side_neigh_i(3*nC,S)*dx)-(dx/2)
 	      side_neigh(3*nC+1,S) = (side_neigh_i(3*nC+1,S)*dy)-(dy)	     
 	  elseif (stag == 3) then
 	      side_neigh(3*nC,S) = (side_neigh_i(3*nC,S)*dx)-(dx/2)
 	      side_neigh(3*nC+1,S) = (side_neigh_i(3*nC+1,S)*dy)-(dy/2)      
 	  endif
 	  side_neigh(3*nC+2,S) = ht_p(side_neigh_i(3*nC,S),side_neigh_i(3*nC+2,S),side_neigh_i(3*nC+1,S))  
       enddo 
    ELSEIF ((inside(ii(0),ki(0),ji(0)) == 0).AND. &
 	 (inside(ii(1),ki(1),ji(1)) == 1).AND. &
 	 (inside(ii(2),ki(2),ji(2)) == 0).AND. &
 	 (inside(ii(3),ki(3),ji(3)) == 1).AND. &
 	 (inside(ii(4),ki(4),ji(4)) == 0).AND. &
 	 (inside(ii(5),ki(5),ji(5)) == 0).AND. &
 	 (inside(ii(6),ki(6),ji(6)) == 0).AND. &
 	 (inside(ii(7),ki(7),ji(7)) == 0)) THEN  
 	 ! neighbors 0,2,4,5,6,7 are the zero computational nodes
 	 nC = 0
 	 side_neigh_i(3*nC,S) = ii(nC)
 	 side_neigh_i(3*nC+1,S) = ji(nC)
 	 side_neigh_i(3*nC+2,S) = ki(nC)		
 	 if (stag ==1 ) then			
 	     side_neigh(3*nC,S) = (side_neigh_i(3*nC,S)*dx)-(dx)
 	     side_neigh(3*nC+1,S) = (side_neigh_i(3*nC+1,S)*dy)-(dy/2)
 	 elseif (stag == 2) then
 	     side_neigh(3*nC,S) = (side_neigh_i(3*nC,S)*dx)-(dx/2)
 	     side_neigh(3*nC+1,S) = (side_neigh_i(3*nC+1,S)*dy)-(dy)	     
 	 elseif (stag == 3) then
 	     side_neigh(3*nC,S) = (side_neigh_i(3*nC,S)*dx)-(dx/2)
 	     side_neigh(3*nC+1,S) = (side_neigh_i(3*nC+1,S)*dy)-(dy/2)       
 	 endif
 	 side_neigh(3*nC+2,S) = ht_p(side_neigh_i(3*nC,S),side_neigh_i(3*nC+2,S),side_neigh_i(3*nC+1,S))
 	 ! neighbor 1 on the boundary face that cuts the 0145 plane
 	 nC = 1 
 	 side_neigh_i(3*nC,S) = 0
 	 side_neigh_i(3*nC+1,S) = 0
 	 side_neigh_i(3*nC+2,S) = 0
 	 ! first z
 	 side_neigh(3*nC+2,S) = ht_p(ii(nC),ki(nC),ji(nC))
 	 if (stag == 1) then
 	     ! solve for x/2
 	     if (ibm_ht_xstag(ii(nC)-1,ji(nC)) >= side_neigh(3*nC+2,S)) then
 		side_neigh(3*nC,S) = ((ii(nC)-1)*dx)-dx + (dx/2)+(dx/4)*((side_neigh(3*nC+2,S)-ibm_ht(ii(nC)-1,ji(nC))) &
 							       /(ibm_ht_xstag(ii(nC)-1,ji(nC))-ibm_ht(ii(nC)-1,ji(nC))))
 	     else
 		side_neigh(3*nC,S) = ((ii(nC)-1)*dx)-(dx/2) +  (dx/4)+(dx/4)*((side_neigh(3*nC+2,S)-ibm_ht_xstag(ii(nC)-1,ji(nC))) &
 									    /(ibm_ht(ii(nC),ji(nC))-ibm_ht_xstag(ii(nC)-1,ji(nC))))
 	     endif	
 	     ! solve for y/2
 	     if (ibm_ht_ystag(ii(nC),ji(nC)+1) >= side_neigh(3*nC+2,S)) then
 		side_neigh(3*nC+1,S) = (ji(nC)*dy)-(dy/2) + (dy/4)+(dy/4)*((side_neigh(3*nC+2,S)-ibm_ht_ystag(ii(nC),ji(nC)+1)) &
 							               /(ibm_ht(ii(nC),ji(nC)+1)-ibm_ht_ystag(ii(nC),ji(nC)+1)))
 	     else
 		side_neigh(3*nC+1,S) = (ji(nC)*dy)-(dy/2) + (dy/4)*((side_neigh(3*nC+2,S)-ibm_ht(ii(nC),ji(nC))) &
 							  /(ibm_ht_ystag(ii(nC),ji(nC)+1)-ibm_ht(ii(nC),ji(nC))))
 	     endif					  
 	 elseif (stag == 2) then
 	     ! solve for x/2
 	     if (ibm_ht_xstag(ii(nC),ji(nC)) >= side_neigh(3*nC+2,S)) then
 		side_neigh(3*nC,S) = ((ii(nC)-1)*dx)-(dx/2) +  (dx/2)+(dx/4)*((side_neigh(3*nC+2,S)-ibm_ht(ii(nC)-1,ji(nC))) &
 								      /(ibm_ht_xstag(ii(nC),ji(nC))-ibm_ht(ii(nC)-1,ji(nC))))
 	     else
 		side_neigh(3*nC,S) = (ii(nC)*dx)-dx +  (dx/4)+(dx/4)*((side_neigh(3*nC+2,S)-ibm_ht_xstag(ii(nC),ji(nC))) &
 								    /(ibm_ht(ii(nC),ji(nC))-ibm_ht_xstag(ii(nC),ji(nC))))
 	     endif
 	     ! solve for y/2
 	     if (ibm_ht_ystag(ii(nC),ji(nC)) >= side_neigh(3*nC+2,S)) then
 		side_neigh(3*nC+1,S) = (ji(nC)*dy)-dy + (dy/4)+(dy/4)*((side_neigh(3*nC+2,S)-ibm_ht_ystag(ii(nC),ji(nC))) &
 						                   /(ibm_ht(ii(nC),ji(nC)+1)-ibm_ht_ystag(ii(nC),ji(nC))))
 	     else
 		side_neigh(3*nC+1,S) = (ji(nC)*dy)-dy + (dy/4)*((side_neigh(3*nC+2,S)-ibm_ht(ii(nC),ji(nC))) &
 							/(ibm_ht_ystag(ii(nC),ji(nC))-ibm_ht(ii(nC),ji(nC))))
 	     endif
 	 elseif (stag == 3) then
 	     ! solve for x/2
 	     if (ibm_ht_xstag(ii(nC),ji(nC)) >= side_neigh(3*nC+2,S)) then
 		side_neigh(3*nC,S) = ((ii(nC)-1)*dx)-(dx/2) + (dx/2)+(dx/4)*((side_neigh(3*nC+2,S)-ibm_ht(ii(nC)-1,ji(nC))) &
 								     /(ibm_ht_xstag(ii(nC),ji(nC))-ibm_ht(ii(nC)-1,ji(nC))))
 	     else
 		side_neigh(3*nC,S) = (ii(nC)*dx)-dx +  (dx/4)+(dx/4)*((side_neigh(3*nC+2,S)-ibm_ht_xstag(ii(nC),ji(nC))) &
 								    /(ibm_ht(ii(nC),ji(nC))-ibm_ht_xstag(ii(nC),ji(nC))))
 	     endif
 	     ! solve for y/2
 	     if (ibm_ht_ystag(ii(nC),ji(nC)+1) >= side_neigh(3*nC+2,S)) then
 		side_neigh(3*nC+1,S) = (ji(nC)*dy)-(dy/2) + (dy/4)+(dy/4)*((side_neigh(3*nC+2,S)-ibm_ht_ystag(ii(nC),ji(nC)+1)) &
 							               /(ibm_ht(ii(nC),ji(nC)+1)-ibm_ht_ystag(ii(nC),ji(nC)+1)))
 	     else
 		side_neigh(3*nC+1,S) = (ji(nC)*dy)-(dy/2) + (dy/4)*((side_neigh(3*nC+2,S)-ibm_ht(ii(nC),ji(nC))) &
 							  /(ibm_ht_ystag(ii(nC),ji(nC)+1)-ibm_ht(ii(nC),ji(nC))))
 	     endif
 	 endif
 	 ! neighbors 0,2,4,5,6,7 are the zero computational nodes
 	 nC = 2
 	 side_neigh_i(3*nC,S) = ii(nC)
 	 side_neigh_i(3*nC+1,S) = ji(nC)
 	 side_neigh_i(3*nC+2,S) = ki(nC)		
 	 if (stag ==1 ) then			
 	     side_neigh(3*nC,S) = (side_neigh_i(3*nC,S)*dx)-(dx)
 	     side_neigh(3*nC+1,S) = (side_neigh_i(3*nC+1,S)*dy)-(dy/2)
 	 elseif (stag == 2) then
 	     side_neigh(3*nC,S) = (side_neigh_i(3*nC,S)*dx)-(dx/2)
 	     side_neigh(3*nC+1,S) = (side_neigh_i(3*nC+1,S)*dy)-(dy)	     
 	 elseif (stag == 3) then
 	     side_neigh(3*nC,S) = (side_neigh_i(3*nC,S)*dx)-(dx/2)
 	     side_neigh(3*nC+1,S) = (side_neigh_i(3*nC+1,S)*dy)-(dy/2)       
 	 endif
 	 side_neigh(3*nC+2,S) = ht_p(side_neigh_i(3*nC,S),side_neigh_i(3*nC+2,S),side_neigh_i(3*nC+1,S))
 	 ! neighbor 3 on the boundary face that cuts the 2367 plane
 	 nC = 3
 	 side_neigh_i(3*nC,S) = 0
 	 side_neigh_i(3*nC+1,S) = 0
 	 side_neigh_i(3*nC+2,S) = 0
 	 ! first z
 	 side_neigh(3*nC+2,S) = ht_p(ii(nC),ki(nC),ji(nC))
 	 if (stag == 1) then
	     ! solve for x/2
 	     if (ibm_ht_xstag(ii(nC)-1,ji(nC)) >= side_neigh(3*nC+2,S)) then
 		side_neigh(3*nC,S) = ((ii(nC)-1)*dx)-dx + (dx/2)+(dx/4)*((side_neigh(3*nC+2,S)-ibm_ht(ii(nC)-1,ji(nC))) &
 							       /(ibm_ht_xstag(ii(nC)-1,ji(nC))-ibm_ht(ii(nC)-1,ji(nC))))
 	     else
 		side_neigh(3*nC,S) = ((ii(nC)-1)*dx)-(dx/2) +  (dx/4)+(dx/4)*((side_neigh(3*nC+2,S)-ibm_ht_xstag(ii(nC)-1,ji(nC))) &
 									    /(ibm_ht(ii(nC),ji(nC))-ibm_ht_xstag(ii(nC)-1,ji(nC))))
 	     endif	
 	     ! solve for y/2
 	     if (ibm_ht_ystag(ii(nC),ji(nC)+1) >= side_neigh(3*nC+2,S)) then
 		side_neigh(3*nC+1,S) = (ji(nC)*dy)-(dy/2) + (dy/4)+(dy/4)*((side_neigh(3*nC+2,S)-ibm_ht_ystag(ii(nC),ji(nC)+1)) &
 							               /(ibm_ht(ii(nC),ji(nC)+1)-ibm_ht_ystag(ii(nC),ji(nC)+1)))
 	     else
 		side_neigh(3*nC+1,S) = (ji(nC)*dy)-(dy/2) + (dy/4)*((side_neigh(3*nC+2,S)-ibm_ht(ii(nC),ji(nC))) &
 							  /(ibm_ht_ystag(ii(nC),ji(nC)+1)-ibm_ht(ii(nC),ji(nC))))
 	     endif						  
 	 elseif (stag == 2) then
 	     ! solve for x/2
 	     if (ibm_ht_xstag(ii(nC),ji(nC)) >= side_neigh(3*nC+2,S)) then
 		side_neigh(3*nC,S) = ((ii(nC)-1)*dx)-(dx/2) +  (dx/2)+(dx/4)*((side_neigh(3*nC+2,S)-ibm_ht(ii(nC)-1,ji(nC))) &
 								      /(ibm_ht_xstag(ii(nC),ji(nC))-ibm_ht(ii(nC)-1,ji(nC))))
 	     else
 		side_neigh(3*nC,S) = (ii(nC)*dx)-dx +  (dx/4)+(dx/4)*((side_neigh(3*nC+2,S)-ibm_ht_xstag(ii(nC),ji(nC))) &
 								    /(ibm_ht(ii(nC),ji(nC))-ibm_ht_xstag(ii(nC),ji(nC))))
 	     endif
 	     ! solve for y/2
 	     if (ibm_ht_ystag(ii(nC),ji(nC)) >= side_neigh(3*nC+2,S)) then
 		side_neigh(3*nC+1,S) = (ji(nC)*dy)-dy + (dy/4)+(dy/4)*((side_neigh(3*nC+2,S)-ibm_ht_ystag(ii(nC),ji(nC))) &
 						                   /(ibm_ht(ii(nC),ji(nC)+1)-ibm_ht_ystag(ii(nC),ji(nC))))
 	     else
 		side_neigh(3*nC+1,S) = (ji(nC)*dy)-dy + (dy/4)*((side_neigh(3*nC+2,S)-ibm_ht(ii(nC),ji(nC))) &
 							/(ibm_ht_ystag(ii(nC),ji(nC))-ibm_ht(ii(nC),ji(nC))))
 	     endif
 	 elseif (stag == 3) then
 	     ! solve for x/2
 	     if (ibm_ht_xstag(ii(nC),ji(nC)) >= side_neigh(3*nC+2,S)) then
 		side_neigh(3*nC,S) = ((ii(nC)-1)*dx)-(dx/2) +  (dx/2)+(dx/4)*((side_neigh(3*nC+2,S)-ibm_ht(ii(nC)-1,ji(nC))) &
 								      /(ibm_ht_xstag(ii(nC),ji(nC))-ibm_ht(ii(nC)-1,ji(nC))))
 	     else
 		side_neigh(3*nC,S) = (ii(nC)*dx)-dx +  (dx/4)+(dx/4)*((side_neigh(3*nC+2,S)-ibm_ht_xstag(ii(nC),ji(nC))) &
 								    /(ibm_ht(ii(nC),ji(nC))-ibm_ht_xstag(ii(nC),ji(nC))))
 	     endif
 	     ! solve for y/2
 	     if (ibm_ht_ystag(ii(nC),ji(nC)+1) >= side_neigh(3*nC+2,S)) then
 		side_neigh(3*nC+1,S) = (ji(nC)*dy)-(dy/2) + (dy/4)+(dy/4)*((side_neigh(3*nC+2,S)-ibm_ht_ystag(ii(nC),ji(nC)+1)) &
 							               /(ibm_ht(ii(nC),ji(nC)+1)-ibm_ht_ystag(ii(nC),ji(nC)+1)))
 	     else
 		side_neigh(3*nC+1,S) = (ji(nC)*dy)-(dy/2) + (dy/4)*((side_neigh(3*nC+2,S)-ibm_ht(ii(nC),ji(nC))) &
 							  /(ibm_ht_ystag(ii(nC),ji(nC)+1)-ibm_ht(ii(nC),ji(nC))))
 	     endif
 	 endif
 	 ! neighbors 0,2,4,5,6,7 are the zero computational nodes
 	 do nC = 4,7
 	    side_neigh_i(3*nC,S) = ii(nC)
 	    side_neigh_i(3*nC+1,S) = ji(nC)
 	    side_neigh_i(3*nC+2,S) = ki(nC)		
 	    if (stag ==1 ) then 			
 		side_neigh(3*nC,S) = (side_neigh_i(3*nC,S)*dx)-(dx)
 		side_neigh(3*nC+1,S) = (side_neigh_i(3*nC+1,S)*dy)-(dy/2)
 	    elseif (stag == 2) then
 		side_neigh(3*nC,S) = (side_neigh_i(3*nC,S)*dx)-(dx/2)
 		side_neigh(3*nC+1,S) = (side_neigh_i(3*nC+1,S)*dy)-(dy)      
 	    elseif (stag == 3) then
 		side_neigh(3*nC,S) = (side_neigh_i(3*nC,S)*dx)-(dx/2)
 		side_neigh(3*nC+1,S) = (side_neigh_i(3*nC+1,S)*dy)-(dy/2)	     
 	    endif
 	    side_neigh(3*nC+2,S) = ht_p(side_neigh_i(3*nC,S),side_neigh_i(3*nC+2,S),side_neigh_i(3*nC+1,S))  
 	 enddo   
    ELSEIF ((inside(ii(0),ki(0),ji(0)) == 0).AND. &
 	(inside(ii(1),ki(1),ji(1)) == 0).AND. &
 	(inside(ii(2),ki(2),ji(2)) == 0).AND. &
 	(inside(ii(3),ki(3),ji(3)) == 0).AND. &
 	(inside(ii(4),ki(4),ji(4)) == 1).AND. &
 	(inside(ii(5),ki(5),ji(5)) == 0).AND. &
 	(inside(ii(6),ki(6),ji(6)) == 1).AND. &
 	(inside(ii(7),ki(7),ji(7)) == 0)) THEN
 	! neighbors 0,1,2,3,5,7 are the zero computational nodes
 	do nC = 0,3
 	   side_neigh_i(3*nC,S) = ii(nC)
 	   side_neigh_i(3*nC+1,S) = ji(nC)
 	   side_neigh_i(3*nC+2,S) = ki(nC)		
 	   if (stag ==1 ) then  		
 	       side_neigh(3*nC,S) = (side_neigh_i(3*nC,S)*dx)-(dx)
 	       side_neigh(3*nC+1,S) = (side_neigh_i(3*nC+1,S)*dy)-(dy/2)
 	   elseif (stag == 2) then
 	       side_neigh(3*nC,S) = (side_neigh_i(3*nC,S)*dx)-(dx/2)
 	       side_neigh(3*nC+1,S) = (side_neigh_i(3*nC+1,S)*dy)-(dy)       
 	   elseif (stag == 3) then
 	       side_neigh(3*nC,S) = (side_neigh_i(3*nC,S)*dx)-(dx/2)
 	       side_neigh(3*nC+1,S) = (side_neigh_i(3*nC+1,S)*dy)-(dy/2)	     
 	   endif
 	   side_neigh(3*nC+2,S) = ht_p(side_neigh_i(3*nC,S),side_neigh_i(3*nC+2,S),side_neigh_i(3*nC+1,S))  
 	enddo
 	! neighbor 4 on the boundary on the 0145 plane 
 	nC = 4 
 	side_neigh_i(3*nC,S) = 0
 	side_neigh_i(3*nC+1,S) = 0
 	side_neigh_i(3*nC+2,S) = 0
 	! first z
 	side_neigh(3*nC+2,S) = ht_p(ii(nC),ki(nC),ji(nC))
 	if (stag == 1) then
 	    ! solve for x
 	    if (ibm_ht_xstag(ii(nC),ji(nC)) >= side_neigh(3*nC+2,S)) then
 	       side_neigh(3*nC,S) = (ii(nC)*dx)-dx + (dx/4)+(dx/4)*((side_neigh(3*nC+2,S)-ibm_ht_xstag(ii(nC),ji(nC))) &
 							        /(ibm_ht(ii(nC)+1,ji(nC))-ibm_ht_xstag(ii(nC),ji(nC))))
 	    else
 	       side_neigh(3*nC,S) = (ii(nC)*dx)-dx + (dx/4)*((side_neigh(3*nC+2,S)-ibm_ht(ii(nC),ji(nC))) &
 						     /(ibm_ht_xstag(ii(nC),ji(nC))-ibm_ht(ii(nC),ji(nC))))
 	    endif						  
 	    ! solve for y
 	    if (ibm_ht_ystag(ii(nC),ji(nC)) >= side_neigh(3*nC+2,S)) then
 	       side_neigh(3*nC+1,S) = ((ji(nC)-1)*dy) +(dy/4)*((side_neigh(3*nC+2,S)-ibm_ht(ii(nC),ji(nC)-1)) &
 						       /(ibm_ht_ystag(ii(nC),ji(nC))-ibm_ht(ii(nC),ji(nC)-1)))
 	    else
 	       side_neigh(3*nC+1,S) = (ji(nC)*dy)-dy + (dy/4)+(dy/4)*((side_neigh(3*nC+2,S)-ibm_ht_ystag(ii(nC),ji(nC))) &
 								    /(ibm_ht(ii(nC),ji(nC))-ibm_ht_ystag(ii(nC),ji(nC))))
 	    endif
 	elseif (stag == 2) then
 	    ! solve for x
 	    if (ibm_ht_xstag(ii(nC)+1,ji(nC)) >= side_neigh(3*nC+2,S)) then
 	       side_neigh(3*nC,S) = (ii(nC)*dx)-(dx/2) + (dx/4)+(dx/4)*((side_neigh(3*nC+2,S)-ibm_ht_xstag(ii(nC)+1,ji(nC))) &
 						                    /(ibm_ht(ii(nC)+1,ji(nC))-ibm_ht_xstag(ii(nC)+1,ji(nC))))
 	    else
 	       side_neigh(3*nC,S) = (ii(nC)*dx)-(dx/2) + (dx/4)*((side_neigh(3*nC+2,S)-ibm_ht(ii(nC),ji(nC))) &
 						       /(ibm_ht_xstag(ii(nC)+1,ji(nC))-ibm_ht(ii(nC),ji(nC))))
 	    endif
 	    ! solve for y
 	    if (ibm_ht_ystag(ii(nC),ji(nC)-1) >= side_neigh(3*nC+2,S)) then
 	       side_neigh(3*nC+1,S) = ((ji(nC)-1)*dy)-dy + (dy/2)+(dy/4)*((side_neigh(3*nC+2,S)-ibm_ht(ii(nC),ji(nC)-1)) &
 								/(ibm_ht_ystag(ii(nC),ji(nC)-1)-ibm_ht(ii(nC),ji(nC)-1)))
 	    else
 	       side_neigh(3*nC+1,S) = ((ji(nC)-1)*dy)-(dy/2) + (dy/4)+(dy/4)*((side_neigh(3*nC+2,S)-ibm_ht_ystag(ii(nC),ji(nC)-1)) &
 									    /(ibm_ht(ii(nC),ji(nC))-ibm_ht_ystag(ii(nC),ji(nC)-1)))
 	    endif
 	elseif (stag == 3) then
 	    ! solve for x
 	    if (ibm_ht_xstag(ii(nC)+1,ji(nC)) >= side_neigh(3*nC+2,S)) then
 	       side_neigh(3*nC,S) = (ii(nC)*dx)-(dx/2) + (dx/4)+(dx/4)*((side_neigh(3*nC+2,S)-ibm_ht_xstag(ii(nC)+1,ji(nC))) &
 						                    /(ibm_ht(ii(nC)+1,ji(nC))-ibm_ht_xstag(ii(nC)+1,ji(nC))))
 	    else 
 	       side_neigh(3*nC,S) = (ii(nC)*dx)-(dx/2) + (dx/4)*((side_neigh(3*nC+2,S)-ibm_ht(ii(nC),ji(nC))) &
 						       /(ibm_ht_xstag(ii(nC)+1,ji(nC))-ibm_ht(ii(nC),ji(nC))))
 	    endif
 	    ! solve for y
 	    if (ibm_ht_ystag(ii(nC),ji(nC)) >= side_neigh(3*nC+2,S)) then
 	       side_neigh(3*nC+1,S) = ((ji(nC)-1)*dy) + (dy/4)*((side_neigh(3*nC+2,S)-ibm_ht(ii(nC),ji(nC)-1)) &
 					                /(ibm_ht_ystag(ii(nC),ji(nC))-ibm_ht(ii(nC),ji(nC)-1)))
 	    else
 	       side_neigh(3*nC+1,S) = ((ji(nC)-1)*dy) + (dy/4)+(dy/4)*((side_neigh(3*nC+2,S)-ibm_ht_ystag(ii(nC),ji(nC))) &
 								      /(ibm_ht(ii(nC),ji(nC))-ibm_ht_ystag(ii(nC),ji(nC))))
 	    endif
 	endif
 	! neighbors 0,1,2,3,5,7 are the zero computational nodes
 	nC = 5
 	side_neigh_i(3*nC,S) = ii(nC)
 	side_neigh_i(3*nC+1,S) = ji(nC)
 	side_neigh_i(3*nC+2,S) = ki(nC) 	
 	if (stag ==1 ) then			
 	    side_neigh(3*nC,S) = (side_neigh_i(3*nC,S)*dx)-(dx)
 	    side_neigh(3*nC+1,S) = (side_neigh_i(3*nC+1,S)*dy)-(dy/2)
 	elseif (stag == 2) then
 	    side_neigh(3*nC,S) = (side_neigh_i(3*nC,S)*dx)-(dx/2)
 	    side_neigh(3*nC+1,S) = (side_neigh_i(3*nC+1,S)*dy)-(dy)	     
 	elseif (stag == 3) then
 	    side_neigh(3*nC,S) = (side_neigh_i(3*nC,S)*dx)-(dx/2)
 	    side_neigh(3*nC+1,S) = (side_neigh_i(3*nC+1,S)*dy)-(dy/2)	     
 	endif
 	side_neigh(3*nC+2,S) = ht_p(side_neigh_i(3*nC,S),side_neigh_i(3*nC+2,S),side_neigh_i(3*nC+1,S))
 	! neighbor 6 on the boundary on the 2367 plane 
 	nC = 6
 	side_neigh_i(3*nC,S) = 0
 	side_neigh_i(3*nC+1,S) = 0
 	side_neigh_i(3*nC+2,S) = 0
 	! first z
 	side_neigh(3*nC+2,S) = ht_p(ii(nC),ki(nC),ji(nC))
 	if (stag == 1) then
  	    ! solve for x
 	    if (ibm_ht_xstag(ii(nC),ji(nC)) >= side_neigh(3*nC+2,S)) then
 	       side_neigh(3*nC,S) = (ii(nC)*dx)-dx + (dx/4)+(dx/4)*((side_neigh(3*nC+2,S)-ibm_ht_xstag(ii(nC),ji(nC))) &
 							        /(ibm_ht(ii(nC)+1,ji(nC))-ibm_ht_xstag(ii(nC),ji(nC))))
 	    else
 	       side_neigh(3*nC,S) = (ii(nC)*dx)-dx + (dx/4)*((side_neigh(3*nC+2,S)-ibm_ht(ii(nC),ji(nC))) &
 						     /(ibm_ht_xstag(ii(nC),ji(nC))-ibm_ht(ii(nC),ji(nC))))
 	    endif						  
 	    ! solve for y
 	    if (ibm_ht_ystag(ii(nC),ji(nC)) >= side_neigh(3*nC+2,S)) then
 	       side_neigh(3*nC+1,S) = ((ji(nC)-1)*dy)-(dy/2) + (dy/2)+(dy/4)*((side_neigh(3*nC+2,S)-ibm_ht(ii(nC),ji(nC)-1)) &
 								      /(ibm_ht_ystag(ii(nC),ji(nC))-ibm_ht(ii(nC),ji(nC)-1)))
 	    else
 	       side_neigh(3*nC+1,S) = (ji(nC)*dy)-dy + (dy/4)+(dy/4)*((side_neigh(3*nC+2,S)-ibm_ht_ystag(ii(nC),ji(nC))) &
 								    /(ibm_ht(ii(nC),ji(nC))-ibm_ht_ystag(ii(nC),ji(nC))))
 	    endif
 	elseif (stag == 2) then
 	    ! solve for x
 	    if (ibm_ht_xstag(ii(nC)+1,ji(nC)) >= side_neigh(3*nC+2,S)) then
 	       side_neigh(3*nC,S) = (ii(nC)*dx)-(dx/2) + (dx/4)+(dx/4)*((side_neigh(3*nC+2,S)-ibm_ht_xstag(ii(nC)+1,ji(nC))) &
 						                    /(ibm_ht(ii(nC)+1,ji(nC))-ibm_ht_xstag(ii(nC)+1,ji(nC))))
 	    else
 	       side_neigh(3*nC,S) = (ii(nC)*dx)-(dx/2) + (dx/4)*((side_neigh(3*nC+2,S)-ibm_ht(ii(nC),ji(nC))) &
 						       /(ibm_ht_xstag(ii(nC)+1,ji(nC))-ibm_ht(ii(nC),ji(nC))))
 	    endif
 	    ! solve for y
 	    if (ibm_ht_ystag(ii(nC),ji(nC)-1) >= side_neigh(3*nC+2,S)) then
 	       side_neigh(3*nC+1,S) = ((ji(nC)-1)*dy)-dy + (dy/2)+(dy/4)*((side_neigh(3*nC+2,S)-ibm_ht(ii(nC),ji(nC)-1)) &
 								/(ibm_ht_ystag(ii(nC),ji(nC)-1)-ibm_ht(ii(nC),ji(nC)-1)))
 	    else
 	       side_neigh(3*nC+1,S) = ((ji(nC)-1)*dy)-(dy/2) + (dy/4)+(dy/4)*((side_neigh(3*nC+2,S)-ibm_ht_ystag(ii(nC),ji(nC)-1)) &
 									    /(ibm_ht(ii(nC),ji(nC))-ibm_ht_ystag(ii(nC),ji(nC)-1)))
 	    endif
 	elseif (stag == 3) then
 	    ! solve for x
 	    if (ibm_ht_xstag(ii(nC)+1,ji(nC)) >= side_neigh(3*nC+2,S)) then
 	       side_neigh(3*nC,S) = (ii(nC)*dx)-(dx/2) + (dx/4)+(dx/4)*((side_neigh(3*nC+2,S)-ibm_ht_xstag(ii(nC)+1,ji(nC))) &
 						                    /(ibm_ht(ii(nC)+1,ji(nC))-ibm_ht_xstag(ii(nC)+1,ji(nC))))
 	    else
 	       side_neigh(3*nC,S) = (ii(nC)*dx)-(dx/2) + (dx/4)*((side_neigh(3*nC+2,S)-ibm_ht(ii(nC),ji(nC))) &
 						       /(ibm_ht_xstag(ii(nC)+1,ji(nC))-ibm_ht(ii(nC),ji(nC))))
 	    endif
 	    ! solve for y
 	    if (ibm_ht_ystag(ii(nC),ji(nC)) >= side_neigh(3*nC+2,S)) then
 	       side_neigh(3*nC+1,S) = ((ji(nC)-1)*dy) +(dy/4)*((side_neigh(3*nC+2,S)-ibm_ht(ii(nC),ji(nC)-1)) &
 						       /(ibm_ht_ystag(ii(nC),ji(nC))-ibm_ht(ii(nC),ji(nC)-1)))
 	    else
 	       side_neigh(3*nC+1,S) = ((ji(nC)-1)*dy) + (dy/4)+(dy/4)*((side_neigh(3*nC+2,S)-ibm_ht_ystag(ii(nC),ji(nC))) &
 								     /(ibm_ht(ii(nC),ji(nC))-ibm_ht_ystag(ii(nC),ji(nC))))
 	    endif
 	endif
 	! neighbors 0,1,2,3,5,7 are the zero computational nodes
 	nC = 7
 	side_neigh_i(3*nC,S) = ii(nC)
 	side_neigh_i(3*nC+1,S) = ji(nC)
 	side_neigh_i(3*nC+2,S) = ki(nC) 	
 	if (stag ==1 ) then			
 	    side_neigh(3*nC,S) = (side_neigh_i(3*nC,S)*dx)-(dx)
 	    side_neigh(3*nC+1,S) = (side_neigh_i(3*nC+1,S)*dy)-(dy/2)
 	elseif (stag == 2) then
 	    side_neigh(3*nC,S) = (side_neigh_i(3*nC,S)*dx)-(dx/2)
 	    side_neigh(3*nC+1,S) = (side_neigh_i(3*nC+1,S)*dy)-(dy)	     
 	elseif (stag == 3) then
 	    side_neigh(3*nC,S) = (side_neigh_i(3*nC,S)*dx)-(dx/2)
 	    side_neigh(3*nC+1,S) = (side_neigh_i(3*nC+1,S)*dy)-(dy/2)	     
 	endif
 	side_neigh(3*nC+2,S) = ht_p(side_neigh_i(3*nC,S),side_neigh_i(3*nC+2,S),side_neigh_i(3*nC+1,S)) 
    ELSEIF ((inside(ii(0),ki(0),ji(0)) == 0).AND. &
 	(inside(ii(1),ki(1),ji(1)) == 0).AND. &
 	(inside(ii(2),ki(2),ji(2)) == 0).AND. &
 	(inside(ii(3),ki(3),ji(3)) == 0).AND. &
 	(inside(ii(4),ki(4),ji(4)) == 0).AND. &
 	(inside(ii(5),ki(5),ji(5)) == 1).AND. &
 	(inside(ii(6),ki(6),ji(6)) == 0).AND. &
 	(inside(ii(7),ki(7),ji(7)) == 1)) THEN
 	 ! neighbors 0,1,2,3,4,6,are the zero computational nodes
 	 do nC = 0,4
 	    side_neigh_i(3*nC,S) = ii(nC)
 	    side_neigh_i(3*nC+1,S) = ji(nC)
 	    side_neigh_i(3*nC+2,S) = ki(nC)		
 	    if (stag ==1 ) then 			
 		side_neigh(3*nC,S) = (side_neigh_i(3*nC,S)*dx)-(dx)
 		side_neigh(3*nC+1,S) = (side_neigh_i(3*nC+1,S)*dy)-(dy/2)
 	    elseif (stag == 2) then
 		side_neigh(3*nC,S) = (side_neigh_i(3*nC,S)*dx)-(dx/2)
 		side_neigh(3*nC+1,S) = (side_neigh_i(3*nC+1,S)*dy)-(dy)      
 	    elseif (stag == 3) then
 		side_neigh(3*nC,S) = (side_neigh_i(3*nC,S)*dx)-(dx/2)
 		side_neigh(3*nC+1,S) = (side_neigh_i(3*nC+1,S)*dy)-(dy/2)	     
 	    endif
 	    side_neigh(3*nC+2,S) = ht_p(side_neigh_i(3*nC,S),side_neigh_i(3*nC+2,S),side_neigh_i(3*nC+1,S))  
 	 enddo    
 	 ! neighbor 5 on the boundary on the 0145 plane 
 	 nC = 5 
 	 side_neigh_i(3*nC,S) = 0
 	 side_neigh_i(3*nC+1,S) = 0
 	 side_neigh_i(3*nC+2,S) = 0
 	 ! first z
 	 side_neigh(3*nC+2,S) = ht_p(ii(nC),ki(nC),ji(nC))
 	 if (stag == 1) then
 	     ! solve for x
 	     if (ibm_ht_xstag(ii(nC)-1,ji(nC)) >= side_neigh(3*nC+2,S)) then
 		side_neigh(3*nC,S) = ((ii(nC)-1)*dx)-dx + (dx/2)+(dx/4)*((side_neigh(3*nC+2,S)-ibm_ht(ii(nC)-1,ji(nC))) &
 							       /(ibm_ht_xstag(ii(nC)-1,ji(nC))-ibm_ht(ii(nC)-1,ji(nC))))
 	     else
 		side_neigh(3*nC,S) = ((ii(nC)-1)*dx)-(dx/2) + (dx/4)+(dx/4)*((side_neigh(3*nC+2,S)-ibm_ht_xstag(ii(nC)-1,ji(nC))) &
 									   /(ibm_ht(ii(nC),ji(nC))-ibm_ht_xstag(ii(nC)-1,ji(nC))))
 	     endif						  
 	     ! solve for y
 	     if (ibm_ht_ystag(ii(nC),ji(nC)) >= side_neigh(3*nC+2,S)) then
 		side_neigh(3*nC+1,S) = ((ji(nC)-1)*dy)-(dy/2) + (dy/2)+(dy/4)*((side_neigh(3*nC+2,S)-ibm_ht(ii(nC),ji(nC)-1)) &
 								       /(ibm_ht_ystag(ii(nC),ji(nC))-ibm_ht(ii(nC),ji(nC)-1)))
 	     else
 		side_neigh(3*nC+1,S) = (ji(nC)*dy)-dy + (dy/4)+(dy/4)*((side_neigh(3*nC+2,S)-ibm_ht_ystag(ii(nC),ji(nC))) &
 								     /(ibm_ht(ii(nC),ji(nC))-ibm_ht_ystag(ii(nC),ji(nC))))
 	     endif
 	 elseif (stag == 2) then
 	     ! solve for x
 	     if (ibm_ht_xstag(ii(nC),ji(nC)) >= side_neigh(3*nC+2,S)) then
 		side_neigh(3*nC,S) = ((ii(nC)-1)*dx)-(dx/2) + (dx/2)+(dx/4)*((side_neigh(3*nC+2,S)-ibm_ht(ii(nC)-1,ji(nC))) &
 								   /(ibm_ht_xstag(ii(nC)+1,ji(nC))-ibm_ht(ii(nC)-1,ji(nC))))
 	     else
 		side_neigh(3*nC,S) = (ii(nC)*dx)-dx + (dx/4)+(dx/4)*((side_neigh(3*nC+2,S)-ibm_ht_xstag(ii(nC),ji(nC))) &
 								   /(ibm_ht(ii(nC),ji(nC))-ibm_ht_xstag(ii(nC),ji(nC))))
 	     endif
 	     ! solve for y
 	     if (ibm_ht_ystag(ii(nC),ji(nC)-1) >= side_neigh(3*nC+2,S)) then
 		side_neigh(3*nC+1,S) = ((ji(nC)-1)*dy)-dy + (dy/2)+(dy/4)*((side_neigh(3*nC+2,S)-ibm_ht(ii(nC),ji(nC)-1)) &
 								 /(ibm_ht_ystag(ii(nC),ji(nC)-1)-ibm_ht(ii(nC),ji(nC)-1)))
 	     else
 		side_neigh(3*nC+1,S) = ((ji(nC)-1)*dy)-(dy/2) + (dy/4)+(dy/4)*((side_neigh(3*nC+2,S)-ibm_ht_ystag(ii(nC),ji(nC)-1)) &
 									     /(ibm_ht(ii(nC),ji(nC))-ibm_ht_ystag(ii(nC),ji(nC)-1)))
 	     endif
 	 elseif (stag == 3) then
 	     ! solve for x
 	     if (ibm_ht_xstag(ii(nC),ji(nC)) >= side_neigh(3*nC+2,S)) then
 		side_neigh(3*nC,S) = ((ii(nC)-1)*dx)-(dx/2) + (dx/2)+(dx/4)*((side_neigh(3*nC+2,S)-ibm_ht(ii(nC)-1,ji(nC))) &
 								     /(ibm_ht_xstag(ii(nC),ji(nC))-ibm_ht(ii(nC)-1,ji(nC))))
 	     else
 		side_neigh(3*nC,S) = (ii(nC)*dx)-dx + (dx/4)+(dx/4)*((side_neigh(3*nC+2,S)-ibm_ht_xstag(ii(nC),ji(nC))) &
 								   /(ibm_ht(ii(nC),ji(nC))-ibm_ht_xstag(ii(nC),ji(nC))))
 	     endif
 	     ! solve for y
 	     if (ibm_ht_ystag(ii(nC),ji(nC)) >= side_neigh(3*nC+2,S)) then
 		side_neigh(3*nC+1,S) = ((ji(nC)-1)*dy)-(dy/2) + (dy/2)+(dy/4)*((side_neigh(3*nC+2,S)-ibm_ht(ii(nC),ji(nC)-1)) &
 								       /(ibm_ht_ystag(ii(nC),ji(nC))-ibm_ht(ii(nC),ji(nC)-1)))
 	     else
 		side_neigh(3*nC+1,S) = (ji(nC)*dy)-dy + (dy/4)+(dy/4)*((side_neigh(3*nC+2,S)-ibm_ht_ystag(ii(nC),ji(nC))) &
 								     /(ibm_ht(ii(nC),ji(nC))-ibm_ht_ystag(ii(nC),ji(nC))))
 	     endif
 	 endif
 	 ! neighbors 0,1,2,3,4,6,are the zero computational nodes
 	 nC = 6
 	 side_neigh_i(3*nC,S) = ii(nC)
 	 side_neigh_i(3*nC+1,S) = ji(nC)
 	 side_neigh_i(3*nC+2,S) = ki(nC)		
 	 if (stag ==1 ) then			
 	     side_neigh(3*nC,S) = (side_neigh_i(3*nC,S)*dx)-(dx)
 	     side_neigh(3*nC+1,S) = (side_neigh_i(3*nC+1,S)*dy)-(dy/2)
 	 elseif (stag == 2) then
 	     side_neigh(3*nC,S) = (side_neigh_i(3*nC,S)*dx)-(dx/2)
 	     side_neigh(3*nC+1,S) = (side_neigh_i(3*nC+1,S)*dy)-(dy)	     
 	 elseif (stag == 3) then
 	     side_neigh(3*nC,S) = (side_neigh_i(3*nC,S)*dx)-(dx/2)
 	     side_neigh(3*nC+1,S) = (side_neigh_i(3*nC+1,S)*dy)-(dy/2)       
 	 endif
 	 side_neigh(3*nC+2,S) = ht_p(side_neigh_i(3*nC,S),side_neigh_i(3*nC+2,S),side_neigh_i(3*nC+1,S))
 	 ! neighbor 7 on the boundary on the 2367 plane 
 	 nC = 7  
 	 side_neigh_i(3*nC,S) = 0
 	 side_neigh_i(3*nC+1,S) = 0
 	 side_neigh_i(3*nC+2,S) = 0
 	 ! first z
 	 side_neigh(3*nC+2,S) = ht_p(ii(nC),ki(nC),ji(nC))
 	 if (stag == 1) then
 	     ! solve for x
 	     if (ibm_ht_xstag(ii(nC)-1,ji(nC)) >= side_neigh(3*nC+2,S)) then
 		side_neigh(3*nC,S) = ((ii(nC)-1)*dx)-dx + (dx/2)+(dx/4)*((side_neigh(3*nC+2,S)-ibm_ht(ii(nC)-1,ji(nC))) &
 							       /(ibm_ht_xstag(ii(nC)-1,ji(nC))-ibm_ht(ii(nC)-1,ji(nC))))
 	     else
 		side_neigh(3*nC,S) = ((ii(nC)-1)*dx)-(dx/2) + (dx/4)+(dx/4)*((side_neigh(3*nC+2,S)-ibm_ht_xstag(ii(nC)-1,ji(nC))) &
 									   /(ibm_ht(ii(nC),ji(nC))-ibm_ht_xstag(ii(nC)-1,ji(nC))))
 	     endif						  
 	     ! solve for y
 	     if (ibm_ht_ystag(ii(nC),ji(nC)) >= side_neigh(3*nC+2,S)) then
 		side_neigh(3*nC+1,S) = ((ji(nC)-1)*dy)-(dy/2) + (dy/2)+(dy/4)*((side_neigh(3*nC+2,S)-ibm_ht(ii(nC),ji(nC)-1)) &
 								       /(ibm_ht_ystag(ii(nC),ji(nC))-ibm_ht(ii(nC),ji(nC)-1)))
 	     else
 		side_neigh(3*nC+1,S) = (ji(nC)*dy)-dy + (dy/4)+(dy/4)*((side_neigh(3*nC+2,S)-ibm_ht_ystag(ii(nC),ji(nC))) &
 								     /(ibm_ht(ii(nC),ji(nC))-ibm_ht_ystag(ii(nC),ji(nC))))
 	     endif
 	 elseif (stag == 2) then
	     ! solve for x
 	     if (ibm_ht_xstag(ii(nC),ji(nC)) >= side_neigh(3*nC+2,S)) then
 		side_neigh(3*nC,S) = ((ii(nC)-1)*dx)-(dx/2) + (dx/2)+(dx/4)*((side_neigh(3*nC+2,S)-ibm_ht(ii(nC)-1,ji(nC))) &
 								   /(ibm_ht_xstag(ii(nC)+1,ji(nC))-ibm_ht(ii(nC)-1,ji(nC))))
 	     else
 		side_neigh(3*nC,S) = (ii(nC)*dx)-dx + (dx/4)+(dx/4)*((side_neigh(3*nC+2,S)-ibm_ht_xstag(ii(nC),ji(nC))) &
 								   /(ibm_ht(ii(nC),ji(nC))-ibm_ht_xstag(ii(nC),ji(nC))))
 	     endif
 	     ! solve for y
 	     if (ibm_ht_ystag(ii(nC),ji(nC)-1) >= side_neigh(3*nC+2,S)) then
 		side_neigh(3*nC+1,S) = ((ji(nC)-1)*dy)-dy + (dy/2)+(dy/4)*((side_neigh(3*nC+2,S)-ibm_ht(ii(nC),ji(nC)-1)) &
 								 /(ibm_ht_ystag(ii(nC),ji(nC)-1)-ibm_ht(ii(nC),ji(nC)-1)))
 	     else
 		side_neigh(3*nC+1,S) = ((ji(nC)-1)*dy)-(dy/2) + (dy/4)+(dy/4)*((side_neigh(3*nC+2,S)-ibm_ht_ystag(ii(nC),ji(nC)-1)) &
 									     /(ibm_ht(ii(nC),ji(nC))-ibm_ht_ystag(ii(nC),ji(nC)-1)))
 	     endif
 	 elseif (stag == 3) then
 	     ! solve for x
 	     if (ibm_ht_xstag(ii(nC),ji(nC)) >= side_neigh(3*nC+2,S)) then
 		side_neigh(3*nC,S) = ((ii(nC)-1)*dx)-(dx/2) + (dx/2)+(dx/4)*((side_neigh(3*nC+2,S)-ibm_ht(ii(nC)-1,ji(nC))) &
 								     /(ibm_ht_xstag(ii(nC),ji(nC))-ibm_ht(ii(nC)-1,ji(nC))))
 	     else
 		side_neigh(3*nC,S) = (ii(nC)*dx)-dx + (dx/4)+(dx/4)*((side_neigh(3*nC+2,S)-ibm_ht_xstag(ii(nC),ji(nC))) &
 								   /(ibm_ht(ii(nC),ji(nC))-ibm_ht_xstag(ii(nC),ji(nC))))
 	     endif
 	     ! solve for y
 	     if (ibm_ht_ystag(ii(nC),ji(nC)) >= side_neigh(3*nC+2,S)) then
 		side_neigh(3*nC+1,S) = ((ji(nC)-1)*dy)-(dy/2) + (dy/2)+(dy/4)*((side_neigh(3*nC+2,S)-ibm_ht(ii(nC),ji(nC)-1)) &
 								       /(ibm_ht_ystag(ii(nC),ji(nC))-ibm_ht(ii(nC),ji(nC)-1)))
 	     else
 		side_neigh(3*nC+1,S) = (ji(nC)*dy)-dy + (dy/4)+(dy/4)*((side_neigh(3*nC+2,S)-ibm_ht_ystag(ii(nC),ji(nC))) &
 								     /(ibm_ht(ii(nC),ji(nC))-ibm_ht_ystag(ii(nC),ji(nC))))
 	     endif
 	 endif
    ELSEIF ((inside(ii(0),ki(0),ji(0)) == 1).AND. &
 	 (inside(ii(1),ki(1),ji(1)) == 0).AND. &
 	 (inside(ii(2),ki(2),ji(2)) == 1).AND. &
 	 (inside(ii(3),ki(3),ji(3)) == 0).AND. &
 	 (inside(ii(4),ki(4),ji(4)) == 0).AND. &
 	 (inside(ii(5),ki(5),ji(5)) == 0).AND. &
 	 (inside(ii(6),ki(6),ji(6)) == 1).AND. &
 	 (inside(ii(7),ki(7),ji(7)) == 0)) THEN  
 	  ! neighbor 0 on the boundary on the 0145 plane
 	  nC = 0 
 	  side_neigh_i(3*nC,S) = 0
 	  side_neigh_i(3*nC+1,S) = 0
 	  side_neigh_i(3*nC+2,S) = 0
 	  ! first z
 	  side_neigh(3*nC+2,S) = ht_p(ii(nC),ki(nC),ji(nC))
 	  if (stag == 1) then
 	      ! solve for x
 	      if (ibm_ht_xstag(ii(nC),ji(nC)) >= side_neigh(3*nC+2,S)) then
 		 side_neigh(3*nC,S) = (ii(nC)*dx)-dx + (dx/4)+(dx/4)*((side_neigh(3*nC+2,S)-ibm_ht_xstag(ii(nC),ji(nC))) &
 							          /(ibm_ht(ii(nC)+1,ji(nC))-ibm_ht_xstag(ii(nC),ji(nC))))
 	      else
 		 side_neigh(3*nC,S) = (ii(nC)*dx)-dx + (dx/4)*((side_neigh(3*nC+2,S)-ibm_ht(ii(nC),ji(nC))) &
 						       /(ibm_ht_xstag(ii(nC),ji(nC))-ibm_ht(ii(nC),ji(nC))))
 	      endif						  
 	      ! solve for y
 	      if (ibm_ht_ystag(ii(nC),ji(nC)+1) >= side_neigh(3*nC+2,S)) then
 		 side_neigh(3*nC+1,S) = (ji(nC)*dy)-(dy/2) + (dy/4)+(dy/4)*((side_neigh(3*nC+2,S)-ibm_ht_ystag(ii(nC),ji(nC)+1)) &
 						   	        	/(ibm_ht(ii(nC),ji(nC)+1)-ibm_ht_ystag(ii(nC),ji(nC)+1)))
 	      else
 		 side_neigh(3*nC+1,S) = (ji(nC)*dy)-(dy/2) + (dy/4)*((side_neigh(3*nC+2,S)-ibm_ht(ii(nC),ji(nC))) &
 							   /(ibm_ht_ystag(ii(nC),ji(nC)+1)-ibm_ht(ii(nC),ji(nC))))
 	      endif
 	  elseif (stag == 2) then
 	     ! solve for x
 	     if (ibm_ht_xstag(ii(nC)+1,ji(nC)) >= side_neigh(3*nC+2,S)) then
 		side_neigh(3*nC,S) = (ii(nC)*dx)-(dx/2) + (dx/4)+(dx/4)*((side_neigh(3*nC+2,S)-ibm_ht_xstag(ii(nC)+1,ji(nC))) &
 						                     /(ibm_ht(ii(nC)+1,ji(nC))-ibm_ht_xstag(ii(nC)+1,ji(nC))))
 	     else
 		side_neigh(3*nC,S) = (ii(nC)*dx)-(dx/2) + (dx/4)*((side_neigh(3*nC+2,S)-ibm_ht(ii(nC),ji(nC))) &
 							/(ibm_ht_xstag(ii(nC)+1,ji(nC))-ibm_ht(ii(nC),ji(nC))))
 	     endif
 	     ! solve for y
 	     if (ibm_ht_ystag(ii(nC),ji(nC)) >= side_neigh(3*nC+2,S)) then
 		side_neigh(3*nC+1,S) = (ji(nC)*dy)-dy + (dy/4)+(dy/4)*((side_neigh(3*nC+2,S)-ibm_ht_ystag(ii(nC),ji(nC))) &
 							  	   /(ibm_ht(ii(nC),ji(nC)+1)-ibm_ht_ystag(ii(nC),ji(nC))))
 	     else
 		side_neigh(3*nC+1,S) = (ji(nC)*dy)-dy + (dy/4)*((side_neigh(3*nC+2,S)-ibm_ht(ii(nC),ji(nC))) &
 							/(ibm_ht_ystag(ii(nC),ji(nC))-ibm_ht(ii(nC),ji(nC))))
 	     endif
 	 elseif (stag == 3) then
 	      ! solve for x
 	      if (ibm_ht_xstag(ii(nC)+1,ji(nC)) >= side_neigh(3*nC+2,S)) then
 		 side_neigh(3*nC,S) = (ii(nC)*dx)-(dx/2) + (dx/4)+(dx/4)*((side_neigh(3*nC+2,S)-ibm_ht_xstag(ii(nC)+1,ji(nC))) &
 						                      /(ibm_ht(ii(nC)+1,ji(nC))-ibm_ht_xstag(ii(nC)+1,ji(nC))))
 	      else
 		 side_neigh(3*nC,S) = (ii(nC)*dx)-(dx/2) + (dx/4)*((side_neigh(3*nC+2,S)-ibm_ht(ii(nC),ji(nC))) &
 							 /(ibm_ht_xstag(ii(nC)+1,ji(nC))-ibm_ht(ii(nC),ji(nC))))
 	      endif
 	      ! solve for y
 	      if (ibm_ht_ystag(ii(nC),ji(nC)+1) >= side_neigh(3*nC+2,S)) then
 		 side_neigh(3*nC+1,S) = (ji(nC)*dy)-(dy/2) + (dy/4)+(dy/4)*((side_neigh(3*nC+2,S)-ibm_ht_ystag(ii(nC),ji(nC)+1)) &
 							        	/(ibm_ht(ii(nC),ji(nC)+1)-ibm_ht_ystag(ii(nC),ji(nC)+1)))
 	      else
 		 side_neigh(3*nC+1,S) = (ji(nC)*dy)-(dy/2) + (dy/4)*((side_neigh(3*nC+2,S)-ibm_ht(ii(nC),ji(nC))) &
 							   /(ibm_ht_ystag(ii(nC),ji(nC)+1)-ibm_ht(ii(nC),ji(nC))))
 	      endif
 	 endif
 	 ! neighbors 1,3,4,5,7 are the zero computational nodes
 	 nC = 1
 	 side_neigh_i(3*nC,S) = ii(nC)
 	 side_neigh_i(3*nC+1,S) = ji(nC)
 	 side_neigh_i(3*nC+2,S) = ki(nC)		
 	 if (stag ==1 ) then  		
 	     side_neigh(3*nC,S) = (side_neigh_i(3*nC,S)*dx)-(dx)
 	     side_neigh(3*nC+1,S) = (side_neigh_i(3*nC+1,S)*dy)-(dy/2)
 	 elseif (stag == 2) then
 	     side_neigh(3*nC,S) = (side_neigh_i(3*nC,S)*dx)-(dx/2)
 	     side_neigh(3*nC+1,S) = (side_neigh_i(3*nC+1,S)*dy)-(dy)       
 	 elseif (stag == 3) then
 	     side_neigh(3*nC,S) = (side_neigh_i(3*nC,S)*dx)-(dx/2)
 	     side_neigh(3*nC+1,S) = (side_neigh_i(3*nC+1,S)*dy)-(dy/2)	     
 	 endif
 	 side_neigh(3*nC+2,S) = ht_p(side_neigh_i(3*nC,S),side_neigh_i(3*nC+2,S),side_neigh_i(3*nC+1,S))  
	 ! neighbor 2 is on the boundary between 2 and 3
	 nC = 2
	 side_neigh_i(3*nC,S) = 0
	 side_neigh_i(3*nC+1,S) = ji(nC)
	 side_neigh_i(3*nC+2,S) = 0
	 ! first z
	 side_neigh(3*nC+2,S) = ht_p(ii(nC),ki(nC),ji(nC))
	 if (stag == 1) then
	     !next y
	     side_neigh(3*nC+1,S) = (side_neigh_i(3*nC+1,S)*dy)-(dy/2)
	     ! solve for x
	     if (ibm_ht_xstag(ii(nC),ji(nC)) >= side_neigh(3*nC+2,S)) then
		side_neigh(3*nC,S) = (ii(nC)*dx)-(dx/2) + (dx/2)*((side_neigh(3*nC+2,S)-ibm_ht_xstag(ii(nC),ji(nC))) &
						              /(ibm_ht(ii(nC)+1,ji(nC))-ibm_ht_xstag(ii(nC),ji(nC))))
	     else
		side_neigh(3*nC,S) = (ii(nC)*dx)-dx + (dx/2)*((side_neigh(3*nC+2,S)-ibm_ht(ii(nC),ji(nC))) &
						      /(ibm_ht_xstag(ii(nC),ji(nC))-ibm_ht(ii(nC),ji(nC))))
	     endif						  
	 elseif (stag == 2) then
	     !next y
	     side_neigh(3*nC+1,S) = (side_neigh_i(3*nC+1,S)*dy)-(dy)
	     ! solve for x
	     if (ibm_ht_xstag(ii(nC)+1,ji(nC)) >= side_neigh(3*nC+2,S)) then
		side_neigh(3*nC,S) = (ii(nC)*dx) + (dx/2)*((side_neigh(3*nC+2,S)-ibm_ht_xstag(ii(nC)+1,ji(nC))) &
						       /(ibm_ht(ii(nC)+1,ji(nC))-ibm_ht_xstag(ii(nC)+1,ji(nC))))
	     else
		side_neigh(3*nC,S) = (ii(nC)*dx)-(dx/2) + (dx/2)*((side_neigh(3*nC+2,S)-ibm_ht(ii(nC),ji(nC))) &
						        /(ibm_ht_xstag(ii(nC)+1,ji(nC))-ibm_ht(ii(nC),ji(nC))))
	     endif
	 elseif (stag == 3) then
	     !next y
	     side_neigh(3*nC+1,S) = (side_neigh_i(3*nC+1,S)*dy)-(dy/2)
	     ! solve for x
	     if (ibm_ht_xstag(ii(nC)+1,ji(nC)) >= side_neigh(3*nC+2,S)) then
		side_neigh(3*nC,S) = (ii(nC)*dx) + (dx/2)*((side_neigh(3*nC+2,S)-ibm_ht_xstag(ii(nC)+1,ji(nC))) &
						       /(ibm_ht(ii(nC)+1,ji(nC))-ibm_ht_xstag(ii(nC)+1,ji(nC))))
	     else
		side_neigh(3*nC,S) = (ii(nC)*dx)-(dx/2) + (dx/2)*((side_neigh(3*nC+2,S)-ibm_ht(ii(nC),ji(nC))) &
						        /(ibm_ht_xstag(ii(nC)+1,ji(nC))-ibm_ht(ii(nC),ji(nC))))
	     endif
	 endif
 	 ! neighbors 1,3,4,5,7 are the zero computational nodes
 	 do nC = 3,5
 	    side_neigh_i(3*nC,S) = ii(nC)
 	    side_neigh_i(3*nC+1,S) = ji(nC)
 	    side_neigh_i(3*nC+2,S) = ki(nC)		
 	    if (stag ==1 ) then  		
 		side_neigh(3*nC,S) = (side_neigh_i(3*nC,S)*dx)-(dx)
 		side_neigh(3*nC+1,S) = (side_neigh_i(3*nC+1,S)*dy)-(dy/2)
 	    elseif (stag == 2) then
 		side_neigh(3*nC,S) = (side_neigh_i(3*nC,S)*dx)-(dx/2)
 		side_neigh(3*nC+1,S) = (side_neigh_i(3*nC+1,S)*dy)-(dy)       
 	    elseif (stag == 3) then
 		side_neigh(3*nC,S) = (side_neigh_i(3*nC,S)*dx)-(dx/2)
 		side_neigh(3*nC+1,S) = (side_neigh_i(3*nC+1,S)*dy)-(dy/2)	     
 	    endif
 	    side_neigh(3*nC+2,S) = ht_p(side_neigh_i(3*nC,S),side_neigh_i(3*nC+2,S),side_neigh_i(3*nC+1,S))  
 	 enddo	
	 ! neighbor 6 is on the boundary between 6 and 7
	 nC = 6
	 side_neigh_i(3*nC,S) = 0
	 side_neigh_i(3*nC+1,S) = ji(nC)
	 side_neigh_i(3*nC+2,S) = 0
	 ! first z
	 side_neigh(3*nC+2,S) = ht_p(ii(nC),ki(nC),ji(nC))
	 if (stag == 1) then
	     !next y
	     side_neigh(3*nC+1,S) = (side_neigh_i(3*nC+1,S)*dy)-(dy/2)
	     ! solve for x
	     if (ibm_ht_xstag(ii(nC),ji(nC)) >= side_neigh(3*nC+2,S)) then
		side_neigh(3*nC,S) = (ii(nC)*dx)-(dx/2) + (dx/2)*((side_neigh(3*nC+2,S)-ibm_ht_xstag(ii(nC),ji(nC))) &
						              /(ibm_ht(ii(nC)+1,ji(nC))-ibm_ht_xstag(ii(nC),ji(nC))))
	     else
		side_neigh(3*nC,S) = (ii(nC)*dx)-dx + (dx/2)*((side_neigh(3*nC+2,S)-ibm_ht(ii(nC),ji(nC))) &
						      /(ibm_ht_xstag(ii(nC),ji(nC))-ibm_ht(ii(nC),ji(nC))))
	     endif						  
	 elseif (stag == 2) then
	     !next y
	     side_neigh(3*nC+1,S) = (side_neigh_i(3*nC+1,S)*dy)-(dy)
	     ! solve for x
	     if (ibm_ht_xstag(ii(nC)+1,ji(nC)) >= side_neigh(3*nC+2,S)) then
		side_neigh(3*nC,S) = (ii(nC)*dx) + (dx/2)*((side_neigh(3*nC+2,S)-ibm_ht_xstag(ii(nC)+1,ji(nC))) &
						       /(ibm_ht(ii(nC)+1,ji(nC))-ibm_ht_xstag(ii(nC)+1,ji(nC))))
	     else
		side_neigh(3*nC,S) = (ii(nC)*dx)-(dx/2) + (dx/2)*((side_neigh(3*nC+2,S)-ibm_ht(ii(nC),ji(nC))) &
						        /(ibm_ht_xstag(ii(nC)+1,ji(nC))-ibm_ht(ii(nC),ji(nC))))
	     endif
	 elseif (stag == 3) then
	     !next y
	     side_neigh(3*nC+1,S) = (side_neigh_i(3*nC+1,S)*dy)-(dy/2)
	     ! solve for x
	     if (ibm_ht_xstag(ii(nC)+1,ji(nC)) >= side_neigh(3*nC+2,S)) then
		side_neigh(3*nC,S) = (ii(nC)*dx) + (dx/2)*((side_neigh(3*nC+2,S)-ibm_ht_xstag(ii(nC)+1,ji(nC))) &
						       /(ibm_ht(ii(nC)+1,ji(nC))-ibm_ht_xstag(ii(nC)+1,ji(nC))))
	     else
		side_neigh(3*nC,S) = (ii(nC)*dx)-(dx/2) + (dx/2)*((side_neigh(3*nC+2,S)-ibm_ht(ii(nC),ji(nC))) &
						        /(ibm_ht_xstag(ii(nC)+1,ji(nC))-ibm_ht(ii(nC),ji(nC))))
	     endif
	 endif
	 ! neighbors 1,3,4,5,7 are the zero computational nodes
 	 nC = 7
 	 side_neigh_i(3*nC,S) = ii(nC)
 	 side_neigh_i(3*nC+1,S) = ji(nC)
 	 side_neigh_i(3*nC+2,S) = ki(nC)		
 	 if (stag ==1 ) then  		
 	     side_neigh(3*nC,S) = (side_neigh_i(3*nC,S)*dx)-(dx)
 	     side_neigh(3*nC+1,S) = (side_neigh_i(3*nC+1,S)*dy)-(dy/2)
 	 elseif (stag == 2) then
 	     side_neigh(3*nC,S) = (side_neigh_i(3*nC,S)*dx)-(dx/2)
 	     side_neigh(3*nC+1,S) = (side_neigh_i(3*nC+1,S)*dy)-(dy)       
 	 elseif (stag == 3) then
 	     side_neigh(3*nC,S) = (side_neigh_i(3*nC,S)*dx)-(dx/2)
 	     side_neigh(3*nC+1,S) = (side_neigh_i(3*nC+1,S)*dy)-(dy/2)	     
 	 endif
 	 side_neigh(3*nC+2,S) = ht_p(side_neigh_i(3*nC,S),side_neigh_i(3*nC+2,S),side_neigh_i(3*nC+1,S))	 
    ELSEIF ((inside(ii(0),ki(0),ji(0)) == 0).AND. &
 	 (inside(ii(1),ki(1),ji(1)) == 0).AND. &
 	 (inside(ii(2),ki(2),ji(2)) == 1).AND. &
 	 (inside(ii(3),ki(3),ji(3)) == 0).AND. &
 	 (inside(ii(4),ki(4),ji(4)) == 1).AND. &
 	 (inside(ii(5),ki(5),ji(5)) == 0).AND. &
 	 (inside(ii(6),ki(6),ji(6)) == 1).AND. &
 	 (inside(ii(7),ki(7),ji(7)) == 0)) THEN  
 	 ! neighbors 0,1,3,5,7 are the zero computational nodes
 	 do nC = 0,1
 	    side_neigh_i(3*nC,S) = ii(nC)
 	    side_neigh_i(3*nC+1,S) = ji(nC)
 	    side_neigh_i(3*nC+2,S) = ki(nC)		
 	    if (stag ==1 ) then  		
 		side_neigh(3*nC,S) = (side_neigh_i(3*nC,S)*dx)-(dx)
 		side_neigh(3*nC+1,S) = (side_neigh_i(3*nC+1,S)*dy)-(dy/2)
 	    elseif (stag == 2) then
 		side_neigh(3*nC,S) = (side_neigh_i(3*nC,S)*dx)-(dx/2)
 		side_neigh(3*nC+1,S) = (side_neigh_i(3*nC+1,S)*dy)-(dy)       
 	    elseif (stag == 3) then
 		side_neigh(3*nC,S) = (side_neigh_i(3*nC,S)*dx)-(dx/2)
 		side_neigh(3*nC+1,S) = (side_neigh_i(3*nC+1,S)*dy)-(dy/2)	     
 	    endif
 	    side_neigh(3*nC+2,S) = ht_p(side_neigh_i(3*nC,S),side_neigh_i(3*nC+2,S),side_neigh_i(3*nC+1,S))  
 	 enddo
	 ! neighbor 2 on the boundary between 2 and 3
	 nC = 2
	 side_neigh_i(3*nC,S) = 0
	 side_neigh_i(3*nC+1,S) = ji(nC)
	 side_neigh_i(3*nC+2,S) = 0
	 ! first z
	 side_neigh(3*nC+2,S) = ht_p(ii(nC),ki(nC),ji(nC))
	 if (stag == 1) then
	     !next y
	     side_neigh(3*nC+1,S) = (side_neigh_i(3*nC+1,S)*dy)-(dy/2)
	     ! solve for x
	     if (ibm_ht_xstag(ii(nC),ji(nC)) >= side_neigh(3*nC+2,S)) then
		side_neigh(3*nC,S) = (ii(nC)*dx)-(dx/2) + (dx/2)*((side_neigh(3*nC+2,S)-ibm_ht_xstag(ii(nC),ji(nC))) &
						              /(ibm_ht(ii(nC)+1,ji(nC))-ibm_ht_xstag(ii(nC),ji(nC))))
	     else
		side_neigh(3*nC,S) = (ii(nC)*dx)-dx + (dx/2)*((side_neigh(3*nC+2,S)-ibm_ht(ii(nC),ji(nC))) &
						      /(ibm_ht_xstag(ii(nC),ji(nC))-ibm_ht(ii(nC),ji(nC))))
	     endif						  
	 elseif (stag == 2) then
	     !next y
	     side_neigh(3*nC+1,S) = (side_neigh_i(3*nC+1,S)*dy)-(dy)
	     ! solve for x
	     if (ibm_ht_xstag(ii(nC)+1,ji(nC)) >= side_neigh(3*nC+2,S)) then
		side_neigh(3*nC,S) = (ii(nC)*dx) + (dx/2)*((side_neigh(3*nC+2,S)-ibm_ht_xstag(ii(nC)+1,ji(nC))) &
						       /(ibm_ht(ii(nC)+1,ji(nC))-ibm_ht_xstag(ii(nC)+1,ji(nC))))
	     else
		side_neigh(3*nC,S) = (ii(nC)*dx)-(dx/2) + (dx/2)*((side_neigh(3*nC+2,S)-ibm_ht(ii(nC),ji(nC))) &
						        /(ibm_ht_xstag(ii(nC)+1,ji(nC))-ibm_ht(ii(nC),ji(nC))))
	     endif
	 elseif (stag == 3) then
	     !next y
	     side_neigh(3*nC+1,S) = (side_neigh_i(3*nC+1,S)*dy)-(dy/2)
	     ! solve for x
	     if (ibm_ht_xstag(ii(nC)+1,ji(nC)) >= side_neigh(3*nC+2,S)) then
		side_neigh(3*nC,S) = (ii(nC)*dx) + (dx/2)*((side_neigh(3*nC+2,S)-ibm_ht_xstag(ii(nC)+1,ji(nC))) &
						       /(ibm_ht(ii(nC)+1,ji(nC))-ibm_ht_xstag(ii(nC)+1,ji(nC))))
	     else
		side_neigh(3*nC,S) = (ii(nC)*dx)-(dx/2) + (dx/2)*((side_neigh(3*nC+2,S)-ibm_ht(ii(nC),ji(nC))) &
						        /(ibm_ht_xstag(ii(nC)+1,ji(nC))-ibm_ht(ii(nC),ji(nC))))
	     endif
	 endif
 	 ! neighbors 0,1,3,5,7 are the zero computational nodes
 	 nC = 3
 	 side_neigh_i(3*nC,S) = ii(nC)
 	 side_neigh_i(3*nC+1,S) = ji(nC)
 	 side_neigh_i(3*nC+2,S) = ki(nC) 	
 	 if (stag ==1 ) then			
 	     side_neigh(3*nC,S) = (side_neigh_i(3*nC,S)*dx)-(dx)
 	     side_neigh(3*nC+1,S) = (side_neigh_i(3*nC+1,S)*dy)-(dy/2)
 	 elseif (stag == 2) then
 	     side_neigh(3*nC,S) = (side_neigh_i(3*nC,S)*dx)-(dx/2)
 	     side_neigh(3*nC+1,S) = (side_neigh_i(3*nC+1,S)*dy)-(dy)	     
 	 elseif (stag == 3) then
 	     side_neigh(3*nC,S) = (side_neigh_i(3*nC,S)*dx)-(dx/2)
 	     side_neigh(3*nC+1,S) = (side_neigh_i(3*nC+1,S)*dy)-(dy/2)	     
 	 endif
 	 side_neigh(3*nC+2,S) = ht_p(side_neigh_i(3*nC,S),side_neigh_i(3*nC+2,S),side_neigh_i(3*nC+1,S))  
 	 ! neighbor 4 on the boundary on the 0145 plane 
 	 nC = 4 
 	 side_neigh_i(3*nC,S) = 0
 	 side_neigh_i(3*nC+1,S) = 0
 	 side_neigh_i(3*nC+2,S) = 0
 	 ! first z
 	 side_neigh(3*nC+2,S) = ht_p(ii(nC),ki(nC),ji(nC))
 	 if (stag == 1) then
 	    ! solve for x
 	    if (ibm_ht_xstag(ii(nC),ji(nC)) >= side_neigh(3*nC+2,S)) then
 	       side_neigh(3*nC,S) = (ii(nC)*dx)-dx + (dx/4)+(dx/4)*((side_neigh(3*nC+2,S)-ibm_ht_xstag(ii(nC),ji(nC))) &
 							        /(ibm_ht(ii(nC)+1,ji(nC))-ibm_ht_xstag(ii(nC),ji(nC))))
 	    else
 	       side_neigh(3*nC,S) = (ii(nC)*dx)-dx + (dx/4)*((side_neigh(3*nC+2,S)-ibm_ht(ii(nC),ji(nC))) &
 						     /(ibm_ht_xstag(ii(nC),ji(nC))-ibm_ht(ii(nC),ji(nC))))
 	    endif						  
 	    ! solve for y
 	    if (ibm_ht_ystag(ii(nC),ji(nC)) >= side_neigh(3*nC+2,S)) then
 	       side_neigh(3*nC+1,S) = ((ji(nC)-1)*dy)-(dy/2) + (dy/2)+(dy/4)*((side_neigh(3*nC+2,S)-ibm_ht(ii(nC),ji(nC)-1)) &
 								      /(ibm_ht_ystag(ii(nC),ji(nC))-ibm_ht(ii(nC),ji(nC)-1)))
 	    else
 	       side_neigh(3*nC+1,S) = (ji(nC)*dy)-dy + (dy/4)+(dy/4)*((side_neigh(3*nC+2,S)-ibm_ht_ystag(ii(nC),ji(nC))) &
 								    /(ibm_ht(ii(nC),ji(nC))-ibm_ht_ystag(ii(nC),ji(nC))))
 	    endif
 	 elseif (stag == 2) then
 	    ! solve for x
 	    if (ibm_ht_xstag(ii(nC)+1,ji(nC)) >= side_neigh(3*nC+2,S)) then
 	       side_neigh(3*nC,S) = (ii(nC)*dx)-(dx/2) + (dx/4)+(dx/4)*((side_neigh(3*nC+2,S)-ibm_ht_xstag(ii(nC)+1,ji(nC))) &
 						                    /(ibm_ht(ii(nC)+1,ji(nC))-ibm_ht_xstag(ii(nC)+1,ji(nC))))
 	    else
 	       side_neigh(3*nC,S) = (ii(nC)*dx)-(dx/2) + (dx/4)*((side_neigh(3*nC+2,S)-ibm_ht(ii(nC),ji(nC))) &
 						       /(ibm_ht_xstag(ii(nC)+1,ji(nC))-ibm_ht(ii(nC),ji(nC))))
 	    endif
 	    ! solve for y
 	    if (ibm_ht_ystag(ii(nC),ji(nC)-1) >= side_neigh(3*nC+2,S)) then
 	       side_neigh(3*nC+1,S) = ((ji(nC)-1)*dy)-dy + (dy/2)+(dy/4)*((side_neigh(3*nC+2,S)-ibm_ht(ii(nC),ji(nC)-1)) &
 								/(ibm_ht_ystag(ii(nC),ji(nC)-1)-ibm_ht(ii(nC),ji(nC)-1)))
 	    else
 	       side_neigh(3*nC+1,S) = ((ji(nC)-1)*dy)-(dy/2) + (dy/4)+(dy/4)*((side_neigh(3*nC+2,S)-ibm_ht_ystag(ii(nC),ji(nC)-1)) &
 									    /(ibm_ht(ii(nC),ji(nC))-ibm_ht_ystag(ii(nC),ji(nC)-1)))
 	    endif
 	 elseif (stag == 3) then
 	     ! solve for x
 	     if (ibm_ht_xstag(ii(nC)+1,ji(nC)) >= side_neigh(3*nC+2,S)) then
 		side_neigh(3*nC,S) = (ii(nC)*dx)-(dx/2) + (dx/4)+(dx/4)*((side_neigh(3*nC+2,S)-ibm_ht_xstag(ii(nC)+1,ji(nC))) &
 						                     /(ibm_ht(ii(nC)+1,ji(nC))-ibm_ht_xstag(ii(nC)+1,ji(nC))))
 	     else 
 		side_neigh(3*nC,S) = (ii(nC)*dx)-(dx/2) + (dx/4)*((side_neigh(3*nC+2,S)-ibm_ht(ii(nC),ji(nC))) &
 							/(ibm_ht_xstag(ii(nC)+1,ji(nC))-ibm_ht(ii(nC),ji(nC))))
 	     endif
 	     ! solve for y
 	     if (ibm_ht_ystag(ii(nC),ji(nC)) >= side_neigh(3*nC+2,S)) then
 		side_neigh(3*nC+1,S) = ((ji(nC)-1)*dy)+ (dy/4)*((side_neigh(3*nC+2,S)-ibm_ht(ii(nC),ji(nC)-1)) &
 					        	/(ibm_ht_ystag(ii(nC),ji(nC))-ibm_ht(ii(nC),ji(nC)-1)))
 	     else
 		side_neigh(3*nC+1,S) = ((ji(nC)-1)*dy) + (dy/4)+(dy/4)*((side_neigh(3*nC+2,S)-ibm_ht_ystag(ii(nC),ji(nC))) &
 								       /(ibm_ht(ii(nC),ji(nC))-ibm_ht_ystag(ii(nC),ji(nC))))
 	     endif
 	 endif
 	 ! neighbors 0,1,2,3,5,7 are the zero computational nodes
 	 nC = 5
 	 side_neigh_i(3*nC,S) = ii(nC)
 	 side_neigh_i(3*nC+1,S) = ji(nC)
 	 side_neigh_i(3*nC+2,S) = ki(nC) 	
 	 if (stag ==1 ) then			
 	     side_neigh(3*nC,S) = (side_neigh_i(3*nC,S)*dx)-(dx)
 	     side_neigh(3*nC+1,S) = (side_neigh_i(3*nC+1,S)*dy)-(dy/2)
 	 elseif (stag == 2) then
 	     side_neigh(3*nC,S) = (side_neigh_i(3*nC,S)*dx)-(dx/2)
 	     side_neigh(3*nC+1,S) = (side_neigh_i(3*nC+1,S)*dy)-(dy)	     
 	 elseif (stag == 3) then
 	     side_neigh(3*nC,S) = (side_neigh_i(3*nC,S)*dx)-(dx/2)
 	     side_neigh(3*nC+1,S) = (side_neigh_i(3*nC+1,S)*dy)-(dy/2)	     
 	 endif
 	 side_neigh(3*nC+2,S) = ht_p(side_neigh_i(3*nC,S),side_neigh_i(3*nC+2,S),side_neigh_i(3*nC+1,S))
	 ! neighbor 6 on the boundary between 6 and 7
	 nC = 6
	 side_neigh_i(3*nC,S) = 0
	 side_neigh_i(3*nC+1,S) = ji(nC)
	 side_neigh_i(3*nC+2,S) = 0
	 ! first z
	 side_neigh(3*nC+2,S) = ht_p(ii(nC),ki(nC),ji(nC))
	 if (stag == 1) then
	     !next y
	     side_neigh(3*nC+1,S) = (side_neigh_i(3*nC+1,S)*dy)-(dy/2)
	     ! solve for x
	     if (ibm_ht_xstag(ii(nC),ji(nC)) >= side_neigh(3*nC+2,S)) then
		side_neigh(3*nC,S) = (ii(nC)*dx)-(dx/2) + (dx/2)*((side_neigh(3*nC+2,S)-ibm_ht_xstag(ii(nC),ji(nC))) &
						              /(ibm_ht(ii(nC)+1,ji(nC))-ibm_ht_xstag(ii(nC),ji(nC))))
	     else
		side_neigh(3*nC,S) = (ii(nC)*dx)-dx + (dx/2)*((side_neigh(3*nC+2,S)-ibm_ht(ii(nC),ji(nC))) &
						      /(ibm_ht_xstag(ii(nC),ji(nC))-ibm_ht(ii(nC),ji(nC))))
	     endif						  
	 elseif (stag == 2) then
	     !next y
	     side_neigh(3*nC+1,S) = (side_neigh_i(3*nC+1,S)*dy)-(dy)
	     ! solve for x
	     if (ibm_ht_xstag(ii(nC)+1,ji(nC)) >= side_neigh(3*nC+2,S)) then
		side_neigh(3*nC,S) = (ii(nC)*dx) + (dx/2)*((side_neigh(3*nC+2,S)-ibm_ht_xstag(ii(nC)+1,ji(nC))) &
						       /(ibm_ht(ii(nC)+1,ji(nC))-ibm_ht_xstag(ii(nC)+1,ji(nC))))
	     else
		side_neigh(3*nC,S) = (ii(nC)*dx)-(dx/2) + (dx/2)*((side_neigh(3*nC+2,S)-ibm_ht(ii(nC),ji(nC))) &
						        /(ibm_ht_xstag(ii(nC)+1,ji(nC))-ibm_ht(ii(nC),ji(nC))))
	     endif
	 elseif (stag == 3) then
	     !next y
	     side_neigh(3*nC+1,S) = (side_neigh_i(3*nC+1,S)*dy)-(dy/2)
	     ! solve for x
	     if (ibm_ht_xstag(ii(nC)+1,ji(nC)) >= side_neigh(3*nC+2,S)) then
		side_neigh(3*nC,S) = (ii(nC)*dx) + (dx/2)*((side_neigh(3*nC+2,S)-ibm_ht_xstag(ii(nC)+1,ji(nC))) &
						       /(ibm_ht(ii(nC)+1,ji(nC))-ibm_ht_xstag(ii(nC)+1,ji(nC))))
	     else
		side_neigh(3*nC,S) = (ii(nC)*dx)-(dx/2) + (dx/2)*((side_neigh(3*nC+2,S)-ibm_ht(ii(nC),ji(nC))) &
						        /(ibm_ht_xstag(ii(nC)+1,ji(nC))-ibm_ht(ii(nC),ji(nC))))
	     endif
	 endif
 	 ! neighbors 0,1,2,3,5,7 are the zero computational nodes
 	 nC = 7
 	 side_neigh_i(3*nC,S) = ii(nC)
 	 side_neigh_i(3*nC+1,S) = ji(nC)
 	 side_neigh_i(3*nC+2,S) = ki(nC) 	
 	 if (stag ==1 ) then			
 	     side_neigh(3*nC,S) = (side_neigh_i(3*nC,S)*dx)-(dx)
 	     side_neigh(3*nC+1,S) = (side_neigh_i(3*nC+1,S)*dy)-(dy/2)
 	 elseif (stag == 2) then
 	     side_neigh(3*nC,S) = (side_neigh_i(3*nC,S)*dx)-(dx/2)
 	     side_neigh(3*nC+1,S) = (side_neigh_i(3*nC+1,S)*dy)-(dy)	     
 	 elseif (stag == 3) then
 	     side_neigh(3*nC,S) = (side_neigh_i(3*nC,S)*dx)-(dx/2)
 	     side_neigh(3*nC+1,S) = (side_neigh_i(3*nC+1,S)*dy)-(dy/2)	     
 	 endif
 	 side_neigh(3*nC+2,S) = ht_p(side_neigh_i(3*nC,S),side_neigh_i(3*nC+2,S),side_neigh_i(3*nC+1,S))
    ELSEIF ((inside(ii(0),ki(0),ji(0)) == 0).AND. &
 	 (inside(ii(1),ki(1),ji(1)) == 1).AND. &
 	 (inside(ii(2),ki(2),ji(2)) == 0).AND. &
 	 (inside(ii(3),ki(3),ji(3)) == 1).AND. &
 	 (inside(ii(4),ki(4),ji(4)) == 0).AND. &
 	 (inside(ii(5),ki(5),ji(5)) == 0).AND. &
 	 (inside(ii(6),ki(6),ji(6)) == 0).AND. &
 	 (inside(ii(7),ki(7),ji(7)) == 1)) THEN 
 	 ! neighbors 0,2,4,5,6 are the zero computational nodes
 	 nC = 0
 	 side_neigh_i(3*nC,S) = ii(nC)
 	 side_neigh_i(3*nC+1,S) = ji(nC)
 	 side_neigh_i(3*nC+2,S) = ki(nC) 	
 	 if (stag ==1 ) then			
 	     side_neigh(3*nC,S) = (side_neigh_i(3*nC,S)*dx)-(dx)
 	     side_neigh(3*nC+1,S) = (side_neigh_i(3*nC+1,S)*dy)-(dy/2)
 	 elseif (stag == 2) then
 	     side_neigh(3*nC,S) = (side_neigh_i(3*nC,S)*dx)-(dx/2)
 	     side_neigh(3*nC+1,S) = (side_neigh_i(3*nC+1,S)*dy)-(dy)	     
 	 elseif (stag == 3) then
 	     side_neigh(3*nC,S) = (side_neigh_i(3*nC,S)*dx)-(dx/2)
 	     side_neigh(3*nC+1,S) = (side_neigh_i(3*nC+1,S)*dy)-(dy/2)	     
 	 endif
 	 side_neigh(3*nC+2,S) = ht_p(side_neigh_i(3*nC,S),side_neigh_i(3*nC+2,S),side_neigh_i(3*nC+1,S))
 	 ! neighbor 1 on the boundary face that cuts the 0145 plane
 	 nC = 1 
 	 side_neigh_i(3*nC,S) = 0
 	 side_neigh_i(3*nC+1,S) = 0
 	 side_neigh_i(3*nC+2,S) = 0
 	 ! first z
 	 side_neigh(3*nC+2,S) = ht_p(ii(nC),ki(nC),ji(nC))
 	 if (stag == 1) then
	     ! solve for x/2
 	     if (ibm_ht_xstag(ii(nC)-1,ji(nC)) >= side_neigh(3*nC+2,S)) then
 		side_neigh(3*nC,S) = ((ii(nC)-1)*dx)-dx + (dx/2)+(dx/4)*((side_neigh(3*nC+2,S)-ibm_ht(ii(nC)-1,ji(nC))) &
 							       /(ibm_ht_xstag(ii(nC)-1,ji(nC))-ibm_ht(ii(nC)-1,ji(nC))))
 	     else
 		side_neigh(3*nC,S) = ((ii(nC)-1)*dx)-(dx/2) +  (dx/4)+(dx/4)*((side_neigh(3*nC+2,S)-ibm_ht_xstag(ii(nC)-1,ji(nC))) &
 									    /(ibm_ht(ii(nC),ji(nC))-ibm_ht_xstag(ii(nC)-1,ji(nC))))
 	     endif	
 	     ! solve for y/2
 	     if (ibm_ht_ystag(ii(nC),ji(nC)+1) >= side_neigh(3*nC+2,S)) then
 		side_neigh(3*nC+1,S) = (ji(nC)*dy)-(dy/2) + (dy/4)+(dy/4)*((side_neigh(3*nC+2,S)-ibm_ht_ystag(ii(nC),ji(nC)+1)) &
 							               /(ibm_ht(ii(nC),ji(nC)+1)-ibm_ht_ystag(ii(nC),ji(nC)+1)))
 	     else
 		side_neigh(3*nC+1,S) = (ji(nC)*dy)-(dy/2) + (dy/4)*((side_neigh(3*nC+2,S)-ibm_ht(ii(nC),ji(nC))) &
 							  /(ibm_ht_ystag(ii(nC),ji(nC)+1)-ibm_ht(ii(nC),ji(nC))))
 	     endif					  
 	 elseif (stag == 2) then
 	     ! solve for x/2
 	     if (ibm_ht_xstag(ii(nC),ji(nC)) >= side_neigh(3*nC+2,S)) then
 		side_neigh(3*nC,S) = ((ii(nC)-1)*dx)-(dx/2) +  (dx/2)+(dx/4)*((side_neigh(3*nC+2,S)-ibm_ht(ii(nC)-1,ji(nC))) &
 								      /(ibm_ht_xstag(ii(nC),ji(nC))-ibm_ht(ii(nC)-1,ji(nC))))
 	     else
 		side_neigh(3*nC,S) = (ii(nC)*dx)-dx +  (dx/4)+(dx/4)*((side_neigh(3*nC+2,S)-ibm_ht_xstag(ii(nC),ji(nC))) &
 								    /(ibm_ht(ii(nC),ji(nC))-ibm_ht_xstag(ii(nC),ji(nC))))
 	     endif
 	     ! solve for y/2
 	     if (ibm_ht_ystag(ii(nC),ji(nC)) >= side_neigh(3*nC+2,S)) then
 		side_neigh(3*nC+1,S) = (ji(nC)*dy)-dy + (dy/4)+(dy/4)*((side_neigh(3*nC+2,S)-ibm_ht_ystag(ii(nC),ji(nC))) &
 						                   /(ibm_ht(ii(nC),ji(nC)+1)-ibm_ht_ystag(ii(nC),ji(nC))))
 	     else
 		side_neigh(3*nC+1,S) = (ji(nC)*dy)-dy + (dy/4)*((side_neigh(3*nC+2,S)-ibm_ht(ii(nC),ji(nC))) &
 							/(ibm_ht_ystag(ii(nC),ji(nC))-ibm_ht(ii(nC),ji(nC))))
 	     endif
 	 elseif (stag == 3) then
 	     ! solve for x/2
 	     if (ibm_ht_xstag(ii(nC),ji(nC)) >= side_neigh(3*nC+2,S)) then
 		side_neigh(3*nC,S) = ((ii(nC)-1)*dx)-(dx/2) + (dx/2)+(dx/4)*((side_neigh(3*nC+2,S)-ibm_ht(ii(nC)-1,ji(nC))) &
 								     /(ibm_ht_xstag(ii(nC),ji(nC))-ibm_ht(ii(nC)-1,ji(nC))))
 	     else
 		side_neigh(3*nC,S) = (ii(nC)*dx)-dx +  (dx/4)+(dx/4)*((side_neigh(3*nC+2,S)-ibm_ht_xstag(ii(nC),ji(nC))) &
 								    /(ibm_ht(ii(nC),ji(nC))-ibm_ht_xstag(ii(nC),ji(nC))))
 	     endif
 	     ! solve for y/2
 	     if (ibm_ht_ystag(ii(nC),ji(nC)+1) >= side_neigh(3*nC+2,S)) then
 		side_neigh(3*nC+1,S) = (ji(nC)*dy)-(dy/2) + (dy/4)+(dy/4)*((side_neigh(3*nC+2,S)-ibm_ht_ystag(ii(nC),ji(nC)+1)) &
 							               /(ibm_ht(ii(nC),ji(nC)+1)-ibm_ht_ystag(ii(nC),ji(nC)+1)))
 	     else
 		side_neigh(3*nC+1,S) = (ji(nC)*dy)-(dy/2) + (dy/4)*((side_neigh(3*nC+2,S)-ibm_ht(ii(nC),ji(nC))) &
 							  /(ibm_ht_ystag(ii(nC),ji(nC)+1)-ibm_ht(ii(nC),ji(nC))))
 	     endif
 	 endif
 	 ! neighbors 0,2,4,5,6 are the zero computational nodes
 	 nC = 2
 	 side_neigh_i(3*nC,S) = ii(nC)
 	 side_neigh_i(3*nC+1,S) = ji(nC)
 	 side_neigh_i(3*nC+2,S) = ki(nC) 	
 	 if (stag ==1 ) then			
 	     side_neigh(3*nC,S) = (side_neigh_i(3*nC,S)*dx)-(dx)
 	     side_neigh(3*nC+1,S) = (side_neigh_i(3*nC+1,S)*dy)-(dy/2)
 	 elseif (stag == 2) then
 	     side_neigh(3*nC,S) = (side_neigh_i(3*nC,S)*dx)-(dx/2)
 	     side_neigh(3*nC+1,S) = (side_neigh_i(3*nC+1,S)*dy)-(dy)	     
 	 elseif (stag == 3) then
 	     side_neigh(3*nC,S) = (side_neigh_i(3*nC,S)*dx)-(dx/2)
 	     side_neigh(3*nC+1,S) = (side_neigh_i(3*nC+1,S)*dy)-(dy/2)	     
 	 endif
 	 side_neigh(3*nC+2,S) = ht_p(side_neigh_i(3*nC,S),side_neigh_i(3*nC+2,S),side_neigh_i(3*nC+1,S))
	 ! neighbor 3 on the boundary between 2 and 3
	 nC = 3
	 side_neigh_i(3*nC,S) = 0
	 side_neigh_i(3*nC+1,S) = ji(nC)
	 side_neigh_i(3*nC+2,S) = 0
	 ! first z
	 side_neigh(3*nC+2,S) = ht_p(ii(nC),ki(nC),ji(nC))
	 if (stag == 1) then
	     !next y
	     side_neigh(3*nC+1,S) = (side_neigh_i(3*nC+1,S)*dy)-(dy/2)
	     ! solve for x
	     if (ibm_ht_xstag(ii(nC)-1,ji(nC)) >= side_neigh(3*nC+2,S)) then
		side_neigh(3*nC,S) = ((ii(nC)-1)*dx)-dx + (dx/2)*((side_neigh(3*nC+2,S)-ibm_ht(ii(nC)-1,ji(nC))) &
						        /(ibm_ht_xstag(ii(nC)-1,ji(nC))-ibm_ht(ii(nC)-1,ji(nC))))
	     else
		side_neigh(3*nC,S) = ((ii(nC)-1)*dx)-(dx/2) + (dx/2)*((side_neigh(3*nC+2,S)-ibm_ht_xstag(ii(nC)-1,ji(nC))) &
							            /(ibm_ht(ii(nC),ji(nC))-ibm_ht_xstag(ii(nC)-1,ji(nC))))
	     endif						  
	 elseif (stag == 2) then
	     !next y
	     side_neigh(3*nC+1,S) = (side_neigh_i(3*nC+1,S)*dy)-(dy)
	     ! solve for x
	     if (ibm_ht_xstag(ii(nC),ji(nC)) >= side_neigh(3*nC+2,S)) then
		side_neigh(3*nC,S) = ((ii(nC)-1)*dx)-(dx/2) + (dx/2)*((side_neigh(3*nC+2,S)-ibm_ht(ii(nC)-1,ji(nC))) &
						              /(ibm_ht_xstag(ii(nC),ji(nC))-ibm_ht(ii(nC)-1,ji(nC))))
	     else
		side_neigh(3*nC,S) = (ii(nC)*dx)-dx + (dx/2)*((side_neigh(3*nC+2,S)-ibm_ht_xstag(ii(nC),ji(nC))) &
						            /(ibm_ht(ii(nC),ji(nC))-ibm_ht_xstag(ii(nC),ji(nC))))
	     endif
	 elseif (stag == 3) then
	     !next y
	     side_neigh(3*nC+1,S) = (side_neigh_i(3*nC+1,S)*dy)-(dy/2)
	     ! solve for x
	     if (ibm_ht_xstag(ii(nC),ji(nC)) >= side_neigh(3*nC+2,S)) then
		side_neigh(3*nC,S) = ((ii(nC)-1)*dx)-(dx/2) + (dx/2)*((side_neigh(3*nC+2,S)-ibm_ht(ii(nC)-1,ji(nC))) &
						              /(ibm_ht_xstag(ii(nC),ji(nC))-ibm_ht(ii(nC)-1,ji(nC))))
	     else
		side_neigh(3*nC,S) = (ii(nC)*dx)-dx + (dx/2)*((side_neigh(3*nC+2,S)-ibm_ht_xstag(ii(nC),ji(nC))) &
						            /(ibm_ht(ii(nC),ji(nC))-ibm_ht_xstag(ii(nC),ji(nC))))
	     endif
	 endif
 	 ! neighbors 0,2,4,5,6 are the zero computational nodes
 	 do nC = 4,6
 	    side_neigh_i(3*nC,S) = ii(nC)
 	    side_neigh_i(3*nC+1,S) = ji(nC)
 	    side_neigh_i(3*nC+2,S) = ki(nC)		
 	    if (stag ==1 ) then  		
 		side_neigh(3*nC,S) = (side_neigh_i(3*nC,S)*dx)-(dx)
 		side_neigh(3*nC+1,S) = (side_neigh_i(3*nC+1,S)*dy)-(dy/2)
 	    elseif (stag == 2) then
 		side_neigh(3*nC,S) = (side_neigh_i(3*nC,S)*dx)-(dx/2)
 		side_neigh(3*nC+1,S) = (side_neigh_i(3*nC+1,S)*dy)-(dy)       
 	    elseif (stag == 3) then
 		side_neigh(3*nC,S) = (side_neigh_i(3*nC,S)*dx)-(dx/2)
 		side_neigh(3*nC+1,S) = (side_neigh_i(3*nC+1,S)*dy)-(dy/2)	     
 	    endif
 	    side_neigh(3*nC+2,S) = ht_p(side_neigh_i(3*nC,S),side_neigh_i(3*nC+2,S),side_neigh_i(3*nC+1,S))
 	 enddo
	 ! neighbor 7 on the boundary between 6 and 7
	 nC = 7 
	 side_neigh_i(3*nC,S) = 0
	 side_neigh_i(3*nC+1,S) = ji(nC)
	 side_neigh_i(3*nC+2,S) = 0
	 ! first z
	 side_neigh(3*nC+2,S) = ht_p(ii(nC),ki(nC),ji(nC))
	 if (stag == 1) then
	     !next y
	     side_neigh(3*nC+1,S) = (side_neigh_i(3*nC+1,S)*dy)-(dy/2)
	     ! solve for x
	     if (ibm_ht_xstag(ii(nC)-1,ji(nC)) >= side_neigh(3*nC+2,S)) then
		side_neigh(3*nC,S) = ((ii(nC)-1)*dx)-dx + (dx/2)*((side_neigh(3*nC+2,S)-ibm_ht(ii(nC)-1,ji(nC))) &
						        /(ibm_ht_xstag(ii(nC)-1,ji(nC))-ibm_ht(ii(nC)-1,ji(nC))))
	     else
		side_neigh(3*nC,S) = ((ii(nC)-1)*dx)-(dx/2) + (dx/2)*((side_neigh(3*nC+2,S)-ibm_ht_xstag(ii(nC)-1,ji(nC))) &
							            /(ibm_ht(ii(nC),ji(nC))-ibm_ht_xstag(ii(nC)-1,ji(nC))))
	     endif						  
	 elseif (stag == 2) then
	     !next y
	     side_neigh(3*nC+1,S) = (side_neigh_i(3*nC+1,S)*dy)-(dy)
	     ! solve for x
	     if (ibm_ht_xstag(ii(nC),ji(nC)) >= side_neigh(3*nC+2,S)) then
		side_neigh(3*nC,S) = ((ii(nC)-1)*dx)-(dx/2) + (dx/2)*((side_neigh(3*nC+2,S)-ibm_ht(ii(nC)-1,ji(nC))) &
						              /(ibm_ht_xstag(ii(nC),ji(nC))-ibm_ht(ii(nC)-1,ji(nC))))
	     else
		side_neigh(3*nC,S) = (ii(nC)*dx)-dx + (dx/2)*((side_neigh(3*nC+2,S)-ibm_ht_xstag(ii(nC),ji(nC))) &
						            /(ibm_ht(ii(nC),ji(nC))-ibm_ht_xstag(ii(nC),ji(nC))))
	     endif
	 elseif (stag == 3) then
	     !next y
	     side_neigh(3*nC+1,S) = (side_neigh_i(3*nC+1,S)*dy)-(dy/2)
	     ! solve for x
	     if (ibm_ht_xstag(ii(nC),ji(nC)) >= side_neigh(3*nC+2,S)) then
		side_neigh(3*nC,S) = ((ii(nC)-1)*dx)-(dx/2) + (dx/2)*((side_neigh(3*nC+2,S)-ibm_ht(ii(nC)-1,ji(nC))) &
						              /(ibm_ht_xstag(ii(nC),ji(nC))-ibm_ht(ii(nC)-1,ji(nC))))
	     else
		side_neigh(3*nC,S) = (ii(nC)*dx)-dx + (dx/2)*((side_neigh(3*nC+2,S)-ibm_ht_xstag(ii(nC),ji(nC))) &
						            /(ibm_ht(ii(nC),ji(nC))-ibm_ht_xstag(ii(nC),ji(nC))))
	     endif
	 endif
    ELSEIF ((inside(ii(0),ki(0),ji(0)) == 0).AND. &
 	 (inside(ii(1),ki(1),ji(1)) == 0).AND. &
 	 (inside(ii(2),ki(2),ji(2)) == 0).AND. &
 	 (inside(ii(3),ki(3),ji(3)) == 1).AND. &
 	 (inside(ii(4),ki(4),ji(4)) == 0).AND. &
 	 (inside(ii(5),ki(5),ji(5)) == 1).AND. &
 	 (inside(ii(6),ki(6),ji(6)) == 0).AND. &
 	 (inside(ii(7),ki(7),ji(7)) == 1)) THEN 
 	 ! neighbors 0,1,2,4,6 are the zero computational nodes
 	 do nC = 0,2
 	    side_neigh_i(3*nC,S) = ii(nC)
 	    side_neigh_i(3*nC+1,S) = ji(nC)
 	    side_neigh_i(3*nC+2,S) = ki(nC)		
 	    if (stag ==1 ) then  		
 		side_neigh(3*nC,S) = (side_neigh_i(3*nC,S)*dx)-(dx)
 		side_neigh(3*nC+1,S) = (side_neigh_i(3*nC+1,S)*dy)-(dy/2)
 	    elseif (stag == 2) then
 		side_neigh(3*nC,S) = (side_neigh_i(3*nC,S)*dx)-(dx/2)
 		side_neigh(3*nC+1,S) = (side_neigh_i(3*nC+1,S)*dy)-(dy)       
 	    elseif (stag == 3) then
 		side_neigh(3*nC,S) = (side_neigh_i(3*nC,S)*dx)-(dx/2)
 		side_neigh(3*nC+1,S) = (side_neigh_i(3*nC+1,S)*dy)-(dy/2)	     
 	    endif
 	    side_neigh(3*nC+2,S) = ht_p(side_neigh_i(3*nC,S),side_neigh_i(3*nC+2,S),side_neigh_i(3*nC+1,S))
 	 enddo
	 ! neighbor 3 on the boundary between 2 and 3
	 nC = 3 
	 side_neigh_i(3*nC,S) = 0
	 side_neigh_i(3*nC+1,S) = ji(nC)
	 side_neigh_i(3*nC+2,S) = 0
	 ! first z
	 side_neigh(3*nC+2,S) = ht_p(ii(nC),ki(nC),ji(nC))
	 if (stag == 1) then
	     !next y
	     side_neigh(3*nC+1,S) = (side_neigh_i(3*nC+1,S)*dy)-(dy/2)
	     ! solve for x
	     if (ibm_ht_xstag(ii(nC)-1,ji(nC)) >= side_neigh(3*nC+2,S)) then
		side_neigh(3*nC,S) = ((ii(nC)-1)*dx)-dx + (dx/2)*((side_neigh(3*nC+2,S)-ibm_ht(ii(nC)-1,ji(nC))) &
						        /(ibm_ht_xstag(ii(nC)-1,ji(nC))-ibm_ht(ii(nC)-1,ji(nC))))
	     else
		side_neigh(3*nC,S) = ((ii(nC)-1)*dx)-(dx/2) + (dx/2)*((side_neigh(3*nC+2,S)-ibm_ht_xstag(ii(nC)-1,ji(nC))) &
							            /(ibm_ht(ii(nC),ji(nC))-ibm_ht_xstag(ii(nC)-1,ji(nC))))
	     endif						  
	 elseif (stag == 2) then
	     !next y
	     side_neigh(3*nC+1,S) = (side_neigh_i(3*nC+1,S)*dy)-(dy)
	     ! solve for x
	     if (ibm_ht_xstag(ii(nC),ji(nC)) >= side_neigh(3*nC+2,S)) then
		side_neigh(3*nC,S) = ((ii(nC)-1)*dx)-(dx/2) + (dx/2)*((side_neigh(3*nC+2,S)-ibm_ht(ii(nC)-1,ji(nC))) &
						              /(ibm_ht_xstag(ii(nC),ji(nC))-ibm_ht(ii(nC)-1,ji(nC))))
	     else
		side_neigh(3*nC,S) = (ii(nC)*dx)-dx + (dx/2)*((side_neigh(3*nC+2,S)-ibm_ht_xstag(ii(nC),ji(nC))) &
						            /(ibm_ht(ii(nC),ji(nC))-ibm_ht_xstag(ii(nC),ji(nC))))
	     endif
	 elseif (stag == 3) then
	     !next y
	     side_neigh(3*nC+1,S) = (side_neigh_i(3*nC+1,S)*dy)-(dy/2)
	     ! solve for x
	     if (ibm_ht_xstag(ii(nC),ji(nC)) >= side_neigh(3*nC+2,S)) then
		side_neigh(3*nC,S) = ((ii(nC)-1)*dx)-(dx/2) + (dx/2)*((side_neigh(3*nC+2,S)-ibm_ht(ii(nC)-1,ji(nC))) &
						              /(ibm_ht_xstag(ii(nC),ji(nC))-ibm_ht(ii(nC)-1,ji(nC))))
	     else
		side_neigh(3*nC,S) = (ii(nC)*dx)-dx + (dx/2)*((side_neigh(3*nC+2,S)-ibm_ht_xstag(ii(nC),ji(nC))) &
						            /(ibm_ht(ii(nC),ji(nC))-ibm_ht_xstag(ii(nC),ji(nC))))
	     endif
	 endif 
 	 ! neighbors 0,1,2,4,6 are the zero computational nodes
 	 nC = 4
 	 side_neigh_i(3*nC,S) = ii(nC)
 	 side_neigh_i(3*nC+1,S) = ji(nC)
 	 side_neigh_i(3*nC+2,S) = ki(nC) 	
 	 if (stag ==1 ) then			
 	     side_neigh(3*nC,S) = (side_neigh_i(3*nC,S)*dx)-(dx)
 	     side_neigh(3*nC+1,S) = (side_neigh_i(3*nC+1,S)*dy)-(dy/2)
 	 elseif (stag == 2) then
 	     side_neigh(3*nC,S) = (side_neigh_i(3*nC,S)*dx)-(dx/2)
 	     side_neigh(3*nC+1,S) = (side_neigh_i(3*nC+1,S)*dy)-(dy)	     
 	 elseif (stag == 3) then
 	     side_neigh(3*nC,S) = (side_neigh_i(3*nC,S)*dx)-(dx/2)
 	     side_neigh(3*nC+1,S) = (side_neigh_i(3*nC+1,S)*dy)-(dy/2)	     
 	 endif
 	 side_neigh(3*nC+2,S) = ht_p(side_neigh_i(3*nC,S),side_neigh_i(3*nC+2,S),side_neigh_i(3*nC+1,S))
 	 ! neighbor 5 on the boundary on the 0145 plane 
 	 nC = 5 
 	 side_neigh_i(3*nC,S) = 0
 	 side_neigh_i(3*nC+1,S) = 0
 	 side_neigh_i(3*nC+2,S) = 0
 	 ! first z
 	 side_neigh(3*nC+2,S) = ht_p(ii(nC),ki(nC),ji(nC))
 	 if (stag == 1) then
	     ! solve for x
 	     if (ibm_ht_xstag(ii(nC)-1,ji(nC)) >= side_neigh(3*nC+2,S)) then
 		side_neigh(3*nC,S) = ((ii(nC)-1)*dx)-dx + (dx/2)+(dx/4)*((side_neigh(3*nC+2,S)-ibm_ht(ii(nC)-1,ji(nC))) &
 							       /(ibm_ht_xstag(ii(nC)-1,ji(nC))-ibm_ht(ii(nC)-1,ji(nC))))
 	     else
 		side_neigh(3*nC,S) = ((ii(nC)-1)*dx)-(dx/2) + (dx/4)+(dx/4)*((side_neigh(3*nC+2,S)-ibm_ht_xstag(ii(nC)-1,ji(nC))) &
 									   /(ibm_ht(ii(nC),ji(nC))-ibm_ht_xstag(ii(nC)-1,ji(nC))))
 	     endif						  
 	     ! solve for y
 	     if (ibm_ht_ystag(ii(nC),ji(nC)) >= side_neigh(3*nC+2,S)) then
 		side_neigh(3*nC+1,S) = ((ji(nC)-1)*dy)-(dy/2) + (dy/2)+(dy/4)*((side_neigh(3*nC+2,S)-ibm_ht(ii(nC),ji(nC)-1)) &
 								       /(ibm_ht_ystag(ii(nC),ji(nC))-ibm_ht(ii(nC),ji(nC)-1)))
 	     else
 		side_neigh(3*nC+1,S) = (ji(nC)*dy)-dy + (dy/4)+(dy/4)*((side_neigh(3*nC+2,S)-ibm_ht_ystag(ii(nC),ji(nC))) &
 								     /(ibm_ht(ii(nC),ji(nC))-ibm_ht_ystag(ii(nC),ji(nC))))
 	     endif
 	 elseif (stag == 2) then
	     ! solve for x
 	     if (ibm_ht_xstag(ii(nC),ji(nC)) >= side_neigh(3*nC+2,S)) then
 		side_neigh(3*nC,S) = ((ii(nC)-1)*dx)-(dx/2) + (dx/2)+(dx/4)*((side_neigh(3*nC+2,S)-ibm_ht(ii(nC)-1,ji(nC))) &
 								   /(ibm_ht_xstag(ii(nC)+1,ji(nC))-ibm_ht(ii(nC)-1,ji(nC))))
 	     else
 		side_neigh(3*nC,S) = (ii(nC)*dx)-dx + (dx/4)+(dx/4)*((side_neigh(3*nC+2,S)-ibm_ht_xstag(ii(nC),ji(nC))) &
 								   /(ibm_ht(ii(nC),ji(nC))-ibm_ht_xstag(ii(nC),ji(nC))))
 	     endif
 	     ! solve for y
 	     if (ibm_ht_ystag(ii(nC),ji(nC)-1) >= side_neigh(3*nC+2,S)) then
 		side_neigh(3*nC+1,S) = ((ji(nC)-1)*dy)-dy + (dy/2)+(dy/4)*((side_neigh(3*nC+2,S)-ibm_ht(ii(nC),ji(nC)-1)) &
 								 /(ibm_ht_ystag(ii(nC),ji(nC)-1)-ibm_ht(ii(nC),ji(nC)-1)))
 	     else
 		side_neigh(3*nC+1,S) = ((ji(nC)-1)*dy)-(dy/2) + (dy/4)+(dy/4)*((side_neigh(3*nC+2,S)-ibm_ht_ystag(ii(nC),ji(nC)-1)) &
 									     /(ibm_ht(ii(nC),ji(nC))-ibm_ht_ystag(ii(nC),ji(nC)-1)))
 	     endif
 	 elseif (stag == 3) then
 	      ! solve for x
 	      if (ibm_ht_xstag(ii(nC),ji(nC)) >= side_neigh(3*nC+2,S)) then
 		 side_neigh(3*nC,S) = ((ii(nC)-1)*dx)-(dx/2) + (dx/2)+(dx/4)*((side_neigh(3*nC+2,S)-ibm_ht(ii(nC)-1,ji(nC))) &
 								      /(ibm_ht_xstag(ii(nC),ji(nC))-ibm_ht(ii(nC)-1,ji(nC))))
 	      else
 		 side_neigh(3*nC,S) = (ii(nC)*dx)-dx + (dx/4)+(dx/4)*((side_neigh(3*nC+2,S)-ibm_ht_xstag(ii(nC),ji(nC))) &
 								    /(ibm_ht(ii(nC),ji(nC))-ibm_ht_xstag(ii(nC),ji(nC))))
 	      endif
 	      ! solve for y
 	      if (ibm_ht_ystag(ii(nC),ji(nC)) >= side_neigh(3*nC+2,S)) then
 		 side_neigh(3*nC+1,S) = ((ji(nC)-1)*dy)-(dy/2) + (dy/2)+(dy/4)*((side_neigh(3*nC+2,S)-ibm_ht(ii(nC),ji(nC)-1)) &
 									/(ibm_ht_ystag(ii(nC),ji(nC))-ibm_ht(ii(nC),ji(nC)-1)))
 	      else
 		 side_neigh(3*nC+1,S) = (ji(nC)*dy)-dy + (dy/4)+(dy/4)*((side_neigh(3*nC+2,S)-ibm_ht_ystag(ii(nC),ji(nC))) &
 								      /(ibm_ht(ii(nC),ji(nC))-ibm_ht_ystag(ii(nC),ji(nC))))
 	      endif
 	 endif	
 	 ! neighbors 0,1,2,4,6 are the zero computational nodes
 	 nC = 6
 	 side_neigh_i(3*nC,S) = ii(nC)
 	 side_neigh_i(3*nC+1,S) = ji(nC)
 	 side_neigh_i(3*nC+2,S) = ki(nC) 	
 	 if (stag ==1 ) then			
 	     side_neigh(3*nC,S) = (side_neigh_i(3*nC,S)*dx)-(dx)
 	     side_neigh(3*nC+1,S) = (side_neigh_i(3*nC+1,S)*dy)-(dy/2)
 	 elseif (stag == 2) then
 	     side_neigh(3*nC,S) = (side_neigh_i(3*nC,S)*dx)-(dx/2)
 	     side_neigh(3*nC+1,S) = (side_neigh_i(3*nC+1,S)*dy)-(dy)	     
 	 elseif (stag == 3) then
 	     side_neigh(3*nC,S) = (side_neigh_i(3*nC,S)*dx)-(dx/2)
 	     side_neigh(3*nC+1,S) = (side_neigh_i(3*nC+1,S)*dy)-(dy/2)	     
 	 endif
 	 side_neigh(3*nC+2,S) = ht_p(side_neigh_i(3*nC,S),side_neigh_i(3*nC+2,S),side_neigh_i(3*nC+1,S))
	 ! neighbor 7 on the boundary between 6 and 7
	 nC = 7 
	 side_neigh_i(3*nC,S) = 0
	 side_neigh_i(3*nC+1,S) = ji(nC)
	 side_neigh_i(3*nC+2,S) = 0
	 ! first z
	 side_neigh(3*nC+2,S) = ht_p(ii(nC),ki(nC),ji(nC))
	 if (stag == 1) then
	     !next y
	     side_neigh(3*nC+1,S) = (side_neigh_i(3*nC+1,S)*dy)-(dy/2)
	     ! solve for x
	     if (ibm_ht_xstag(ii(nC)-1,ji(nC)) >= side_neigh(3*nC+2,S)) then
		side_neigh(3*nC,S) = ((ii(nC)-1)*dx)-dx + (dx/2)*((side_neigh(3*nC+2,S)-ibm_ht(ii(nC)-1,ji(nC))) &
						        /(ibm_ht_xstag(ii(nC)-1,ji(nC))-ibm_ht(ii(nC)-1,ji(nC))))
	     else
		side_neigh(3*nC,S) = ((ii(nC)-1)*dx)-(dx/2) + (dx/2)*((side_neigh(3*nC+2,S)-ibm_ht_xstag(ii(nC)-1,ji(nC))) &
							            /(ibm_ht(ii(nC),ji(nC))-ibm_ht_xstag(ii(nC)-1,ji(nC))))
	     endif						  
	 elseif (stag == 2) then
	     !next y
	     side_neigh(3*nC+1,S) = (side_neigh_i(3*nC+1,S)*dy)-(dy)
	     ! solve for x
	     if (ibm_ht_xstag(ii(nC),ji(nC)) >= side_neigh(3*nC+2,S)) then
		side_neigh(3*nC,S) = ((ii(nC)-1)*dx)-(dx/2) + (dx/2)*((side_neigh(3*nC+2,S)-ibm_ht(ii(nC)-1,ji(nC))) &
						              /(ibm_ht_xstag(ii(nC),ji(nC))-ibm_ht(ii(nC)-1,ji(nC))))
	     else
		side_neigh(3*nC,S) = (ii(nC)*dx)-dx + (dx/2)*((side_neigh(3*nC+2,S)-ibm_ht_xstag(ii(nC),ji(nC))) &
						            /(ibm_ht(ii(nC),ji(nC))-ibm_ht_xstag(ii(nC),ji(nC))))
	     endif
	 elseif (stag == 3) then
	     !next y
	     side_neigh(3*nC+1,S) = (side_neigh_i(3*nC+1,S)*dy)-(dy/2)
	     ! solve for x
	     if (ibm_ht_xstag(ii(nC),ji(nC)) >= side_neigh(3*nC+2,S)) then
		side_neigh(3*nC,S) = ((ii(nC)-1)*dx)-(dx/2) + (dx/2)*((side_neigh(3*nC+2,S)-ibm_ht(ii(nC)-1,ji(nC))) &
						              /(ibm_ht_xstag(ii(nC),ji(nC))-ibm_ht(ii(nC)-1,ji(nC))))
	     else
		side_neigh(3*nC,S) = (ii(nC)*dx)-dx + (dx/2)*((side_neigh(3*nC+2,S)-ibm_ht_xstag(ii(nC),ji(nC))) &
						            /(ibm_ht(ii(nC),ji(nC))-ibm_ht_xstag(ii(nC),ji(nC))))
	     endif
	 endif
    ELSEIF ((inside(ii(0),ki(0),ji(0)) == 1).AND. &
 	 (inside(ii(1),ki(1),ji(1)) == 0).AND. &
 	 (inside(ii(2),ki(2),ji(2)) == 1).AND. &
 	 (inside(ii(3),ki(3),ji(3)) == 1).AND. &
 	 (inside(ii(4),ki(4),ji(4)) == 0).AND. &
 	 (inside(ii(5),ki(5),ji(5)) == 0).AND. &
 	 (inside(ii(6),ki(6),ji(6)) == 0).AND. &
 	 (inside(ii(7),ki(7),ji(7)) == 0)) THEN 
 	  ! neighbor 0 on the boundary on the 0145 plane
 	  nC = 0 
 	  side_neigh_i(3*nC,S) = 0
 	  side_neigh_i(3*nC+1,S) = 0
 	  side_neigh_i(3*nC+2,S) = 0
 	  ! first z
 	  side_neigh(3*nC+2,S) = ht_p(ii(nC),ki(nC),ji(nC))
 	  if (stag == 1) then
  	     ! solve for x
 	     if (ibm_ht_xstag(ii(nC),ji(nC)) >= side_neigh(3*nC+2,S)) then
 		side_neigh(3*nC,S) = (ii(nC)*dx)-dx + (dx/4)+(dx/4)*((side_neigh(3*nC+2,S)-ibm_ht_xstag(ii(nC),ji(nC))) &
 							         /(ibm_ht(ii(nC)+1,ji(nC))-ibm_ht_xstag(ii(nC),ji(nC))))
 	     else
 		side_neigh(3*nC,S) = (ii(nC)*dx)-dx + (dx/4)*((side_neigh(3*nC+2,S)-ibm_ht(ii(nC),ji(nC))) &
 						      /(ibm_ht_xstag(ii(nC),ji(nC))-ibm_ht(ii(nC),ji(nC))))
 	     endif						  
 	     ! solve for y
 	     if (ibm_ht_ystag(ii(nC),ji(nC)+1) >= side_neigh(3*nC+2,S)) then
 		side_neigh(3*nC+1,S) = (ji(nC)*dy)-(dy/2) + (dy/4)+(dy/4)*((side_neigh(3*nC+2,S)-ibm_ht_ystag(ii(nC),ji(nC)+1)) &
 						   	               /(ibm_ht(ii(nC),ji(nC)+1)-ibm_ht_ystag(ii(nC),ji(nC)+1)))
 	     else
 		side_neigh(3*nC+1,S) = (ji(nC)*dy)-(dy/2) + (dy/4)*((side_neigh(3*nC+2,S)-ibm_ht(ii(nC),ji(nC))) &
 							  /(ibm_ht_ystag(ii(nC),ji(nC)+1)-ibm_ht(ii(nC),ji(nC))))
 	     endif
 	  elseif (stag == 2) then
 	     ! solve for x
 	     if (ibm_ht_xstag(ii(nC)+1,ji(nC)) >= side_neigh(3*nC+2,S)) then
 		side_neigh(3*nC,S) = (ii(nC)*dx)-(dx/2) + (dx/4)+(dx/4)*((side_neigh(3*nC+2,S)-ibm_ht_xstag(ii(nC)+1,ji(nC))) &
 						                     /(ibm_ht(ii(nC)+1,ji(nC))-ibm_ht_xstag(ii(nC)+1,ji(nC))))
 	     else
 		side_neigh(3*nC,S) = (ii(nC)*dx)-(dx/2) + (dx/4)*((side_neigh(3*nC+2,S)-ibm_ht(ii(nC),ji(nC))) &
 							/(ibm_ht_xstag(ii(nC)+1,ji(nC))-ibm_ht(ii(nC),ji(nC))))
 	     endif
 	     ! solve for y
 	     if (ibm_ht_ystag(ii(nC),ji(nC)) >= side_neigh(3*nC+2,S)) then
 		side_neigh(3*nC+1,S) = (ji(nC)*dy)-dy + (dy/4)+(dy/4)*((side_neigh(3*nC+2,S)-ibm_ht_ystag(ii(nC),ji(nC))) &
 							  	   /(ibm_ht(ii(nC),ji(nC)+1)-ibm_ht_ystag(ii(nC),ji(nC))))
 	     else
 		side_neigh(3*nC+1,S) = (ji(nC)*dy)-dy + (dy/4)*((side_neigh(3*nC+2,S)-ibm_ht(ii(nC),ji(nC))) &
 							/(ibm_ht_ystag(ii(nC),ji(nC))-ibm_ht(ii(nC),ji(nC))))
 	     endif
 	 elseif (stag == 3) then
 	      ! solve for x
 	      if (ibm_ht_xstag(ii(nC)+1,ji(nC)) >= side_neigh(3*nC+2,S)) then
 		 side_neigh(3*nC,S) = (ii(nC)*dx)-(dx/2) + (dx/4)+(dx/4)*((side_neigh(3*nC+2,S)-ibm_ht_xstag(ii(nC)+1,ji(nC))) &
 						                      /(ibm_ht(ii(nC)+1,ji(nC))-ibm_ht_xstag(ii(nC)+1,ji(nC))))
 	      else
 		 side_neigh(3*nC,S) = (ii(nC)*dx)-(dx/2) + (dx/4)*((side_neigh(3*nC+2,S)-ibm_ht(ii(nC),ji(nC))) &
 							 /(ibm_ht_xstag(ii(nC)+1,ji(nC))-ibm_ht(ii(nC),ji(nC))))
 	      endif
 	      ! solve for y
 	      if (ibm_ht_ystag(ii(nC),ji(nC)+1) >= side_neigh(3*nC+2,S)) then
 		 side_neigh(3*nC+1,S) = (ji(nC)*dy)-(dy/2) + (dy/4)+(dy/4)*((side_neigh(3*nC+2,S)-ibm_ht_ystag(ii(nC),ji(nC)+1)) &
 							        	/(ibm_ht(ii(nC),ji(nC)+1)-ibm_ht_ystag(ii(nC),ji(nC)+1)))
 	      else
 		 side_neigh(3*nC+1,S) = (ji(nC)*dy)-(dy/2) + (dy/4)*((side_neigh(3*nC+2,S)-ibm_ht(ii(nC),ji(nC))) &
 							   /(ibm_ht_ystag(ii(nC),ji(nC)+1)-ibm_ht(ii(nC),ji(nC))))
 	      endif
 	 endif	 
 	 ! neighbors 1,4,5,6,7 are the zero computational nodes
 	 nC = 1
 	 side_neigh_i(3*nC,S) = ii(nC)
 	 side_neigh_i(3*nC+1,S) = ji(nC)
 	 side_neigh_i(3*nC+2,S) = ki(nC) 	
 	 if (stag ==1 ) then			
 	     side_neigh(3*nC,S) = (side_neigh_i(3*nC,S)*dx)-(dx)
 	     side_neigh(3*nC+1,S) = (side_neigh_i(3*nC+1,S)*dy)-(dy/2)
 	 elseif (stag == 2) then
 	     side_neigh(3*nC,S) = (side_neigh_i(3*nC,S)*dx)-(dx/2)
 	     side_neigh(3*nC+1,S) = (side_neigh_i(3*nC+1,S)*dy)-(dy)	     
 	 elseif (stag == 3) then
 	     side_neigh(3*nC,S) = (side_neigh_i(3*nC,S)*dx)-(dx/2)
 	     side_neigh(3*nC+1,S) = (side_neigh_i(3*nC+1,S)*dy)-(dy/2)	     
 	 endif
 	 side_neigh(3*nC+2,S) = ht_p(side_neigh_i(3*nC,S),side_neigh_i(3*nC+2,S),side_neigh_i(3*nC+1,S))
	! neighbor 2 is on the boundary between 2 and 6
	! neighbor 3 is on the boundary between 3 and 7
	do nC = 2,3
	   side_neigh_i(3*nC,S) = ii(nC)
	   side_neigh_i(3*nC+1,S) = 0
	   side_neigh_i(3*nC+2,S) = 0
	   ! first z
	   side_neigh(3*nC+2,S) = ht_p(ii(nC),ki(nC),ji(nC))
	   if (stag == 1) then
	       !next x
	       side_neigh(3*nC,S) = (side_neigh_i(3*nC,S)*dx)-(dx)
	       ! solve for y
	       if (ibm_ht_ystag(ii(nC),ji(nC)+1) >= side_neigh(3*nC+2,S)) then
		  side_neigh(3*nC+1,S) = (ji(nC)*dy) + (dy/2)*((side_neigh(3*nC+2,S)-ibm_ht_ystag(ii(nC),ji(nC)+1)) &
						           /(ibm_ht(ii(nC),ji(nC)+1)-ibm_ht_ystag(ii(nC),ji(nC)+1)))
	       else
		  side_neigh(3*nC+1,S) = (ji(nC)*dy)-(dy/2) + (dy/2)*((side_neigh(3*nC+2,S)-ibm_ht(ii(nC),ji(nC))) &
						            /(ibm_ht_ystag(ii(nC),ji(nC)+1)-ibm_ht(ii(nC),ji(nC))))
	       endif						  
	   elseif (stag == 2) then
	       !next x
	       side_neigh(3*nC,S) = (side_neigh_i(3*nC,S)*dx)-(dx/2)
	       ! solve for y
	       if (ibm_ht_ystag(ii(nC),ji(nC)) >= side_neigh(3*nC+2,S)) then
		  side_neigh(3*nC+1,S) = (ji(nC)*dy-(dy/2)) + (dy/2)*((side_neigh(3*nC+2,S)-ibm_ht_ystag(ii(nC),ji(nC))) &
						                  /(ibm_ht(ii(nC),ji(nC)+1)-ibm_ht_ystag(ii(nC),ji(nC))))
	       else
		  side_neigh(3*nC+1,S) = (ji(nC)*dy)-dy + (dy/2)*((side_neigh(3*nC+2,S)-ibm_ht(ii(nC),ji(nC))) &
						          /(ibm_ht_ystag(ii(nC),ji(nC))-ibm_ht(ii(nC),ji(nC))))
	       endif
	   elseif (stag == 3) then
	       !next x
	       side_neigh(3*nC,S) = (side_neigh_i(3*nC,S)*dx)-(dx/2)
	       ! solve for y
	       if (ibm_ht_ystag(ii(nC),ji(nC)+1) >= side_neigh(3*nC+2,S)) then
		  side_neigh(3*nC+1,S) = (ji(nC)*dy) + (dy/2)*((side_neigh(3*nC+2,S)-ibm_ht_ystag(ii(nC),ji(nC)+1)) &
						           /(ibm_ht(ii(nC),ji(nC)+1)-ibm_ht_ystag(ii(nC),ji(nC)+1)))
	       else
		  side_neigh(3*nC+1,S) = (ji(nC)*dy)-(dy/2) + (dy/2)*((side_neigh(3*nC+2,S)-ibm_ht(ii(nC),ji(nC))) &
							    /(ibm_ht_ystag(ii(nC),ji(nC)+1)-ibm_ht(ii(nC),ji(nC))))
	       endif	
	   endif
	 enddo 			 
 	 ! neighbors 1,4,5,6,7 are the zero computational nodes
 	 do nC = 4,7
 	    side_neigh_i(3*nC,S) = ii(nC)
 	    side_neigh_i(3*nC+1,S) = ji(nC)
 	    side_neigh_i(3*nC+2,S) = ki(nC) 	
 	    if (stag ==1 ) then			
 		side_neigh(3*nC,S) = (side_neigh_i(3*nC,S)*dx)-(dx)
 		side_neigh(3*nC+1,S) = (side_neigh_i(3*nC+1,S)*dy)-(dy/2)
 	    elseif (stag == 2) then
 		side_neigh(3*nC,S) = (side_neigh_i(3*nC,S)*dx)-(dx/2)
 		side_neigh(3*nC+1,S) = (side_neigh_i(3*nC+1,S)*dy)-(dy)	     
 	    elseif (stag == 3) then
 		side_neigh(3*nC,S) = (side_neigh_i(3*nC,S)*dx)-(dx/2)
 		side_neigh(3*nC+1,S) = (side_neigh_i(3*nC+1,S)*dy)-(dy/2)	     
 	    endif
 	    side_neigh(3*nC+2,S) = ht_p(side_neigh_i(3*nC,S),side_neigh_i(3*nC+2,S),side_neigh_i(3*nC+1,S))
	 enddo	 
    ELSEIF ((inside(ii(0),ki(0),ji(0)) == 0).AND. &
 	 (inside(ii(1),ki(1),ji(1)) == 0).AND. &
 	 (inside(ii(2),ki(2),ji(2)) == 0).AND. &
 	 (inside(ii(3),ki(3),ji(3)) == 0).AND. &
 	 (inside(ii(4),ki(4),ji(4)) == 1).AND. &
 	 (inside(ii(5),ki(5),ji(5)) == 0).AND. &
 	 (inside(ii(6),ki(6),ji(6)) == 1).AND. &
 	 (inside(ii(7),ki(7),ji(7)) == 1)) THEN 
 	 ! neighbors 0,1,2,3,5 are the zero computational nodes
 	 do nC = 0,3
 	    side_neigh_i(3*nC,S) = ii(nC)
 	    side_neigh_i(3*nC+1,S) = ji(nC)
 	    side_neigh_i(3*nC+2,S) = ki(nC) 	
 	    if (stag ==1 ) then			
 		side_neigh(3*nC,S) = (side_neigh_i(3*nC,S)*dx)-(dx)
 		side_neigh(3*nC+1,S) = (side_neigh_i(3*nC+1,S)*dy)-(dy/2)
 	    elseif (stag == 2) then
 		side_neigh(3*nC,S) = (side_neigh_i(3*nC,S)*dx)-(dx/2)
 		side_neigh(3*nC+1,S) = (side_neigh_i(3*nC+1,S)*dy)-(dy)	     
 	    elseif (stag == 3) then
 		side_neigh(3*nC,S) = (side_neigh_i(3*nC,S)*dx)-(dx/2)
 		side_neigh(3*nC+1,S) = (side_neigh_i(3*nC+1,S)*dy)-(dy/2)	     
 	    endif
 	    side_neigh(3*nC+2,S) = ht_p(side_neigh_i(3*nC,S),side_neigh_i(3*nC+2,S),side_neigh_i(3*nC+1,S))
	 enddo	 
 	 ! neighbor 4 on the boundary on the 0145 plane 
 	 nC = 4 
 	 side_neigh_i(3*nC,S) = 0
 	 side_neigh_i(3*nC+1,S) = 0
 	 side_neigh_i(3*nC+2,S) = 0
 	 ! first z
 	 side_neigh(3*nC+2,S) = ht_p(ii(nC),ki(nC),ji(nC))
 	 if (stag == 1) then
 	     ! solve for x
 	     if (ibm_ht_xstag(ii(nC),ji(nC)) >= side_neigh(3*nC+2,S)) then
 		side_neigh(3*nC,S) = (ii(nC)*dx)-dx + (dx/4)+(dx/4)*((side_neigh(3*nC+2,S)-ibm_ht_xstag(ii(nC),ji(nC))) &
 							         /(ibm_ht(ii(nC)+1,ji(nC))-ibm_ht_xstag(ii(nC),ji(nC))))
 	     else
 		side_neigh(3*nC,S) = (ii(nC)*dx)-dx + (dx/4)*((side_neigh(3*nC+2,S)-ibm_ht(ii(nC),ji(nC))) &
 						      /(ibm_ht_xstag(ii(nC),ji(nC))-ibm_ht(ii(nC),ji(nC))))
 	     endif						  
 	     ! solve for y
 	     if (ibm_ht_ystag(ii(nC),ji(nC)) >= side_neigh(3*nC+2,S)) then
 		side_neigh(3*nC+1,S) = ((ji(nC)-1)*dy)-(dy/2) + (dy/2)+(dy/4)*((side_neigh(3*nC+2,S)-ibm_ht(ii(nC),ji(nC)-1)) &
 								       /(ibm_ht_ystag(ii(nC),ji(nC))-ibm_ht(ii(nC),ji(nC)-1)))
 	     else
 		side_neigh(3*nC+1,S) = (ji(nC)*dy)-dy + (dy/4)+(dy/4)*((side_neigh(3*nC+2,S)-ibm_ht_ystag(ii(nC),ji(nC))) &
 								     /(ibm_ht(ii(nC),ji(nC))-ibm_ht_ystag(ii(nC),ji(nC))))
 	     endif
 	 elseif (stag == 2) then
  	    ! solve for x
 	    if (ibm_ht_xstag(ii(nC)+1,ji(nC)) >= side_neigh(3*nC+2,S)) then
 	       side_neigh(3*nC,S) = (ii(nC)*dx)-(dx/2) + (dx/4)+(dx/4)*((side_neigh(3*nC+2,S)-ibm_ht_xstag(ii(nC)+1,ji(nC))) &
 						                    /(ibm_ht(ii(nC)+1,ji(nC))-ibm_ht_xstag(ii(nC)+1,ji(nC))))
 	    else
 	       side_neigh(3*nC,S) = (ii(nC)*dx)-(dx/2) + (dx/4)*((side_neigh(3*nC+2,S)-ibm_ht(ii(nC),ji(nC))) &
 						       /(ibm_ht_xstag(ii(nC)+1,ji(nC))-ibm_ht(ii(nC),ji(nC))))
 	    endif
 	    ! solve for y
 	    if (ibm_ht_ystag(ii(nC),ji(nC)-1) >= side_neigh(3*nC+2,S)) then
 	       side_neigh(3*nC+1,S) = ((ji(nC)-1)*dy)-dy + (dy/2)+(dy/4)*((side_neigh(3*nC+2,S)-ibm_ht(ii(nC),ji(nC)-1)) &
 								/(ibm_ht_ystag(ii(nC),ji(nC)-1)-ibm_ht(ii(nC),ji(nC)-1)))
 	    else
 	       side_neigh(3*nC+1,S) = ((ji(nC)-1)*dy)-(dy/2) + (dy/4)+(dy/4)*((side_neigh(3*nC+2,S)-ibm_ht_ystag(ii(nC),ji(nC)-1)) &
 									    /(ibm_ht(ii(nC),ji(nC))-ibm_ht_ystag(ii(nC),ji(nC)-1)))
 	    endif
 	 elseif (stag == 3) then
 	     ! solve for x
 	     if (ibm_ht_xstag(ii(nC)+1,ji(nC)) >= side_neigh(3*nC+2,S)) then
 		side_neigh(3*nC,S) = (ii(nC)*dx)-(dx/2) + (dx/4)+(dx/4)*((side_neigh(3*nC+2,S)-ibm_ht_xstag(ii(nC)+1,ji(nC))) &
 						                     /(ibm_ht(ii(nC)+1,ji(nC))-ibm_ht_xstag(ii(nC)+1,ji(nC))))
 	     else 
 		side_neigh(3*nC,S) = (ii(nC)*dx)-(dx/2) + (dx/4)*((side_neigh(3*nC+2,S)-ibm_ht(ii(nC),ji(nC))) &
 							/(ibm_ht_xstag(ii(nC)+1,ji(nC))-ibm_ht(ii(nC),ji(nC))))
 	     endif
 	     ! solve for y
 	     if (ibm_ht_ystag(ii(nC),ji(nC)) >= side_neigh(3*nC+2,S)) then
 		side_neigh(3*nC+1,S) = ((ji(nC)-1)*dy)+ (dy/4)*((side_neigh(3*nC+2,S)-ibm_ht(ii(nC),ji(nC)-1)) &
 					        	/(ibm_ht_ystag(ii(nC),ji(nC))-ibm_ht(ii(nC),ji(nC)-1)))
 	     else
 		side_neigh(3*nC+1,S) = ((ji(nC)-1)*dy) + (dy/4)+(dy/4)*((side_neigh(3*nC+2,S)-ibm_ht_ystag(ii(nC),ji(nC))) &
 								       /(ibm_ht(ii(nC),ji(nC))-ibm_ht_ystag(ii(nC),ji(nC))))
 	     endif
 	 endif
 	 ! neighbors 0,1,2,3,5 are the zero computational nodes
 	 nC = 5
 	 side_neigh_i(3*nC,S) = ii(nC)
 	 side_neigh_i(3*nC+1,S) = ji(nC)
 	 side_neigh_i(3*nC+2,S) = ki(nC) 	
 	 if (stag ==1 ) then			
 	     side_neigh(3*nC,S) = (side_neigh_i(3*nC,S)*dx)-(dx)
 	     side_neigh(3*nC+1,S) = (side_neigh_i(3*nC+1,S)*dy)-(dy/2)
 	 elseif (stag == 2) then
 	     side_neigh(3*nC,S) = (side_neigh_i(3*nC,S)*dx)-(dx/2)
 	     side_neigh(3*nC+1,S) = (side_neigh_i(3*nC+1,S)*dy)-(dy)	     
 	 elseif (stag == 3) then
 	     side_neigh(3*nC,S) = (side_neigh_i(3*nC,S)*dx)-(dx/2)
 	     side_neigh(3*nC+1,S) = (side_neigh_i(3*nC+1,S)*dy)-(dy/2)	     
 	 endif
 	 side_neigh(3*nC+2,S) = ht_p(side_neigh_i(3*nC,S),side_neigh_i(3*nC+2,S),side_neigh_i(3*nC+1,S))
         ! neighbor 6 is on the boundary between 6 and 2
	 ! neighbor 7 is on the boundary between 7 and 3	 
	 do nC = 6,7
	    side_neigh_i(3*nC,S) = ii(nC)
	    side_neigh_i(3*nC+1,S) = 0
	    side_neigh_i(3*nC+2,S) = 0
	    ! first z
	    side_neigh(3*nC+2,S) = ht_p(ii(nC),ki(nC),ji(nC))
	    if (stag == 1) then
		!next x
		side_neigh(3*nC,S) = (side_neigh_i(3*nC,S)*dx)-(dx)
		! solve for y
		if (ibm_ht_ystag(ii(nC),ji(nC)) >= side_neigh(3*nC+2,S)) then
		   side_neigh(3*nC+1,S) = ((ji(nC)-1)*dy)-(dy/2) + (dy/2)*((side_neigh(3*nC+2,S)-ibm_ht(ii(nC),ji(nC)-1)) &
						                   /(ibm_ht_ystag(ii(nC),ji(nC))-ibm_ht(ii(nC),ji(nC)-1)))
		else
		   side_neigh(3*nC+1,S) = (ji(nC)*dy)-dy + (dy/2)*((side_neigh(3*nC+2,S)-ibm_ht_ystag(ii(nC),ji(nC))) &
							         /(ibm_ht(ii(nC),ji(nC))-ibm_ht_ystag(ii(nC),ji(nC))))
		endif						  
	    elseif (stag == 2) then
		!next x
		side_neigh(3*nC,S) = (side_neigh_i(3*nC,S)*dx)-(dx/2)
		! solve for y
		if (ibm_ht_ystag(ii(nC),ji(nC)-1) >= side_neigh(3*nC+2,S)) then
		   side_neigh(3*nC+1,S) = ((ji(nC)-1)*dy)-dy + (dy/2)*((side_neigh(3*nC+2,S)-ibm_ht(ii(nC),ji(nC)-1)) &
						             /(ibm_ht_ystag(ii(nC),ji(nC)-1)-ibm_ht(ii(nC),ji(nC)-1)))
		else
		   side_neigh(3*nC+1,S) = ((ji(nC)-1)*dy)-(dy/2) + (dy/2)*((side_neigh(3*nC+2,S)-ibm_ht_ystag(ii(nC),ji(nC)-1)) &
						                         /(ibm_ht(ii(nC),ji(nC))-ibm_ht_ystag(ii(nC),ji(nC)-1)))
		endif
	    elseif (stag == 3) then
		!next x
		side_neigh(3*nC,S) = (side_neigh_i(3*nC,S)*dx)-(dx/2)
		! solve for y
		if (ibm_ht_ystag(ii(nC),ji(nC)) >= side_neigh(3*nC+2,S)) then
		   side_neigh(3*nC+1,S) = ((ji(nC)-1)*dy)-(dy/2) + (dy/2)*((side_neigh(3*nC+2,S)-ibm_ht(ii(nC),ji(nC)-1)) &
						                   /(ibm_ht_ystag(ii(nC),ji(nC))-ibm_ht(ii(nC),ji(nC)-1)))
		else
		   side_neigh(3*nC+1,S) = (ji(nC)*dy)-dy + (dy/2)*((side_neigh(3*nC+2,S)-ibm_ht_ystag(ii(nC),ji(nC))) &
							         /(ibm_ht(ii(nC),ji(nC))-ibm_ht_ystag(ii(nC),ji(nC))))
		endif
	    endif
	 enddo
    ELSEIF ((inside(ii(0),ki(0),ji(0)) == 0).AND. &
 	 (inside(ii(1),ki(1),ji(1)) == 1).AND. &
 	 (inside(ii(2),ki(2),ji(2)) == 1).AND. &
 	 (inside(ii(3),ki(3),ji(3)) == 1).AND. &
 	 (inside(ii(4),ki(4),ji(4)) == 0).AND. &
 	 (inside(ii(5),ki(5),ji(5)) == 0).AND. &
 	 (inside(ii(6),ki(6),ji(6)) == 0).AND. &
 	 (inside(ii(7),ki(7),ji(7)) == 0)) THEN 
 	 ! neighbors 0,4,5,6,7 are the zero computational nodes
 	 nC = 0
 	 side_neigh_i(3*nC,S) = ii(nC)
 	 side_neigh_i(3*nC+1,S) = ji(nC)
 	 side_neigh_i(3*nC+2,S) = ki(nC) 	
 	 if (stag ==1 ) then			
 	     side_neigh(3*nC,S) = (side_neigh_i(3*nC,S)*dx)-(dx)
 	     side_neigh(3*nC+1,S) = (side_neigh_i(3*nC+1,S)*dy)-(dy/2)
 	 elseif (stag == 2) then
 	     side_neigh(3*nC,S) = (side_neigh_i(3*nC,S)*dx)-(dx/2)
 	     side_neigh(3*nC+1,S) = (side_neigh_i(3*nC+1,S)*dy)-(dy)	     
 	 elseif (stag == 3) then
 	     side_neigh(3*nC,S) = (side_neigh_i(3*nC,S)*dx)-(dx/2)
 	     side_neigh(3*nC+1,S) = (side_neigh_i(3*nC+1,S)*dy)-(dy/2)	     
 	 endif
 	 side_neigh(3*nC+2,S) = ht_p(side_neigh_i(3*nC,S),side_neigh_i(3*nC+2,S),side_neigh_i(3*nC+1,S))
 	 ! neighbor 1 on the boundary face that cuts the 0145 plane
 	 nC = 1 
 	 side_neigh_i(3*nC,S) = 0
 	 side_neigh_i(3*nC+1,S) = 0
 	 side_neigh_i(3*nC+2,S) = 0
 	 ! first z
 	 side_neigh(3*nC+2,S) = ht_p(ii(nC),ki(nC),ji(nC))
 	 if (stag == 1) then
 	     ! solve for x/2
 	     if (ibm_ht_xstag(ii(nC)-1,ji(nC)) >= side_neigh(3*nC+2,S)) then
 		side_neigh(3*nC,S) = ((ii(nC)-1)*dx)-dx + (dx/2)+(dx/4)*((side_neigh(3*nC+2,S)-ibm_ht(ii(nC)-1,ji(nC))) &
 							       /(ibm_ht_xstag(ii(nC)-1,ji(nC))-ibm_ht(ii(nC)-1,ji(nC))))
 	     else
 		side_neigh(3*nC,S) = ((ii(nC)-1)*dx)-(dx/2) +  (dx/4)+(dx/4)*((side_neigh(3*nC+2,S)-ibm_ht_xstag(ii(nC)-1,ji(nC))) &
 									    /(ibm_ht(ii(nC),ji(nC))-ibm_ht_xstag(ii(nC)-1,ji(nC))))
 	     endif	
 	     ! solve for y/2
 	     if (ibm_ht_ystag(ii(nC),ji(nC)+1) >= side_neigh(3*nC+2,S)) then
 		side_neigh(3*nC+1,S) = (ji(nC)*dy)-(dy/2) + (dy/4)+(dy/4)*((side_neigh(3*nC+2,S)-ibm_ht_ystag(ii(nC),ji(nC)+1)) &
 							               /(ibm_ht(ii(nC),ji(nC)+1)-ibm_ht_ystag(ii(nC),ji(nC)+1)))
 	     else
 		side_neigh(3*nC+1,S) = (ji(nC)*dy)-(dy/2) + (dy/4)*((side_neigh(3*nC+2,S)-ibm_ht(ii(nC),ji(nC))) &
 							  /(ibm_ht_ystag(ii(nC),ji(nC)+1)-ibm_ht(ii(nC),ji(nC))))
 	     endif						  
 	 elseif (stag == 2) then
 	     ! solve for x/2
 	     if (ibm_ht_xstag(ii(nC),ji(nC)) >= side_neigh(3*nC+2,S)) then
 		side_neigh(3*nC,S) = ((ii(nC)-1)*dx)-(dx/2) +  (dx/2)+(dx/4)*((side_neigh(3*nC+2,S)-ibm_ht(ii(nC)-1,ji(nC))) &
 								      /(ibm_ht_xstag(ii(nC),ji(nC))-ibm_ht(ii(nC)-1,ji(nC))))
 	     else
 		side_neigh(3*nC,S) = (ii(nC)*dx)-dx +  (dx/4)+(dx/4)*((side_neigh(3*nC+2,S)-ibm_ht_xstag(ii(nC),ji(nC))) &
 								    /(ibm_ht(ii(nC),ji(nC))-ibm_ht_xstag(ii(nC),ji(nC))))
 	     endif
 	     ! solve for y/2
 	     if (ibm_ht_ystag(ii(nC),ji(nC)) >= side_neigh(3*nC+2,S)) then
 		side_neigh(3*nC+1,S) = (ji(nC)*dy)-dy + (dy/4)+(dy/4)*((side_neigh(3*nC+2,S)-ibm_ht_ystag(ii(nC),ji(nC))) &
 						                   /(ibm_ht(ii(nC),ji(nC)+1)-ibm_ht_ystag(ii(nC),ji(nC))))
 	     else
 		side_neigh(3*nC+1,S) = (ji(nC)*dy)-dy + (dy/4)*((side_neigh(3*nC+2,S)-ibm_ht(ii(nC),ji(nC))) &
 							/(ibm_ht_ystag(ii(nC),ji(nC))-ibm_ht(ii(nC),ji(nC))))
 	     endif
 	 elseif (stag == 3) then
 	     ! solve for x/2
 	     if (ibm_ht_xstag(ii(nC),ji(nC)) >= side_neigh(3*nC+2,S)) then
 		side_neigh(3*nC,S) = ((ii(nC)-1)*dx)-(dx/2) + (dx/2)+(dx/4)*((side_neigh(3*nC+2,S)-ibm_ht(ii(nC)-1,ji(nC))) &
 								     /(ibm_ht_xstag(ii(nC),ji(nC))-ibm_ht(ii(nC)-1,ji(nC))))
 	     else
 		side_neigh(3*nC,S) = (ii(nC)*dx)-dx +  (dx/4)+(dx/4)*((side_neigh(3*nC+2,S)-ibm_ht_xstag(ii(nC),ji(nC))) &
 								    /(ibm_ht(ii(nC),ji(nC))-ibm_ht_xstag(ii(nC),ji(nC))))
 	     endif
 	     ! solve for y/2
 	     if (ibm_ht_ystag(ii(nC),ji(nC)+1) >= side_neigh(3*nC+2,S)) then
 		side_neigh(3*nC+1,S) = (ji(nC)*dy)-(dy/2) + (dy/4)+(dy/4)*((side_neigh(3*nC+2,S)-ibm_ht_ystag(ii(nC),ji(nC)+1)) &
 							               /(ibm_ht(ii(nC),ji(nC)+1)-ibm_ht_ystag(ii(nC),ji(nC)+1)))
 	     else
 		side_neigh(3*nC+1,S) = (ji(nC)*dy)-(dy/2) + (dy/4)*((side_neigh(3*nC+2,S)-ibm_ht(ii(nC),ji(nC))) &
 							  /(ibm_ht_ystag(ii(nC),ji(nC)+1)-ibm_ht(ii(nC),ji(nC))))
 	     endif
 	 endif
	! neighbor 2 is on the boundary between 2 and 6
	! neighbor 3 is on the boundary between 3 and 7
	do nC = 2,3
	   side_neigh_i(3*nC,S) = ii(nC)
	   side_neigh_i(3*nC+1,S) = 0
	   side_neigh_i(3*nC+2,S) = 0
	   ! first z
	   side_neigh(3*nC+2,S) = ht_p(ii(nC),ki(nC),ji(nC))
	   if (stag == 1) then
	       !next x
	       side_neigh(3*nC,S) = (side_neigh_i(3*nC,S)*dx)-(dx)
	       ! solve for y
	       if (ibm_ht_ystag(ii(nC),ji(nC)+1) >= side_neigh(3*nC+2,S)) then
		  side_neigh(3*nC+1,S) = (ji(nC)*dy) + (dy/2)*((side_neigh(3*nC+2,S)-ibm_ht_ystag(ii(nC),ji(nC)+1)) &
						           /(ibm_ht(ii(nC),ji(nC)+1)-ibm_ht_ystag(ii(nC),ji(nC)+1)))
	       else
		  side_neigh(3*nC+1,S) = (ji(nC)*dy)-(dy/2) + (dy/2)*((side_neigh(3*nC+2,S)-ibm_ht(ii(nC),ji(nC))) &
						            /(ibm_ht_ystag(ii(nC),ji(nC)+1)-ibm_ht(ii(nC),ji(nC))))
	       endif						  
	   elseif (stag == 2) then
	       !next x
	       side_neigh(3*nC,S) = (side_neigh_i(3*nC,S)*dx)-(dx/2)
	       ! solve for y
	       if (ibm_ht_ystag(ii(nC),ji(nC)) >= side_neigh(3*nC+2,S)) then
		  side_neigh(3*nC+1,S) = (ji(nC)*dy-(dy/2)) + (dy/2)*((side_neigh(3*nC+2,S)-ibm_ht_ystag(ii(nC),ji(nC))) &
						                  /(ibm_ht(ii(nC),ji(nC)+1)-ibm_ht_ystag(ii(nC),ji(nC))))
	       else
		  side_neigh(3*nC+1,S) = (ji(nC)*dy)-dy + (dy/2)*((side_neigh(3*nC+2,S)-ibm_ht(ii(nC),ji(nC))) &
						          /(ibm_ht_ystag(ii(nC),ji(nC))-ibm_ht(ii(nC),ji(nC))))
	       endif
	   elseif (stag == 3) then
	       !next x
	       side_neigh(3*nC,S) = (side_neigh_i(3*nC,S)*dx)-(dx/2)
	       ! solve for y
	       if (ibm_ht_ystag(ii(nC),ji(nC)+1) >= side_neigh(3*nC+2,S)) then
		  side_neigh(3*nC+1,S) = (ji(nC)*dy) + (dy/2)*((side_neigh(3*nC+2,S)-ibm_ht_ystag(ii(nC),ji(nC)+1)) &
						           /(ibm_ht(ii(nC),ji(nC)+1)-ibm_ht_ystag(ii(nC),ji(nC)+1)))
	       else
		  side_neigh(3*nC+1,S) = (ji(nC)*dy)-(dy/2) + (dy/2)*((side_neigh(3*nC+2,S)-ibm_ht(ii(nC),ji(nC))) &
							    /(ibm_ht_ystag(ii(nC),ji(nC)+1)-ibm_ht(ii(nC),ji(nC))))
	       endif	
	   endif
	 enddo 
 	 ! neighbors 0,4,5,6,7 are the zero computational nodes
 	 do nC = 4,7
 	    side_neigh_i(3*nC,S) = ii(nC)
 	    side_neigh_i(3*nC+1,S) = ji(nC)
 	    side_neigh_i(3*nC+2,S) = ki(nC) 	
 	    if (stag ==1 ) then			
 		side_neigh(3*nC,S) = (side_neigh_i(3*nC,S)*dx)-(dx)
 		side_neigh(3*nC+1,S) = (side_neigh_i(3*nC+1,S)*dy)-(dy/2)
 	    elseif (stag == 2) then
 		side_neigh(3*nC,S) = (side_neigh_i(3*nC,S)*dx)-(dx/2)
 		side_neigh(3*nC+1,S) = (side_neigh_i(3*nC+1,S)*dy)-(dy)	     
 	    elseif (stag == 3) then
 		side_neigh(3*nC,S) = (side_neigh_i(3*nC,S)*dx)-(dx/2)
 		side_neigh(3*nC+1,S) = (side_neigh_i(3*nC+1,S)*dy)-(dy/2)	     
 	    endif
 	    side_neigh(3*nC+2,S) = ht_p(side_neigh_i(3*nC,S),side_neigh_i(3*nC+2,S),side_neigh_i(3*nC+1,S))
         enddo	 
    ELSEIF ((inside(ii(0),ki(0),ji(0)) == 0).AND. &
 	 (inside(ii(1),ki(1),ji(1)) == 0).AND. &
 	 (inside(ii(2),ki(2),ji(2)) == 0).AND. &
 	 (inside(ii(3),ki(3),ji(3)) == 0).AND. &
 	 (inside(ii(4),ki(4),ji(4)) == 0).AND. &
 	 (inside(ii(5),ki(5),ji(5)) == 1).AND. &
 	 (inside(ii(6),ki(6),ji(6)) == 1).AND. &
 	 (inside(ii(7),ki(7),ji(7)) == 1)) THEN 
 	 ! neighbors 0,1,2,3,4 are the zero computational nodes
 	 do nC = 0,4
 	    side_neigh_i(3*nC,S) = ii(nC)
 	    side_neigh_i(3*nC+1,S) = ji(nC)
 	    side_neigh_i(3*nC+2,S) = ki(nC) 	
 	    if (stag ==1 ) then			
 		side_neigh(3*nC,S) = (side_neigh_i(3*nC,S)*dx)-(dx)
 		side_neigh(3*nC+1,S) = (side_neigh_i(3*nC+1,S)*dy)-(dy/2)
 	    elseif (stag == 2) then
 		side_neigh(3*nC,S) = (side_neigh_i(3*nC,S)*dx)-(dx/2)
 		side_neigh(3*nC+1,S) = (side_neigh_i(3*nC+1,S)*dy)-(dy)	     
 	    elseif (stag == 3) then
 		side_neigh(3*nC,S) = (side_neigh_i(3*nC,S)*dx)-(dx/2)
 		side_neigh(3*nC+1,S) = (side_neigh_i(3*nC+1,S)*dy)-(dy/2)	     
 	    endif
 	    side_neigh(3*nC+2,S) = ht_p(side_neigh_i(3*nC,S),side_neigh_i(3*nC+2,S),side_neigh_i(3*nC+1,S))
         enddo
 	 ! neighbor 5 on the boundary on the 0145 plane 
 	 nC = 5 
 	 side_neigh_i(3*nC,S) = 0
 	 side_neigh_i(3*nC+1,S) = 0
 	 side_neigh_i(3*nC+2,S) = 0
 	 ! first z
 	 side_neigh(3*nC+2,S) = ht_p(ii(nC),ki(nC),ji(nC))
 	 if (stag == 1) then
 	     ! solve for x
 	     if (ibm_ht_xstag(ii(nC)-1,ji(nC)) >= side_neigh(3*nC+2,S)) then
 		side_neigh(3*nC,S) = ((ii(nC)-1)*dx)-dx + (dx/2)+(dx/4)*((side_neigh(3*nC+2,S)-ibm_ht(ii(nC)-1,ji(nC))) &
 							       /(ibm_ht_xstag(ii(nC)-1,ji(nC))-ibm_ht(ii(nC)-1,ji(nC))))
 	     else
 		side_neigh(3*nC,S) = ((ii(nC)-1)*dx)-(dx/2) + (dx/4)+(dx/4)*((side_neigh(3*nC+2,S)-ibm_ht_xstag(ii(nC)-1,ji(nC))) &
 									   /(ibm_ht(ii(nC),ji(nC))-ibm_ht_xstag(ii(nC)-1,ji(nC))))
 	     endif						  
 	     ! solve for y
 	     if (ibm_ht_ystag(ii(nC),ji(nC)) >= side_neigh(3*nC+2,S)) then
 		side_neigh(3*nC+1,S) = ((ji(nC)-1)*dy)-(dy/2) + (dy/2)+(dy/4)*((side_neigh(3*nC+2,S)-ibm_ht(ii(nC),ji(nC)-1)) &
 								       /(ibm_ht_ystag(ii(nC),ji(nC))-ibm_ht(ii(nC),ji(nC)-1)))
 	     else
 		side_neigh(3*nC+1,S) = (ji(nC)*dy)-dy + (dy/4)+(dy/4)*((side_neigh(3*nC+2,S)-ibm_ht_ystag(ii(nC),ji(nC))) &
 								     /(ibm_ht(ii(nC),ji(nC))-ibm_ht_ystag(ii(nC),ji(nC))))
 	     endif
 	 elseif (stag == 2) then
	     ! solve for x
 	     if (ibm_ht_xstag(ii(nC),ji(nC)) >= side_neigh(3*nC+2,S)) then
 		side_neigh(3*nC,S) = ((ii(nC)-1)*dx)-(dx/2) + (dx/2)+(dx/4)*((side_neigh(3*nC+2,S)-ibm_ht(ii(nC)-1,ji(nC))) &
 								   /(ibm_ht_xstag(ii(nC)+1,ji(nC))-ibm_ht(ii(nC)-1,ji(nC))))
 	     else
 		side_neigh(3*nC,S) = (ii(nC)*dx)-dx + (dx/4)+(dx/4)*((side_neigh(3*nC+2,S)-ibm_ht_xstag(ii(nC),ji(nC))) &
 								   /(ibm_ht(ii(nC),ji(nC))-ibm_ht_xstag(ii(nC),ji(nC))))
 	     endif
 	     ! solve for y
 	     if (ibm_ht_ystag(ii(nC),ji(nC)-1) >= side_neigh(3*nC+2,S)) then
 		side_neigh(3*nC+1,S) = ((ji(nC)-1)*dy)-dy + (dy/2)+(dy/4)*((side_neigh(3*nC+2,S)-ibm_ht(ii(nC),ji(nC)-1)) &
 								 /(ibm_ht_ystag(ii(nC),ji(nC)-1)-ibm_ht(ii(nC),ji(nC)-1)))
 	     else
 		side_neigh(3*nC+1,S) = ((ji(nC)-1)*dy)-(dy/2) + (dy/4)+(dy/4)*((side_neigh(3*nC+2,S)-ibm_ht_ystag(ii(nC),ji(nC)-1)) &
 									     /(ibm_ht(ii(nC),ji(nC))-ibm_ht_ystag(ii(nC),ji(nC)-1)))
 	     endif
 	 elseif (stag == 3) then
 	     ! solve for x
 	     if (ibm_ht_xstag(ii(nC),ji(nC)) >= side_neigh(3*nC+2,S)) then
 		side_neigh(3*nC,S) = ((ii(nC)-1)*dx)-(dx/2) + (dx/2)+(dx/4)*((side_neigh(3*nC+2,S)-ibm_ht(ii(nC)-1,ji(nC))) &
 								     /(ibm_ht_xstag(ii(nC),ji(nC))-ibm_ht(ii(nC)-1,ji(nC))))
 	     else
 		side_neigh(3*nC,S) = (ii(nC)*dx)-dx + (dx/4)+(dx/4)*((side_neigh(3*nC+2,S)-ibm_ht_xstag(ii(nC),ji(nC))) &
 								   /(ibm_ht(ii(nC),ji(nC))-ibm_ht_xstag(ii(nC),ji(nC))))
 	     endif
 	     ! solve for y
 	     if (ibm_ht_ystag(ii(nC),ji(nC)) >= side_neigh(3*nC+2,S)) then
 		side_neigh(3*nC+1,S) = ((ji(nC)-1)*dy)-(dy/2) + (dy/2)+(dy/4)*((side_neigh(3*nC+2,S)-ibm_ht(ii(nC),ji(nC)-1)) &
 								       /(ibm_ht_ystag(ii(nC),ji(nC))-ibm_ht(ii(nC),ji(nC)-1)))
 	     else
 		side_neigh(3*nC+1,S) = (ji(nC)*dy)-dy + (dy/4)+(dy/4)*((side_neigh(3*nC+2,S)-ibm_ht_ystag(ii(nC),ji(nC))) &
 								     /(ibm_ht(ii(nC),ji(nC))-ibm_ht_ystag(ii(nC),ji(nC))))
 	     endif
 	 endif
         ! neighbor 6 is on the boundary between 6 and 2
	 ! neighbor 7 is on the boundary between 7 and 3	 
	 do nC = 6,7
	    side_neigh_i(3*nC,S) = ii(nC)
	    side_neigh_i(3*nC+1,S) = 0
	    side_neigh_i(3*nC+2,S) = 0
	    ! first z
	    side_neigh(3*nC+2,S) = ht_p(ii(nC),ki(nC),ji(nC))
	    if (stag == 1) then
		!next x
		side_neigh(3*nC,S) = (side_neigh_i(3*nC,S)*dx)-(dx)
		! solve for y
		if (ibm_ht_ystag(ii(nC),ji(nC)) >= side_neigh(3*nC+2,S)) then
		   side_neigh(3*nC+1,S) = ((ji(nC)-1)*dy)-(dy/2) + (dy/2)*((side_neigh(3*nC+2,S)-ibm_ht(ii(nC),ji(nC)-1)) &
						                   /(ibm_ht_ystag(ii(nC),ji(nC))-ibm_ht(ii(nC),ji(nC)-1)))
		else
		   side_neigh(3*nC+1,S) = (ji(nC)*dy)-dy + (dy/2)*((side_neigh(3*nC+2,S)-ibm_ht_ystag(ii(nC),ji(nC))) &
							         /(ibm_ht(ii(nC),ji(nC))-ibm_ht_ystag(ii(nC),ji(nC))))
		endif						  
	    elseif (stag == 2) then
		!next x
		side_neigh(3*nC,S) = (side_neigh_i(3*nC,S)*dx)-(dx/2)
		! solve for y
		if (ibm_ht_ystag(ii(nC),ji(nC)-1) >= side_neigh(3*nC+2,S)) then
		   side_neigh(3*nC+1,S) = ((ji(nC)-1)*dy)-dy + (dy/2)*((side_neigh(3*nC+2,S)-ibm_ht(ii(nC),ji(nC)-1)) &
						             /(ibm_ht_ystag(ii(nC),ji(nC)-1)-ibm_ht(ii(nC),ji(nC)-1)))
		else
		   side_neigh(3*nC+1,S) = ((ji(nC)-1)*dy)-(dy/2) + (dy/2)*((side_neigh(3*nC+2,S)-ibm_ht_ystag(ii(nC),ji(nC)-1)) &
						                         /(ibm_ht(ii(nC),ji(nC))-ibm_ht_ystag(ii(nC),ji(nC)-1)))
		endif
	    elseif (stag == 3) then
		!next x
		side_neigh(3*nC,S) = (side_neigh_i(3*nC,S)*dx)-(dx/2)
		! solve for y
		if (ibm_ht_ystag(ii(nC),ji(nC)) >= side_neigh(3*nC+2,S)) then
		   side_neigh(3*nC+1,S) = ((ji(nC)-1)*dy)-(dy/2) + (dy/2)*((side_neigh(3*nC+2,S)-ibm_ht(ii(nC),ji(nC)-1)) &
						                   /(ibm_ht_ystag(ii(nC),ji(nC))-ibm_ht(ii(nC),ji(nC)-1)))
		else
		   side_neigh(3*nC+1,S) = (ji(nC)*dy)-dy + (dy/2)*((side_neigh(3*nC+2,S)-ibm_ht_ystag(ii(nC),ji(nC))) &
							         /(ibm_ht(ii(nC),ji(nC))-ibm_ht_ystag(ii(nC),ji(nC))))
		endif
	    endif	 
	 enddo	 
    ELSEIF ((inside(ii(0),ki(0),ji(0)) == 1).AND. &
	(inside(ii(1),ki(1),ji(1)) == 0).AND. &
	(inside(ii(2),ki(2),ji(2)) == 1).AND. &
	(inside(ii(3),ki(3),ji(3)) == 0).AND. &
	(inside(ii(4),ki(4),ji(4)) == 1).AND. &
	(inside(ii(5),ki(5),ji(5)) == 0).AND. &
	(inside(ii(6),ki(6),ji(6)) == 1).AND. &
	(inside(ii(7),ki(7),ji(7)) == 0)) THEN
	 ! neighbor 0 on the boundary between 0 and 1
	 nC = 0 
	 side_neigh_i(3*nC,S) = 0
	 side_neigh_i(3*nC+1,S) = ji(nC)
	 side_neigh_i(3*nC+2,S) = 0
	 ! first z
	 side_neigh(3*nC+2,S) = ht_p(ii(nC),ki(nC),ji(nC))
	 if (stag == 1) then
	     !next y
	     side_neigh(3*nC+1,S) = (side_neigh_i(3*nC+1,S)*dy)-(dy/2)
	     ! solve for x
	     if (ibm_ht_xstag(ii(nC),ji(nC)) >= side_neigh(3*nC+2,S)) then
		side_neigh(3*nC,S) = (ii(nC)*dx)-(dx/2) + (dx/2)*((side_neigh(3*nC+2,S)-ibm_ht_xstag(ii(nC),ji(nC))) &
						              /(ibm_ht(ii(nC)+1,ji(nC))-ibm_ht_xstag(ii(nC),ji(nC))))
	     else
		side_neigh(3*nC,S) = (ii(nC)*dx)-dx + (dx/2)*((side_neigh(3*nC+2,S)-ibm_ht(ii(nC),ji(nC))) &
						      /(ibm_ht_xstag(ii(nC),ji(nC))-ibm_ht(ii(nC),ji(nC))))
	     endif						  
	 elseif (stag == 2) then
	     !next y
	     side_neigh(3*nC+1,S) = (side_neigh_i(3*nC+1,S)*dy)-(dy)
	     ! solve for x
	     if (ibm_ht_xstag(ii(nC)+1,ji(nC)) >= side_neigh(3*nC+2,S)) then
		side_neigh(3*nC,S) = (ii(nC)*dx) + (dx/2)*((side_neigh(3*nC+2,S)-ibm_ht_xstag(ii(nC)+1,ji(nC))) &
						       /(ibm_ht(ii(nC)+1,ji(nC))-ibm_ht_xstag(ii(nC)+1,ji(nC))))
	     else
		side_neigh(3*nC,S) = (ii(nC)*dx)-(dx/2) + (dx/2)*((side_neigh(3*nC+2,S)-ibm_ht(ii(nC),ji(nC))) &
						        /(ibm_ht_xstag(ii(nC)+1,ji(nC))-ibm_ht(ii(nC),ji(nC))))
	     endif
	 elseif (stag == 3) then
	     !next y
	     side_neigh(3*nC+1,S) = (side_neigh_i(3*nC+1,S)*dy)-(dy/2)
	     ! solve for x
	     if (ibm_ht_xstag(ii(nC)+1,ji(nC)) >= side_neigh(3*nC+2,S)) then
		side_neigh(3*nC,S) = (ii(nC)*dx) + (dx/2)*((side_neigh(3*nC+2,S)-ibm_ht_xstag(ii(nC)+1,ji(nC))) &
						       /(ibm_ht(ii(nC)+1,ji(nC))-ibm_ht_xstag(ii(nC)+1,ji(nC))))
	     else
		side_neigh(3*nC,S) = (ii(nC)*dx)-(dx/2) + (dx/2)*((side_neigh(3*nC+2,S)-ibm_ht(ii(nC),ji(nC))) &
						        /(ibm_ht_xstag(ii(nC)+1,ji(nC))-ibm_ht(ii(nC),ji(nC))))
	     endif
	 endif
	 ! neighbors 1,3,5,7 are the zero computational nodes
	 nC = 1
	 side_neigh_i(3*nC,S) = ii(nC)
	 side_neigh_i(3*nC+1,S) = ji(nC)
	 side_neigh_i(3*nC+2,S) = ki(nC)		
	 if (stag ==1 ) then 			
	     side_neigh(3*nC,S) = (side_neigh_i(3*nC,S)*dx)-(dx)
	     side_neigh(3*nC+1,S) = (side_neigh_i(3*nC+1,S)*dy)-(dy/2)
	 elseif (stag == 2) then
	     side_neigh(3*nC,S) = (side_neigh_i(3*nC,S)*dx)-(dx/2)
	     side_neigh(3*nC+1,S) = (side_neigh_i(3*nC+1,S)*dy)-(dy)	     
	 elseif (stag == 3) then
	     side_neigh(3*nC,S) = (side_neigh_i(3*nC,S)*dx)-(dx/2)
	     side_neigh(3*nC+1,S) = (side_neigh_i(3*nC+1,S)*dy)-(dy/2)	     
	 endif
	 side_neigh(3*nC+2,S) = ht_p(side_neigh_i(3*nC,S),side_neigh_i(3*nC+2,S),side_neigh_i(3*nC+1,S))  
	 ! neighbor 2 is on the boundary between 2 and 3
	 nC = 2
	 side_neigh_i(3*nC,S) = 0
	 side_neigh_i(3*nC+1,S) = ji(nC)
	 side_neigh_i(3*nC+2,S) = 0
	 ! first z
	 side_neigh(3*nC+2,S) = ht_p(ii(nC),ki(nC),ji(nC))
	 if (stag == 1) then
	     !next y
	     side_neigh(3*nC+1,S) = (side_neigh_i(3*nC+1,S)*dy)-(dy/2)
	     ! solve for x
	     if (ibm_ht_xstag(ii(nC),ji(nC)) >= side_neigh(3*nC+2,S)) then
		side_neigh(3*nC,S) = (ii(nC)*dx)-(dx/2) + (dx/2)*((side_neigh(3*nC+2,S)-ibm_ht_xstag(ii(nC),ji(nC))) &
						              /(ibm_ht(ii(nC)+1,ji(nC))-ibm_ht_xstag(ii(nC),ji(nC))))
	     else
		side_neigh(3*nC,S) = (ii(nC)*dx)-dx + (dx/2)*((side_neigh(3*nC+2,S)-ibm_ht(ii(nC),ji(nC))) &
						      /(ibm_ht_xstag(ii(nC),ji(nC))-ibm_ht(ii(nC),ji(nC))))
	     endif						  
	 elseif (stag == 2) then
	     !next y
	     side_neigh(3*nC+1,S) = (side_neigh_i(3*nC+1,S)*dy)-(dy)
	     ! solve for x
	     if (ibm_ht_xstag(ii(nC)+1,ji(nC)) >= side_neigh(3*nC+2,S)) then
		side_neigh(3*nC,S) = (ii(nC)*dx) + (dx/2)*((side_neigh(3*nC+2,S)-ibm_ht_xstag(ii(nC)+1,ji(nC))) &
						       /(ibm_ht(ii(nC)+1,ji(nC))-ibm_ht_xstag(ii(nC)+1,ji(nC))))
	     else
		side_neigh(3*nC,S) = (ii(nC)*dx)-(dx/2) + (dx/2)*((side_neigh(3*nC+2,S)-ibm_ht(ii(nC),ji(nC))) &
						        /(ibm_ht_xstag(ii(nC)+1,ji(nC))-ibm_ht(ii(nC),ji(nC))))
	     endif
	 elseif (stag == 3) then
	     !next y
	     side_neigh(3*nC+1,S) = (side_neigh_i(3*nC+1,S)*dy)-(dy/2)
	     ! solve for x
	     if (ibm_ht_xstag(ii(nC)+1,ji(nC)) >= side_neigh(3*nC+2,S)) then
		side_neigh(3*nC,S) = (ii(nC)*dx) + (dx/2)*((side_neigh(3*nC+2,S)-ibm_ht_xstag(ii(nC)+1,ji(nC))) &
						       /(ibm_ht(ii(nC)+1,ji(nC))-ibm_ht_xstag(ii(nC)+1,ji(nC))))
	     else
		side_neigh(3*nC,S) = (ii(nC)*dx)-(dx/2) + (dx/2)*((side_neigh(3*nC+2,S)-ibm_ht(ii(nC),ji(nC))) &
						        /(ibm_ht_xstag(ii(nC)+1,ji(nC))-ibm_ht(ii(nC),ji(nC))))
	     endif
	 endif
	 ! neighbors 1,3,5,7 are the zero computational nodes
	 nC = 3
	 side_neigh_i(3*nC,S) = ii(nC)
	 side_neigh_i(3*nC+1,S) = ji(nC)
	 side_neigh_i(3*nC+2,S) = ki(nC)		
	 if (stag ==1 ) then 			
	     side_neigh(3*nC,S) = (side_neigh_i(3*nC,S)*dx)-(dx)
	     side_neigh(3*nC+1,S) = (side_neigh_i(3*nC+1,S)*dy)-(dy/2)
	 elseif (stag == 2) then
	     side_neigh(3*nC,S) = (side_neigh_i(3*nC,S)*dx)-(dx/2)
	     side_neigh(3*nC+1,S) = (side_neigh_i(3*nC+1,S)*dy)-(dy)	     
	 elseif (stag == 3) then
	     side_neigh(3*nC,S) = (side_neigh_i(3*nC,S)*dx)-(dx/2)
	     side_neigh(3*nC+1,S) = (side_neigh_i(3*nC+1,S)*dy)-(dy/2)	     
	 endif
	 side_neigh(3*nC+2,S) = ht_p(side_neigh_i(3*nC,S),side_neigh_i(3*nC+2,S),side_neigh_i(3*nC+1,S))
	 ! neighbor 4 is on the boundary between 4 and 5
	 nC = 4
	 side_neigh_i(3*nC,S) = 0
	 side_neigh_i(3*nC+1,S) = ji(nC)
	 side_neigh_i(3*nC+2,S) = 0
	 ! first z
	 side_neigh(3*nC+2,S) = ht_p(ii(nC),ki(nC),ji(nC))
	 if (stag == 1) then
	     !next y
	     side_neigh(3*nC+1,S) = (side_neigh_i(3*nC+1,S)*dy)-(dy/2)
	     ! solve for x
	     if (ibm_ht_xstag(ii(nC),ji(nC)) >= side_neigh(3*nC+2,S)) then
		side_neigh(3*nC,S) = (ii(nC)*dx)-(dx/2) + (dx/2)*((side_neigh(3*nC+2,S)-ibm_ht_xstag(ii(nC),ji(nC))) &
						              /(ibm_ht(ii(nC)+1,ji(nC))-ibm_ht_xstag(ii(nC),ji(nC))))
	     else
		side_neigh(3*nC,S) = (ii(nC)*dx)-dx + (dx/2)*((side_neigh(3*nC+2,S)-ibm_ht(ii(nC),ji(nC))) &
						      /(ibm_ht_xstag(ii(nC),ji(nC))-ibm_ht(ii(nC),ji(nC))))
	     endif						  
	 elseif (stag == 2) then
	     !next y
	     side_neigh(3*nC+1,S) = (side_neigh_i(3*nC+1,S)*dy)-(dy)
	     ! solve for x
	     if (ibm_ht_xstag(ii(nC)+1,ji(nC)) >= side_neigh(3*nC+2,S)) then
		side_neigh(3*nC,S) = (ii(nC)*dx) + (dx/2)*((side_neigh(3*nC+2,S)-ibm_ht_xstag(ii(nC)+1,ji(nC))) &
						       /(ibm_ht(ii(nC)+1,ji(nC))-ibm_ht_xstag(ii(nC)+1,ji(nC))))
	     else
		side_neigh(3*nC,S) = (ii(nC)*dx)-(dx/2) + (dx/2)*((side_neigh(3*nC+2,S)-ibm_ht(ii(nC),ji(nC))) &
						        /(ibm_ht_xstag(ii(nC)+1,ji(nC))-ibm_ht(ii(nC),ji(nC))))
	     endif
	 elseif (stag == 3) then
	     !next y
	     side_neigh(3*nC+1,S) = (side_neigh_i(3*nC+1,S)*dy)-(dy/2)
	     ! solve for x
	     if (ibm_ht_xstag(ii(nC)+1,ji(nC)) >= side_neigh(3*nC+2,S)) then
		side_neigh(3*nC,S) = (ii(nC)*dx) + (dx/2)*((side_neigh(3*nC+2,S)-ibm_ht_xstag(ii(nC)+1,ji(nC))) &
						       /(ibm_ht(ii(nC)+1,ji(nC))-ibm_ht_xstag(ii(nC)+1,ji(nC))))
	     else
		side_neigh(3*nC,S) = (ii(nC)*dx)-(dx/2) + (dx/2)*((side_neigh(3*nC+2,S)-ibm_ht(ii(nC),ji(nC))) &
						        /(ibm_ht_xstag(ii(nC)+1,ji(nC))-ibm_ht(ii(nC),ji(nC))))
	     endif
	 endif
	 ! neighbors 1,3,5,7 are the zero computational nodes
	 nC = 5
	 side_neigh_i(3*nC,S) = ii(nC)
	 side_neigh_i(3*nC+1,S) = ji(nC)
	 side_neigh_i(3*nC+2,S) = ki(nC)		
	 if (stag ==1 ) then 			
	     side_neigh(3*nC,S) = (side_neigh_i(3*nC,S)*dx)-(dx)
	     side_neigh(3*nC+1,S) = (side_neigh_i(3*nC+1,S)*dy)-(dy/2)
	 elseif (stag == 2) then
	     side_neigh(3*nC,S) = (side_neigh_i(3*nC,S)*dx)-(dx/2)
	     side_neigh(3*nC+1,S) = (side_neigh_i(3*nC+1,S)*dy)-(dy)	     
	 elseif (stag == 3) then
	     side_neigh(3*nC,S) = (side_neigh_i(3*nC,S)*dx)-(dx/2)
	     side_neigh(3*nC+1,S) = (side_neigh_i(3*nC+1,S)*dy)-(dy/2)	     
	 endif
	 side_neigh(3*nC+2,S) = ht_p(side_neigh_i(3*nC,S),side_neigh_i(3*nC+2,S),side_neigh_i(3*nC+1,S))
	 ! neighbor 6 is on the boundary between 6 and 7
	 nC = 6
	 side_neigh_i(3*nC,S) = 0
	 side_neigh_i(3*nC+1,S) = ji(nC)
	 side_neigh_i(3*nC+2,S) = 0
	 ! first z
	 side_neigh(3*nC+2,S) = ht_p(ii(nC),ki(nC),ji(nC))
	 if (stag == 1) then
	     !next y
	     side_neigh(3*nC+1,S) = (side_neigh_i(3*nC+1,S)*dy)-(dy/2)
	     ! solve for x
	     if (ibm_ht_xstag(ii(nC),ji(nC)) >= side_neigh(3*nC+2,S)) then
		side_neigh(3*nC,S) = (ii(nC)*dx)-(dx/2) + (dx/2)*((side_neigh(3*nC+2,S)-ibm_ht_xstag(ii(nC),ji(nC))) &
						              /(ibm_ht(ii(nC)+1,ji(nC))-ibm_ht_xstag(ii(nC),ji(nC))))
	     else
		side_neigh(3*nC,S) = (ii(nC)*dx)-dx + (dx/2)*((side_neigh(3*nC+2,S)-ibm_ht(ii(nC),ji(nC))) &
						      /(ibm_ht_xstag(ii(nC),ji(nC))-ibm_ht(ii(nC),ji(nC))))
	     endif						  
	 elseif (stag == 2) then
	     !next y
	     side_neigh(3*nC+1,S) = (side_neigh_i(3*nC+1,S)*dy)-(dy)
	     ! solve for x
	     if (ibm_ht_xstag(ii(nC)+1,ji(nC)) >= side_neigh(3*nC+2,S)) then
		side_neigh(3*nC,S) = (ii(nC)*dx) + (dx/2)*((side_neigh(3*nC+2,S)-ibm_ht_xstag(ii(nC)+1,ji(nC))) &
						       /(ibm_ht(ii(nC)+1,ji(nC))-ibm_ht_xstag(ii(nC)+1,ji(nC))))
	     else
		side_neigh(3*nC,S) = (ii(nC)*dx)-(dx/2) + (dx/2)*((side_neigh(3*nC+2,S)-ibm_ht(ii(nC),ji(nC))) &
						        /(ibm_ht_xstag(ii(nC)+1,ji(nC))-ibm_ht(ii(nC),ji(nC))))
	     endif
	 elseif (stag == 3) then
	     !next y
	     side_neigh(3*nC+1,S) = (side_neigh_i(3*nC+1,S)*dy)-(dy/2)
	     ! solve for x
	     if (ibm_ht_xstag(ii(nC)+1,ji(nC)) >= side_neigh(3*nC+2,S)) then
		side_neigh(3*nC,S) = (ii(nC)*dx) + (dx/2)*((side_neigh(3*nC+2,S)-ibm_ht_xstag(ii(nC)+1,ji(nC))) &
						       /(ibm_ht(ii(nC)+1,ji(nC))-ibm_ht_xstag(ii(nC)+1,ji(nC))))
	     else
		side_neigh(3*nC,S) = (ii(nC)*dx)-(dx/2) + (dx/2)*((side_neigh(3*nC+2,S)-ibm_ht(ii(nC),ji(nC))) &
						        /(ibm_ht_xstag(ii(nC)+1,ji(nC))-ibm_ht(ii(nC),ji(nC))))
	     endif
	 endif
	 ! neighbors 1,3,5,7 are the zero computational nodes
	 nC = 7
	 side_neigh_i(3*nC,S) = ii(nC)
	 side_neigh_i(3*nC+1,S) = ji(nC)
	 side_neigh_i(3*nC+2,S) = ki(nC)		
	 if (stag ==1 ) then 			
	     side_neigh(3*nC,S) = (side_neigh_i(3*nC,S)*dx)-(dx)
	     side_neigh(3*nC+1,S) = (side_neigh_i(3*nC+1,S)*dy)-(dy/2)
	 elseif (stag == 2) then
	     side_neigh(3*nC,S) = (side_neigh_i(3*nC,S)*dx)-(dx/2)
	     side_neigh(3*nC+1,S) = (side_neigh_i(3*nC+1,S)*dy)-(dy)	     
	 elseif (stag == 3) then
	     side_neigh(3*nC,S) = (side_neigh_i(3*nC,S)*dx)-(dx/2)
	     side_neigh(3*nC+1,S) = (side_neigh_i(3*nC+1,S)*dy)-(dy/2)	     
	 endif
	 side_neigh(3*nC+2,S) = ht_p(side_neigh_i(3*nC,S),side_neigh_i(3*nC+2,S),side_neigh_i(3*nC+1,S))	
    ELSEIF ((inside(ii(0),ki(0),ji(0)) == 0).AND. &
	 (inside(ii(1),ki(1),ji(1)) == 1).AND. &
	 (inside(ii(2),ki(2),ji(2)) == 0).AND. &
	 (inside(ii(3),ki(3),ji(3)) == 1).AND. &
	 (inside(ii(4),ki(4),ji(4)) == 0).AND. &
	 (inside(ii(5),ki(5),ji(5)) == 1).AND. &
	 (inside(ii(6),ki(6),ji(6)) == 0).AND. &
	 (inside(ii(7),ki(7),ji(7)) == 1)) THEN	 
	 ! neighbors 0,2,4,6,are the zero computational nodes
	 nC = 0
	 side_neigh_i(3*nC,S) = ii(nC)
	 side_neigh_i(3*nC+1,S) = ji(nC)
	 side_neigh_i(3*nC+2,S) = ki(nC)		
	 if (stag ==1 ) then 			
	     side_neigh(3*nC,S) = (side_neigh_i(3*nC,S)*dx)-(dx)
	     side_neigh(3*nC+1,S) = (side_neigh_i(3*nC+1,S)*dy)-(dy/2)
	 elseif (stag == 2) then
	     side_neigh(3*nC,S) = (side_neigh_i(3*nC,S)*dx)-(dx/2)
	     side_neigh(3*nC+1,S) = (side_neigh_i(3*nC+1,S)*dy)-(dy)	     
	 elseif (stag == 3) then
	     side_neigh(3*nC,S) = (side_neigh_i(3*nC,S)*dx)-(dx/2)
	     side_neigh(3*nC+1,S) = (side_neigh_i(3*nC+1,S)*dy)-(dy/2)	     
	 endif
	 side_neigh(3*nC+2,S) = ht_p(side_neigh_i(3*nC,S),side_neigh_i(3*nC+2,S),side_neigh_i(3*nC+1,S)) 
	 ! neighbor 1 on the boundary between 0 and 1
	 nC = 1 
	 side_neigh_i(3*nC,S) = 0
	 side_neigh_i(3*nC+1,S) = ji(nC)
	 side_neigh_i(3*nC+2,S) = 0
	 ! first z
	 side_neigh(3*nC+2,S) = ht_p(ii(nC),ki(nC),ji(nC))
	 if (stag == 1) then
	     !next y
	     side_neigh(3*nC+1,S) = (side_neigh_i(3*nC+1,S)*dy)-(dy/2)
	     ! solve for x
	     if (ibm_ht_xstag(ii(nC)-1,ji(nC)) >= side_neigh(3*nC+2,S)) then
		side_neigh(3*nC,S) = ((ii(nC)-1)*dx)-dx + (dx/2)*((side_neigh(3*nC+2,S)-ibm_ht(ii(nC)-1,ji(nC))) &
						        /(ibm_ht_xstag(ii(nC)-1,ji(nC))-ibm_ht(ii(nC)-1,ji(nC))))
	     else
		side_neigh(3*nC,S) = ((ii(nC)-1)*dx)-(dx/2) + (dx/2)*((side_neigh(3*nC+2,S)-ibm_ht_xstag(ii(nC)-1,ji(nC))) &
							            /(ibm_ht(ii(nC),ji(nC))-ibm_ht_xstag(ii(nC)-1,ji(nC))))
	     endif						  
	 elseif (stag == 2) then
	     !next y
	     side_neigh(3*nC+1,S) = (side_neigh_i(3*nC+1,S)*dy)-(dy)
	     ! solve for x
	     if (ibm_ht_xstag(ii(nC),ji(nC)) >= side_neigh(3*nC+2,S)) then
		side_neigh(3*nC,S) = ((ii(nC)-1)*dx)-(dx/2) + (dx/2)*((side_neigh(3*nC+2,S)-ibm_ht(ii(nC)-1,ji(nC))) &
						              /(ibm_ht_xstag(ii(nC),ji(nC))-ibm_ht(ii(nC)-1,ji(nC))))
	     else
		side_neigh(3*nC,S) = (ii(nC)*dx)-dx + (dx/2)*((side_neigh(3*nC+2,S)-ibm_ht_xstag(ii(nC),ji(nC))) &
						            /(ibm_ht(ii(nC),ji(nC))-ibm_ht_xstag(ii(nC),ji(nC))))
	     endif
	 elseif (stag == 3) then
	     !next y
	     side_neigh(3*nC+1,S) = (side_neigh_i(3*nC+1,S)*dy)-(dy/2)
	     ! solve for x
	     if (ibm_ht_xstag(ii(nC),ji(nC)) >= side_neigh(3*nC+2,S)) then
		side_neigh(3*nC,S) = ((ii(nC)-1)*dx)-(dx/2) + (dx/2)*((side_neigh(3*nC+2,S)-ibm_ht(ii(nC)-1,ji(nC))) &
						              /(ibm_ht_xstag(ii(nC),ji(nC))-ibm_ht(ii(nC)-1,ji(nC))))
	     else
		side_neigh(3*nC,S) = (ii(nC)*dx)-dx + (dx/2)*((side_neigh(3*nC+2,S)-ibm_ht_xstag(ii(nC),ji(nC))) &
						            /(ibm_ht(ii(nC),ji(nC))-ibm_ht_xstag(ii(nC),ji(nC))))
	     endif
	 endif
	 ! neighbors 0,2,4,6,are the zero computational nodes
	 nC = 2
	 side_neigh_i(3*nC,S) = ii(nC)
	 side_neigh_i(3*nC+1,S) = ji(nC)
	 side_neigh_i(3*nC+2,S) = ki(nC)		
	 if (stag ==1 ) then 			
	     side_neigh(3*nC,S) = (side_neigh_i(3*nC,S)*dx)-(dx)
	     side_neigh(3*nC+1,S) = (side_neigh_i(3*nC+1,S)*dy)-(dy/2)
	 elseif (stag == 2) then
	     side_neigh(3*nC,S) = (side_neigh_i(3*nC,S)*dx)-(dx/2)
	     side_neigh(3*nC+1,S) = (side_neigh_i(3*nC+1,S)*dy)-(dy)	     
	 elseif (stag == 3) then
	     side_neigh(3*nC,S) = (side_neigh_i(3*nC,S)*dx)-(dx/2)
	     side_neigh(3*nC+1,S) = (side_neigh_i(3*nC+1,S)*dy)-(dy/2)	     
	 endif
	 side_neigh(3*nC+2,S) = ht_p(side_neigh_i(3*nC,S),side_neigh_i(3*nC+2,S),side_neigh_i(3*nC+1,S)) 
	 ! neighbor 3 on the boundary between 3 and 2
	 nC = 3 
	 side_neigh_i(3*nC,S) = 0
	 side_neigh_i(3*nC+1,S) = ji(nC)
	 side_neigh_i(3*nC+2,S) = 0
	 ! first z
	 side_neigh(3*nC+2,S) = ht_p(ii(nC),ki(nC),ji(nC))
	 if (stag == 1) then
	     !next y
	     side_neigh(3*nC+1,S) = (side_neigh_i(3*nC+1,S)*dy)-(dy/2)
	     ! solve for x
	     if (ibm_ht_xstag(ii(nC)-1,ji(nC)) >= side_neigh(3*nC+2,S)) then
		side_neigh(3*nC,S) = ((ii(nC)-1)*dx)-dx + (dx/2)*((side_neigh(3*nC+2,S)-ibm_ht(ii(nC)-1,ji(nC))) &
						        /(ibm_ht_xstag(ii(nC)-1,ji(nC))-ibm_ht(ii(nC)-1,ji(nC))))
	     else
		side_neigh(3*nC,S) = ((ii(nC)-1)*dx)-(dx/2) + (dx/2)*((side_neigh(3*nC+2,S)-ibm_ht_xstag(ii(nC)-1,ji(nC))) &
							            /(ibm_ht(ii(nC),ji(nC))-ibm_ht_xstag(ii(nC)-1,ji(nC))))
	     endif						  
	 elseif (stag == 2) then
	     !next y
	     side_neigh(3*nC+1,S) = (side_neigh_i(3*nC+1,S)*dy)-(dy)
	     ! solve for x
	     if (ibm_ht_xstag(ii(nC),ji(nC)) >= side_neigh(3*nC+2,S)) then
		side_neigh(3*nC,S) = ((ii(nC)-1)*dx)-(dx/2) + (dx/2)*((side_neigh(3*nC+2,S)-ibm_ht(ii(nC)-1,ji(nC))) &
						              /(ibm_ht_xstag(ii(nC),ji(nC))-ibm_ht(ii(nC)-1,ji(nC))))
	     else
		side_neigh(3*nC,S) = (ii(nC)*dx)-dx + (dx/2)*((side_neigh(3*nC+2,S)-ibm_ht_xstag(ii(nC),ji(nC))) &
						            /(ibm_ht(ii(nC),ji(nC))-ibm_ht_xstag(ii(nC),ji(nC))))
	     endif
	 elseif (stag == 3) then
	     !next y
	     side_neigh(3*nC+1,S) = (side_neigh_i(3*nC+1,S)*dy)-(dy/2)
	     ! solve for x
	     if (ibm_ht_xstag(ii(nC),ji(nC)) >= side_neigh(3*nC+2,S)) then
		side_neigh(3*nC,S) = ((ii(nC)-1)*dx)-(dx/2) + (dx/2)*((side_neigh(3*nC+2,S)-ibm_ht(ii(nC)-1,ji(nC))) &
						              /(ibm_ht_xstag(ii(nC),ji(nC))-ibm_ht(ii(nC)-1,ji(nC))))
	     else
		side_neigh(3*nC,S) = (ii(nC)*dx)-dx + (dx/2)*((side_neigh(3*nC+2,S)-ibm_ht_xstag(ii(nC),ji(nC))) &
						            /(ibm_ht(ii(nC),ji(nC))-ibm_ht_xstag(ii(nC),ji(nC))))
	     endif
	 endif
	 ! neighbors 0,2,4,6,are the zero computational nodes
	 nC = 4
	 side_neigh_i(3*nC,S) = ii(nC)
	 side_neigh_i(3*nC+1,S) = ji(nC)
	 side_neigh_i(3*nC+2,S) = ki(nC)		
	 if (stag ==1 ) then 			
	     side_neigh(3*nC,S) = (side_neigh_i(3*nC,S)*dx)-(dx)
	     side_neigh(3*nC+1,S) = (side_neigh_i(3*nC+1,S)*dy)-(dy/2)
	 elseif (stag == 2) then
	     side_neigh(3*nC,S) = (side_neigh_i(3*nC,S)*dx)-(dx/2)
	     side_neigh(3*nC+1,S) = (side_neigh_i(3*nC+1,S)*dy)-(dy)	     
	 elseif (stag == 3) then
	     side_neigh(3*nC,S) = (side_neigh_i(3*nC,S)*dx)-(dx/2)
	     side_neigh(3*nC+1,S) = (side_neigh_i(3*nC+1,S)*dy)-(dy/2)	     
	 endif
	 side_neigh(3*nC+2,S) = ht_p(side_neigh_i(3*nC,S),side_neigh_i(3*nC+2,S),side_neigh_i(3*nC+1,S)) 
	 ! neighbor 5 on the boundary between 5 and 4
	 nC = 5 
	 side_neigh_i(3*nC,S) = 0
	 side_neigh_i(3*nC+1,S) = ji(nC)
	 side_neigh_i(3*nC+2,S) = 0
	 ! first z
	 side_neigh(3*nC+2,S) = ht_p(ii(nC),ki(nC),ji(nC))
	 if (stag == 1) then
	     !next y
	     side_neigh(3*nC+1,S) = (side_neigh_i(3*nC+1,S)*dy)-(dy/2)
	     ! solve for x
	     if (ibm_ht_xstag(ii(nC)-1,ji(nC)) >= side_neigh(3*nC+2,S)) then
		side_neigh(3*nC,S) = ((ii(nC)-1)*dx)-dx + (dx/2)*((side_neigh(3*nC+2,S)-ibm_ht(ii(nC)-1,ji(nC))) &
						        /(ibm_ht_xstag(ii(nC)-1,ji(nC))-ibm_ht(ii(nC)-1,ji(nC))))
	     else
		side_neigh(3*nC,S) = ((ii(nC)-1)*dx)-(dx/2) + (dx/2)*((side_neigh(3*nC+2,S)-ibm_ht_xstag(ii(nC)-1,ji(nC))) &
							            /(ibm_ht(ii(nC),ji(nC))-ibm_ht_xstag(ii(nC)-1,ji(nC))))
	     endif						  
	 elseif (stag == 2) then
	     !next y
	     side_neigh(3*nC+1,S) = (side_neigh_i(3*nC+1,S)*dy)-(dy)
	     ! solve for x
	     if (ibm_ht_xstag(ii(nC),ji(nC)) >= side_neigh(3*nC+2,S)) then
		side_neigh(3*nC,S) = ((ii(nC)-1)*dx)-(dx/2) + (dx/2)*((side_neigh(3*nC+2,S)-ibm_ht(ii(nC)-1,ji(nC))) &
						              /(ibm_ht_xstag(ii(nC),ji(nC))-ibm_ht(ii(nC)-1,ji(nC))))
	     else
		side_neigh(3*nC,S) = (ii(nC)*dx)-dx + (dx/2)*((side_neigh(3*nC+2,S)-ibm_ht_xstag(ii(nC),ji(nC))) &
						            /(ibm_ht(ii(nC),ji(nC))-ibm_ht_xstag(ii(nC),ji(nC))))
	     endif
	 elseif (stag == 3) then
	     !next y
	     side_neigh(3*nC+1,S) = (side_neigh_i(3*nC+1,S)*dy)-(dy/2)
	     ! solve for x
	     if (ibm_ht_xstag(ii(nC),ji(nC)) >= side_neigh(3*nC+2,S)) then
		side_neigh(3*nC,S) = ((ii(nC)-1)*dx)-(dx/2) + (dx/2)*((side_neigh(3*nC+2,S)-ibm_ht(ii(nC)-1,ji(nC))) &
						              /(ibm_ht_xstag(ii(nC),ji(nC))-ibm_ht(ii(nC)-1,ji(nC))))
	     else
		side_neigh(3*nC,S) = (ii(nC)*dx)-dx + (dx/2)*((side_neigh(3*nC+2,S)-ibm_ht_xstag(ii(nC),ji(nC))) &
						            /(ibm_ht(ii(nC),ji(nC))-ibm_ht_xstag(ii(nC),ji(nC))))
	     endif
	 endif
	 ! neighbors 0,2,4,6,are the zero computational nodes
	 nC = 6
	 side_neigh_i(3*nC,S) = ii(nC)
	 side_neigh_i(3*nC+1,S) = ji(nC)
	 side_neigh_i(3*nC+2,S) = ki(nC)		
	 if (stag ==1 ) then 			
	     side_neigh(3*nC,S) = (side_neigh_i(3*nC,S)*dx)-(dx)
	     side_neigh(3*nC+1,S) = (side_neigh_i(3*nC+1,S)*dy)-(dy/2)
	 elseif (stag == 2) then
	     side_neigh(3*nC,S) = (side_neigh_i(3*nC,S)*dx)-(dx/2)
	     side_neigh(3*nC+1,S) = (side_neigh_i(3*nC+1,S)*dy)-(dy)	     
	 elseif (stag == 3) then
	     side_neigh(3*nC,S) = (side_neigh_i(3*nC,S)*dx)-(dx/2)
	     side_neigh(3*nC+1,S) = (side_neigh_i(3*nC+1,S)*dy)-(dy/2)	     
	 endif
	 side_neigh(3*nC+2,S) = ht_p(side_neigh_i(3*nC,S),side_neigh_i(3*nC+2,S),side_neigh_i(3*nC+1,S)) 	 	 
	 ! neighbor 7 on the boundary between 7 and 6
	 nC = 7
	 side_neigh_i(3*nC,S) = 0
	 side_neigh_i(3*nC+1,S) = ji(nC)
	 side_neigh_i(3*nC+2,S) = 0
	 ! first z
	 side_neigh(3*nC+2,S) = ht_p(ii(nC),ki(nC),ji(nC))
	 if (stag == 1) then
	     !next y
	     side_neigh(3*nC+1,S) = (side_neigh_i(3*nC+1,S)*dy)-(dy/2)
	     ! solve for x
	     if (ibm_ht_xstag(ii(nC)-1,ji(nC)) >= side_neigh(3*nC+2,S)) then
		side_neigh(3*nC,S) = ((ii(nC)-1)*dx)-dx + (dx/2)*((side_neigh(3*nC+2,S)-ibm_ht(ii(nC)-1,ji(nC))) &
						        /(ibm_ht_xstag(ii(nC)-1,ji(nC))-ibm_ht(ii(nC)-1,ji(nC))))
	     else
		side_neigh(3*nC,S) = ((ii(nC)-1)*dx)-(dx/2) + (dx/2)*((side_neigh(3*nC+2,S)-ibm_ht_xstag(ii(nC)-1,ji(nC))) &
							            /(ibm_ht(ii(nC),ji(nC))-ibm_ht_xstag(ii(nC)-1,ji(nC))))
	     endif						  
	 elseif (stag == 2) then
	     !next y
	     side_neigh(3*nC+1,S) = (side_neigh_i(3*nC+1,S)*dy)-(dy)
	     ! solve for x
	     if (ibm_ht_xstag(ii(nC),ji(nC)) >= side_neigh(3*nC+2,S)) then
		side_neigh(3*nC,S) = ((ii(nC)-1)*dx)-(dx/2) + (dx/2)*((side_neigh(3*nC+2,S)-ibm_ht(ii(nC)-1,ji(nC))) &
						              /(ibm_ht_xstag(ii(nC),ji(nC))-ibm_ht(ii(nC)-1,ji(nC))))
	     else
		side_neigh(3*nC,S) = (ii(nC)*dx)-dx + (dx/2)*((side_neigh(3*nC+2,S)-ibm_ht_xstag(ii(nC),ji(nC))) &
						            /(ibm_ht(ii(nC),ji(nC))-ibm_ht_xstag(ii(nC),ji(nC))))
	     endif
	 elseif (stag == 3) then
	     !next y
	     side_neigh(3*nC+1,S) = (side_neigh_i(3*nC+1,S)*dy)-(dy/2)
	     ! solve for x
	     if (ibm_ht_xstag(ii(nC),ji(nC)) >= side_neigh(3*nC+2,S)) then
		side_neigh(3*nC,S) = ((ii(nC)-1)*dx)-(dx/2) + (dx/2)*((side_neigh(3*nC+2,S)-ibm_ht(ii(nC)-1,ji(nC))) &
						              /(ibm_ht_xstag(ii(nC),ji(nC))-ibm_ht(ii(nC)-1,ji(nC))))
	     else
		side_neigh(3*nC,S) = (ii(nC)*dx)-dx + (dx/2)*((side_neigh(3*nC+2,S)-ibm_ht_xstag(ii(nC),ji(nC))) &
						            /(ibm_ht(ii(nC),ji(nC))-ibm_ht_xstag(ii(nC),ji(nC))))
	     endif
	 endif	
    ELSEIF ((inside(ii(0),ki(0),ji(0)) == 1).AND. &
	(inside(ii(1),ki(1),ji(1)) == 1).AND. &
	(inside(ii(2),ki(2),ji(2)) == 1).AND. &
	(inside(ii(3),ki(3),ji(3)) == 1).AND. &
	(inside(ii(4),ki(4),ji(4)) == 0).AND. &
	(inside(ii(5),ki(5),ji(5)) == 0).AND. &
	(inside(ii(6),ki(6),ji(6)) == 0).AND. &
	(inside(ii(7),ki(7),ji(7)) == 0)) THEN
	! neighbor 0 is on the boundary between 0 and 4
	! neighbor 1 is on the boundary between 1 and 5 
	! neighbor 2 is on the boundary between 2 and 6
	! neighbor 3 is on the boundary between 3 and 7
	do nC = 0,3
	   side_neigh_i(3*nC,S) = ii(nC)
	   side_neigh_i(3*nC+1,S) = 0
	   side_neigh_i(3*nC+2,S) = 0
	   ! first z
	   side_neigh(3*nC+2,S) = ht_p(ii(nC),ki(nC),ji(nC))
	   if (stag == 1) then
	       !next x
	       side_neigh(3*nC,S) = (side_neigh_i(3*nC,S)*dx)-(dx)
	       ! solve for y
	       if (ibm_ht_ystag(ii(nC),ji(nC)+1) >= side_neigh(3*nC+2,S)) then
		  side_neigh(3*nC+1,S) = (ji(nC)*dy) + (dy/2)*((side_neigh(3*nC+2,S)-ibm_ht_ystag(ii(nC),ji(nC)+1)) &
						           /(ibm_ht(ii(nC),ji(nC)+1)-ibm_ht_ystag(ii(nC),ji(nC)+1)))
	       else
		  side_neigh(3*nC+1,S) = (ji(nC)*dy)-(dy/2) + (dy/2)*((side_neigh(3*nC+2,S)-ibm_ht(ii(nC),ji(nC))) &
						            /(ibm_ht_ystag(ii(nC),ji(nC)+1)-ibm_ht(ii(nC),ji(nC))))
	       endif						  
	   elseif (stag == 2) then
	       !next x
	       side_neigh(3*nC,S) = (side_neigh_i(3*nC,S)*dx)-(dx/2)
	       ! solve for y
	       if (ibm_ht_ystag(ii(nC),ji(nC)) >= side_neigh(3*nC+2,S)) then
		  side_neigh(3*nC+1,S) = (ji(nC)*dy-(dy/2)) + (dy/2)*((side_neigh(3*nC+2,S)-ibm_ht_ystag(ii(nC),ji(nC))) &
						                  /(ibm_ht(ii(nC),ji(nC)+1)-ibm_ht_ystag(ii(nC),ji(nC))))
	       else
		  side_neigh(3*nC+1,S) = (ji(nC)*dy)-dy + (dy/2)*((side_neigh(3*nC+2,S)-ibm_ht(ii(nC),ji(nC))) &
						          /(ibm_ht_ystag(ii(nC),ji(nC))-ibm_ht(ii(nC),ji(nC))))
	       endif
	   elseif (stag == 3) then
	       !next x
	       side_neigh(3*nC,S) = (side_neigh_i(3*nC,S)*dx)-(dx/2)
	       ! solve for y
	       if (ibm_ht_ystag(ii(nC),ji(nC)+1) >= side_neigh(3*nC+2,S)) then
		  side_neigh(3*nC+1,S) = (ji(nC)*dy) + (dy/2)*((side_neigh(3*nC+2,S)-ibm_ht_ystag(ii(nC),ji(nC)+1)) &
						           /(ibm_ht(ii(nC),ji(nC)+1)-ibm_ht_ystag(ii(nC),ji(nC)+1)))
	       else
		  side_neigh(3*nC+1,S) = (ji(nC)*dy)-(dy/2) + (dy/2)*((side_neigh(3*nC+2,S)-ibm_ht(ii(nC),ji(nC))) &
							    /(ibm_ht_ystag(ii(nC),ji(nC)+1)-ibm_ht(ii(nC),ji(nC))))
	       endif	
	   endif
	 enddo 		
	 ! neighbors 4,5,6,7 are the zero computational nodes
	 do nC = 4,7
	    side_neigh_i(3*nC,S) = ii(nC)
	    side_neigh_i(3*nC+1,S) = ji(nC)
	    side_neigh_i(3*nC+2,S) = ki(nC)		
	    if (stag ==1 ) then 			
		side_neigh(3*nC,S) = (side_neigh_i(3*nC,S)*dx)-(dx)
		side_neigh(3*nC+1,S) = (side_neigh_i(3*nC+1,S)*dy)-(dy/2)
	    elseif (stag == 2) then
		side_neigh(3*nC,S) = (side_neigh_i(3*nC,S)*dx)-(dx/2)
		side_neigh(3*nC+1,S) = (side_neigh_i(3*nC+1,S)*dy)-(dy)	     
	    elseif (stag == 3) then
		side_neigh(3*nC,S) = (side_neigh_i(3*nC,S)*dx)-(dx/2)
		side_neigh(3*nC+1,S) = (side_neigh_i(3*nC+1,S)*dy)-(dy/2)	     
	    endif
	    side_neigh(3*nC+2,S) = ht_p(side_neigh_i(3*nC,S),side_neigh_i(3*nC+2,S),side_neigh_i(3*nC+1,S))  
	 enddo
    ELSEIF ((inside(ii(0),ki(0),ji(0)) == 0).AND. &
	(inside(ii(1),ki(1),ji(1)) == 0).AND. &
	(inside(ii(2),ki(2),ji(2)) == 0).AND. &
	(inside(ii(3),ki(3),ji(3)) == 0).AND. &
	(inside(ii(4),ki(4),ji(4)) == 1).AND. &
	(inside(ii(5),ki(5),ji(5)) == 1).AND. &
	(inside(ii(6),ki(6),ji(6)) == 1).AND. &
	(inside(ii(7),ki(7),ji(7)) == 1)) THEN
	 ! neighbors 0,1,2,3 are the zero computational nodes
	 do nC = 0,3
	    side_neigh_i(3*nC,S) = ii(nC)
	    side_neigh_i(3*nC+1,S) = ji(nC)
	    side_neigh_i(3*nC+2,S) = ki(nC)		
	    if (stag ==1 ) then 			
		side_neigh(3*nC,S) = (side_neigh_i(3*nC,S)*dx)-(dx)
		side_neigh(3*nC+1,S) = (side_neigh_i(3*nC+1,S)*dy)-(dy/2)
	    elseif (stag == 2) then
		side_neigh(3*nC,S) = (side_neigh_i(3*nC,S)*dx)-(dx/2)
		side_neigh(3*nC+1,S) = (side_neigh_i(3*nC+1,S)*dy)-(dy)	     
	    elseif (stag == 3) then
		side_neigh(3*nC,S) = (side_neigh_i(3*nC,S)*dx)-(dx/2)
		side_neigh(3*nC+1,S) = (side_neigh_i(3*nC+1,S)*dy)-(dy/2)	     
	    endif
	    side_neigh(3*nC+2,S) = ht_p(side_neigh_i(3*nC,S),side_neigh_i(3*nC+2,S),side_neigh_i(3*nC+1,S))  
	 enddo
	 ! neighbor 4 is on the boundary between 4 and 0
	 ! neighbor 5 is on the boundary between 5 and 1
         ! neighbor 6 is on the boundary between 6 and 2
	 ! neighbor 7 is on the boundary between 7 and 3	 
	 do nC = 4,7
	    side_neigh_i(3*nC,S) = ii(nC)
	    side_neigh_i(3*nC+1,S) = 0
	    side_neigh_i(3*nC+2,S) = 0
	    ! first z
	    side_neigh(3*nC+2,S) = ht_p(ii(nC),ki(nC),ji(nC))
	    if (stag == 1) then
		!next x
		side_neigh(3*nC,S) = (side_neigh_i(3*nC,S)*dx)-(dx)
		! solve for y
		if (ibm_ht_ystag(ii(nC),ji(nC)) >= side_neigh(3*nC+2,S)) then
		   side_neigh(3*nC+1,S) = ((ji(nC)-1)*dy)-(dy/2) + (dy/2)*((side_neigh(3*nC+2,S)-ibm_ht(ii(nC),ji(nC)-1)) &
						                   /(ibm_ht_ystag(ii(nC),ji(nC))-ibm_ht(ii(nC),ji(nC)-1)))
		else
		   side_neigh(3*nC+1,S) = (ji(nC)*dy)-dy + (dy/2)*((side_neigh(3*nC+2,S)-ibm_ht_ystag(ii(nC),ji(nC))) &
							         /(ibm_ht(ii(nC),ji(nC))-ibm_ht_ystag(ii(nC),ji(nC))))
		endif						  
	    elseif (stag == 2) then
		!next x
		side_neigh(3*nC,S) = (side_neigh_i(3*nC,S)*dx)-(dx/2)
		! solve for y
		if (ibm_ht_ystag(ii(nC),ji(nC)-1) >= side_neigh(3*nC+2,S)) then
		   side_neigh(3*nC+1,S) = ((ji(nC)-1)*dy)-dy + (dy/2)*((side_neigh(3*nC+2,S)-ibm_ht(ii(nC),ji(nC)-1)) &
						             /(ibm_ht_ystag(ii(nC),ji(nC)-1)-ibm_ht(ii(nC),ji(nC)-1)))
		else
		   side_neigh(3*nC+1,S) = ((ji(nC)-1)*dy)-(dy/2) + (dy/2)*((side_neigh(3*nC+2,S)-ibm_ht_ystag(ii(nC),ji(nC)-1)) &
						                         /(ibm_ht(ii(nC),ji(nC))-ibm_ht_ystag(ii(nC),ji(nC)-1)))
		endif
	    elseif (stag == 3) then
		!next x
		side_neigh(3*nC,S) = (side_neigh_i(3*nC,S)*dx)-(dx/2)
		! solve for y
		if (ibm_ht_ystag(ii(nC),ji(nC)) >= side_neigh(3*nC+2,S)) then
		   side_neigh(3*nC+1,S) = ((ji(nC)-1)*dy)-(dy/2) + (dy/2)*((side_neigh(3*nC+2,S)-ibm_ht(ii(nC),ji(nC)-1)) &
						                   /(ibm_ht_ystag(ii(nC),ji(nC))-ibm_ht(ii(nC),ji(nC)-1)))
		else
		   side_neigh(3*nC+1,S) = (ji(nC)*dy)-dy + (dy/2)*((side_neigh(3*nC+2,S)-ibm_ht_ystag(ii(nC),ji(nC))) &
							         /(ibm_ht(ii(nC),ji(nC))-ibm_ht_ystag(ii(nC),ji(nC))))
		endif
	    endif
	 enddo
    ELSE		   
         ! store the neighbors
	 DO nC=0,n-1
	    side_neigh_i(3*nC,S) = ii(nC)
	    side_neigh_i(3*nC+1,S) = ji(nC)
	    side_neigh_i(3*nC+2,S) = ki(nC)
	    if (stag ==1 ) then			
	       side_neigh(3*nC,S) = (side_neigh_i(3*nC,S)*dx)-(dx)
	       side_neigh(3*nC+1,S) = (side_neigh_i(3*nC+1,S)*dy)-(dy/2)
	    elseif (stag == 2) then
	       side_neigh(3*nC,S) = (side_neigh_i(3*nC,S)*dx)-(dx/2)
	       side_neigh(3*nC+1,S) = (side_neigh_i(3*nC+1,S)*dy)-(dy)       
	    elseif (stag == 3) then
	       side_neigh(3*nC,S) = (side_neigh_i(3*nC,S)*dx)-(dx/2)
	       side_neigh(3*nC+1,S) = (side_neigh_i(3*nC+1,S)*dy)-(dy/2)	     
	    endif
	    side_neigh(3*nC+2,S) = ht_p(side_neigh_i(3*nC,S),side_neigh_i(3*nC+2,S),side_neigh_i(3*nC+1,S))
	 ENDDO
!         write(*,'((A),1i5,(A),1i5,(A),9i4)') 'S=',S,'for stag =',stag,'for bc =', bc_type,         &
!	                                       inside(ii(0),ki(0),ji(0)),inside(ii(1),ki(1),ji(1)), &
!                                               inside(ii(2),ki(2),ji(2)),inside(ii(3),ki(3),ji(3)), &
!					       inside(ii(4),ki(4),ji(4)),inside(ii(5),ki(5),ji(5)), &
!     					       inside(ii(6),ki(6),ji(6)),inside(ii(7),ki(7),ji(7))
    ENDIF   
 ENDDO
   
   ! make the image coord the origin (x,y,z,)=(0,0,0)
   DO S=1,np
   DO nC=0,n-1
      side_neigh(3*nC,S) = side_neigh(3*nC,S)-side_img(4,S)
      side_neigh(3*nC+1,S) = side_neigh(3*nC+1,S)-side_img(5,S)
      side_neigh(3*nC+2,S) = side_neigh(3*nC+2,S)-side_img(6,S)     
   ENDDO
   ENDDO
   
   !! make the ghost point coord the origin (x,y,z,)=(0,0,0)
   ! DO S=1,np
   ! DO nC=0,n-1
   !    side_neigh(3*nC,S) = side_neigh(3*nC,S)-side_img(1,S)
   !    side_neigh(3*nC+1,S) = side_neigh(3*nC+1,S)-side_img(2,S)
   !    side_neigh(3*nC+2,S) = side_neigh(3*nC+2,S)-side_img(3,S)     
   ! ENDDO
   ! ENDDO    

 END SUBROUTINE get_side_pts_3d

!------------------------------------------------------------------------------------ 

 SUBROUTINE lagrange_extrap(img_ht_p,ibm_ht_p,i_p,ph_p,vel_p,RHS_p, &
                           ims,ime,jms,jme,kms,kme)
    IMPLICIT NONE
    !input data
    REAL, INTENT(IN   )                                     :: img_ht_p,&
                                                               ibm_ht_p
    INTEGER, DIMENSION(3), INTENT(IN   )                    :: i_p
    REAL, DIMENSION(ims:ime,kms:kme,jms:jme), INTENT(IN   ) :: ph_p,   &
                                                               vel_p
    REAL, INTENT(  OUT)                                     :: RHS_p							       
    INTEGER                                                 :: ims,ime,&
                                                               jms,jme,&
							       kms,kme
    !local data
    REAL, DIMENSION(3)                                      :: l_coef, ht_p
    REAL                                                    :: surf_ht
 !--------------------------------------------------------------------------------
 ! the executable begins here
 ! this subroutine
 ! print *, 'dyn_em/module_ibm.F/subroutine lagrange_extrap'
 !-------------------------------------------------------------------------------- 
  
 surf_ht = img_ht_p + ibm_ht_p
 
 ht_p(1) = ph_p(i_p(1),i_p(3),i_p(2))
 ht_p(2) = ph_p(i_p(1),i_p(3)+1,i_p(2))
 ht_p(3) = ph_p(i_p(1),i_p(3)+2,i_p(2))
 
 l_coef(1) = ((surf_ht-ht_p(2))*(surf_ht-ht_p(3)))/((ht_p(1)-ht_p(2))*(ht_p(1)-ht_p(3)))
 l_coef(2) = ((surf_ht-ht_p(1))*(surf_ht-ht_p(3)))/((ht_p(2)-ht_p(1))*(ht_p(2)-ht_p(3)))
 l_coef(3) = ((surf_ht-ht_p(1))*(surf_ht-ht_p(2)))/((ht_p(3)-ht_p(1))*(ht_p(3)-ht_p(2)))
 
 RHS_p = l_coef(1)*vel_p(i_p(1),i_p(3),i_p(2))    &
       + l_coef(2)*vel_p(i_p(1),i_p(3)+1,i_p(2))  &
       + l_coef(3)*vel_p(i_p(1),i_p(3)+2,i_p(2))

 END SUBROUTINE lagrange_extrap
 
!--------------------------------------------------------------------------------------------------- 
Subroutine rnkpar (XDONT, IRNGT, NORD)
!  Ranks partially XDONT by IRNGT, up to order NORD
! __________________________________________________________
!  This routine uses a pivoting strategy such as the one of
!  finding the median based on the quicksort algorithm, but
!  we skew the pivot choice to try to bring it to NORD as
!  fast as possible. It uses 2 temporary arrays, where it
!  stores the indices of the values smaller than the pivot
!  (ILOWT), and the indices of values larger than the pivot
!  that we might still need later on (IHIGT). It iterates
!  until it can bring the number of values in ILOWT to
!  exactly NORD, and then uses an insertion sort to rank
!  this set, since it is supposedly small.
!  Michel Olagnon - Feb. 2000
! __________________________________________________________
! _________________________________________________________
      Real, Dimension (:), Intent (In) :: XDONT
      Integer, Dimension (:), Intent (Out) :: IRNGT
      Integer, Intent (In) :: NORD
! __________________________________________________________
      Real    :: XPIV, XPIV0, XWRK, XWRK1, XMIN, XMAX
!
      Integer, Dimension (SIZE(XDONT)) :: ILOWT, IHIGT
      Integer :: NDON, JHIG, JLOW, IHIG, IWRK, IWRK1, IWRK2, IWRK3
      Integer :: IDEB, JDEB, IMIL, IFIN, NWRK, ICRS, IDCR, ILOW
      Integer :: JLM2, JLM1, JHM2, JHM1
!
      NDON = SIZE (XDONT)
!
!    First loop is used to fill-in ILOWT, IHIGT at the same time
!
      If (NDON < 2) Then
         If (NORD >= 1) IRNGT (1) = 1
         Return
      End If
!
!  One chooses a pivot, best estimate possible to put fractile near
!  mid-point of the set of low values.
!
      If (XDONT(2) < XDONT(1)) Then
         ILOWT (1) = 2
         IHIGT (1) = 1
      Else
         ILOWT (1) = 1
         IHIGT (1) = 2
      End If
!
      If (NDON < 3) Then
         If (NORD >= 1) IRNGT (1) = ILOWT (1)
         If (NORD >= 2) IRNGT (2) = IHIGT (1)
         Return
      End If
!
      If (XDONT(3) < XDONT(IHIGT(1))) Then
         IHIGT (2) = IHIGT (1)
         If (XDONT(3) < XDONT(ILOWT(1))) Then
            IHIGT (1) = ILOWT (1)
            ILOWT (1) = 3
         Else
            IHIGT (1) = 3
         End If
      Else
         IHIGT (2) = 3
      End If
!
      If (NDON < 4) Then
         If (NORD >= 1) IRNGT (1) = ILOWT (1)
         If (NORD >= 2) IRNGT (2) = IHIGT (1)
         If (NORD >= 3) IRNGT (3) = IHIGT (2)
         Return
      End If
!
      If (XDONT(NDON) < XDONT(IHIGT(1))) Then
         IHIGT (3) = IHIGT (2)
         IHIGT (2) = IHIGT (1)
         If (XDONT(NDON) < XDONT(ILOWT(1))) Then
            IHIGT (1) = ILOWT (1)
            ILOWT (1) = NDON
         Else
            IHIGT (1) = NDON
         End If
      Else
         IHIGT (3) = NDON
      End If
!
      If (NDON < 5) Then
         If (NORD >= 1) IRNGT (1) = ILOWT (1)
         If (NORD >= 2) IRNGT (2) = IHIGT (1)
         If (NORD >= 3) IRNGT (3) = IHIGT (2)
         If (NORD >= 4) IRNGT (4) = IHIGT (3)
         Return
      End If
!
      JDEB = 0
      IDEB = JDEB + 1
      JLOW = IDEB
      JHIG = 3
      XPIV = XDONT (ILOWT(IDEB)) + REAL(2*NORD)/REAL(NDON+NORD) * &
                                   (XDONT(IHIGT(3))-XDONT(ILOWT(IDEB)))
      If (XPIV >= XDONT(IHIGT(1))) Then
         XPIV = XDONT (ILOWT(IDEB)) + REAL(2*NORD)/REAL(NDON+NORD) * &
                                      (XDONT(IHIGT(2))-XDONT(ILOWT(IDEB)))
         If (XPIV >= XDONT(IHIGT(1))) &
             XPIV = XDONT (ILOWT(IDEB)) + REAL (2*NORD) / REAL (NDON+NORD) * &
                                          (XDONT(IHIGT(1))-XDONT(ILOWT(IDEB)))
      End If
      XPIV0 = XPIV
!
!  One puts values > pivot in the end and those <= pivot
!  at the beginning. This is split in 2 cases, so that
!  we can skip the loop test a number of times.
!  As we are also filling in the work arrays at the same time
!  we stop filling in the IHIGT array as soon as we have more
!  than enough values in ILOWT.
!
!
      If (XDONT(NDON) > XPIV) Then
         ICRS = 3
         Do
            ICRS = ICRS + 1
            If (XDONT(ICRS) > XPIV) Then
               If (ICRS >= NDON) Exit
               JHIG = JHIG + 1
               IHIGT (JHIG) = ICRS
            Else
               JLOW = JLOW + 1
               ILOWT (JLOW) = ICRS
               If (JLOW >= NORD) Exit
            End If
         End Do
!
!  One restricts further processing because it is no use
!  to store more high values
!
         If (ICRS < NDON-1) Then
            Do
               ICRS = ICRS + 1
               If (XDONT(ICRS) <= XPIV) Then
                  JLOW = JLOW + 1
                  ILOWT (JLOW) = ICRS
               Else If (ICRS >= NDON) Then
                  Exit
               End If
            End Do
         End If
!
!
      Else
!
!  Same as above, but this is not as easy to optimize, so the
!  DO-loop is kept
!
         Do ICRS = 4, NDON - 1
            If (XDONT(ICRS) > XPIV) Then
               JHIG = JHIG + 1
               IHIGT (JHIG) = ICRS
            Else
               JLOW = JLOW + 1
               ILOWT (JLOW) = ICRS
               If (JLOW >= NORD) Exit
            End If
         End Do
!
         If (ICRS < NDON-1) Then
            Do
               ICRS = ICRS + 1
               If (XDONT(ICRS) <= XPIV) Then
                  If (ICRS >= NDON) Exit
                  JLOW = JLOW + 1
                  ILOWT (JLOW) = ICRS
               End If
            End Do
         End If
      End If
!
      JLM2 = 0
      JLM1 = 0
      JHM2 = 0
      JHM1 = 0
      Do
         if (JLOW == NORD) Exit
         If (JLM2 == JLOW .And. JHM2 == JHIG) Then
!
!   We are oscillating. Perturbate by bringing JLOW closer by one
!   to NORD
!
           If (NORD > JLOW) Then
                XMIN = XDONT (IHIGT(1))
                IHIG = 1
                Do ICRS = 2, JHIG
                   If (XDONT(IHIGT(ICRS)) < XMIN) Then
                      XMIN = XDONT (IHIGT(ICRS))
                      IHIG = ICRS
                   End If
                End Do
!
                JLOW = JLOW + 1
                ILOWT (JLOW) = IHIGT (IHIG)
                IHIGT (IHIG) = IHIGT (JHIG)
                JHIG = JHIG - 1
             Else
                ILOW = ILOWT (JLOW)
                XMAX = XDONT (ILOW)
                Do ICRS = 1, JLOW
                   If (XDONT(ILOWT(ICRS)) > XMAX) Then
                      IWRK = ILOWT (ICRS)
                      XMAX = XDONT (IWRK)
                      ILOWT (ICRS) = ILOW
                      ILOW = IWRK
                   End If
                End Do
                JLOW = JLOW - 1
             End If
         End If
         JLM2 = JLM1
         JLM1 = JLOW
         JHM2 = JHM1
         JHM1 = JHIG
!
!   We try to bring the number of values in the low values set
!   closer to NORD.
!
        Select Case (NORD-JLOW)
         Case (2:)
!
!   Not enough values in low part, at least 2 are missing
!
            Select Case (JHIG)
!!!!!           CASE DEFAULT
!!!!!              write (*,*) "Assertion failed"
!!!!!              STOP
!
!   We make a special case when we have so few values in
!   the high values set that it is bad performance to choose a pivot
!   and apply the general algorithm.
!
            Case (2)
               If (XDONT(IHIGT(1)) <= XDONT(IHIGT(2))) Then
                  JLOW = JLOW + 1
                  ILOWT (JLOW) = IHIGT (1)
                  JLOW = JLOW + 1
                  ILOWT (JLOW) = IHIGT (2)
               Else
                  JLOW = JLOW + 1
                  ILOWT (JLOW) = IHIGT (2)
                  JLOW = JLOW + 1
                  ILOWT (JLOW) = IHIGT (1)
               End If
               Exit
!
            Case (3)
!
!
               IWRK1 = IHIGT (1)
               IWRK2 = IHIGT (2)
               IWRK3 = IHIGT (3)
               If (XDONT(IWRK2) < XDONT(IWRK1)) Then
                  IHIGT (1) = IWRK2
                  IHIGT (2) = IWRK1
                  IWRK2 = IWRK1
               End If
               If (XDONT(IWRK2) > XDONT(IWRK3)) Then
                  IHIGT (3) = IWRK2
                  IHIGT (2) = IWRK3
                  IWRK2 = IWRK3
                  If (XDONT(IWRK2) < XDONT(IHIGT(1))) Then
                     IHIGT (2) = IHIGT (1)
                     IHIGT (1) = IWRK2
                  End If
               End If
               JHIG = 0
               Do ICRS = JLOW + 1, NORD
                  JHIG = JHIG + 1
                  ILOWT (ICRS) = IHIGT (JHIG)
               End Do
               JLOW = NORD
               Exit
!
            Case (4:)
!
!
               XPIV0 = XPIV
               IFIN = JHIG
!
!  One chooses a pivot from the 2 first values and the last one.
!  This should ensure sufficient renewal between iterations to
!  avoid worst case behavior effects.
!
               IWRK1 = IHIGT (1)
               IWRK2 = IHIGT (2)
               IWRK3 = IHIGT (IFIN)
               If (XDONT(IWRK2) < XDONT(IWRK1)) Then
                  IHIGT (1) = IWRK2
                  IHIGT (2) = IWRK1
                  IWRK2 = IWRK1
               End If
               If (XDONT(IWRK2) > XDONT(IWRK3)) Then
                  IHIGT (IFIN) = IWRK2
                  IHIGT (2) = IWRK3
                  IWRK2 = IWRK3
                  If (XDONT(IWRK2) < XDONT(IHIGT(1))) Then
                     IHIGT (2) = IHIGT (1)
                     IHIGT (1) = IWRK2
                  End If
               End If
!
               JDEB = JLOW
               NWRK = NORD - JLOW
               IWRK1 = IHIGT (1)
               JLOW = JLOW + 1
               ILOWT (JLOW) = IWRK1
               XPIV = XDONT (IWRK1) + REAL (NWRK) / REAL (NORD+NWRK) * &
                                      (XDONT(IHIGT(IFIN))-XDONT(IWRK1))
!
!  One takes values <= pivot to ILOWT
!  Again, 2 parts, one where we take care of the remaining
!  high values because we might still need them, and the
!  other when we know that we will have more than enough
!  low values in the end.
!
               JHIG = 0
               Do ICRS = 2, IFIN
                  If (XDONT(IHIGT(ICRS)) <= XPIV) Then
                     JLOW = JLOW + 1
                     ILOWT (JLOW) = IHIGT (ICRS)
                     If (JLOW >= NORD) Exit
                  Else
                     JHIG = JHIG + 1
                     IHIGT (JHIG) = IHIGT (ICRS)
                  End If
               End Do
!
               Do ICRS = ICRS + 1, IFIN
                  If (XDONT(IHIGT(ICRS)) <= XPIV) Then
                     JLOW = JLOW + 1
                     ILOWT (JLOW) = IHIGT (ICRS)
                  End If
               End Do
           End Select
!
!
         Case (1)
!
!  Only 1 value is missing in low part
!
            XMIN = XDONT (IHIGT(1))
            IHIG = 1
            Do ICRS = 2, JHIG
               If (XDONT(IHIGT(ICRS)) < XMIN) Then
                  XMIN = XDONT (IHIGT(ICRS))
                  IHIG = ICRS
               End If
            End Do
!
            JLOW = JLOW + 1
            ILOWT (JLOW) = IHIGT (IHIG)
            Exit
!
!
         Case (0)
!
!  Low part is exactly what we want
!
            Exit
!
!
         Case (-5:-1)
!
!  Only few values too many in low part
!
            IRNGT (1) = ILOWT (1)
            Do ICRS = 2, NORD
               IWRK = ILOWT (ICRS)
               XWRK = XDONT (IWRK)
               Do IDCR = ICRS - 1, 1, - 1
                  If (XWRK < XDONT(IRNGT(IDCR))) Then
                     IRNGT (IDCR+1) = IRNGT (IDCR)
                  Else
                     Exit
                  End If
               End Do
               IRNGT (IDCR+1) = IWRK
            End Do
!
            XWRK1 = XDONT (IRNGT(NORD))
            Do ICRS = NORD + 1, JLOW
               If (XDONT(ILOWT (ICRS)) < XWRK1) Then
                  XWRK = XDONT (ILOWT (ICRS))
                  Do IDCR = NORD - 1, 1, - 1
                     If (XWRK >= XDONT(IRNGT(IDCR))) Exit
                     IRNGT (IDCR+1) = IRNGT (IDCR)
                  End Do
                  IRNGT (IDCR+1) = ILOWT (ICRS)
                  XWRK1 = XDONT (IRNGT(NORD))
               End If
            End Do
!
            Return
!
!
         Case (:-6)
!
! last case: too many values in low part
!
            IDEB = JDEB + 1
            IMIL = (JLOW+IDEB) / 2
            IFIN = JLOW
!
!  One chooses a pivot from 1st, last, and middle values
!
            If (XDONT(ILOWT(IMIL)) < XDONT(ILOWT(IDEB))) Then
               IWRK = ILOWT (IDEB)
               ILOWT (IDEB) = ILOWT (IMIL)
               ILOWT (IMIL) = IWRK
            End If
            If (XDONT(ILOWT(IMIL)) > XDONT(ILOWT(IFIN))) Then
               IWRK = ILOWT (IFIN)
               ILOWT (IFIN) = ILOWT (IMIL)
               ILOWT (IMIL) = IWRK
               If (XDONT(ILOWT(IMIL)) < XDONT(ILOWT(IDEB))) Then
                  IWRK = ILOWT (IDEB)
                  ILOWT (IDEB) = ILOWT (IMIL)
                  ILOWT (IMIL) = IWRK
               End If
            End If
            If (IFIN <= 3) Exit
!
            XPIV = XDONT (ILOWT(1)) + REAL(NORD)/REAL(JLOW+NORD) * &
                                      (XDONT(ILOWT(IFIN))-XDONT(ILOWT(1)))
            If (JDEB > 0) Then
               If (XPIV <= XPIV0) &
                   XPIV = XPIV0 + REAL(2*NORD-JDEB)/REAL (JLOW+NORD) * &
                                  (XDONT(ILOWT(IFIN))-XPIV0)
            Else
               IDEB = 1
            End If
!
!  One takes values > XPIV to IHIGT
!  However, we do not process the first values if we have been
!  through the case when we did not have enough low values
!
            JHIG = 0
            JLOW = JDEB
!
            If (XDONT(ILOWT(IFIN)) > XPIV) Then
               ICRS = JDEB
               Do
                 ICRS = ICRS + 1
                  If (XDONT(ILOWT(ICRS)) > XPIV) Then
                     JHIG = JHIG + 1
                     IHIGT (JHIG) = ILOWT (ICRS)
                     If (ICRS >= IFIN) Exit
                  Else
                     JLOW = JLOW + 1
                     ILOWT (JLOW) = ILOWT (ICRS)
                     If (JLOW >= NORD) Exit
                  End If
               End Do
!
               If (ICRS < IFIN) Then
                  Do
                     ICRS = ICRS + 1
                     If (XDONT(ILOWT(ICRS)) <= XPIV) Then
                        JLOW = JLOW + 1
                        ILOWT (JLOW) = ILOWT (ICRS)
                     Else
                        If (ICRS >= IFIN) Exit
                     End If
                  End Do
               End If
           Else
               Do ICRS = IDEB, IFIN
                  If (XDONT(ILOWT(ICRS)) > XPIV) Then
                     JHIG = JHIG + 1
                     IHIGT (JHIG) = ILOWT (ICRS)
                  Else
                     JLOW = JLOW + 1
                     ILOWT (JLOW) = ILOWT (ICRS)
                     If (JLOW >= NORD) Exit
                  End If
               End Do
!
               Do ICRS = ICRS + 1, IFIN
                  If (XDONT(ILOWT(ICRS)) <= XPIV) Then
                     JLOW = JLOW + 1
                     ILOWT (JLOW) = ILOWT (ICRS)
                  End If
               End Do
            End If
!
         End Select
!
      End Do
!
!  Now, we only need to complete ranking of the 1:NORD set
!  Assuming NORD is small, we use a simple insertion sort
!
      IRNGT (1) = ILOWT (1)
      Do ICRS = 2, NORD
         IWRK = ILOWT (ICRS)
         XWRK = XDONT (IWRK)
         Do IDCR = ICRS - 1, 1, - 1
            If (XWRK < XDONT(IRNGT(IDCR))) Then
               IRNGT (IDCR+1) = IRNGT (IDCR)
            Else
               Exit
            End If
         End Do
         IRNGT (IDCR+1) = IWRK
      End Do
     Return
!
!
End Subroutine rnkpar 
 
 
END MODULE module_ibm
